/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 10-Apr-2007.
 */
#include <stdio.h>
#include <stdlib.h>
#include "ranapTable.h"
#include "rtPrint.h"
#include "asn1intl.h"

#include "ranapTable.h"
#include "rtPrint.h"

/**************************************************************/
/*                                                            */
/*  ProtocolIE_ID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ProtocolIE_ID (ASN1CTXT* pctxt, ProtocolIE_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Criticality                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Criticality (ASN1CTXT* pctxt, Criticality* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = reject; break;
      case 1: *pvalue = ignore; break;
      case 2: *pvalue = notify; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Presence                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Presence (ASN1CTXT* pctxt, Presence* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = optional; break;
      case 1: *pvalue = conditional; break;
      case 2: *pvalue = mandatory; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProtocolExtensionID                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ProtocolExtensionID (ASN1CTXT* pctxt, ProtocolExtensionID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProcedureCode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ProcedureCode (ASN1CTXT* pctxt, ProcedureCode* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TriggeringMessage                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TriggeringMessage (ASN1CTXT* pctxt, TriggeringMessage* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = initiating_message; break;
      case 1: *pvalue = successful_outcome; break;
      case 2: *pvalue = unsuccessfull_outcome; break;
      case 3: *pvalue = outcome; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateIE_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrivateIE_ID (ASN1CTXT* pctxt, PrivateIE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* local */
      case 0:
         stat = pd_ConsUInt16 (pctxt, &pvalue->u.local, OSUINTCONST(0), OSUINTCONST(65535));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         break;

      /* global */
      case 1:
         pvalue->u.global = rtMemAllocTypeZ (pctxt, ASN1OBJID);
         if (pvalue->u.global == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = pd_ObjectIdentifier (pctxt, pvalue->u.global);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateIE_ID                                              */
/*                                                            */
/**************************************************************/

int asn1CmpTC_PrivateIE_ID (PrivateIE_ID* pValue, PrivateIE_ID* pCmpValue)
{
   if(pValue->t != pCmpValue->t)
   {
      return -1;
   }
   switch (pValue->t) {
      case T_PrivateIE_ID_local:
         return rtCmpTCUSINT(&pValue->u.local, &pCmpValue->u.local);
         break;

      case T_PrivateIE_ID_global:
         return rtCmpTCOID(pValue->u.global, pCmpValue->u.global);
         break;

      default:
         return -1;
   }
   return 0;
}
/**************************************************************/
/*                                                            */
/*  ProtocolIE_ID                                             */
/*                                                            */
/**************************************************************/

void asn1Print_ProtocolIE_ID
   (const char* name, ProtocolIE_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  Criticality                                               */
/*                                                            */
/**************************************************************/

void asn1Print_Criticality
   (const char* name, Criticality* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("reject\n"); break;
      case 1: printf ("ignore\n"); break;
      case 2: printf ("notify\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  Presence                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_Presence
   (const char* name, Presence* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("optional\n"); break;
      case 1: printf ("conditional\n"); break;
      case 2: printf ("mandatory\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  ProtocolExtensionID                                       */
/*                                                            */
/**************************************************************/

void asn1Print_ProtocolExtensionID
   (const char* name, ProtocolExtensionID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  ProcedureCode                                             */
/*                                                            */
/**************************************************************/

void asn1Print_ProcedureCode
   (const char* name, ProcedureCode* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  TriggeringMessage                                         */
/*                                                            */
/**************************************************************/

void asn1Print_TriggeringMessage
   (const char* name, TriggeringMessage* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("initiating_message\n"); break;
      case 1: printf ("successful_outcome\n"); break;
      case 2: printf ("unsuccessfull_outcome\n"); break;
      case 3: printf ("outcome\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  PrivateIE_ID                                              */
/*                                                            */
/**************************************************************/

void asn1Print_PrivateIE_ID
   (const char* name, PrivateIE_ID* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.local", name);
         rtPrintUnsigned (namebuf, pvalue->u.local);
         break;

      case 2:
         sprintf (namebuf, "%s.u.global", name);
         rtPrintOID (namebuf, pvalue->u.global);
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  CauseRadioNetwork                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseRadioNetwork (ASN1CTXT* pctxt, CauseRadioNetwork* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(64));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseTransmissionNetwork                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseTransmissionNetwork (ASN1CTXT* pctxt, CauseTransmissionNetwork* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(65), OSUINTCONST(80));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseNAS                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseNAS (ASN1CTXT* pctxt, CauseNAS* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(81), OSUINTCONST(96));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseProtocol                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseProtocol (ASN1CTXT* pctxt, CauseProtocol* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(97), OSUINTCONST(112));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseMisc                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseMisc (ASN1CTXT* pctxt, CauseMisc* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(113), OSUINTCONST(128));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseNon_Standard                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseNon_Standard (ASN1CTXT* pctxt, CauseNon_Standard* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(129), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseRadioNetworkExtension                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseRadioNetworkExtension (ASN1CTXT* pctxt, CauseRadioNetworkExtension* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(257), OSUINTCONST(512));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cause                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cause (ASN1CTXT* pctxt, Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* radioNetwork */
         case 0:
            stat = asn1PD_CauseRadioNetwork (pctxt, &pvalue->u.radioNetwork);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* transmissionNetwork */
         case 1:
            stat = asn1PD_CauseTransmissionNetwork (pctxt, &pvalue->u.transmissionNetwork);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nAS */
         case 2:
            stat = asn1PD_CauseNAS (pctxt, &pvalue->u.nAS);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* protocol */
         case 3:
            stat = asn1PD_CauseProtocol (pctxt, &pvalue->u.protocol);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* misc */
         case 4:
            stat = asn1PD_CauseMisc (pctxt, &pvalue->u.misc);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* non_Standard */
         case 5:
            stat = asn1PD_CauseNon_Standard (pctxt, &pvalue->u.non_Standard);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* radioNetworkExtension */
         case 7:
            stat = asn1PD_CauseRadioNetworkExtension (pctxt, &pvalue->u.radioNetworkExtension);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      rtCopyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ID (ASN1CTXT* pctxt, RAB_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfullyTransmittedDataVolume                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfullyTransmittedDataVolume (ASN1CTXT* pctxt, UnsuccessfullyTransmittedDataVolume* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReference                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReference (ASN1CTXT* pctxt, DataVolumeReference* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_GTP_PDU_SequenceNumber                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_GTP_PDU_SequenceNumber (ASN1CTXT* pctxt, DL_GTP_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_GTP_PDU_SequenceNumber                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_GTP_PDU_SequenceNumber (ASN1CTXT* pctxt, UL_GTP_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber0                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RepetitionNumber0 (ASN1CTXT* pctxt, RepetitionNumber0* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RepetitionNumber1 (ASN1CTXT* pctxt, RepetitionNumber1* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure_element_iE_Extensions_element (ASN1CTXT* pctxt, MessageStructure_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MessageStructure_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MessageStructure_element_iE_Extensions_element (ASN1CTXT* pctxt,
   MessageStructure_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MessageStructure_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MessageStructure_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MessageStructure_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MessageStructure_ExtIEs[index].ExtensionSize);
   stat = MessageStructure_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure_element_iE_Extensions (ASN1CTXT* pctxt, MessageStructure_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MessageStructure_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MessageStructure_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MessageStructure_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure_element (ASN1CTXT* pctxt, MessageStructure_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iE_ID */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      stat = asn1PD_RepetitionNumber1 (pctxt, &pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_MessageStructure_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure (ASN1CTXT* pctxt, MessageStructure* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   MessageStructure_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MessageStructure_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MessageStructure_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CriticalityDiagnostics_IE_List_ExtIEs_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CriticalityDiagnostics_IE_List_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CriticalityDiagnostics_IE_List_ExtIEs_Extension *pvalue = (_CriticalityDiagnostics_IE_List_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_MessageStructure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TypeOfError                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TypeOfError (ASN1CTXT* pctxt, TypeOfError* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = not_understood; break;
         case 1: *pvalue = missing; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CriticalityDiagnostics_IE_List_ExtIEs_Extension_1        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CriticalityDiagnostics_IE_List_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CriticalityDiagnostics_IE_List_ExtIEs_Extension_1 *pvalue = (_CriticalityDiagnostics_IE_List_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_TypeOfError (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (ASN1CTXT* pctxt,
   CriticalityDiagnostics_IE_List_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CriticalityDiagnostics_IE_List_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CriticalityDiagnostics_IE_List_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CriticalityDiagnostics_IE_List_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CriticalityDiagnostics_IE_List_ExtIEs[index].ExtensionSize);
   stat = CriticalityDiagnostics_IE_List_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List_element_iE_Extensions (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CriticalityDiagnostics_IE_List_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List_element (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iECriticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->iECriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_ID */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      stat = asn1PD_RepetitionNumber0 (pctxt, &pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CriticalityDiagnostics_IE_List_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   CriticalityDiagnostics_IE_List_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CriticalityDiagnostics_IE_List_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_iE_Extensions_element (ASN1CTXT* pctxt, CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CriticalityDiagnostics_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CriticalityDiagnostics_iE_Extensions_element (ASN1CTXT* pctxt,
   CriticalityDiagnostics_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CriticalityDiagnostics_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CriticalityDiagnostics_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CriticalityDiagnostics_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CriticalityDiagnostics_ExtIEs[index].ExtensionSize);
   stat = CriticalityDiagnostics_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_iE_Extensions (ASN1CTXT* pctxt, CriticalityDiagnostics_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CriticalityDiagnostics_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CriticalityDiagnostics_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CriticalityDiagnostics_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics (ASN1CTXT* pctxt, CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.procedureCodePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.triggeringMessagePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.procedureCriticalityPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iEsCriticalityDiagnosticsPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode procedureCode */

   if (pvalue->m.procedureCodePresent) {
      stat = asn1PD_ProcedureCode (pctxt, &pvalue->procedureCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      stat = asn1PD_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      stat = asn1PD_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      stat = asn1PD_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CriticalityDiagnostics_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationType (ASN1CTXT* pctxt, RelocationType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ue_not_involved; break;
         case 1: *pvalue = ue_involved; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TBCD_STRING                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TBCD_STRING (ASN1CTXT* pctxt, TBCD_STRING* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNidentity                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNidentity (ASN1CTXT* pctxt, PLMNidentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNC_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNC_ID (ASN1CTXT* pctxt, RNC_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt, SourceRNC_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SourceRNC_ID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SourceRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceRNC_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceRNC_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceRNC_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceRNC_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SourceRNC_ID_ExtIEs[index].ExtensionSize);
   stat = SourceRNC_ID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ID_iE_Extensions (ASN1CTXT* pctxt, SourceRNC_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SourceRNC_ID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SourceRNC_ID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SourceRNC_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ID (ASN1CTXT* pctxt, SourceRNC_ID* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rNC_ID */

   stat = asn1PD_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SourceRNC_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LAC (ASN1CTXT* pctxt, LAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAC (ASN1CTXT* pctxt, SAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAI_iE_Extensions_element (ASN1CTXT* pctxt, SAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SAI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SAI_iE_Extensions_element (ASN1CTXT* pctxt,
   SAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SAI_ExtIEs[index].ExtensionSize);
   stat = SAI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAI_iE_Extensions (ASN1CTXT* pctxt, SAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SAI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SAI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAI (ASN1CTXT* pctxt, SAI* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode lAC */

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode sAC */

   stat = asn1PD_SAC (pctxt, &pvalue->sAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceID (ASN1CTXT* pctxt, SourceID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sourceRNC_ID */
         case 0:
            pvalue->u.sourceRNC_ID = rtMemAllocTypeZ (pctxt, SourceRNC_ID);
            if (pvalue->u.sourceRNC_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SourceRNC_ID (pctxt, pvalue->u.sourceRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* sAI */
         case 1:
            pvalue->u.sAI = rtMemAllocTypeZ (pctxt, SAI);
            if (pvalue->u.sAI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LAI_iE_Extensions_element (ASN1CTXT* pctxt, LAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LAI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LAI_iE_Extensions_element (ASN1CTXT* pctxt,
   LAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LAI_ExtIEs[index].ExtensionSize);
   stat = LAI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LAI_iE_Extensions (ASN1CTXT* pctxt, LAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LAI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LAI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LAI (ASN1CTXT* pctxt, LAI* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode lAC */

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_LAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAC (ASN1CTXT* pctxt, RAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt, TargetRNC_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TargetRNC_ID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TargetRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   TargetRNC_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TargetRNC_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TargetRNC_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TargetRNC_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TargetRNC_ID_ExtIEs[index].ExtensionSize);
   stat = TargetRNC_ID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ID_iE_Extensions (ASN1CTXT* pctxt, TargetRNC_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TargetRNC_ID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TargetRNC_ID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TargetRNC_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ID (ASN1CTXT* pctxt, TargetRNC_ID* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rACPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAI */

   stat = asn1PD_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rAC */

   if (pvalue->m.rACPresent) {
      stat = asn1PD_RAC (pctxt, &pvalue->rAC);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rNC_ID */

   stat = asn1PD_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TargetRNC_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CI                                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CI (ASN1CTXT* pctxt, CI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CGI_ExtIEs_Extension                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CGI_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CGI_ExtIEs_Extension *pvalue = (_CGI_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CGI_iE_Extensions_element (ASN1CTXT* pctxt, CGI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CGI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CGI_iE_Extensions_element (ASN1CTXT* pctxt,
   CGI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CGI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CGI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CGI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CGI_ExtIEs[index].ExtensionSize);
   stat = CGI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CGI_iE_Extensions (ASN1CTXT* pctxt, CGI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CGI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CGI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CGI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CGI (ASN1CTXT* pctxt, CGI* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode lAC */

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cI */

   stat = asn1PD_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetID (ASN1CTXT* pctxt, TargetID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* targetRNC_ID */
         case 0:
            pvalue->u.targetRNC_ID = rtMemAllocTypeZ (pctxt, TargetRNC_ID);
            if (pvalue->u.targetRNC_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* cGI */
         case 1:
            pvalue->u.cGI = rtMemAllocTypeZ (pctxt, CGI);
            if (pvalue->u.cGI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CGI (pctxt, pvalue->u.cGI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClassmarkInformation2                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ClassmarkInformation2 (ASN1CTXT* pctxt, ClassmarkInformation2* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClassmarkInformation3                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ClassmarkInformation3 (ASN1CTXT* pctxt, ClassmarkInformation3* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RRC_Container                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RRC_Container (ASN1CTXT* pctxt, RRC_Container* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberOfIuInstances                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NumberOfIuInstances (ASN1CTXT* pctxt, NumberOfIuInstances* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionAlgorithm                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionAlgorithm (ASN1CTXT* pctxt, IntegrityProtectionAlgorithm* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ChosenIntegrityProtectionAlgorithm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ChosenIntegrityProtectionAlgorithm (ASN1CTXT* pctxt, ChosenIntegrityProtectionAlgorithm* pvalue)
{
   int stat = 0;

   stat = asn1PD_IntegrityProtectionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionKey                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionKey (ASN1CTXT* pctxt, IntegrityProtectionKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(128), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionAlgorithm                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionAlgorithm (ASN1CTXT* pctxt, EncryptionAlgorithm* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ChosenEncryptionAlgorithm                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ChosenEncryptionAlgorithm (ASN1CTXT* pctxt, ChosenEncryptionAlgorithm* pvalue)
{
   int stat = 0;

   stat = asn1PD_EncryptionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionKey                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionKey (ASN1CTXT* pctxt, EncryptionKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(128), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  D_RNTI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_D_RNTI (ASN1CTXT* pctxt, D_RNTI* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetCellId                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetCellId (ASN1CTXT* pctxt, TargetCellId* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(268435455));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_ID (ASN1CTXT* pctxt, DCH_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_ID (ASN1CTXT* pctxt, DSCH_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_ID (ASN1CTXT* pctxt, USCH_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCH_MAC_d_Flow_ID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCH_MAC_d_Flow_ID (ASN1CTXT* pctxt, HS_DSCH_MAC_d_Flow_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _TrCH_ID_ExtIEs_Extension                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__TrCH_ID_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _TrCH_ID_ExtIEs_Extension *pvalue = (_TrCH_ID_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_HS_DSCH_MAC_d_Flow_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MAC_d_Flow_ID                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MAC_d_Flow_ID (ASN1CTXT* pctxt, E_DCH_MAC_d_Flow_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _TrCH_ID_ExtIEs_Extension_1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__TrCH_ID_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _TrCH_ID_ExtIEs_Extension_1 *pvalue = (_TrCH_ID_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_E_DCH_MAC_d_Flow_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrCH_ID_iE_Extensions_element (ASN1CTXT* pctxt, TrCH_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TrCH_ID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TrCH_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   TrCH_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TrCH_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TrCH_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TrCH_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TrCH_ID_ExtIEs[index].ExtensionSize);
   stat = TrCH_ID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrCH_ID_iE_Extensions (ASN1CTXT* pctxt, TrCH_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TrCH_ID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TrCH_ID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TrCH_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrCH_ID (ASN1CTXT* pctxt, TrCH_ID* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dCH_IDPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dSCH_IDPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uSCH_IDPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode dCH_ID */

   if (pvalue->m.dCH_IDPresent) {
      stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dSCH_ID */

   if (pvalue->m.dSCH_IDPresent) {
      stat = asn1PD_DSCH_ID (pctxt, &pvalue->dSCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uSCH_ID */

   if (pvalue->m.uSCH_IDPresent) {
      stat = asn1PD_USCH_ID (pctxt, &pvalue->uSCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TrCH_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_List                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrCH_ID_List (ASN1CTXT* pctxt, TrCH_ID_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(7), 0 };
   int stat = 0;
   TrCH_ID* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TrCH_ID);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TrCH_ID (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DomainIndicator                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DomainIndicator (ASN1CTXT* pctxt, CN_DomainIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = cs_domain; break;
      case 1: *pvalue = ps_domain; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_TrCH_MappingItem_ExtIEs_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_TrCH_MappingItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_TrCH_MappingItem_ExtIEs_Extension *pvalue = (_RAB_TrCH_MappingItem_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_TrCH_MappingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_TrCH_MappingItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_TrCH_MappingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_TrCH_MappingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_TrCH_MappingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_TrCH_MappingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_TrCH_MappingItem_ExtIEs[index].ExtensionSize);
   stat = RAB_TrCH_MappingItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_TrCH_MappingItem_iE_Extensions (ASN1CTXT* pctxt, RAB_TrCH_MappingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_TrCH_MappingItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_TrCH_MappingItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_TrCH_MappingItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_TrCH_MappingItem (ASN1CTXT* pctxt, RAB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode trCH_ID_List */

   stat = asn1PD_TrCH_ID_List (pctxt, &pvalue->trCH_ID_List);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_TrCH_MappingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_Mapping                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_TrCH_Mapping (ASN1CTXT* pctxt, RAB_TrCH_Mapping* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_TrCH_MappingItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_TrCH_MappingItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_TrCH_MappingItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_ID (ASN1CTXT* pctxt, SRB_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt, SRB_TrCH_MappingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRB_TrCH_MappingItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   SRB_TrCH_MappingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRB_TrCH_MappingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRB_TrCH_MappingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRB_TrCH_MappingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SRB_TrCH_MappingItem_ExtIEs[index].ExtensionSize);
   stat = SRB_TrCH_MappingItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_TrCH_MappingItem_iE_Extensions (ASN1CTXT* pctxt, SRB_TrCH_MappingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRB_TrCH_MappingItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRB_TrCH_MappingItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRB_TrCH_MappingItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_TrCH_MappingItem (ASN1CTXT* pctxt, SRB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode sRB_ID */

   stat = asn1PD_SRB_ID (pctxt, &pvalue->sRB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode trCH_ID */

   stat = asn1PD_TrCH_ID (pctxt, &pvalue->trCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SRB_TrCH_MappingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_Mapping                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_TrCH_Mapping (ASN1CTXT* pctxt, SRB_TrCH_Mapping* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   SRB_TrCH_MappingItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRB_TrCH_MappingItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRB_TrCH_MappingItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_SRB_TrCH_Mapping (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceUTRANCellID_iE_Extensions_element (ASN1CTXT* pctxt, SourceUTRANCellID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SourceUTRANCellID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SourceUTRANCellID_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceUTRANCellID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceUTRANCellID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceUTRANCellID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceUTRANCellID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SourceUTRANCellID_ExtIEs[index].ExtensionSize);
   stat = SourceUTRANCellID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceUTRANCellID_iE_Extensions (ASN1CTXT* pctxt, SourceUTRANCellID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SourceUTRANCellID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SourceUTRANCellID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SourceUTRANCellID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceUTRANCellID (ASN1CTXT* pctxt, SourceUTRANCellID* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uTRANcellID */

   stat = asn1PD_TargetCellId (pctxt, &pvalue->uTRANcellID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SourceUTRANCellID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceCellID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceCellID (ASN1CTXT* pctxt, SourceCellID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sourceUTRANCellID */
         case 0:
            pvalue->u.sourceUTRANCellID = rtMemAllocTypeZ (pctxt, SourceUTRANCellID);
            if (pvalue->u.sourceUTRANCellID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SourceUTRANCellID (pctxt, pvalue->u.sourceUTRANCellID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* sourceGERANCellID */
         case 1:
            pvalue->u.sourceGERANCellID = rtMemAllocTypeZ (pctxt, CGI);
            if (pvalue->u.sourceGERANCellID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CGI (pctxt, pvalue->u.sourceGERANCellID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_Capacity_Class_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_Capacity_Class_Value (ASN1CTXT* pctxt, Cell_Capacity_Class_Value* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LoadValue                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LoadValue (ASN1CTXT* pctxt, LoadValue* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTLoadValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RTLoadValue (ASN1CTXT* pctxt, RTLoadValue* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NRTLoadInformationValue                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NRTLoadInformationValue (ASN1CTXT* pctxt, NRTLoadInformationValue* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformation_iE_Extensions_element (ASN1CTXT* pctxt, CellLoadInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CellLoadInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CellLoadInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   CellLoadInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CellLoadInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CellLoadInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CellLoadInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CellLoadInformation_ExtIEs[index].ExtensionSize);
   stat = CellLoadInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformation_iE_Extensions (ASN1CTXT* pctxt, CellLoadInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CellLoadInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellLoadInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellLoadInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformation (ASN1CTXT* pctxt, CellLoadInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rTLoadValuePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nRTLoadInformationValuePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode cell_Capacity_Class_Value */

   stat = asn1PD_Cell_Capacity_Class_Value (pctxt, &pvalue->cell_Capacity_Class_Value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode loadValue */

   stat = asn1PD_LoadValue (pctxt, &pvalue->loadValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rTLoadValue */

   if (pvalue->m.rTLoadValuePresent) {
      stat = asn1PD_RTLoadValue (pctxt, &pvalue->rTLoadValue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode nRTLoadInformationValue */

   if (pvalue->m.nRTLoadInformationValuePresent) {
      stat = asn1PD_NRTLoadInformationValue (pctxt, &pvalue->nRTLoadInformationValue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CellLoadInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformationGroup_iE_Extensions_element (ASN1CTXT* pctxt, CellLoadInformationGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CellLoadInformationGroup_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CellLoadInformationGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   CellLoadInformationGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CellLoadInformationGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CellLoadInformationGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CellLoadInformationGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CellLoadInformationGroup_ExtIEs[index].ExtensionSize);
   stat = CellLoadInformationGroup_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformationGroup_iE_Extensions (ASN1CTXT* pctxt, CellLoadInformationGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CellLoadInformationGroup_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellLoadInformationGroup_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellLoadInformationGroup_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformationGroup (ASN1CTXT* pctxt, CellLoadInformationGroup* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uplinkCellLoadInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.downlinkCellLoadInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode sourceCellID */

   stat = asn1PD_SourceCellID (pctxt, &pvalue->sourceCellID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uplinkCellLoadInformation */

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      stat = asn1PD_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode downlinkCellLoadInformation */

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      stat = asn1PD_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CellLoadInformationGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_CellLoadInformationGroup (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceReference                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceReference (ASN1CTXT* pctxt, TraceReference* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionReference                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceRecordingSessionReference (ASN1CTXT* pctxt, TraceRecordingSessionReference* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceRecordingSessionInformation_iE_Extensions_element (ASN1CTXT* pctxt, TraceRecordingSessionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TraceRecordingSessionInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TraceRecordingSessionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   TraceRecordingSessionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TraceRecordingSessionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TraceRecordingSessionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TraceRecordingSessionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TraceRecordingSessionInformation_ExtIEs[index].ExtensionSize);
   stat = TraceRecordingSessionInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceRecordingSessionInformation_iE_Extensions (ASN1CTXT* pctxt, TraceRecordingSessionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TraceRecordingSessionInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TraceRecordingSessionInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TraceRecordingSessionInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceRecordingSessionInformation (ASN1CTXT* pctxt, TraceRecordingSessionInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode traceReference */

   stat = asn1PD_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode traceRecordingSessionReference */

   stat = asn1PD_TraceRecordingSessionReference (pctxt, &pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TraceRecordingSessionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2*) pvalue_;

   stat = asn1PD_TraceRecordingSessionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSLinkingInformation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSLinkingInformation (ASN1CTXT* pctxt, MBMSLinkingInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = uE_has_joined_multicast_services; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3*) pvalue_;

   stat = asn1PD_MBMSLinkingInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].ExtensionSize);
   stat = SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ToTargetRNC_TransparentContainer (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.chosenIntegrityProtectionAlgorithmPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.integrityProtectionKeyPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.chosenEncryptionAlgorithForSignallingPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cipheringKeyPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.chosenEncryptionAlgorithForCSPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.chosenEncryptionAlgorithForPSPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.d_RNTIPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.targetCellIdPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rAB_TrCH_MappingPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rRC_Container */

   stat = asn1PD_RRC_Container (pctxt, &pvalue->rRC_Container);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode numberOfIuInstances */

   stat = asn1PD_NumberOfIuInstances (pctxt, &pvalue->numberOfIuInstances);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode relocationType */

   stat = asn1PD_RelocationType (pctxt, &pvalue->relocationType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode chosenIntegrityProtectionAlgorithm */

   if (pvalue->m.chosenIntegrityProtectionAlgorithmPresent) {
      stat = asn1PD_ChosenIntegrityProtectionAlgorithm (pctxt, &pvalue->chosenIntegrityProtectionAlgorithm);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode integrityProtectionKey */

   if (pvalue->m.integrityProtectionKeyPresent) {
      stat = asn1PD_IntegrityProtectionKey (pctxt, &pvalue->integrityProtectionKey);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode chosenEncryptionAlgorithForSignalling */

   if (pvalue->m.chosenEncryptionAlgorithForSignallingPresent) {
      stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForSignalling);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode cipheringKey */

   if (pvalue->m.cipheringKeyPresent) {
      stat = asn1PD_EncryptionKey (pctxt, &pvalue->cipheringKey);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode chosenEncryptionAlgorithForCS */

   if (pvalue->m.chosenEncryptionAlgorithForCSPresent) {
      stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode chosenEncryptionAlgorithForPS */

   if (pvalue->m.chosenEncryptionAlgorithForPSPresent) {
      stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForPS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode d_RNTI */

   if (pvalue->m.d_RNTIPresent) {
      stat = asn1PD_D_RNTI (pctxt, &pvalue->d_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode targetCellId */

   if (pvalue->m.targetCellIdPresent) {
      stat = asn1PD_TargetCellId (pctxt, &pvalue->targetCellId);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAB_TrCH_Mapping */

   if (pvalue->m.rAB_TrCH_MappingPresent) {
      stat = asn1PD_RAB_TrCH_Mapping (pctxt, &pvalue->rAB_TrCH_Mapping);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OldBSS_ToNewBSS_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_OldBSS_ToNewBSS_Information (ASN1CTXT* pctxt, OldBSS_ToNewBSS_Information* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Classmark                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Classmark (ASN1CTXT* pctxt, GERAN_Classmark* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceBSS_ToTargetBSS_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceBSS_ToTargetBSS_TransparentContainer (ASN1CTXT* pctxt, SourceBSS_ToTargetBSS_TransparentContainer* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].ExtensionSize);
   stat = TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ToSourceRNC_TransparentContainer (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.d_RNTIPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rRC_Container */

   stat = asn1PD_RRC_Container (pctxt, &pvalue->rRC_Container);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode d_RNTI */

   if (pvalue->m.d_RNTIPresent) {
      stat = asn1PD_D_RNTI (pctxt, &pvalue->d_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  L3_Information                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_L3_Information (ASN1CTXT* pctxt, L3_Information* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerAddress                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerAddress (ASN1CTXT* pctxt, TransportLayerAddress* pvalue)
{
   static Asn1SizeCnst lsize2 = { 1, OSUINTCONST(0), OSUINT32_MAX, 0 };
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(160), 0 };
   int stat = 0;

   lsize1.next = &lsize2;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_DynBitString (pctxt, (ASN1DynBitStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GTP_TEI                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GTP_TEI (ASN1CTXT* pctxt, GTP_TEI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BindingID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BindingID (ASN1CTXT* pctxt, BindingID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IuTransportAssociation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IuTransportAssociation (ASN1CTXT* pctxt, IuTransportAssociation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* gTP_TEI */
         case 0:
            pvalue->u.gTP_TEI = rtMemAllocTypeZ (pctxt, GTP_TEI);
            if (pvalue->u.gTP_TEI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GTP_TEI (pctxt, pvalue->u.gTP_TEI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* bindingID */
         case 1:
            pvalue->u.bindingID = rtMemAllocTypeZ (pctxt, BindingID);
            if (pvalue->u.bindingID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_BindingID (pctxt, pvalue->u.bindingID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterSystemInformation_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InterSystemInformation_TransparentContainer_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InterSystemInformation_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   InterSystemInformation_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InterSystemInformation_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InterSystemInformation_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InterSystemInformation_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InterSystemInformation_TransparentContainer_ExtIEs[index].ExtensionSize);
   stat = InterSystemInformation_TransparentContainer_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterSystemInformation_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InterSystemInformation_TransparentContainer_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InterSystemInformation_TransparentContainer_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InterSystemInformation_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterSystemInformation_TransparentContainer (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.downlinkCellLoadInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uplinkCellLoadInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode downlinkCellLoadInformation */

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      stat = asn1PD_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uplinkCellLoadInformation */

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      stat = asn1PD_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_InterSystemInformation_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetBSS_ToSourceBSS_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetBSS_ToSourceBSS_TransparentContainer (ASN1CTXT* pctxt, TargetBSS_ToSourceBSS_TransparentContainer* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMSI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMSI (ASN1CTXT* pctxt, IMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermanentNAS_UE_ID                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PermanentNAS_UE_ID (ASN1CTXT* pctxt, PermanentNAS_UE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iMSI */
         case 0:
            pvalue->u.iMSI = rtMemAllocTypeZ (pctxt, IMSI);
            if (pvalue->u.iMSI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMSI (pctxt, pvalue->u.iMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_SynchronisationIndicator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NAS_SynchronisationIndicator (ASN1CTXT* pctxt, NAS_SynchronisationIndicator* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrafficClass                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrafficClass (ASN1CTXT* pctxt, TrafficClass* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = conversational; break;
         case 1: *pvalue = streaming; break;
         case 2: *pvalue = interactive; break;
         case 3: *pvalue = background; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AsymmetryIndicator                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AsymmetryIndicator (ASN1CTXT* pctxt, RAB_AsymmetryIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = symmetric_bidirectional; break;
         case 1: *pvalue = asymmetric_unidirectional_downlink; break;
         case 2: *pvalue = asymmetric_unidirectional_uplink; break;
         case 3: *pvalue = asymmetric_bidirectional; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxBitrate                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaxBitrate (ASN1CTXT* pctxt, MaxBitrate* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(16000000));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameter_MaxBitrateList                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MaxBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GuaranteedBitrate                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GuaranteedBitrate (ASN1CTXT* pctxt, GuaranteedBitrate* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(16000000));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameter_GuaranteedBitrateList                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeliveryOrder                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeliveryOrder (ASN1CTXT* pctxt, DeliveryOrder* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = delivery_order_requested; break;
      case 1: *pvalue = delivery_order_not_requested; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxSDU_Size                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaxSDU_Size (ASN1CTXT* pctxt, MaxSDU_Size* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(32768));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_ErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt, SDU_ErrorRatio_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SDU_ErrorRatio_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SDU_ErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_ErrorRatio_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_ErrorRatio_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_ErrorRatio_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_ErrorRatio_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SDU_ErrorRatio_ExtIEs[index].ExtensionSize);
   stat = SDU_ErrorRatio_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_ErrorRatio_iE_Extensions (ASN1CTXT* pctxt, SDU_ErrorRatio_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SDU_ErrorRatio_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_ErrorRatio_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_ErrorRatio_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_ErrorRatio (ASN1CTXT* pctxt, SDU_ErrorRatio* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode mantissa */

   stat = pd_ConsUInt8 (pctxt, &pvalue->mantissa, OSUINTCONST(1), OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode exponent */

   stat = pd_ConsUInt8 (pctxt, &pvalue->exponent, OSUINTCONST(1), OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SDU_ErrorRatio_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResidualBitErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt, ResidualBitErrorRatio_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResidualBitErrorRatio_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResidualBitErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt,
   ResidualBitErrorRatio_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResidualBitErrorRatio_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResidualBitErrorRatio_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResidualBitErrorRatio_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResidualBitErrorRatio_ExtIEs[index].ExtensionSize);
   stat = ResidualBitErrorRatio_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResidualBitErrorRatio_iE_Extensions (ASN1CTXT* pctxt, ResidualBitErrorRatio_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResidualBitErrorRatio_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResidualBitErrorRatio_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResidualBitErrorRatio_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResidualBitErrorRatio (ASN1CTXT* pctxt, ResidualBitErrorRatio* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode mantissa */

   stat = pd_ConsUInt8 (pctxt, &pvalue->mantissa, OSUINTCONST(1), OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode exponent */

   stat = pd_ConsUInt8 (pctxt, &pvalue->exponent, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_ResidualBitErrorRatio_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeliveryOfErroneousSDU                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeliveryOfErroneousSDU (ASN1CTXT* pctxt, DeliveryOfErroneousSDU* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = yes; break;
      case 1: *pvalue = no; break;
      case 2: *pvalue = no_error_detection_consideration; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SubflowSDU_Size                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SubflowSDU_Size (ASN1CTXT* pctxt, SubflowSDU_Size* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SubflowCombinationBitRate                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SubflowCombinationBitRate (ASN1CTXT* pctxt, RAB_SubflowCombinationBitRate* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(16000000));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_FormatInformationParameters_element_iE_Extensions_element (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SDU_FormatInformationParameters_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SDU_FormatInformationParameters_element_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_FormatInformationParameters_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_FormatInformationParameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_FormatInformationParameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_FormatInformationParameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SDU_FormatInformationParameters_ExtIEs[index].ExtensionSize);
   stat = SDU_FormatInformationParameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_FormatInformationParameters_element_iE_Extensions (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SDU_FormatInformationParameters_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_FormatInformationParameters_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_FormatInformationParameters_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_FormatInformationParameters_element (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.subflowSDU_SizePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rAB_SubflowCombinationBitRatePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode subflowSDU_Size */

   if (pvalue->m.subflowSDU_SizePresent) {
      stat = asn1PD_SubflowSDU_Size (pctxt, &pvalue->subflowSDU_Size);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAB_SubflowCombinationBitRate */

   if (pvalue->m.rAB_SubflowCombinationBitRatePresent) {
      stat = asn1PD_RAB_SubflowCombinationBitRate (pctxt, &pvalue->rAB_SubflowCombinationBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SDU_FormatInformationParameters_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_FormatInformationParameters (ASN1CTXT* pctxt, SDU_FormatInformationParameters* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   SDU_FormatInformationParameters_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_FormatInformationParameters_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_FormatInformationParameters_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_Parameters_element_iE_Extensions_element (ASN1CTXT* pctxt, SDU_Parameters_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SDU_Parameters_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SDU_Parameters_element_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_Parameters_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SDU_Parameters_ExtIEs[index].ExtensionSize);
   stat = SDU_Parameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_Parameters_element_iE_Extensions (ASN1CTXT* pctxt, SDU_Parameters_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SDU_Parameters_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_Parameters_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_Parameters_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_Parameters_element (ASN1CTXT* pctxt, SDU_Parameters_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sDU_ErrorRatioPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sDU_FormatInformationParametersPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode sDU_ErrorRatio */

   if (pvalue->m.sDU_ErrorRatioPresent) {
      stat = asn1PD_SDU_ErrorRatio (pctxt, &pvalue->sDU_ErrorRatio);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode residualBitErrorRatio */

   stat = asn1PD_ResidualBitErrorRatio (pctxt, &pvalue->residualBitErrorRatio);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode deliveryOfErroneousSDU */

   stat = asn1PD_DeliveryOfErroneousSDU (pctxt, &pvalue->deliveryOfErroneousSDU);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode sDU_FormatInformationParameters */

   if (pvalue->m.sDU_FormatInformationParametersPresent) {
      stat = asn1PD_SDU_FormatInformationParameters (pctxt, &pvalue->sDU_FormatInformationParameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SDU_Parameters_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_Parameters (ASN1CTXT* pctxt, SDU_Parameters* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(7), 0 };
   int stat = 0;
   SDU_Parameters_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_Parameters_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_Parameters_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransferDelay                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransferDelay (ASN1CTXT* pctxt, TransferDelay* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrafficHandlingPriority                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrafficHandlingPriority (ASN1CTXT* pctxt, TrafficHandlingPriority* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityLevel                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityLevel (ASN1CTXT* pctxt, PriorityLevel* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionCapability                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Pre_emptionCapability (ASN1CTXT* pctxt, Pre_emptionCapability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = shall_not_trigger_pre_emption; break;
      case 1: *pvalue = may_trigger_pre_emption; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionVulnerability                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Pre_emptionVulnerability (ASN1CTXT* pctxt, Pre_emptionVulnerability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = not_pre_emptable; break;
      case 1: *pvalue = pre_emptable; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QueuingAllowed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_QueuingAllowed (ASN1CTXT* pctxt, QueuingAllowed* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = queueing_not_allowed; break;
      case 1: *pvalue = queueing_allowed; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllocationOrRetentionPriority_iE_Extensions_element (ASN1CTXT* pctxt, AllocationOrRetentionPriority_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_AllocationOrRetentionPriority_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_AllocationOrRetentionPriority_iE_Extensions_element (ASN1CTXT* pctxt,
   AllocationOrRetentionPriority_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < AllocationOrRetentionPriority_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &AllocationOrRetentionPriority_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == AllocationOrRetentionPriority_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, AllocationOrRetentionPriority_ExtIEs[index].ExtensionSize);
   stat = AllocationOrRetentionPriority_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllocationOrRetentionPriority_iE_Extensions (ASN1CTXT* pctxt, AllocationOrRetentionPriority_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   AllocationOrRetentionPriority_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AllocationOrRetentionPriority_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AllocationOrRetentionPriority_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllocationOrRetentionPriority (ASN1CTXT* pctxt, AllocationOrRetentionPriority* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode priorityLevel */

   stat = asn1PD_PriorityLevel (pctxt, &pvalue->priorityLevel);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode pre_emptionCapability */

   stat = asn1PD_Pre_emptionCapability (pctxt, &pvalue->pre_emptionCapability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode pre_emptionVulnerability */

   stat = asn1PD_Pre_emptionVulnerability (pctxt, &pvalue->pre_emptionVulnerability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode queuingAllowed */

   stat = asn1PD_QueuingAllowed (pctxt, &pvalue->queuingAllowed);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_AllocationOrRetentionPriority_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceStatisticsDescriptor                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceStatisticsDescriptor (ASN1CTXT* pctxt, SourceStatisticsDescriptor* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = speech; break;
         case 1: *pvalue = unknown; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequirement                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequirement (ASN1CTXT* pctxt, RelocationRequirement* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = realtime; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = lossless; break;
         case 1: *pvalue = none; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignallingIndication                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SignallingIndication (ASN1CTXT* pctxt, SignallingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = signalling; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_Parameters_ExtIEs_Extension                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_Parameters_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_Parameters_ExtIEs_Extension *pvalue = (_RAB_Parameters_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_SignallingIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_Parameters_ExtIEs[index].ExtensionSize);
   stat = RAB_Parameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_Parameters_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_Parameters_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_Parameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameters (ASN1CTXT* pctxt, RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.guaranteedBitRatePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transferDelayPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.trafficHandlingPriorityPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allocationOrRetentionPriorityPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sourceStatisticsDescriptorPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.relocationRequirementPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode trafficClass */

   stat = asn1PD_TrafficClass (pctxt, &pvalue->trafficClass);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rAB_AsymmetryIndicator */

   stat = asn1PD_RAB_AsymmetryIndicator (pctxt, &pvalue->rAB_AsymmetryIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode maxBitrate */

   stat = asn1PD_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->maxBitrate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode guaranteedBitRate */

   if (pvalue->m.guaranteedBitRatePresent) {
      stat = asn1PD_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->guaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode deliveryOrder */

   stat = asn1PD_DeliveryOrder (pctxt, &pvalue->deliveryOrder);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode maxSDU_Size */

   stat = asn1PD_MaxSDU_Size (pctxt, &pvalue->maxSDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode sDU_Parameters */

   stat = asn1PD_SDU_Parameters (pctxt, &pvalue->sDU_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transferDelay */

   if (pvalue->m.transferDelayPresent) {
      stat = asn1PD_TransferDelay (pctxt, &pvalue->transferDelay);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode trafficHandlingPriority */

   if (pvalue->m.trafficHandlingPriorityPresent) {
      stat = asn1PD_TrafficHandlingPriority (pctxt, &pvalue->trafficHandlingPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode allocationOrRetentionPriority */

   if (pvalue->m.allocationOrRetentionPriorityPresent) {
      stat = asn1PD_AllocationOrRetentionPriority (pctxt, &pvalue->allocationOrRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode sourceStatisticsDescriptor */

   if (pvalue->m.sourceStatisticsDescriptorPresent) {
      stat = asn1PD_SourceStatisticsDescriptor (pctxt, &pvalue->sourceStatisticsDescriptor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode relocationRequirement */

   if (pvalue->m.relocationRequirementPresent) {
      stat = asn1PD_RelocationRequirement (pctxt, &pvalue->relocationRequirement);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportingIndication                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportingIndication (ASN1CTXT* pctxt, DataVolumeReportingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = do_report; break;
      case 1: *pvalue = do_not_report; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDP_Type                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDP_Type (ASN1CTXT* pctxt, PDP_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = empty; break;
         case 1: *pvalue = ppp; break;
         case 2: *pvalue = osp_ihoss; break;
         case 3: *pvalue = ipv4; break;
         case 4: *pvalue = ipv6; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDP_TypeInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDP_TypeInformation (ASN1CTXT* pctxt, PDP_TypeInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_PDP_Type (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneMode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UserPlaneMode (ASN1CTXT* pctxt, UserPlaneMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = transparent_mode; break;
         case 1: *pvalue = support_mode_for_predefined_SDU_sizes; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UP_ModeVersions                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UP_ModeVersions (ASN1CTXT* pctxt, UP_ModeVersions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Service_Handover                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Service_Handover (ASN1CTXT* pctxt, Service_Handover* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = handover_to_GSM_should_be_performed; break;
         case 1: *pvalue = handover_to_GSM_should_not_be_performed; break;
         case 2: *pvalue = handover_to_GSM_shall_not_be_performed; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateType                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_MaxBitrateType (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = unspecified_1; break;
         case 1: *pvalue = value_range_1; break;
         case 2: *pvalue = discrete_values_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MaxBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrates                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_MaxBitrates (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Alt_RAB_Parameter_MaxBitrateList* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Alt_RAB_Parameter_MaxBitrateList);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Alt_RAB_Parameter_MaxBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateInf                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_MaxBitrateInf (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.altMaxBitratesPresent = optbit;

   /* decode altMaxBitrateType */

   stat = asn1PD_Alt_RAB_Parameter_MaxBitrateType (pctxt, &pvalue->altMaxBitrateType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altMaxBitrates */

   if (pvalue->m.altMaxBitratesPresent) {
      stat = asn1PD_Alt_RAB_Parameter_MaxBitrates (pctxt, &pvalue->altMaxBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateType                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_GuaranteedBitrateType (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = unspecified; break;
         case 1: *pvalue = value_range; break;
         case 2: *pvalue = discrete_values; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateList                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrates                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_GuaranteedBitrates (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Alt_RAB_Parameter_GuaranteedBitrateList* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Alt_RAB_Parameter_GuaranteedBitrateList);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Alt_RAB_Parameter_GuaranteedBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateInf                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_GuaranteedBitrateInf (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.altGuaranteedBitratesPresent = optbit;

   /* decode altGuaranteedBitrateType */

   stat = asn1PD_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, &pvalue->altGuaranteedBitrateType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altGuaranteedBitrates */

   if (pvalue->m.altGuaranteedBitratesPresent) {
      stat = asn1PD_Alt_RAB_Parameter_GuaranteedBitrates (pctxt, &pvalue->altGuaranteedBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Alt_RAB_Parameters_ExtIEs_Extension                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Alt_RAB_Parameters_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Alt_RAB_Parameters_ExtIEs_Extension *pvalue = (_Alt_RAB_Parameters_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, Alt_RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Alt_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Alt_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   Alt_RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Alt_RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Alt_RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Alt_RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Alt_RAB_Parameters_ExtIEs[index].ExtensionSize);
   stat = Alt_RAB_Parameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, Alt_RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Alt_RAB_Parameters_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Alt_RAB_Parameters_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Alt_RAB_Parameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameters (ASN1CTXT* pctxt, Alt_RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.altMaxBitrateInfPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.altGuaranteedBitRateInfPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode altMaxBitrateInf */

   if (pvalue->m.altMaxBitrateInfPresent) {
      stat = asn1PD_Alt_RAB_Parameter_MaxBitrateInf (pctxt, &pvalue->altMaxBitrateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode altGuaranteedBitRateInf */

   if (pvalue->m.altGuaranteedBitRateInfPresent) {
      stat = asn1PD_Alt_RAB_Parameter_GuaranteedBitrateInf (pctxt, &pvalue->altGuaranteedBitRateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_Alt_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_BSC_Container                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_BSC_Container (ASN1CTXT* pctxt, GERAN_BSC_Container* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermittedIntegrityProtectionAlgorithms                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PermittedIntegrityProtectionAlgorithms (ASN1CTXT* pctxt, PermittedIntegrityProtectionAlgorithms* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (16 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_IntegrityProtectionAlgorithm (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionInformation_iE_Extensions_element (ASN1CTXT* pctxt, IntegrityProtectionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_IntegrityProtectionInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_IntegrityProtectionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   IntegrityProtectionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IntegrityProtectionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IntegrityProtectionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IntegrityProtectionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, IntegrityProtectionInformation_ExtIEs[index].ExtensionSize);
   stat = IntegrityProtectionInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionInformation_iE_Extensions (ASN1CTXT* pctxt, IntegrityProtectionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   IntegrityProtectionInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, IntegrityProtectionInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_IntegrityProtectionInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionInformation (ASN1CTXT* pctxt, IntegrityProtectionInformation* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode permittedAlgorithms */

   stat = asn1PD_PermittedIntegrityProtectionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode key */

   stat = asn1PD_IntegrityProtectionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_IntegrityProtectionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermittedEncryptionAlgorithms                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PermittedEncryptionAlgorithms (ASN1CTXT* pctxt, PermittedEncryptionAlgorithms* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (16 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_EncryptionAlgorithm (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionInformation_iE_Extensions_element (ASN1CTXT* pctxt, EncryptionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_EncryptionInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_EncryptionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   EncryptionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < EncryptionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &EncryptionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == EncryptionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, EncryptionInformation_ExtIEs[index].ExtensionSize);
   stat = EncryptionInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionInformation_iE_Extensions (ASN1CTXT* pctxt, EncryptionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   EncryptionInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, EncryptionInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_EncryptionInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionInformation (ASN1CTXT* pctxt, EncryptionInformation* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode permittedAlgorithms */

   stat = asn1PD_PermittedEncryptionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode key */

   stat = asn1PD_EncryptionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_EncryptionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IuSignallingConnectionIdentifier                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IuSignallingConnectionIdentifier (ASN1CTXT* pctxt, IuSignallingConnectionIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_ID                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_ID (ASN1CTXT* pctxt, CN_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GlobalCN_ID                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GlobalCN_ID (ASN1CTXT* pctxt, GlobalCN_ID* pvalue)
{
   int stat = 0;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cN_ID */

   stat = asn1PD_CN_ID (pctxt, &pvalue->cN_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNAC                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SNAC (ASN1CTXT* pctxt, SNAC* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedSNAs                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedSNAs (ASN1CTXT* pctxt, AuthorisedSNAs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, SNAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_SNAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedPLMNs_element_iE_Extensions_element (ASN1CTXT* pctxt, AuthorisedPLMNs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_AuthorisedPLMNs_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_AuthorisedPLMNs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   AuthorisedPLMNs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < AuthorisedPLMNs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &AuthorisedPLMNs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == AuthorisedPLMNs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, AuthorisedPLMNs_ExtIEs[index].ExtensionSize);
   stat = AuthorisedPLMNs_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedPLMNs_element_iE_Extensions (ASN1CTXT* pctxt, AuthorisedPLMNs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   AuthorisedPLMNs_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AuthorisedPLMNs_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AuthorisedPLMNs_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedPLMNs_element (ASN1CTXT* pctxt, AuthorisedPLMNs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.authorisedSNAsListPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode authorisedSNAsList */

   if (pvalue->m.authorisedSNAsListPresent) {
      stat = asn1PD_AuthorisedSNAs (pctxt, &pvalue->authorisedSNAsList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_AuthorisedPLMNs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedPLMNs (ASN1CTXT* pctxt, AuthorisedPLMNs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   AuthorisedPLMNs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AuthorisedPLMNs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AuthorisedPLMNs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SNA_Access_Information_iE_Extensions_element (ASN1CTXT* pctxt, SNA_Access_Information_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SNA_Access_Information_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SNA_Access_Information_iE_Extensions_element (ASN1CTXT* pctxt,
   SNA_Access_Information_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SNA_Access_Information_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SNA_Access_Information_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SNA_Access_Information_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SNA_Access_Information_ExtIEs[index].ExtensionSize);
   stat = SNA_Access_Information_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SNA_Access_Information_iE_Extensions (ASN1CTXT* pctxt, SNA_Access_Information_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SNA_Access_Information_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SNA_Access_Information_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SNA_Access_Information_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SNA_Access_Information (ASN1CTXT* pctxt, SNA_Access_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode authorisedPLMNs */

   stat = asn1PD_AuthorisedPLMNs (pctxt, &pvalue->authorisedPLMNs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SNA_Access_Information_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_IuA                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_IuA (ASN1CTXT* pctxt, UESBI_IuA* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_IuB                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_IuB (ASN1CTXT* pctxt, UESBI_IuB* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_Iu_iE_Extensions_element (ASN1CTXT* pctxt, UESBI_Iu_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UESBI_Iu_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UESBI_Iu_iE_Extensions_element (ASN1CTXT* pctxt,
   UESBI_Iu_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESBI_Iu_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESBI_Iu_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UESBI_Iu_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UESBI_Iu_ExtIEs[index].ExtensionSize);
   stat = UESBI_Iu_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_Iu_iE_Extensions (ASN1CTXT* pctxt, UESBI_Iu_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UESBI_Iu_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UESBI_Iu_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UESBI_Iu_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_Iu (ASN1CTXT* pctxt, UESBI_Iu* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uESBI_IuAPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uESBI_IuBPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode uESBI_IuA */

   if (pvalue->m.uESBI_IuAPresent) {
      stat = asn1PD_UESBI_IuA (pctxt, &pvalue->uESBI_IuA);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uESBI_IuB */

   if (pvalue->m.uESBI_IuBPresent) {
      stat = asn1PD_UESBI_IuB (pctxt, &pvalue->uESBI_IuB);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_UESBI_Iu_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_serviceID                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMGI_serviceID (ASN1CTXT* pctxt, TMGI_serviceID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMGI_iE_Extensions_element (ASN1CTXT* pctxt, TMGI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TMGI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TMGI_iE_Extensions_element (ASN1CTXT* pctxt,
   TMGI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TMGI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TMGI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TMGI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TMGI_ExtIEs[index].ExtensionSize);
   stat = TMGI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMGI_iE_Extensions (ASN1CTXT* pctxt, TMGI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TMGI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TMGI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TMGI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMGI (ASN1CTXT* pctxt, TMGI* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode serviceID */

   stat = asn1PD_TMGI_serviceID (pctxt, &pvalue->serviceID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TMGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMS_PTP_RAB_ID                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMS_PTP_RAB_ID (ASN1CTXT* pctxt, MBMS_PTP_RAB_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameter_MaxBitrateList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Ass_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MaxBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameter_GuaranteedBitrateList                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Ass_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, Ass_RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Ass_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Ass_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   Ass_RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Ass_RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Ass_RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Ass_RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Ass_RAB_Parameters_ExtIEs[index].ExtensionSize);
   stat = Ass_RAB_Parameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, Ass_RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Ass_RAB_Parameters_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Ass_RAB_Parameters_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Ass_RAB_Parameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameters (ASN1CTXT* pctxt, Ass_RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.assMaxBitrateInfPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.assGuaranteedBitRateInfPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode assMaxBitrateInf */

   if (pvalue->m.assMaxBitrateInfPresent) {
      stat = asn1PD_Ass_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->assMaxBitrateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode assGuaranteedBitRateInf */

   if (pvalue->m.assGuaranteedBitRateInfPresent) {
      stat = asn1PD_Ass_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->assGuaranteedBitRateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_Ass_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewBSS_To_OldBSS_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NewBSS_To_OldBSS_Information (ASN1CTXT* pctxt, NewBSS_To_OldBSS_Information* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_N_PDU_SequenceNumber                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_N_PDU_SequenceNumber (ASN1CTXT* pctxt, DL_N_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_N_PDU_SequenceNumber                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_N_PDU_SequenceNumber (ASN1CTXT* pctxt, UL_N_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyStatus                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_KeyStatus (ASN1CTXT* pctxt, KeyStatus* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = old; break;
         case 1: *pvalue = new_; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GlobalRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GlobalRNC_ID (ASN1CTXT* pctxt, GlobalRNC_ID* pvalue)
{
   int stat = 0;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rNC_ID */

   stat = asn1PD_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMSI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMSI (ASN1CTXT* pctxt, TMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_TMSI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_P_TMSI (ASN1CTXT* pctxt, P_TMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TemporaryUE_ID                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TemporaryUE_ID (ASN1CTXT* pctxt, TemporaryUE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* tMSI */
         case 0:
            pvalue->u.tMSI = rtMemAllocTypeZ (pctxt, TMSI);
            if (pvalue->u.tMSI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_TMSI (pctxt, pvalue->u.tMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* p_TMSI */
         case 1:
            pvalue->u.p_TMSI = rtMemAllocTypeZ (pctxt, P_TMSI);
            if (pvalue->u.p_TMSI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_P_TMSI (pctxt, pvalue->u.p_TMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAI_iE_Extensions_element (ASN1CTXT* pctxt, RAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAI_iE_Extensions_element (ASN1CTXT* pctxt,
   RAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAI_ExtIEs[index].ExtensionSize);
   stat = RAI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAI_iE_Extensions (ASN1CTXT* pctxt, RAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAI (ASN1CTXT* pctxt, RAI* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAI */

   stat = asn1PD_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rAC */

   stat = asn1PD_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PagingAreaID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PagingAreaID (ASN1CTXT* pctxt, PagingAreaID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* lAI */
         case 0:
            pvalue->u.lAI = rtMemAllocTypeZ (pctxt, LAI);
            if (pvalue->u.lAI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_LAI (pctxt, pvalue->u.lAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* rAI */
         case 1:
            pvalue->u.rAI = rtMemAllocTypeZ (pctxt, RAI);
            if (pvalue->u.rAI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RAI (pctxt, pvalue->u.rAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PagingCause                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PagingCause (ASN1CTXT* pctxt, PagingCause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = terminating_high_priority_signalling; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = terminating_conversational_call; break;
         case 1: *pvalue = terminating_streaming_call; break;
         case 2: *pvalue = terminating_interactive_call; break;
         case 3: *pvalue = terminating_background_call; break;
         case 4: *pvalue = terminating_low_priority_signalling; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonSearchingIndication                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NonSearchingIndication (ASN1CTXT* pctxt, NonSearchingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = non_searching; break;
      case 1: *pvalue = searching; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DRX_CycleLengthCoefficient                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DRX_CycleLengthCoefficient (ASN1CTXT* pctxt, DRX_CycleLengthCoefficient* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(6), OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceType (ASN1CTXT* pctxt, TraceType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TriggerID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TriggerID (ASN1CTXT* pctxt, TriggerID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(22), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEI (ASN1CTXT* pctxt, IMEI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISV                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISV (ASN1CTXT* pctxt, IMEISV* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UE_ID                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UE_ID (ASN1CTXT* pctxt, UE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* imsi */
         case 0:
            pvalue->u.imsi = rtMemAllocTypeZ (pctxt, IMSI);
            if (pvalue->u.imsi == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMSI (pctxt, pvalue->u.imsi);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* imei */
         case 1:
            pvalue->u.imei = rtMemAllocTypeZ (pctxt, IMEI);
            if (pvalue->u.imei == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEI (pctxt, pvalue->u.imei);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* imeisv */
         case 3:
            pvalue->u.imeisv = rtMemAllocTypeZ (pctxt, IMEISV);
            if (pvalue->u.imeisv == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEISV (pctxt, pvalue->u.imeisv);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      rtCopyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OMC_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_OMC_ID (ASN1CTXT* pctxt, OMC_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(22), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceDepth                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceDepth (ASN1CTXT* pctxt, TraceDepth* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = minimum; break;
         case 1: *pvalue = medium; break;
         case 2: *pvalue = maximum; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_interface_                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterfacesToTraceItem_interface_ (ASN1CTXT* pctxt, InterfacesToTraceItem_interface_* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = iu_cs; break;
         case 1: *pvalue = iu_ps; break;
         case 2: *pvalue = iur; break;
         case 3: *pvalue = iub; break;
         case 4: *pvalue = uu; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterfacesToTraceItem_iE_Extensions_element (ASN1CTXT* pctxt, InterfacesToTraceItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InterfacesToTraceItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InterfacesToTraceItem_iE_Extensions_element (ASN1CTXT* pctxt,
   InterfacesToTraceItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InterfacesToTraceItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InterfacesToTraceItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InterfacesToTraceItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InterfacesToTraceItem_ExtIEs[index].ExtensionSize);
   stat = InterfacesToTraceItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterfacesToTraceItem_iE_Extensions (ASN1CTXT* pctxt, InterfacesToTraceItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InterfacesToTraceItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InterfacesToTraceItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InterfacesToTraceItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterfacesToTraceItem (ASN1CTXT* pctxt, InterfacesToTraceItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode interface_ */

   stat = asn1PD_InterfacesToTraceItem_interface_ (pctxt, &pvalue->interface_);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_InterfacesToTraceItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ListOfInterfacesToTrace                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ListOfInterfacesToTrace (ASN1CTXT* pctxt, ListOfInterfacesToTrace* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   InterfacesToTraceItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InterfacesToTraceItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InterfacesToTraceItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TracePropagationParameters_iE_Extensions_element (ASN1CTXT* pctxt, TracePropagationParameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TracePropagationParameters_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TracePropagationParameters_iE_Extensions_element (ASN1CTXT* pctxt,
   TracePropagationParameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TracePropagationParameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TracePropagationParameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TracePropagationParameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TracePropagationParameters_ExtIEs[index].ExtensionSize);
   stat = TracePropagationParameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TracePropagationParameters_iE_Extensions (ASN1CTXT* pctxt, TracePropagationParameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TracePropagationParameters_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TracePropagationParameters_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TracePropagationParameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TracePropagationParameters (ASN1CTXT* pctxt, TracePropagationParameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.listOfInterfacesToTracePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode traceRecordingSessionReference */

   stat = asn1PD_TraceRecordingSessionReference (pctxt, &pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode traceDepth */

   stat = asn1PD_TraceDepth (pctxt, &pvalue->traceDepth);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode listOfInterfacesToTrace */

   if (pvalue->m.listOfInterfacesToTracePresent) {
      stat = asn1PD_ListOfInterfacesToTrace (pctxt, &pvalue->listOfInterfacesToTrace);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TracePropagationParameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Event                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Event (ASN1CTXT* pctxt, Event* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = stop_direct; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = stop_change_of_service_area; break;
         case 1: *pvalue = direct; break;
         case 2: *pvalue = change_of_servicearea; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportArea                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportArea (ASN1CTXT* pctxt, ReportArea* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = service_area; break;
         case 1: *pvalue = geographical_area; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestType (ASN1CTXT* pctxt, RequestType* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.accuracyCodePresent = optbit;

   /* decode event */

   stat = asn1PD_Event (pctxt, &pvalue->event);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode reportArea */

   stat = asn1PD_ReportArea (pctxt, &pvalue->reportArea);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode accuracyCode */

   if (pvalue->m.accuracyCodePresent) {
      stat = pd_ConsUInt8 (pctxt, &pvalue->accuracyCode, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VerticalAccuracyCode                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_VerticalAccuracyCode (ASN1CTXT* pctxt, VerticalAccuracyCode* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResponseTime                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResponseTime (ASN1CTXT* pctxt, ResponseTime* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = lowdelay; break;
         case 1: *pvalue = delaytolerant; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningPriority                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositioningPriority (ASN1CTXT* pctxt, PositioningPriority* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = high_Priority; break;
         case 1: *pvalue = normal_Priority; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClientType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ClientType (ASN1CTXT* pctxt, ClientType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = emergency_Services; break;
         case 1: *pvalue = value_Added_Services; break;
         case 2: *pvalue = pLMN_Operator_Services; break;
         case 3: *pvalue = lawful_Intercept_Services; break;
         case 4: *pvalue = pLMN_Operator_Broadcast_Services; break;
         case 5: *pvalue = pLMN_Operator_O_et_M; break;
         case 6: *pvalue = pLMN_Operator_Anonymous_Statistics; break;
         case 7: *pvalue = pLMN_Operator_Target_MS_Service_Support; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_latitudeSign                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalCoordinates_latitudeSign (ASN1CTXT* pctxt, GeographicalCoordinates_latitudeSign* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = north; break;
      case 1: *pvalue = south; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalCoordinates_iE_Extensions_element (ASN1CTXT* pctxt, GeographicalCoordinates_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GeographicalCoordinates_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GeographicalCoordinates_iE_Extensions_element (ASN1CTXT* pctxt,
   GeographicalCoordinates_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GeographicalCoordinates_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GeographicalCoordinates_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GeographicalCoordinates_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GeographicalCoordinates_ExtIEs[index].ExtensionSize);
   stat = GeographicalCoordinates_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalCoordinates_iE_Extensions (ASN1CTXT* pctxt, GeographicalCoordinates_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GeographicalCoordinates_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GeographicalCoordinates_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GeographicalCoordinates_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalCoordinates (ASN1CTXT* pctxt, GeographicalCoordinates* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode latitudeSign */

   stat = asn1PD_GeographicalCoordinates_latitudeSign (pctxt, &pvalue->latitudeSign);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode latitude */

   stat = pd_ConsUnsigned (pctxt, &pvalue->latitude, OSUINTCONST(0), OSUINTCONST(8388607));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode longitude */

   stat = pd_ConsInteger (pctxt, &pvalue->longitude, OSINTCONST(-8388608), OSINTCONST(8388607));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GeographicalCoordinates_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Point_iE_Extensions_element (ASN1CTXT* pctxt, GA_Point_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_Point_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_Point_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_Point_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_Point_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_Point_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_Point_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_Point_ExtIEs[index].ExtensionSize);
   stat = GA_Point_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Point_iE_Extensions (ASN1CTXT* pctxt, GA_Point_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_Point_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_Point_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_Point_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Point (ASN1CTXT* pctxt, GA_Point* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_Point_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertainty_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithUnCertainty_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_PointWithUnCertainty_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_PointWithUnCertainty_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithUnCertainty_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithUnCertainty_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithUnCertainty_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithUnCertainty_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_PointWithUnCertainty_ExtIEs[index].ExtensionSize);
   stat = GA_PointWithUnCertainty_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertainty_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithUnCertainty_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_PointWithUnCertainty_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_PointWithUnCertainty_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_PointWithUnCertainty_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertainty (ASN1CTXT* pctxt, GA_PointWithUnCertainty* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_PointWithUnCertainty_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uncertaintyCode */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyCode, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Polygon_element_iE_Extensions_element (ASN1CTXT* pctxt, GA_Polygon_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_Polygon_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_Polygon_element_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_Polygon_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_Polygon_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_Polygon_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_Polygon_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_Polygon_ExtIEs[index].ExtensionSize);
   stat = GA_Polygon_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Polygon_element_iE_Extensions (ASN1CTXT* pctxt, GA_Polygon_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_Polygon_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_Polygon_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_Polygon_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Polygon_element (ASN1CTXT* pctxt, GA_Polygon_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_Polygon_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Polygon (ASN1CTXT* pctxt, GA_Polygon* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   GA_Polygon_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_Polygon_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_Polygon_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_UncertaintyEllipse                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_UncertaintyEllipse (ASN1CTXT* pctxt, GA_UncertaintyEllipse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   rtDListInit (&pvalue->extElem1);

   /* decode uncertaintySemi_major */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySemi_major, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintySemi_minor */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySemi_minor, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode orientationOfMajorAxis */

   stat = pd_ConsUInt8 (pctxt, &pvalue->orientationOfMajorAxis, OSUINTCONST(0), OSUINTCONST(179));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithUnCertaintyEllipse_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithUnCertaintyEllipse_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithUnCertaintyEllipse_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithUnCertaintyEllipse_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_PointWithUnCertaintyEllipse_ExtIEs[index].ExtensionSize);
   stat = GA_PointWithUnCertaintyEllipse_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertaintyEllipse_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_PointWithUnCertaintyEllipse_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_PointWithUnCertaintyEllipse_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertaintyEllipse (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintyEllipse */

   stat = asn1PD_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode confidence */

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_PointWithUnCertaintyEllipse_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_AltitudeAndDirection_directionOfAltitude               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_AltitudeAndDirection_directionOfAltitude (ASN1CTXT* pctxt, GA_AltitudeAndDirection_directionOfAltitude* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = height; break;
      case 1: *pvalue = depth; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_AltitudeAndDirection                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_AltitudeAndDirection (ASN1CTXT* pctxt, GA_AltitudeAndDirection* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   rtDListInit (&pvalue->extElem1);

   /* decode directionOfAltitude */

   stat = asn1PD_GA_AltitudeAndDirection_directionOfAltitude (pctxt, &pvalue->directionOfAltitude);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altitude */

   stat = pd_ConsUInt16 (pctxt, &pvalue->altitude, OSUINTCONST(0), OSUINTCONST(32767));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitude_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithAltitude_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_PointWithAltitude_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_PointWithAltitude_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithAltitude_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithAltitude_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithAltitude_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithAltitude_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_PointWithAltitude_ExtIEs[index].ExtensionSize);
   stat = GA_PointWithAltitude_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitude_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithAltitude_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_PointWithAltitude_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_PointWithAltitude_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_PointWithAltitude_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitude (ASN1CTXT* pctxt, GA_PointWithAltitude* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altitudeAndDirection */

   stat = asn1PD_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_PointWithAltitude_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].ExtensionSize);
   stat = GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altitudeAndDirection */

   stat = asn1PD_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintyEllipse */

   stat = asn1PD_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintyAltitude */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyAltitude, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode confidence */

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_EllipsoidArc_iE_Extensions_element (ASN1CTXT* pctxt, GA_EllipsoidArc_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_EllipsoidArc_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_EllipsoidArc_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_EllipsoidArc_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_EllipsoidArc_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_EllipsoidArc_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_EllipsoidArc_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_EllipsoidArc_ExtIEs[index].ExtensionSize);
   stat = GA_EllipsoidArc_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_EllipsoidArc_iE_Extensions (ASN1CTXT* pctxt, GA_EllipsoidArc_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_EllipsoidArc_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_EllipsoidArc_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_EllipsoidArc_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_EllipsoidArc (ASN1CTXT* pctxt, GA_EllipsoidArc* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode innerRadius */

   stat = pd_ConsUInt16 (pctxt, &pvalue->innerRadius, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintyRadius */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyRadius, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode offsetAngle */

   stat = pd_ConsUInt8 (pctxt, &pvalue->offsetAngle, OSUINTCONST(0), OSUINTCONST(179));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode includedAngle */

   stat = pd_ConsUInt8 (pctxt, &pvalue->includedAngle, OSUINTCONST(0), OSUINTCONST(179));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode confidence */

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_EllipsoidArc_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalArea                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalArea (ASN1CTXT* pctxt, GeographicalArea* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* point */
         case 0:
            pvalue->u.point = rtMemAllocTypeZ (pctxt, GA_Point);
            if (pvalue->u.point == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_Point (pctxt, pvalue->u.point);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* pointWithUnCertainty */
         case 1:
            pvalue->u.pointWithUnCertainty = rtMemAllocTypeZ (pctxt, GA_PointWithUnCertainty);
            if (pvalue->u.pointWithUnCertainty == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_PointWithUnCertainty (pctxt, pvalue->u.pointWithUnCertainty);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* polygon */
         case 2:
            pvalue->u.polygon = rtMemAllocTypeZ (pctxt, GA_Polygon);
            if (pvalue->u.polygon == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_Polygon (pctxt, pvalue->u.polygon);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* pointWithUncertaintyEllipse */
         case 4:
            pvalue->u.pointWithUncertaintyEllipse = rtMemAllocTypeZ (pctxt, GA_PointWithUnCertaintyEllipse);
            if (pvalue->u.pointWithUncertaintyEllipse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_PointWithUnCertaintyEllipse (pctxt, pvalue->u.pointWithUncertaintyEllipse);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* pointWithAltitude */
         case 5:
            pvalue->u.pointWithAltitude = rtMemAllocTypeZ (pctxt, GA_PointWithAltitude);
            if (pvalue->u.pointWithAltitude == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_PointWithAltitude (pctxt, pvalue->u.pointWithAltitude);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* pointWithAltitudeAndUncertaintyEllipsoid */
         case 6:
            pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid = rtMemAllocTypeZ (pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid);
            if (pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid (pctxt, pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* ellipsoidArc */
         case 7:
            pvalue->u.ellipsoidArc = rtMemAllocTypeZ (pctxt, GA_EllipsoidArc);
            if (pvalue->u.ellipsoidArc == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_EllipsoidArc (pctxt, pvalue->u.ellipsoidArc);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      rtCopyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AreaIdentity                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AreaIdentity (ASN1CTXT* pctxt, AreaIdentity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sAI */
         case 0:
            pvalue->u.sAI = rtMemAllocTypeZ (pctxt, SAI);
            if (pvalue->u.sAI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* geographicalArea */
         case 1:
            pvalue->u.geographicalArea = rtMemAllocTypeZ (pctxt, GeographicalArea);
            if (pvalue->u.geographicalArea == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeographicalArea (pctxt, pvalue->u.geographicalArea);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LastKnownServiceArea_iE_Extensions_element (ASN1CTXT* pctxt, LastKnownServiceArea_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LastKnownServiceArea_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LastKnownServiceArea_iE_Extensions_element (ASN1CTXT* pctxt,
   LastKnownServiceArea_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LastKnownServiceArea_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LastKnownServiceArea_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LastKnownServiceArea_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LastKnownServiceArea_ExtIEs[index].ExtensionSize);
   stat = LastKnownServiceArea_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LastKnownServiceArea_iE_Extensions (ASN1CTXT* pctxt, LastKnownServiceArea_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LastKnownServiceArea_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LastKnownServiceArea_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LastKnownServiceArea_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LastKnownServiceArea (ASN1CTXT* pctxt, LastKnownServiceArea* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode sAI */

   stat = asn1PD_SAI (pctxt, &pvalue->sAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode ageOfSAI */

   stat = pd_ConsUInt16 (pctxt, &pvalue->ageOfSAI, OSUINTCONST(0), OSUINTCONST(32767));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_LastKnownServiceArea_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningDataDiscriminator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositioningDataDiscriminator (ASN1CTXT* pctxt, PositioningDataDiscriminator* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningMethodAndUsage                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositioningMethodAndUsage (ASN1CTXT* pctxt, PositioningMethodAndUsage* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningDataSet                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositioningDataSet (ASN1CTXT* pctxt, PositioningDataSet* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(9), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (9 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositionData_iE_Extensions_element (ASN1CTXT* pctxt, PositionData_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_PositionData_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_PositionData_iE_Extensions_element (ASN1CTXT* pctxt,
   PositionData_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PositionData_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PositionData_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PositionData_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, PositionData_ExtIEs[index].ExtensionSize);
   stat = PositionData_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositionData_iE_Extensions (ASN1CTXT* pctxt, PositionData_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   PositionData_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PositionData_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PositionData_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositionData (ASN1CTXT* pctxt, PositionData* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.positioningDataSetPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode positioningDataDiscriminator */

   stat = asn1PD_PositioningDataDiscriminator (pctxt, &pvalue->positioningDataDiscriminator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode positioningDataSet */

   if (pvalue->m.positioningDataSetPresent) {
      stat = asn1PD_PositioningDataSet (pctxt, &pvalue->positioningDataSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_PositionData_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionDataSpecificToGERANIuMode                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositionDataSpecificToGERANIuMode (ASN1CTXT* pctxt, PositionDataSpecificToGERANIuMode* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccuracyFulfilmentIndicator                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AccuracyFulfilmentIndicator (ASN1CTXT* pctxt, AccuracyFulfilmentIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = requested_Accuracy_Fulfilled; break;
         case 1: *pvalue = requested_Accuracy_Not_Fulfilled; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_PDU                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NAS_PDU (ASN1CTXT* pctxt, NAS_PDU* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_SequenceNumber                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NAS_SequenceNumber (ASN1CTXT* pctxt, NAS_SequenceNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAPI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAPI (ASN1CTXT* pctxt, SAPI* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = sapi_0; break;
         case 1: *pvalue = sapi_3; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RejectCauseValue                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RejectCauseValue (ASN1CTXT* pctxt, RejectCauseValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = pLMN_Not_Allowed; break;
         case 1: *pvalue = location_Area_Not_Allowed; break;
         case 2: *pvalue = roaming_Not_Allowed_In_This_Location_Area; break;
         case 3: *pvalue = no_Suitable_Cell_In_Location_Area; break;
         case 4: *pvalue = gPRS_Services_Not_Allowed_In_This_PLMN; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionCompleted                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RedirectionCompleted (ASN1CTXT* pctxt, RedirectionCompleted* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = redirection_completed; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberOfSteps                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NumberOfSteps (ASN1CTXT* pctxt, NumberOfSteps* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_MaxBitrateList                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Requested_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MaxBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_GuaranteedBitrateList             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Requested_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AlternativeRABConfigurationRequest                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AlternativeRABConfigurationRequest (ASN1CTXT* pctxt, AlternativeRABConfigurationRequest* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = alternative_RAB_configuration_Requested; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Requested_RAB_Parameter_Values_ExtIEs_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Requested_RAB_Parameter_Values_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Requested_RAB_Parameter_Values_ExtIEs_Extension *pvalue = (_Requested_RAB_Parameter_Values_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_AlternativeRABConfigurationRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_Values_iE_Extensions_element (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Requested_RAB_Parameter_Values_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Requested_RAB_Parameter_Values_iE_Extensions_element (ASN1CTXT* pctxt,
   Requested_RAB_Parameter_Values_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Requested_RAB_Parameter_Values_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Requested_RAB_Parameter_Values_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Requested_RAB_Parameter_Values_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Requested_RAB_Parameter_Values_ExtIEs[index].ExtensionSize);
   stat = Requested_RAB_Parameter_Values_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_Values_iE_Extensions (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Requested_RAB_Parameter_Values_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Requested_RAB_Parameter_Values_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Requested_RAB_Parameter_Values_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_Values (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.requestedMaxBitratesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.requestedGuaranteedBitratesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode requestedMaxBitrates */

   if (pvalue->m.requestedMaxBitratesPresent) {
      stat = asn1PD_Requested_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->requestedMaxBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode requestedGuaranteedBitrates */

   if (pvalue->m.requestedGuaranteedBitratesPresent) {
      stat = asn1PD_Requested_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->requestedGuaranteedBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_Requested_RAB_Parameter_Values_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedLocationRelatedDataType                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedLocationRelatedDataType (ASN1CTXT* pctxt, RequestedLocationRelatedDataType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = decipheringKeysUEBasedOTDOA; break;
         case 1: *pvalue = decipheringKeysAssistedGPS; break;
         case 2: *pvalue = dedicatedAssistanceDataUEBasedOTDOA; break;
         case 3: *pvalue = dedicatedAssistanceDataAssistedGPS; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedGPSAssistanceData                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedGPSAssistanceData (ASN1CTXT* pctxt, RequestedGPSAssistanceData* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(38), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestType                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequestType (ASN1CTXT* pctxt, LocationRelatedDataRequestType* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.requestedGPSAssistanceDataPresent = optbit;

   /* decode requestedLocationRelatedDataType */

   stat = asn1PD_RequestedLocationRelatedDataType (pctxt, &pvalue->requestedLocationRelatedDataType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode requestedGPSAssistanceData */

   if (pvalue->m.requestedGPSAssistanceDataPresent) {
      stat = asn1PD_RequestedGPSAssistanceData (pctxt, &pvalue->requestedGPSAssistanceData);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestTypeSpecificToGERANIuMode       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequestTypeSpecificToGERANIuMode (ASN1CTXT* pctxt, LocationRelatedDataRequestTypeSpecificToGERANIuMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = decipheringKeysEOTD; break;
         case 1: *pvalue = dedicatedMobileAssistedEOTDAssistanceData; break;
         case 2: *pvalue = dedicatedMobileBasedEOTDAssistanceData; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_currentDecipherin  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(56), OSUINTCONST(56), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_nextDecipheringKe  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(56), OSUINTCONST(56), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BroadcastAssistanceDataDecipheringKeys (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   rtDListInit (&pvalue->extElem1);

   /* decode cipheringKeyFlag */

   stat = asn1PD_BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag (pctxt, &pvalue->cipheringKeyFlag);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode currentDecipheringKey */

   stat = asn1PD_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (pctxt, &pvalue->currentDecipheringKey);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode nextDecipheringKey */

   stat = asn1PD_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (pctxt, &pvalue->nextDecipheringKey);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferID (ASN1CTXT* pctxt, InformationTransferID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ListOF_SNAs                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ListOF_SNAs (ASN1CTXT* pctxt, ListOF_SNAs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, SNAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_SNAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LA_LIST_element_iE_Extensions_element (ASN1CTXT* pctxt, LA_LIST_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LA_LIST_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LA_LIST_element_iE_Extensions_element (ASN1CTXT* pctxt,
   LA_LIST_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LA_LIST_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LA_LIST_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LA_LIST_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LA_LIST_ExtIEs[index].ExtensionSize);
   stat = LA_LIST_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LA_LIST_element_iE_Extensions (ASN1CTXT* pctxt, LA_LIST_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LA_LIST_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LA_LIST_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LA_LIST_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LA_LIST_element (ASN1CTXT* pctxt, LA_LIST_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAC */

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode listOF_SNAs */

   stat = asn1PD_ListOF_SNAs (pctxt, &pvalue->listOF_SNAs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_LA_LIST_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LA_LIST (ASN1CTXT* pctxt, LA_LIST* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   LA_LIST_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;
   int lstat;

   rtDListInit (pvalue);

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, LA_LIST_element);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_LA_LIST_element (pctxt, pdata);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         rtDListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == 0) break;
   }
   stat = pu_checkSizeConstraint (pctxt, pvalue->count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNs_in_shared_network_element_iE_Extensions_element (ASN1CTXT* pctxt, PLMNs_in_shared_network_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_PLMNs_in_shared_network_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_PLMNs_in_shared_network_element_iE_Extensions_element (ASN1CTXT* pctxt,
   PLMNs_in_shared_network_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PLMNs_in_shared_network_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PLMNs_in_shared_network_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PLMNs_in_shared_network_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, PLMNs_in_shared_network_ExtIEs[index].ExtensionSize);
   stat = PLMNs_in_shared_network_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNs_in_shared_network_element_iE_Extensions (ASN1CTXT* pctxt, PLMNs_in_shared_network_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   PLMNs_in_shared_network_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PLMNs_in_shared_network_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PLMNs_in_shared_network_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNs_in_shared_network_element (ASN1CTXT* pctxt, PLMNs_in_shared_network_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode lA_LIST */

   stat = asn1PD_LA_LIST (pctxt, &pvalue->lA_LIST);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_PLMNs_in_shared_network_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNs_in_shared_network (ASN1CTXT* pctxt, PLMNs_in_shared_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   PLMNs_in_shared_network_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PLMNs_in_shared_network_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PLMNs_in_shared_network_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Shared_Network_Information_iE_Extensions_element (ASN1CTXT* pctxt, Shared_Network_Information_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Shared_Network_Information_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Shared_Network_Information_iE_Extensions_element (ASN1CTXT* pctxt,
   Shared_Network_Information_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Shared_Network_Information_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Shared_Network_Information_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Shared_Network_Information_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Shared_Network_Information_ExtIEs[index].ExtensionSize);
   stat = Shared_Network_Information_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Shared_Network_Information_iE_Extensions (ASN1CTXT* pctxt, Shared_Network_Information_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Shared_Network_Information_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Shared_Network_Information_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Shared_Network_Information_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Shared_Network_Information (ASN1CTXT* pctxt, Shared_Network_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNs_in_shared_network */

   stat = asn1PD_PLMNs_in_shared_network (pctxt, &pvalue->pLMNs_in_shared_network);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_Shared_Network_Information_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProvidedData                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ProvidedData (ASN1CTXT* pctxt, ProvidedData* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* shared_network_information */
         case 0:
            pvalue->u.shared_network_information = rtMemAllocTypeZ (pctxt, Shared_Network_Information);
            if (pvalue->u.shared_network_information == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Shared_Network_Information (pctxt, pvalue->u.shared_network_information);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIMInformation                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIMInformation (ASN1CTXT* pctxt, RIMInformation* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Cell_ID_iE_Extensions_element (ASN1CTXT* pctxt, GERAN_Cell_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GERAN_Cell_ID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GERAN_Cell_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   GERAN_Cell_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Cell_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Cell_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Cell_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GERAN_Cell_ID_ExtIEs[index].ExtensionSize);
   stat = GERAN_Cell_ID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Cell_ID_iE_Extensions (ASN1CTXT* pctxt, GERAN_Cell_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GERAN_Cell_ID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GERAN_Cell_ID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GERAN_Cell_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Cell_ID (ASN1CTXT* pctxt, GERAN_Cell_ID* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAI */

   stat = asn1PD_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rAC */

   stat = asn1PD_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cI */

   stat = asn1PD_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GERAN_Cell_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIMRoutingAddress                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIMRoutingAddress (ASN1CTXT* pctxt, RIMRoutingAddress* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* globalRNC_ID */
         case 0:
            pvalue->u.globalRNC_ID = rtMemAllocTypeZ (pctxt, GlobalRNC_ID);
            if (pvalue->u.globalRNC_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GlobalRNC_ID (pctxt, pvalue->u.globalRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* gERAN_Cell_ID */
         case 1:
            pvalue->u.gERAN_Cell_ID = rtMemAllocTypeZ (pctxt, GERAN_Cell_ID);
            if (pvalue->u.gERAN_Cell_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GERAN_Cell_ID (pctxt, pvalue->u.gERAN_Cell_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIM_Transfer_iE_Extensions_element (ASN1CTXT* pctxt, RIM_Transfer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RIM_Transfer_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RIM_Transfer_iE_Extensions_element (ASN1CTXT* pctxt,
   RIM_Transfer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RIM_Transfer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RIM_Transfer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RIM_Transfer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RIM_Transfer_ExtIEs[index].ExtensionSize);
   stat = RIM_Transfer_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIM_Transfer_iE_Extensions (ASN1CTXT* pctxt, RIM_Transfer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RIM_Transfer_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RIM_Transfer_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RIM_Transfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIM_Transfer (ASN1CTXT* pctxt, RIM_Transfer* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rIMRoutingAddressPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rIMInformation */

   stat = asn1PD_RIMInformation (pctxt, &pvalue->rIMInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rIMRoutingAddress */

   if (pvalue->m.rIMRoutingAddressPresent) {
      stat = asn1PD_RIMRoutingAddress (pctxt, &pvalue->rIMRoutingAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RIM_Transfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformationTransferType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterSystemInformationTransferType (ASN1CTXT* pctxt, InterSystemInformationTransferType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rIM_Transfer */
         case 0:
            pvalue->u.rIM_Transfer = rtMemAllocTypeZ (pctxt, RIM_Transfer);
            if (pvalue->u.rIM_Transfer == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RIM_Transfer (pctxt, pvalue->u.rIM_Transfer);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeID (ASN1CTXT* pctxt, InformationExchangeID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeType (ASN1CTXT* pctxt, InformationExchangeType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = transfer; break;
         case 1: *pvalue = request; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_traceActivationIndicator              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNCTraceInformation_traceActivationIndicator (ASN1CTXT* pctxt, RNCTraceInformation_traceActivationIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = activated; break;
      case 1: *pvalue = deactivated; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIList                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIList (ASN1CTXT* pctxt, IMEIList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (64 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_IMEI (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVList                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVList (ASN1CTXT* pctxt, IMEISVList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (64 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_IMEISV (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iMEIMask                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIGroup_iMEIMask (ASN1CTXT* pctxt, IMEIGroup_iMEIMask* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(7), OSUINTCONST(7), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIGroup_iE_Extensions_element (ASN1CTXT* pctxt, IMEIGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_IMEIGroup_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_IMEIGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   IMEIGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IMEIGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IMEIGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IMEIGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, IMEIGroup_ExtIEs[index].ExtensionSize);
   stat = IMEIGroup_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIGroup_iE_Extensions (ASN1CTXT* pctxt, IMEIGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   IMEIGroup_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, IMEIGroup_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_IMEIGroup_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIGroup (ASN1CTXT* pctxt, IMEIGroup* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iMEI */

   stat = asn1PD_IMEI (pctxt, &pvalue->iMEI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iMEIMask */

   stat = asn1PD_IMEIGroup_iMEIMask (pctxt, &pvalue->iMEIMask);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_IMEIGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iMEISVMask                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVGroup_iMEISVMask (ASN1CTXT* pctxt, IMEISVGroup_iMEISVMask* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(7), OSUINTCONST(7), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVGroup_iE_Extensions_element (ASN1CTXT* pctxt, IMEISVGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_IMEISVGroup_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_IMEISVGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   IMEISVGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IMEISVGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IMEISVGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IMEISVGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, IMEISVGroup_ExtIEs[index].ExtensionSize);
   stat = IMEISVGroup_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVGroup_iE_Extensions (ASN1CTXT* pctxt, IMEISVGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   IMEISVGroup_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, IMEISVGroup_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_IMEISVGroup_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVGroup (ASN1CTXT* pctxt, IMEISVGroup* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iMEISV */

   stat = asn1PD_IMEISV (pctxt, &pvalue->iMEISV);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iMEISVMask */

   stat = asn1PD_IMEISVGroup_iMEISVMask (pctxt, &pvalue->iMEISVMask);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_IMEISVGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquipmentsToBeTraced                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EquipmentsToBeTraced (ASN1CTXT* pctxt, EquipmentsToBeTraced* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iMEIlist */
         case 0:
            pvalue->u.iMEIlist = rtMemAllocTypeZ (pctxt, IMEIList);
            if (pvalue->u.iMEIlist == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEIList (pctxt, pvalue->u.iMEIlist);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* iMEISVlist */
         case 1:
            pvalue->u.iMEISVlist = rtMemAllocTypeZ (pctxt, IMEISVList);
            if (pvalue->u.iMEISVlist == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEISVList (pctxt, pvalue->u.iMEISVlist);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* iMEIgroup */
         case 2:
            pvalue->u.iMEIgroup = rtMemAllocTypeZ (pctxt, IMEIGroup);
            if (pvalue->u.iMEIgroup == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEIGroup (pctxt, pvalue->u.iMEIgroup);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* iMEISVgroup */
         case 3:
            pvalue->u.iMEISVgroup = rtMemAllocTypeZ (pctxt, IMEISVGroup);
            if (pvalue->u.iMEISVgroup == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEISVGroup (pctxt, pvalue->u.iMEISVgroup);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNCTraceInformation_iE_Extensions_element (ASN1CTXT* pctxt, RNCTraceInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RNCTraceInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RNCTraceInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   RNCTraceInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RNCTraceInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RNCTraceInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RNCTraceInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RNCTraceInformation_ExtIEs[index].ExtensionSize);
   stat = RNCTraceInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNCTraceInformation_iE_Extensions (ASN1CTXT* pctxt, RNCTraceInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RNCTraceInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RNCTraceInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RNCTraceInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNCTraceInformation (ASN1CTXT* pctxt, RNCTraceInformation* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.equipmentsToBeTracedPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode traceReference */

   stat = asn1PD_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode traceActivationIndicator */

   stat = asn1PD_RNCTraceInformation_traceActivationIndicator (pctxt, &pvalue->traceActivationIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode equipmentsToBeTraced */

   if (pvalue->m.equipmentsToBeTracedPresent) {
      stat = asn1PD_EquipmentsToBeTraced (pctxt, &pvalue->equipmentsToBeTraced);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RNCTraceInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferType (ASN1CTXT* pctxt, InformationTransferType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rNCTraceInformation */
         case 0:
            pvalue->u.rNCTraceInformation = rtMemAllocTypeZ (pctxt, RNCTraceInformation);
            if (pvalue->u.rNCTraceInformation == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RNCTraceInformation (pctxt, pvalue->u.rNCTraceInformation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNRequest                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSIPMulticastAddressandAPNRequest (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(512), 0 };
   int stat = 0;
   TMGI* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TMGI);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TMGI (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationRequestType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationRequestType (ASN1CTXT* pctxt, InformationRequestType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* mBMSIPMulticastAddressandAPNRequest */
         case 0:
            pvalue->u.mBMSIPMulticastAddressandAPNRequest = rtMemAllocTypeZ (pctxt, MBMSIPMulticastAddressandAPNRequest);
            if (pvalue->u.mBMSIPMulticastAddressandAPNRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_MBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.mBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* permanentNAS_UE_ID */
         case 1:
            pvalue->u.permanentNAS_UE_ID = rtMemAllocTypeZ (pctxt, PermanentNAS_UE_ID);
            if (pvalue->u.permanentNAS_UE_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue->u.permanentNAS_UE_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPMulticastAddress                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPMulticastAddress (ASN1CTXT* pctxt, IPMulticastAddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(16), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  APN                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_APN (ASN1CTXT* pctxt, APN* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(255), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (ASN1CTXT* pctxt,
   MBMSIPMulticastAddressandAPNlist_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSIPMulticastAddressandAPNlist_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSIPMulticastAddressandAPNlist_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSIPMulticastAddressandAPNlist_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSIPMulticastAddressandAPNlist_ExtIEs[index].ExtensionSize);
   stat = MBMSIPMulticastAddressandAPNlist_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSIPMulticastAddressandAPNlist_iE_Extensions (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSIPMulticastAddressandAPNlist_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSIPMulticastAddressandAPNlist_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSIPMulticastAddressandAPNlist (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode tMGI */

   stat = asn1PD_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iPMulticastAddress */

   stat = asn1PD_IPMulticastAddress (pctxt, &pvalue->iPMulticastAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode aPN */

   stat = asn1PD_APN (pctxt, &pvalue->aPN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_MBMSIPMulticastAddressandAPNlist_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedMBMSIPMulticastAddressandAPNRequest              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedMBMSIPMulticastAddressandAPNRequest (ASN1CTXT* pctxt, RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(512), 0 };
   int stat = 0;
   MBMSIPMulticastAddressandAPNlist* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSIPMulticastAddressandAPNlist);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSIPMulticastAddressandAPNlist (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedMulticastServiceList                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedMulticastServiceList (ASN1CTXT* pctxt, RequestedMulticastServiceList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   TMGI* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TMGI);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TMGI (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationRequested                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationRequested (ASN1CTXT* pctxt, InformationRequested* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* requestedMBMSIPMulticastAddressandAPNRequest */
         case 0:
            pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest = rtMemAllocTypeZ (pctxt, RequestedMBMSIPMulticastAddressandAPNRequest);
            if (pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RequestedMBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* requestedMulticastServiceList */
         case 1:
            pvalue->u.requestedMulticastServiceList = rtMemAllocTypeZ (pctxt, RequestedMulticastServiceList);
            if (pvalue->u.requestedMulticastServiceList == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RequestedMulticastServiceList (pctxt, pvalue->u.requestedMulticastServiceList);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionIdentity                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionIdentity (ASN1CTXT* pctxt, MBMSSessionIdentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSBearerServiceType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSBearerServiceType (ASN1CTXT* pctxt, MBMSBearerServiceType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = multicast; break;
         case 1: *pvalue = broadcast; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionDuration                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionDuration (ASN1CTXT* pctxt, MBMSSessionDuration* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSServiceArea                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSServiceArea (ASN1CTXT* pctxt, MBMSServiceArea* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrequenceLayerConvergenceFlag                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FrequenceLayerConvergenceFlag (ASN1CTXT* pctxt, FrequenceLayerConvergenceFlag* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = no_FLC_flag; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAofIdleModeUEs                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAofIdleModeUEs (ASN1CTXT* pctxt, RAofIdleModeUEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, RAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt,
   NotEmptyRAListofIdleModeUEs_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < NotEmptyRAListofIdleModeUEs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &NotEmptyRAListofIdleModeUEs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == NotEmptyRAListofIdleModeUEs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, NotEmptyRAListofIdleModeUEs_ExtIEs[index].ExtensionSize);
   stat = NotEmptyRAListofIdleModeUEs_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NotEmptyRAListofIdleModeUEs_iE_Extensions (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   NotEmptyRAListofIdleModeUEs_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, NotEmptyRAListofIdleModeUEs_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NotEmptyRAListofIdleModeUEs (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAofIdleModeUEs */

   stat = asn1PD_RAofIdleModeUEs (pctxt, &pvalue->rAofIdleModeUEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_NotEmptyRAListofIdleModeUEs_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (ASN1CTXT* pctxt, RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = emptylist; break;
         case 1: *pvalue = fulllist; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListofIdleModeUEs                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAListofIdleModeUEs (ASN1CTXT* pctxt, RAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* notEmptyRAListofIdleModeUEs */
         case 0:
            pvalue->u.notEmptyRAListofIdleModeUEs = rtMemAllocTypeZ (pctxt, NotEmptyRAListofIdleModeUEs);
            if (pvalue->u.notEmptyRAListofIdleModeUEs == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_NotEmptyRAListofIdleModeUEs (pctxt, pvalue->u.notEmptyRAListofIdleModeUEs);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* emptyFullRAListofIdleModeUEs */
         case 1:
            stat = asn1PD_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (pctxt, &pvalue->u.emptyFullRAListofIdleModeUEs);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionRepetitionNumber                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionRepetitionNumber (ASN1CTXT* pctxt, MBMSSessionRepetitionNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeToMBMSDataTransfer                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeToMBMSDataTransfer (ASN1CTXT* pctxt, TimeToMBMSDataTransfer* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SessionUpdateID                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SessionUpdateID (ASN1CTXT* pctxt, SessionUpdateID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewRAListofIdleModeUEs                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NewRAListofIdleModeUEs (ASN1CTXT* pctxt, NewRAListofIdleModeUEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, RAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListwithNoIdleModeUEsAnyMore                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAListwithNoIdleModeUEsAnyMore (ASN1CTXT* pctxt, RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, RAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeltaRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DeltaRAListofIdleModeUEs_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DeltaRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt,
   DeltaRAListofIdleModeUEs_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DeltaRAListofIdleModeUEs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DeltaRAListofIdleModeUEs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DeltaRAListofIdleModeUEs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DeltaRAListofIdleModeUEs_ExtIEs[index].ExtensionSize);
   stat = DeltaRAListofIdleModeUEs_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeltaRAListofIdleModeUEs_iE_Extensions (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DeltaRAListofIdleModeUEs_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DeltaRAListofIdleModeUEs_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DeltaRAListofIdleModeUEs_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeltaRAListofIdleModeUEs (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.newRAListofIdleModeUEsPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode newRAListofIdleModeUEs */

   if (pvalue->m.newRAListofIdleModeUEsPresent) {
      stat = asn1PD_NewRAListofIdleModeUEs (pctxt, &pvalue->newRAListofIdleModeUEs);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAListwithNoIdleModeUEsAnyMore */

   if (pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent) {
      stat = asn1PD_RAListwithNoIdleModeUEsAnyMore (pctxt, &pvalue->rAListwithNoIdleModeUEsAnyMore);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_DeltaRAListofIdleModeUEs_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_Registration                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_Registration (ASN1CTXT* pctxt, MBMSCNDe_Registration* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = normalsessionstop; break;
         case 1: *pvalue = deregister; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequestType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequestType (ASN1CTXT* pctxt, MBMSRegistrationRequestType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = register_; break;
         case 1: *pvalue = deregister_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateControlAllowed                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RateControlAllowed (ASN1CTXT* pctxt, RateControlAllowed* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = not_allowed; break;
      case 1: *pvalue = allowed; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

extern void init_AllocationOrRetentionPriority_ExtIEs(ASN1CTXT *pctxt);
extern void init_Alt_RAB_Parameters_ExtIEs(ASN1CTXT *pctxt);
extern void init_Ass_RAB_Parameters_ExtIEs(ASN1CTXT *pctxt);
extern void init_AuthorisedPLMNs_ExtIEs(ASN1CTXT *pctxt);
extern void init_CellLoadInformation_ExtIEs(ASN1CTXT *pctxt);
extern void init_CellLoadInformationGroup_ExtIEs(ASN1CTXT *pctxt);
extern void init_CriticalityDiagnostics_ExtIEs(ASN1CTXT *pctxt);
extern void init_CriticalityDiagnostics_IE_List_ExtIEs(ASN1CTXT *pctxt);
extern void init_MessageStructure_ExtIEs(ASN1CTXT *pctxt);
extern void init_CGI_ExtIEs(ASN1CTXT *pctxt);
extern void init_DeltaRAListofIdleModeUEs_ExtIEs(ASN1CTXT *pctxt);
extern void init_EncryptionInformation_ExtIEs(ASN1CTXT *pctxt);
extern void init_GeographicalCoordinates_ExtIEs(ASN1CTXT *pctxt);
extern void init_GA_EllipsoidArc_ExtIEs(ASN1CTXT *pctxt);
extern void init_GA_Point_ExtIEs(ASN1CTXT *pctxt);
extern void init_GA_PointWithAltitude_ExtIEs(ASN1CTXT *pctxt);
extern void init_GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs(ASN1CTXT *pctxt);
extern void init_GA_PointWithUnCertainty_ExtIEs(ASN1CTXT *pctxt);
extern void init_GA_PointWithUnCertaintyEllipse_ExtIEs(ASN1CTXT *pctxt);
extern void init_GA_Polygon_ExtIEs(ASN1CTXT *pctxt);
extern void init_GERAN_Cell_ID_ExtIEs(ASN1CTXT *pctxt);
extern void init_IMEIGroup_ExtIEs(ASN1CTXT *pctxt);
extern void init_IMEISVGroup_ExtIEs(ASN1CTXT *pctxt);
extern void init_IntegrityProtectionInformation_ExtIEs(ASN1CTXT *pctxt);
extern void init_InterSystemInformation_TransparentContainer_ExtIEs(ASN1CTXT *pctxt);
extern void init_LA_LIST_ExtIEs(ASN1CTXT *pctxt);
extern void init_LAI_ExtIEs(ASN1CTXT *pctxt);
extern void init_LastKnownServiceArea_ExtIEs(ASN1CTXT *pctxt);
extern void init_InterfacesToTraceItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_PLMNs_in_shared_network_ExtIEs(ASN1CTXT *pctxt);
extern void init_PositionData_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_Parameters_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_TrCH_MappingItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAI_ExtIEs(ASN1CTXT *pctxt);
extern void init_NotEmptyRAListofIdleModeUEs_ExtIEs(ASN1CTXT *pctxt);
extern void init_MBMSIPMulticastAddressandAPNlist_ExtIEs(ASN1CTXT *pctxt);
extern void init_Requested_RAB_Parameter_Values_ExtIEs(ASN1CTXT *pctxt);
extern void init_ResidualBitErrorRatio_ExtIEs(ASN1CTXT *pctxt);
extern void init_RIM_Transfer_ExtIEs(ASN1CTXT *pctxt);
extern void init_RNCTraceInformation_ExtIEs(ASN1CTXT *pctxt);
extern void init_SAI_ExtIEs(ASN1CTXT *pctxt);
extern void init_Shared_Network_Information_ExtIEs(ASN1CTXT *pctxt);
extern void init_SDU_ErrorRatio_ExtIEs(ASN1CTXT *pctxt);
extern void init_SDU_FormatInformationParameters_ExtIEs(ASN1CTXT *pctxt);
extern void init_SDU_Parameters_ExtIEs(ASN1CTXT *pctxt);
extern void init_SNA_Access_Information_ExtIEs(ASN1CTXT *pctxt);
extern void init_SourceRNC_ID_ExtIEs(ASN1CTXT *pctxt);
extern void init_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs(ASN1CTXT *pctxt);
extern void init_SourceUTRANCellID_ExtIEs(ASN1CTXT *pctxt);
extern void init_SRB_TrCH_MappingItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_TargetRNC_ID_ExtIEs(ASN1CTXT *pctxt);
extern void init_TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs(ASN1CTXT *pctxt);
extern void init_TMGI_ExtIEs(ASN1CTXT *pctxt);
extern void init_TracePropagationParameters_ExtIEs(ASN1CTXT *pctxt);
extern void init_TraceRecordingSessionInformation_ExtIEs(ASN1CTXT *pctxt);
extern void init_TrCH_ID_ExtIEs(ASN1CTXT *pctxt);
extern void init_UESBI_Iu_ExtIEs(ASN1CTXT *pctxt);

void RANAP_IEs_init(ASN1CTXT *pctxt)
{
   init_AllocationOrRetentionPriority_ExtIEs(pctxt);
   init_Alt_RAB_Parameters_ExtIEs(pctxt);
   init_Ass_RAB_Parameters_ExtIEs(pctxt);
   init_AuthorisedPLMNs_ExtIEs(pctxt);
   init_CellLoadInformation_ExtIEs(pctxt);
   init_CellLoadInformationGroup_ExtIEs(pctxt);
   init_CriticalityDiagnostics_ExtIEs(pctxt);
   init_CriticalityDiagnostics_IE_List_ExtIEs(pctxt);
   init_MessageStructure_ExtIEs(pctxt);
   init_CGI_ExtIEs(pctxt);
   init_DeltaRAListofIdleModeUEs_ExtIEs(pctxt);
   init_EncryptionInformation_ExtIEs(pctxt);
   init_GeographicalCoordinates_ExtIEs(pctxt);
   init_GA_EllipsoidArc_ExtIEs(pctxt);
   init_GA_Point_ExtIEs(pctxt);
   init_GA_PointWithAltitude_ExtIEs(pctxt);
   init_GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs(pctxt);
   init_GA_PointWithUnCertainty_ExtIEs(pctxt);
   init_GA_PointWithUnCertaintyEllipse_ExtIEs(pctxt);
   init_GA_Polygon_ExtIEs(pctxt);
   init_GERAN_Cell_ID_ExtIEs(pctxt);
   init_IMEIGroup_ExtIEs(pctxt);
   init_IMEISVGroup_ExtIEs(pctxt);
   init_IntegrityProtectionInformation_ExtIEs(pctxt);
   init_InterSystemInformation_TransparentContainer_ExtIEs(pctxt);
   init_LA_LIST_ExtIEs(pctxt);
   init_LAI_ExtIEs(pctxt);
   init_LastKnownServiceArea_ExtIEs(pctxt);
   init_InterfacesToTraceItem_ExtIEs(pctxt);
   init_PLMNs_in_shared_network_ExtIEs(pctxt);
   init_PositionData_ExtIEs(pctxt);
   init_RAB_Parameters_ExtIEs(pctxt);
   init_RAB_TrCH_MappingItem_ExtIEs(pctxt);
   init_RAI_ExtIEs(pctxt);
   init_NotEmptyRAListofIdleModeUEs_ExtIEs(pctxt);
   init_MBMSIPMulticastAddressandAPNlist_ExtIEs(pctxt);
   init_Requested_RAB_Parameter_Values_ExtIEs(pctxt);
   init_ResidualBitErrorRatio_ExtIEs(pctxt);
   init_RIM_Transfer_ExtIEs(pctxt);
   init_RNCTraceInformation_ExtIEs(pctxt);
   init_SAI_ExtIEs(pctxt);
   init_Shared_Network_Information_ExtIEs(pctxt);
   init_SDU_ErrorRatio_ExtIEs(pctxt);
   init_SDU_FormatInformationParameters_ExtIEs(pctxt);
   init_SDU_Parameters_ExtIEs(pctxt);
   init_SNA_Access_Information_ExtIEs(pctxt);
   init_SourceRNC_ID_ExtIEs(pctxt);
   init_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs(pctxt);
   init_SourceUTRANCellID_ExtIEs(pctxt);
   init_SRB_TrCH_MappingItem_ExtIEs(pctxt);
   init_TargetRNC_ID_ExtIEs(pctxt);
   init_TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs(pctxt);
   init_TMGI_ExtIEs(pctxt);
   init_TracePropagationParameters_ExtIEs(pctxt);
   init_TraceRecordingSessionInformation_ExtIEs(pctxt);
   init_TrCH_ID_ExtIEs(pctxt);
   init_UESBI_Iu_ExtIEs(pctxt);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_ExtIEs                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION AllocationOrRetentionPriority_ExtIEs[1];
int AllocationOrRetentionPriority_ExtIEs_Size = 0;

void init_AllocationOrRetentionPriority_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_ExtIEs                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION Alt_RAB_Parameters_ExtIEs[1];
int Alt_RAB_Parameters_ExtIEs_Size = 1;

void init_Alt_RAB_Parameters_ExtIEs(ASN1CTXT *pctxt)
{

   Alt_RAB_Parameters_ExtIEs[0].id = 158;
   Alt_RAB_Parameters_ExtIEs[0].criticality = ignore;
   Alt_RAB_Parameters_ExtIEs[0].ExtensionSize = sizeof(_Alt_RAB_Parameters_ExtIEs_Extension);
   Alt_RAB_Parameters_ExtIEs[0].decodeExtension = &asn1PD__Alt_RAB_Parameters_ExtIEs_Extension;
   Alt_RAB_Parameters_ExtIEs[0].printExtension = &asn1Print__Alt_RAB_Parameters_ExtIEs_Extension;
   Alt_RAB_Parameters_ExtIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_ExtIEs                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION Ass_RAB_Parameters_ExtIEs[1];
int Ass_RAB_Parameters_ExtIEs_Size = 0;

void init_Ass_RAB_Parameters_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_ExtIEs                                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION AuthorisedPLMNs_ExtIEs[1];
int AuthorisedPLMNs_ExtIEs_Size = 0;

void init_AuthorisedPLMNs_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_ExtIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CellLoadInformation_ExtIEs[1];
int CellLoadInformation_ExtIEs_Size = 0;

void init_CellLoadInformation_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_ExtIEs                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CellLoadInformationGroup_ExtIEs[1];
int CellLoadInformationGroup_ExtIEs_Size = 0;

void init_CellLoadInformationGroup_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_ExtIEs                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CriticalityDiagnostics_ExtIEs[1];
int CriticalityDiagnostics_ExtIEs_Size = 0;

void init_CriticalityDiagnostics_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_ExtIEs                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CriticalityDiagnostics_IE_List_ExtIEs[2];
int CriticalityDiagnostics_IE_List_ExtIEs_Size = 2;

void init_CriticalityDiagnostics_IE_List_ExtIEs(ASN1CTXT *pctxt)
{

   CriticalityDiagnostics_IE_List_ExtIEs[0].id = 88;
   CriticalityDiagnostics_IE_List_ExtIEs[0].criticality = ignore;
   CriticalityDiagnostics_IE_List_ExtIEs[0].ExtensionSize = sizeof(_CriticalityDiagnostics_IE_List_ExtIEs_Extension);
   CriticalityDiagnostics_IE_List_ExtIEs[0].decodeExtension = &asn1PD__CriticalityDiagnostics_IE_List_ExtIEs_Extension;
   CriticalityDiagnostics_IE_List_ExtIEs[0].printExtension = &asn1Print__CriticalityDiagnostics_IE_List_ExtIEs_Extension;
   CriticalityDiagnostics_IE_List_ExtIEs[0].presence = optional;

   CriticalityDiagnostics_IE_List_ExtIEs[1].id = 93;
   CriticalityDiagnostics_IE_List_ExtIEs[1].criticality = ignore;
   CriticalityDiagnostics_IE_List_ExtIEs[1].ExtensionSize = sizeof(_CriticalityDiagnostics_IE_List_ExtIEs_Extension_1);
   CriticalityDiagnostics_IE_List_ExtIEs[1].decodeExtension = &asn1PD__CriticalityDiagnostics_IE_List_ExtIEs_Extension_1;
   CriticalityDiagnostics_IE_List_ExtIEs[1].printExtension = &asn1Print__CriticalityDiagnostics_IE_List_ExtIEs_Extension_1;
   CriticalityDiagnostics_IE_List_ExtIEs[1].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  MessageStructure_ExtIEs                                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MessageStructure_ExtIEs[1];
int MessageStructure_ExtIEs_Size = 0;

void init_MessageStructure_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  CGI_ExtIEs                                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CGI_ExtIEs[1];
int CGI_ExtIEs_Size = 1;

void init_CGI_ExtIEs(ASN1CTXT *pctxt)
{

   CGI_ExtIEs[0].id = 55;
   CGI_ExtIEs[0].criticality = ignore;
   CGI_ExtIEs[0].ExtensionSize = sizeof(_CGI_ExtIEs_Extension);
   CGI_ExtIEs[0].decodeExtension = &asn1PD__CGI_ExtIEs_Extension;
   CGI_ExtIEs[0].printExtension = &asn1Print__CGI_ExtIEs_Extension;
   CGI_ExtIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_ExtIEs                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION DeltaRAListofIdleModeUEs_ExtIEs[1];
int DeltaRAListofIdleModeUEs_ExtIEs_Size = 0;

void init_DeltaRAListofIdleModeUEs_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_ExtIEs                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION EncryptionInformation_ExtIEs[1];
int EncryptionInformation_ExtIEs_Size = 0;

void init_EncryptionInformation_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_ExtIEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GeographicalCoordinates_ExtIEs[1];
int GeographicalCoordinates_ExtIEs_Size = 0;

void init_GeographicalCoordinates_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_ExtIEs                                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GA_EllipsoidArc_ExtIEs[1];
int GA_EllipsoidArc_ExtIEs_Size = 0;

void init_GA_EllipsoidArc_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GA_Point_ExtIEs                                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GA_Point_ExtIEs[1];
int GA_Point_ExtIEs_Size = 0;

void init_GA_Point_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_ExtIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GA_PointWithAltitude_ExtIEs[1];
int GA_PointWithAltitude_ExtIEs_Size = 0;

void init_GA_PointWithAltitude_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[1];
int GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size = 0;

void init_GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_ExtIEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GA_PointWithUnCertainty_ExtIEs[1];
int GA_PointWithUnCertainty_ExtIEs_Size = 0;

void init_GA_PointWithUnCertainty_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_ExtIEs                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GA_PointWithUnCertaintyEllipse_ExtIEs[1];
int GA_PointWithUnCertaintyEllipse_ExtIEs_Size = 0;

void init_GA_PointWithUnCertaintyEllipse_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_ExtIEs                                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GA_Polygon_ExtIEs[1];
int GA_Polygon_ExtIEs_Size = 0;

void init_GA_Polygon_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_ExtIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GERAN_Cell_ID_ExtIEs[1];
int GERAN_Cell_ID_ExtIEs_Size = 0;

void init_GERAN_Cell_ID_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_ExtIEs                                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION IMEIGroup_ExtIEs[1];
int IMEIGroup_ExtIEs_Size = 0;

void init_IMEIGroup_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_ExtIEs                                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION IMEISVGroup_ExtIEs[1];
int IMEISVGroup_ExtIEs_Size = 0;

void init_IMEISVGroup_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_ExtIEs                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION IntegrityProtectionInformation_ExtIEs[1];
int IntegrityProtectionInformation_ExtIEs_Size = 0;

void init_IntegrityProtectionInformation_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_ExtIEs        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION InterSystemInformation_TransparentContainer_ExtIEs[1];
int InterSystemInformation_TransparentContainer_ExtIEs_Size = 0;

void init_InterSystemInformation_TransparentContainer_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  LA_LIST_ExtIEs                                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LA_LIST_ExtIEs[1];
int LA_LIST_ExtIEs_Size = 0;

void init_LA_LIST_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  LAI_ExtIEs                                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LAI_ExtIEs[1];
int LAI_ExtIEs_Size = 0;

void init_LAI_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_ExtIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LastKnownServiceArea_ExtIEs[1];
int LastKnownServiceArea_ExtIEs_Size = 0;

void init_LastKnownServiceArea_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_ExtIEs                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION InterfacesToTraceItem_ExtIEs[1];
int InterfacesToTraceItem_ExtIEs_Size = 0;

void init_InterfacesToTraceItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_ExtIEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION PLMNs_in_shared_network_ExtIEs[1];
int PLMNs_in_shared_network_ExtIEs_Size = 0;

void init_PLMNs_in_shared_network_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  PositionData_ExtIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION PositionData_ExtIEs[1];
int PositionData_ExtIEs_Size = 0;

void init_PositionData_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_ExtIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_Parameters_ExtIEs[1];
int RAB_Parameters_ExtIEs_Size = 1;

void init_RAB_Parameters_ExtIEs(ASN1CTXT *pctxt)
{

   RAB_Parameters_ExtIEs[0].id = 116;
   RAB_Parameters_ExtIEs[0].criticality = ignore;
   RAB_Parameters_ExtIEs[0].ExtensionSize = sizeof(_RAB_Parameters_ExtIEs_Extension);
   RAB_Parameters_ExtIEs[0].decodeExtension = &asn1PD__RAB_Parameters_ExtIEs_Extension;
   RAB_Parameters_ExtIEs[0].printExtension = &asn1Print__RAB_Parameters_ExtIEs_Extension;
   RAB_Parameters_ExtIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_ExtIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_TrCH_MappingItem_ExtIEs[1];
int RAB_TrCH_MappingItem_ExtIEs_Size = 1;

void init_RAB_TrCH_MappingItem_ExtIEs(ASN1CTXT *pctxt)
{

   RAB_TrCH_MappingItem_ExtIEs[0].id = 3;
   RAB_TrCH_MappingItem_ExtIEs[0].criticality = ignore;
   RAB_TrCH_MappingItem_ExtIEs[0].ExtensionSize = sizeof(_RAB_TrCH_MappingItem_ExtIEs_Extension);
   RAB_TrCH_MappingItem_ExtIEs[0].decodeExtension = &asn1PD__RAB_TrCH_MappingItem_ExtIEs_Extension;
   RAB_TrCH_MappingItem_ExtIEs[0].printExtension = &asn1Print__RAB_TrCH_MappingItem_ExtIEs_Extension;
   RAB_TrCH_MappingItem_ExtIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAI_ExtIEs                                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAI_ExtIEs[1];
int RAI_ExtIEs_Size = 0;

void init_RAI_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_ExtIEs                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION NotEmptyRAListofIdleModeUEs_ExtIEs[1];
int NotEmptyRAListofIdleModeUEs_ExtIEs_Size = 0;

void init_NotEmptyRAListofIdleModeUEs_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_ExtIEs                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSIPMulticastAddressandAPNlist_ExtIEs[1];
int MBMSIPMulticastAddressandAPNlist_ExtIEs_Size = 0;

void init_MBMSIPMulticastAddressandAPNlist_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_ExtIEs                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION Requested_RAB_Parameter_Values_ExtIEs[1];
int Requested_RAB_Parameter_Values_ExtIEs_Size = 1;

void init_Requested_RAB_Parameter_Values_ExtIEs(ASN1CTXT *pctxt)
{

   Requested_RAB_Parameter_Values_ExtIEs[0].id = 159;
   Requested_RAB_Parameter_Values_ExtIEs[0].criticality = ignore;
   Requested_RAB_Parameter_Values_ExtIEs[0].ExtensionSize = sizeof(_Requested_RAB_Parameter_Values_ExtIEs_Extension);
   Requested_RAB_Parameter_Values_ExtIEs[0].decodeExtension = &asn1PD__Requested_RAB_Parameter_Values_ExtIEs_Extension;
   Requested_RAB_Parameter_Values_ExtIEs[0].printExtension = &asn1Print__Requested_RAB_Parameter_Values_ExtIEs_Extension;
   Requested_RAB_Parameter_Values_ExtIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_ExtIEs                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ResidualBitErrorRatio_ExtIEs[1];
int ResidualBitErrorRatio_ExtIEs_Size = 0;

void init_ResidualBitErrorRatio_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_ExtIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RIM_Transfer_ExtIEs[1];
int RIM_Transfer_ExtIEs_Size = 0;

void init_RIM_Transfer_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_ExtIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RNCTraceInformation_ExtIEs[1];
int RNCTraceInformation_ExtIEs_Size = 0;

void init_RNCTraceInformation_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SAI_ExtIEs                                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SAI_ExtIEs[1];
int SAI_ExtIEs_Size = 0;

void init_SAI_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_ExtIEs                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION Shared_Network_Information_ExtIEs[1];
int Shared_Network_Information_ExtIEs_Size = 0;

void init_Shared_Network_Information_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_ExtIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SDU_ErrorRatio_ExtIEs[1];
int SDU_ErrorRatio_ExtIEs_Size = 0;

void init_SDU_ErrorRatio_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_ExtIEs                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SDU_FormatInformationParameters_ExtIEs[1];
int SDU_FormatInformationParameters_ExtIEs_Size = 0;

void init_SDU_FormatInformationParameters_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_ExtIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SDU_Parameters_ExtIEs[1];
int SDU_Parameters_ExtIEs_Size = 0;

void init_SDU_Parameters_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_ExtIEs                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SNA_Access_Information_ExtIEs[1];
int SNA_Access_Information_ExtIEs_Size = 0;

void init_SNA_Access_Information_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_ExtIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SourceRNC_ID_ExtIEs[1];
int SourceRNC_ID_ExtIEs_Size = 0;

void init_SourceRNC_ID_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[4];
int SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size = 4;

void init_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs(ASN1CTXT *pctxt)
{

   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[0].id = 98;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[0].criticality = reject;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[0].ExtensionSize = sizeof(_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension);
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[0].decodeExtension = &asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[0].printExtension = &asn1Print__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[0].presence = optional;

   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[1].id = 121;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[1].criticality = ignore;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[1].ExtensionSize = sizeof(_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1);
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[1].decodeExtension = &asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[1].printExtension = &asn1Print__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[1].presence = optional;

   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[2].id = 124;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[2].criticality = ignore;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[2].ExtensionSize = sizeof(_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2);
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[2].decodeExtension = &asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[2].printExtension = &asn1Print__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[2].presence = optional;

   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[3].id = 156;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[3].criticality = ignore;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[3].ExtensionSize = sizeof(_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3);
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[3].decodeExtension = &asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[3].printExtension = &asn1Print__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3;
   SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_ExtIEs                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SourceUTRANCellID_ExtIEs[1];
int SourceUTRANCellID_ExtIEs_Size = 0;

void init_SourceUTRANCellID_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_ExtIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SRB_TrCH_MappingItem_ExtIEs[1];
int SRB_TrCH_MappingItem_ExtIEs_Size = 0;

void init_SRB_TrCH_MappingItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_ExtIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION TargetRNC_ID_ExtIEs[1];
int TargetRNC_ID_ExtIEs_Size = 0;

void init_TargetRNC_ID_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[1];
int TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size = 0;

void init_TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  TMGI_ExtIEs                                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION TMGI_ExtIEs[1];
int TMGI_ExtIEs_Size = 0;

void init_TMGI_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_ExtIEs                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION TracePropagationParameters_ExtIEs[1];
int TracePropagationParameters_ExtIEs_Size = 0;

void init_TracePropagationParameters_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_ExtIEs                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION TraceRecordingSessionInformation_ExtIEs[1];
int TraceRecordingSessionInformation_ExtIEs_Size = 0;

void init_TraceRecordingSessionInformation_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_ExtIEs                                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION TrCH_ID_ExtIEs[2];
int TrCH_ID_ExtIEs_Size = 2;

void init_TrCH_ID_ExtIEs(ASN1CTXT *pctxt)
{

   TrCH_ID_ExtIEs[0].id = 117;
   TrCH_ID_ExtIEs[0].criticality = ignore;
   TrCH_ID_ExtIEs[0].ExtensionSize = sizeof(_TrCH_ID_ExtIEs_Extension);
   TrCH_ID_ExtIEs[0].decodeExtension = &asn1PD__TrCH_ID_ExtIEs_Extension;
   TrCH_ID_ExtIEs[0].printExtension = &asn1Print__TrCH_ID_ExtIEs_Extension;
   TrCH_ID_ExtIEs[0].presence = optional;

   TrCH_ID_ExtIEs[1].id = 160;
   TrCH_ID_ExtIEs[1].criticality = ignore;
   TrCH_ID_ExtIEs[1].ExtensionSize = sizeof(_TrCH_ID_ExtIEs_Extension_1);
   TrCH_ID_ExtIEs[1].decodeExtension = &asn1PD__TrCH_ID_ExtIEs_Extension_1;
   TrCH_ID_ExtIEs[1].printExtension = &asn1Print__TrCH_ID_ExtIEs_Extension_1;
   TrCH_ID_ExtIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_ExtIEs                                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION UESBI_Iu_ExtIEs[1];
int UESBI_Iu_ExtIEs_Size = 0;

void init_UESBI_Iu_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  CauseRadioNetwork                                         */
/*                                                            */
/**************************************************************/

void asn1Print_CauseRadioNetwork
   (const char* name, CauseRadioNetwork* pvalue)
{
   switch (*pvalue) {
      case 1: printf ("%s = rab_pre_empted\n", name); break;
      case 2: printf ("%s = trelocoverall_expiry\n", name); break;
      case 3: printf ("%s = trelocprep_expiry\n", name); break;
      case 4: printf ("%s = treloccomplete_expiry\n", name); break;
      case 5: printf ("%s = tqueing_expiry\n", name); break;
      case 6: printf ("%s = relocation_triggered\n", name); break;
      case 7: printf ("%s = trellocalloc_expiry\n", name); break;
      case 8: printf ("%s = unable_to_establish_during_relocation\n", name); break;
      case 9: printf ("%s = unknown_target_rnc\n", name); break;
      case 10: printf ("%s = relocation_cancelled\n", name); break;
      case 11: printf ("%s = successful_relocation\n", name); break;
      case 12: printf ("%s = requested_ciphering_and_or_integrity_protection_algorithms_not_supported\n", name); break;
      case 13: printf ("%s = conflict_with_already_existing_integrity_protection_and_or_ciphering_information\n", name); break;
      case 14: printf ("%s = failure_in_the_radio_interface_procedure\n", name); break;
      case 15: printf ("%s = release_due_to_utran_generated_reason\n", name); break;
      case 16: printf ("%s = user_inactivity\n", name); break;
      case 17: printf ("%s = time_critical_relocation\n", name); break;
      case 18: printf ("%s = requested_traffic_class_not_available\n", name); break;
      case 19: printf ("%s = invalid_rab_parameters_value\n", name); break;
      case 20: printf ("%s = requested_maximum_bit_rate_not_available\n", name); break;
      case 21: printf ("%s = requested_guaranteed_bit_rate_not_available\n", name); break;
      case 22: printf ("%s = requested_transfer_delay_not_achievable\n", name); break;
      case 23: printf ("%s = invalid_rab_parameters_combination\n", name); break;
      case 24: printf ("%s = condition_violation_for_sdu_parameters\n", name); break;
      case 25: printf ("%s = condition_violation_for_traffic_handling_priority\n", name); break;
      case 26: printf ("%s = condition_violation_for_guaranteed_bit_rate\n", name); break;
      case 27: printf ("%s = user_plane_versions_not_supported\n", name); break;
      case 28: printf ("%s = iu_up_failure\n", name); break;
      case 29: printf ("%s = relocation_failure_in_target_CN_RNC_or_target_system\n", name); break;
      case 30: printf ("%s = invalid_RAB_ID\n", name); break;
      case 31: printf ("%s = no_remaining_rab\n", name); break;
      case 32: printf ("%s = interaction_with_other_procedure\n", name); break;
      case 33: printf ("%s = requested_maximum_bit_rate_for_dl_not_available\n", name); break;
      case 34: printf ("%s = requested_maximum_bit_rate_for_ul_not_available\n", name); break;
      case 35: printf ("%s = requested_guaranteed_bit_rate_for_dl_not_available\n", name); break;
      case 36: printf ("%s = requested_guaranteed_bit_rate_for_ul_not_available\n", name); break;
      case 37: printf ("%s = repeated_integrity_checking_failure\n", name); break;
      case 38: printf ("%s = requested_request_type_not_supported\n", name); break;
      case 39: printf ("%s = request_superseded\n", name); break;
      case 40: printf ("%s = release_due_to_UE_generated_signalling_connection_release\n", name); break;
      case 41: printf ("%s = resource_optimisation_relocation\n", name); break;
      case 42: printf ("%s = requested_information_not_available\n", name); break;
      case 43: printf ("%s = relocation_desirable_for_radio_reasons\n", name); break;
      case 44: printf ("%s = relocation_not_supported_in_target_RNC_or_target_system\n", name); break;
      case 45: printf ("%s = directed_retry\n", name); break;
      case 46: printf ("%s = radio_connection_with_UE_Lost\n", name); break;
      case 47: printf ("%s = rNC_unable_to_establish_all_RFCs\n", name); break;
      case 48: printf ("%s = deciphering_keys_not_available\n", name); break;
      case 49: printf ("%s = dedicated_assistance_data_not_available\n", name); break;
      case 50: printf ("%s = relocation_target_not_allowed\n", name); break;
      case 51: printf ("%s = location_reporting_congestion\n", name); break;
      case 52: printf ("%s = reduce_load_in_serving_cell\n", name); break;
      case 53: printf ("%s = no_radio_resources_available_in_target_cell\n", name); break;
      case 54: printf ("%s = gERAN_Iumode_failure\n", name); break;
      case 55: printf ("%s = access_restricted_due_to_shared_networks\n", name); break;
      case 56: printf ("%s = incoming_relocation_not_supported_due_to_PUESBINE_feature\n", name); break;
      case 57: printf ("%s = traffic_load_in_the_target_cell_higher_than_in_the_source_cell\n", name); break;
      case 58: printf ("%s = mBMS_no_multicast_service_for_this_UE\n", name); break;
      case 59: printf ("%s = mBMS_unknown_UE_ID\n", name); break;
      case 60: printf ("%s = successful_MBMS_session_start_no_data_bearer_necessary\n", name); break;
      case 61: printf ("%s = mBMS_superseded_due_to_NNSF\n", name); break;
      case 62: printf ("%s = mBMS_UE_linking_already_done\n", name); break;
      case 63: printf ("%s = mBMS_UE_de_linking_failure_no_existing_UE_linking\n", name); break;
      case 64: printf ("%s = tMGI_unknown\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  CauseTransmissionNetwork                                  */
/*                                                            */
/**************************************************************/

void asn1Print_CauseTransmissionNetwork
   (const char* name, CauseTransmissionNetwork* pvalue)
{
   switch (*pvalue) {
      case 65: printf ("%s = signalling_transport_resource_failure\n", name); break;
      case 66: printf ("%s = iu_transport_connection_failed_to_establish\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  CauseNAS                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_CauseNAS
   (const char* name, CauseNAS* pvalue)
{
   switch (*pvalue) {
      case 81: printf ("%s = user_restriction_start_indication\n", name); break;
      case 82: printf ("%s = user_restriction_end_indication\n", name); break;
      case 83: printf ("%s = normal_release\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  CauseProtocol                                             */
/*                                                            */
/**************************************************************/

void asn1Print_CauseProtocol
   (const char* name, CauseProtocol* pvalue)
{
   switch (*pvalue) {
      case 97: printf ("%s = transfer_syntax_error\n", name); break;
      case 98: printf ("%s = semantic_error\n", name); break;
      case 99: printf ("%s = message_not_compatible_with_receiver_state\n", name); break;
      case 100: printf ("%s = abstract_syntax_error_reject\n", name); break;
      case 101: printf ("%s = abstract_syntax_error_ignore_and_notify\n", name); break;
      case 102: printf ("%s = abstract_syntax_error_falsely_constructed_message\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  CauseMisc                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_CauseMisc
   (const char* name, CauseMisc* pvalue)
{
   switch (*pvalue) {
      case 113: printf ("%s = om_intervention\n", name); break;
      case 114: printf ("%s = no_resource_available\n", name); break;
      case 115: printf ("%s = unspecified_failure\n", name); break;
      case 116: printf ("%s = network_optimisation\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  CauseNon_Standard                                         */
/*                                                            */
/**************************************************************/

void asn1Print_CauseNon_Standard
   (const char* name, CauseNon_Standard* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  CauseRadioNetworkExtension                                */
/*                                                            */
/**************************************************************/

void asn1Print_CauseRadioNetworkExtension
   (const char* name, CauseRadioNetworkExtension* pvalue)
{
   switch (*pvalue) {
      case 257: printf ("%s = iP_multicast_address_and_APN_not_valid\n", name); break;
      case 258: printf ("%s = mBMS_de_registration_rejected_due_to_implicit_registration\n", name); break;
      case 259: printf ("%s = mBMS_request_superseded\n", name); break;
      case 260: printf ("%s = mBMS_de_registration_during_session_not_allowed\n", name); break;
      case 261: printf ("%s = mBMS_no_data_bearer_necessary\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  Cause                                                     */
/*                                                            */
/**************************************************************/

void asn1Print_Cause
   (const char* name, Cause* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.radioNetwork", name);
         asn1Print_CauseRadioNetwork (namebuf, &pvalue->u.radioNetwork);
         break;

      case 2:
         sprintf (namebuf, "%s.u.transmissionNetwork", name);
         asn1Print_CauseTransmissionNetwork (namebuf, &pvalue->u.transmissionNetwork);
         break;

      case 3:
         sprintf (namebuf, "%s.u.nAS", name);
         asn1Print_CauseNAS (namebuf, &pvalue->u.nAS);
         break;

      case 4:
         sprintf (namebuf, "%s.u.protocol", name);
         asn1Print_CauseProtocol (namebuf, &pvalue->u.protocol);
         break;

      case 5:
         sprintf (namebuf, "%s.u.misc", name);
         asn1Print_CauseMisc (namebuf, &pvalue->u.misc);
         break;

      case 6:
         sprintf (namebuf, "%s.u.non_Standard", name);
         asn1Print_CauseNon_Standard (namebuf, &pvalue->u.non_Standard);
         break;

      case 7:
         sprintf (namebuf, "%s.u.radioNetworkExtension", name);
         asn1Print_CauseRadioNetworkExtension (namebuf, &pvalue->u.radioNetworkExtension);
         break;

      case 8:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ID                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ID
   (const char* name, RAB_ID* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfullyTransmittedDataVolume                       */
/*                                                            */
/**************************************************************/

void asn1Print_UnsuccessfullyTransmittedDataVolume
   (const char* name, UnsuccessfullyTransmittedDataVolume* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReference                                       */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReference
   (const char* name, DataVolumeReference* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  DL_GTP_PDU_SequenceNumber                                 */
/*                                                            */
/**************************************************************/

void asn1Print_DL_GTP_PDU_SequenceNumber
   (const char* name, DL_GTP_PDU_SequenceNumber* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  UL_GTP_PDU_SequenceNumber                                 */
/*                                                            */
/**************************************************************/

void asn1Print_UL_GTP_PDU_SequenceNumber
   (const char* name, UL_GTP_PDU_SequenceNumber* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber0                                         */
/*                                                            */
/**************************************************************/

void asn1Print_RepetitionNumber0
   (const char* name, RepetitionNumber0* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber1                                         */
/*                                                            */
/**************************************************************/

void asn1Print_RepetitionNumber1
   (const char* name, RepetitionNumber1* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

void asn1Print_MessageStructure_element_iE_Extensions_element
   (const char* name, MessageStructure_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MessageStructure_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MessageStructure_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MessageStructure_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MessageStructure_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions                    */
/*                                                            */
/**************************************************************/

void asn1Print_MessageStructure_element_iE_Extensions
   (const char* name, MessageStructure_element_iE_Extensions* pvalue)
{
   MessageStructure_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MessageStructure_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MessageStructure_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element                                  */
/*                                                            */
/**************************************************************/

void asn1Print_MessageStructure_element
   (const char* name, MessageStructure_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.repetitionNumberPresent = %d\n", name, (int)pvalue->m.repetitionNumberPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.iE_ID", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->iE_ID);

   if (pvalue->m.repetitionNumberPresent) {
      sprintf (namebuf, "%s.repetitionNumber", name);
      asn1Print_RepetitionNumber1 (namebuf, &pvalue->repetitionNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_MessageStructure_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  MessageStructure                                          */
/*                                                            */
/**************************************************************/

void asn1Print_MessageStructure
   (const char* name, MessageStructure* pvalue)
{
   MessageStructure_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MessageStructure_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MessageStructure_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _CriticalityDiagnostics_IE_List_ExtIEs_Extension          */
/*                                                            */
/**************************************************************/

void asn1Print__CriticalityDiagnostics_IE_List_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _CriticalityDiagnostics_IE_List_ExtIEs_Extension *pvalue = (_CriticalityDiagnostics_IE_List_ExtIEs_Extension*) pvalue_;
   asn1Print_MessageStructure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  TypeOfError                                               */
/*                                                            */
/**************************************************************/

void asn1Print_TypeOfError
   (const char* name, TypeOfError* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("not_understood\n"); break;
      case 1: printf ("missing\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  _CriticalityDiagnostics_IE_List_ExtIEs_Extension_1        */
/*                                                            */
/**************************************************************/

void asn1Print__CriticalityDiagnostics_IE_List_ExtIEs_Extension_1
   (const char* name, void* pvalue_)
{
   _CriticalityDiagnostics_IE_List_ExtIEs_Extension_1 *pvalue = (_CriticalityDiagnostics_IE_List_ExtIEs_Extension_1*) pvalue_;
   asn1Print_TypeOfError (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions_ele  */
/*                                                            */
/**************************************************************/

void asn1Print_CriticalityDiagnostics_IE_List_element_iE_Extensions_element
   (const char* name, CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CriticalityDiagnostics_IE_List_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CriticalityDiagnostics_IE_List_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CriticalityDiagnostics_IE_List_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CriticalityDiagnostics_IE_List_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions      */
/*                                                            */
/**************************************************************/

void asn1Print_CriticalityDiagnostics_IE_List_element_iE_Extensions
   (const char* name, CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CriticalityDiagnostics_IE_List_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_CriticalityDiagnostics_IE_List_element
   (const char* name, CriticalityDiagnostics_IE_List_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.repetitionNumberPresent = %d\n", name, (int)pvalue->m.repetitionNumberPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.iECriticality", name);
   asn1Print_Criticality (namebuf, &pvalue->iECriticality);

   sprintf (namebuf, "%s.iE_ID", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->iE_ID);

   if (pvalue->m.repetitionNumberPresent) {
      sprintf (namebuf, "%s.repetitionNumber", name);
      asn1Print_RepetitionNumber0 (namebuf, &pvalue->repetitionNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_CriticalityDiagnostics_IE_List_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List                            */
/*                                                            */
/**************************************************************/

void asn1Print_CriticalityDiagnostics_IE_List
   (const char* name, CriticalityDiagnostics_IE_List* pvalue)
{
   CriticalityDiagnostics_IE_List_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CriticalityDiagnostics_IE_List_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CriticalityDiagnostics_IE_List_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_CriticalityDiagnostics_iE_Extensions_element
   (const char* name, CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CriticalityDiagnostics_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CriticalityDiagnostics_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CriticalityDiagnostics_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CriticalityDiagnostics_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_CriticalityDiagnostics_iE_Extensions
   (const char* name, CriticalityDiagnostics_iE_Extensions* pvalue)
{
   CriticalityDiagnostics_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CriticalityDiagnostics_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CriticalityDiagnostics_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics                                    */
/*                                                            */
/**************************************************************/

void asn1Print_CriticalityDiagnostics
   (const char* name, CriticalityDiagnostics* pvalue)
{
   char namebuf[512];

   printf ("%s.m.procedureCodePresent = %d\n", name, (int)pvalue->m.procedureCodePresent);
   printf ("%s.m.triggeringMessagePresent = %d\n", name, (int)pvalue->m.triggeringMessagePresent);
   printf ("%s.m.procedureCriticalityPresent = %d\n", name, (int)pvalue->m.procedureCriticalityPresent);
   printf ("%s.m.iEsCriticalityDiagnosticsPresent = %d\n", name, (int)pvalue->m.iEsCriticalityDiagnosticsPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.procedureCodePresent) {
      sprintf (namebuf, "%s.procedureCode", name);
      asn1Print_ProcedureCode (namebuf, &pvalue->procedureCode);
   }

   if (pvalue->m.triggeringMessagePresent) {
      sprintf (namebuf, "%s.triggeringMessage", name);
      asn1Print_TriggeringMessage (namebuf, &pvalue->triggeringMessage);
   }

   if (pvalue->m.procedureCriticalityPresent) {
      sprintf (namebuf, "%s.procedureCriticality", name);
      asn1Print_Criticality (namebuf, &pvalue->procedureCriticality);
   }

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      sprintf (namebuf, "%s.iEsCriticalityDiagnostics", name);
      asn1Print_CriticalityDiagnostics_IE_List (namebuf, &pvalue->iEsCriticalityDiagnostics);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_CriticalityDiagnostics_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RelocationType                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationType
   (const char* name, RelocationType* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ue_not_involved\n"); break;
      case 1: printf ("ue_involved\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  TBCD_STRING                                               */
/*                                                            */
/**************************************************************/

void asn1Print_TBCD_STRING
   (const char* name, TBCD_STRING* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  PLMNidentity                                              */
/*                                                            */
/**************************************************************/

void asn1Print_PLMNidentity
   (const char* name, PLMNidentity* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  RNC_ID                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RNC_ID
   (const char* name, RNC_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_SourceRNC_ID_iE_Extensions_element
   (const char* name, SourceRNC_ID_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SourceRNC_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceRNC_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceRNC_ID_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SourceRNC_ID_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions                                */
/*                                                            */
/**************************************************************/

void asn1Print_SourceRNC_ID_iE_Extensions
   (const char* name, SourceRNC_ID_iE_Extensions* pvalue)
{
   SourceRNC_ID_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SourceRNC_ID_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SourceRNC_ID_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID                                              */
/*                                                            */
/**************************************************************/

void asn1Print_SourceRNC_ID
   (const char* name, SourceRNC_ID* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.rNC_ID", name);
   asn1Print_RNC_ID (namebuf, &pvalue->rNC_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SourceRNC_ID_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  LAC                                                       */
/*                                                            */
/**************************************************************/

void asn1Print_LAC
   (const char* name, LAC* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  SAC                                                       */
/*                                                            */
/**************************************************************/

void asn1Print_SAC
   (const char* name, SAC* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

void asn1Print_SAI_iE_Extensions_element
   (const char* name, SAI_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SAI_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SAI_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

void asn1Print_SAI_iE_Extensions
   (const char* name, SAI_iE_Extensions* pvalue)
{
   SAI_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SAI_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SAI_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SAI                                                       */
/*                                                            */
/**************************************************************/

void asn1Print_SAI
   (const char* name, SAI* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.lAC", name);
   asn1Print_LAC (namebuf, &pvalue->lAC);

   sprintf (namebuf, "%s.sAC", name);
   asn1Print_SAC (namebuf, &pvalue->sAC);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SAI_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  SourceID                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_SourceID
   (const char* name, SourceID* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.sourceRNC_ID", name);
         asn1Print_SourceRNC_ID (namebuf, pvalue->u.sourceRNC_ID);
         break;

      case 2:
         sprintf (namebuf, "%s.u.sAI", name);
         asn1Print_SAI (namebuf, pvalue->u.sAI);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

void asn1Print_LAI_iE_Extensions_element
   (const char* name, LAI_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LAI_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LAI_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

void asn1Print_LAI_iE_Extensions
   (const char* name, LAI_iE_Extensions* pvalue)
{
   LAI_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LAI_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LAI_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LAI                                                       */
/*                                                            */
/**************************************************************/

void asn1Print_LAI
   (const char* name, LAI* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.lAC", name);
   asn1Print_LAC (namebuf, &pvalue->lAC);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_LAI_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  RAC                                                       */
/*                                                            */
/**************************************************************/

void asn1Print_RAC
   (const char* name, RAC* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_TargetRNC_ID_iE_Extensions_element
   (const char* name, TargetRNC_ID_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < TargetRNC_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TargetRNC_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TargetRNC_ID_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      TargetRNC_ID_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions                                */
/*                                                            */
/**************************************************************/

void asn1Print_TargetRNC_ID_iE_Extensions
   (const char* name, TargetRNC_ID_iE_Extensions* pvalue)
{
   TargetRNC_ID_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TargetRNC_ID_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TargetRNC_ID_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID                                              */
/*                                                            */
/**************************************************************/

void asn1Print_TargetRNC_ID
   (const char* name, TargetRNC_ID* pvalue)
{
   char namebuf[512];

   printf ("%s.m.rACPresent = %d\n", name, (int)pvalue->m.rACPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.lAI", name);
   asn1Print_LAI (namebuf, &pvalue->lAI);

   if (pvalue->m.rACPresent) {
      sprintf (namebuf, "%s.rAC", name);
      asn1Print_RAC (namebuf, &pvalue->rAC);
   }

   sprintf (namebuf, "%s.rNC_ID", name);
   asn1Print_RNC_ID (namebuf, &pvalue->rNC_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_TargetRNC_ID_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  CI                                                        */
/*                                                            */
/**************************************************************/

void asn1Print_CI
   (const char* name, CI* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  _CGI_ExtIEs_Extension                                     */
/*                                                            */
/**************************************************************/

void asn1Print__CGI_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _CGI_ExtIEs_Extension *pvalue = (_CGI_ExtIEs_Extension*) pvalue_;
   asn1Print_RAC (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

void asn1Print_CGI_iE_Extensions_element
   (const char* name, CGI_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CGI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CGI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CGI_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CGI_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

void asn1Print_CGI_iE_Extensions
   (const char* name, CGI_iE_Extensions* pvalue)
{
   CGI_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CGI_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CGI_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CGI                                                       */
/*                                                            */
/**************************************************************/

void asn1Print_CGI
   (const char* name, CGI* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.lAC", name);
   asn1Print_LAC (namebuf, &pvalue->lAC);

   sprintf (namebuf, "%s.cI", name);
   asn1Print_CI (namebuf, &pvalue->cI);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_CGI_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  TargetID                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_TargetID
   (const char* name, TargetID* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.targetRNC_ID", name);
         asn1Print_TargetRNC_ID (namebuf, pvalue->u.targetRNC_ID);
         break;

      case 2:
         sprintf (namebuf, "%s.u.cGI", name);
         asn1Print_CGI (namebuf, pvalue->u.cGI);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  ClassmarkInformation2                                     */
/*                                                            */
/**************************************************************/

void asn1Print_ClassmarkInformation2
   (const char* name, ClassmarkInformation2* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  ClassmarkInformation3                                     */
/*                                                            */
/**************************************************************/

void asn1Print_ClassmarkInformation3
   (const char* name, ClassmarkInformation3* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  RRC_Container                                             */
/*                                                            */
/**************************************************************/

void asn1Print_RRC_Container
   (const char* name, RRC_Container* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  NumberOfIuInstances                                       */
/*                                                            */
/**************************************************************/

void asn1Print_NumberOfIuInstances
   (const char* name, NumberOfIuInstances* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionAlgorithm                              */
/*                                                            */
/**************************************************************/

void asn1Print_IntegrityProtectionAlgorithm
   (const char* name, IntegrityProtectionAlgorithm* pvalue)
{
   switch (*pvalue) {
      case 0: printf ("%s = standard_UMTS_integrity_algorithm_UIA1\n", name); break;
      case 15: printf ("%s = no_value\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  ChosenIntegrityProtectionAlgorithm                        */
/*                                                            */
/**************************************************************/

void asn1Print_ChosenIntegrityProtectionAlgorithm
   (const char* name, ChosenIntegrityProtectionAlgorithm* pvalue)
{
   asn1Print_IntegrityProtectionAlgorithm (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionKey                                    */
/*                                                            */
/**************************************************************/

void asn1Print_IntegrityProtectionKey
   (const char* name, IntegrityProtectionKey* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  EncryptionAlgorithm                                       */
/*                                                            */
/**************************************************************/

void asn1Print_EncryptionAlgorithm
   (const char* name, EncryptionAlgorithm* pvalue)
{
   switch (*pvalue) {
      case 0: printf ("%s = no_encryption\n", name); break;
      case 1: printf ("%s = standard_UMTS_encryption_algorith_UEA1\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  ChosenEncryptionAlgorithm                                 */
/*                                                            */
/**************************************************************/

void asn1Print_ChosenEncryptionAlgorithm
   (const char* name, ChosenEncryptionAlgorithm* pvalue)
{
   asn1Print_EncryptionAlgorithm (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  EncryptionKey                                             */
/*                                                            */
/**************************************************************/

void asn1Print_EncryptionKey
   (const char* name, EncryptionKey* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  D_RNTI                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_D_RNTI
   (const char* name, D_RNTI* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  TargetCellId                                              */
/*                                                            */
/**************************************************************/

void asn1Print_TargetCellId
   (const char* name, TargetCellId* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  DCH_ID                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_DCH_ID
   (const char* name, DCH_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  DSCH_ID                                                   */
/*                                                            */
/**************************************************************/

void asn1Print_DSCH_ID
   (const char* name, DSCH_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  USCH_ID                                                   */
/*                                                            */
/**************************************************************/

void asn1Print_USCH_ID
   (const char* name, USCH_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCH_MAC_d_Flow_ID                                     */
/*                                                            */
/**************************************************************/

void asn1Print_HS_DSCH_MAC_d_Flow_ID
   (const char* name, HS_DSCH_MAC_d_Flow_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  _TrCH_ID_ExtIEs_Extension                                 */
/*                                                            */
/**************************************************************/

void asn1Print__TrCH_ID_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _TrCH_ID_ExtIEs_Extension *pvalue = (_TrCH_ID_ExtIEs_Extension*) pvalue_;
   asn1Print_HS_DSCH_MAC_d_Flow_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MAC_d_Flow_ID                                       */
/*                                                            */
/**************************************************************/

void asn1Print_E_DCH_MAC_d_Flow_ID
   (const char* name, E_DCH_MAC_d_Flow_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  _TrCH_ID_ExtIEs_Extension_1                               */
/*                                                            */
/**************************************************************/

void asn1Print__TrCH_ID_ExtIEs_Extension_1
   (const char* name, void* pvalue_)
{
   _TrCH_ID_ExtIEs_Extension_1 *pvalue = (_TrCH_ID_ExtIEs_Extension_1*) pvalue_;
   asn1Print_E_DCH_MAC_d_Flow_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions_element                             */
/*                                                            */
/**************************************************************/

void asn1Print_TrCH_ID_iE_Extensions_element
   (const char* name, TrCH_ID_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < TrCH_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TrCH_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TrCH_ID_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      TrCH_ID_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions                                     */
/*                                                            */
/**************************************************************/

void asn1Print_TrCH_ID_iE_Extensions
   (const char* name, TrCH_ID_iE_Extensions* pvalue)
{
   TrCH_ID_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TrCH_ID_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TrCH_ID_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID                                                   */
/*                                                            */
/**************************************************************/

void asn1Print_TrCH_ID
   (const char* name, TrCH_ID* pvalue)
{
   char namebuf[512];

   printf ("%s.m.dCH_IDPresent = %d\n", name, (int)pvalue->m.dCH_IDPresent);
   printf ("%s.m.dSCH_IDPresent = %d\n", name, (int)pvalue->m.dSCH_IDPresent);
   printf ("%s.m.uSCH_IDPresent = %d\n", name, (int)pvalue->m.uSCH_IDPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.dCH_IDPresent) {
      sprintf (namebuf, "%s.dCH_ID", name);
      asn1Print_DCH_ID (namebuf, &pvalue->dCH_ID);
   }

   if (pvalue->m.dSCH_IDPresent) {
      sprintf (namebuf, "%s.dSCH_ID", name);
      asn1Print_DSCH_ID (namebuf, &pvalue->dSCH_ID);
   }

   if (pvalue->m.uSCH_IDPresent) {
      sprintf (namebuf, "%s.uSCH_ID", name);
      asn1Print_USCH_ID (namebuf, &pvalue->uSCH_ID);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_TrCH_ID_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_List                                              */
/*                                                            */
/**************************************************************/

void asn1Print_TrCH_ID_List
   (const char* name, TrCH_ID_List* pvalue)
{
   TrCH_ID* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TrCH_ID*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TrCH_ID (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CN_DomainIndicator                                        */
/*                                                            */
/**************************************************************/

void asn1Print_CN_DomainIndicator
   (const char* name, CN_DomainIndicator* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cs_domain\n"); break;
      case 1: printf ("ps_domain\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_TrCH_MappingItem_ExtIEs_Extension                    */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_TrCH_MappingItem_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _RAB_TrCH_MappingItem_ExtIEs_Extension *pvalue = (_RAB_TrCH_MappingItem_ExtIEs_Extension*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_TrCH_MappingItem_iE_Extensions_element
   (const char* name, RAB_TrCH_MappingItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_TrCH_MappingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_TrCH_MappingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_TrCH_MappingItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_TrCH_MappingItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_TrCH_MappingItem_iE_Extensions
   (const char* name, RAB_TrCH_MappingItem_iE_Extensions* pvalue)
{
   RAB_TrCH_MappingItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_TrCH_MappingItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_TrCH_MappingItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem                                      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_TrCH_MappingItem
   (const char* name, RAB_TrCH_MappingItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   sprintf (namebuf, "%s.trCH_ID_List", name);
   asn1Print_TrCH_ID_List (namebuf, &pvalue->trCH_ID_List);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_TrCH_MappingItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_Mapping                                          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_TrCH_Mapping
   (const char* name, RAB_TrCH_Mapping* pvalue)
{
   RAB_TrCH_MappingItem* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_TrCH_MappingItem*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_TrCH_MappingItem (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SRB_ID                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_SRB_ID
   (const char* name, SRB_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

void asn1Print_SRB_TrCH_MappingItem_iE_Extensions_element
   (const char* name, SRB_TrCH_MappingItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SRB_TrCH_MappingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRB_TrCH_MappingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRB_TrCH_MappingItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SRB_TrCH_MappingItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

void asn1Print_SRB_TrCH_MappingItem_iE_Extensions
   (const char* name, SRB_TrCH_MappingItem_iE_Extensions* pvalue)
{
   SRB_TrCH_MappingItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SRB_TrCH_MappingItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SRB_TrCH_MappingItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem                                      */
/*                                                            */
/**************************************************************/

void asn1Print_SRB_TrCH_MappingItem
   (const char* name, SRB_TrCH_MappingItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.sRB_ID", name);
   asn1Print_SRB_ID (namebuf, &pvalue->sRB_ID);

   sprintf (namebuf, "%s.trCH_ID", name);
   asn1Print_TrCH_ID (namebuf, &pvalue->trCH_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SRB_TrCH_MappingItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_Mapping                                          */
/*                                                            */
/**************************************************************/

void asn1Print_SRB_TrCH_Mapping
   (const char* name, SRB_TrCH_Mapping* pvalue)
{
   SRB_TrCH_MappingItem* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SRB_TrCH_MappingItem*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SRB_TrCH_MappingItem (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

void asn1Print__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension*) pvalue_;
   asn1Print_SRB_TrCH_Mapping (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_SourceUTRANCellID_iE_Extensions_element
   (const char* name, SourceUTRANCellID_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SourceUTRANCellID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceUTRANCellID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceUTRANCellID_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SourceUTRANCellID_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions                           */
/*                                                            */
/**************************************************************/

void asn1Print_SourceUTRANCellID_iE_Extensions
   (const char* name, SourceUTRANCellID_iE_Extensions* pvalue)
{
   SourceUTRANCellID_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SourceUTRANCellID_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SourceUTRANCellID_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID                                         */
/*                                                            */
/**************************************************************/

void asn1Print_SourceUTRANCellID
   (const char* name, SourceUTRANCellID* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.uTRANcellID", name);
   asn1Print_TargetCellId (namebuf, &pvalue->uTRANcellID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SourceUTRANCellID_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  SourceCellID                                              */
/*                                                            */
/**************************************************************/

void asn1Print_SourceCellID
   (const char* name, SourceCellID* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.sourceUTRANCellID", name);
         asn1Print_SourceUTRANCellID (namebuf, pvalue->u.sourceUTRANCellID);
         break;

      case 2:
         sprintf (namebuf, "%s.u.sourceGERANCellID", name);
         asn1Print_CGI (namebuf, pvalue->u.sourceGERANCellID);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  Cell_Capacity_Class_Value                                 */
/*                                                            */
/**************************************************************/

void asn1Print_Cell_Capacity_Class_Value
   (const char* name, Cell_Capacity_Class_Value* pvalue)
{
   rtPrintInteger (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  LoadValue                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_LoadValue
   (const char* name, LoadValue* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  RTLoadValue                                               */
/*                                                            */
/**************************************************************/

void asn1Print_RTLoadValue
   (const char* name, RTLoadValue* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  NRTLoadInformationValue                                   */
/*                                                            */
/**************************************************************/

void asn1Print_NRTLoadInformationValue
   (const char* name, NRTLoadInformationValue* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_CellLoadInformation_iE_Extensions_element
   (const char* name, CellLoadInformation_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CellLoadInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CellLoadInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CellLoadInformation_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CellLoadInformation_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions                         */
/*                                                            */
/**************************************************************/

void asn1Print_CellLoadInformation_iE_Extensions
   (const char* name, CellLoadInformation_iE_Extensions* pvalue)
{
   CellLoadInformation_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CellLoadInformation_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CellLoadInformation_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation                                       */
/*                                                            */
/**************************************************************/

void asn1Print_CellLoadInformation
   (const char* name, CellLoadInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.rTLoadValuePresent = %d\n", name, (int)pvalue->m.rTLoadValuePresent);
   printf ("%s.m.nRTLoadInformationValuePresent = %d\n", name, (int)pvalue->m.nRTLoadInformationValuePresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.cell_Capacity_Class_Value", name);
   asn1Print_Cell_Capacity_Class_Value (namebuf, &pvalue->cell_Capacity_Class_Value);

   sprintf (namebuf, "%s.loadValue", name);
   asn1Print_LoadValue (namebuf, &pvalue->loadValue);

   if (pvalue->m.rTLoadValuePresent) {
      sprintf (namebuf, "%s.rTLoadValue", name);
      asn1Print_RTLoadValue (namebuf, &pvalue->rTLoadValue);
   }

   if (pvalue->m.nRTLoadInformationValuePresent) {
      sprintf (namebuf, "%s.nRTLoadInformationValue", name);
      asn1Print_NRTLoadInformationValue (namebuf, &pvalue->nRTLoadInformationValue);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_CellLoadInformation_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

void asn1Print_CellLoadInformationGroup_iE_Extensions_element
   (const char* name, CellLoadInformationGroup_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CellLoadInformationGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CellLoadInformationGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CellLoadInformationGroup_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CellLoadInformationGroup_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions                    */
/*                                                            */
/**************************************************************/

void asn1Print_CellLoadInformationGroup_iE_Extensions
   (const char* name, CellLoadInformationGroup_iE_Extensions* pvalue)
{
   CellLoadInformationGroup_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CellLoadInformationGroup_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CellLoadInformationGroup_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup                                  */
/*                                                            */
/**************************************************************/

void asn1Print_CellLoadInformationGroup
   (const char* name, CellLoadInformationGroup* pvalue)
{
   char namebuf[512];

   printf ("%s.m.uplinkCellLoadInformationPresent = %d\n", name, (int)pvalue->m.uplinkCellLoadInformationPresent);
   printf ("%s.m.downlinkCellLoadInformationPresent = %d\n", name, (int)pvalue->m.downlinkCellLoadInformationPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.sourceCellID", name);
   asn1Print_SourceCellID (namebuf, &pvalue->sourceCellID);

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      sprintf (namebuf, "%s.uplinkCellLoadInformation", name);
      asn1Print_CellLoadInformation (namebuf, &pvalue->uplinkCellLoadInformation);
   }

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      sprintf (namebuf, "%s.downlinkCellLoadInformation", name);
      asn1Print_CellLoadInformation (namebuf, &pvalue->downlinkCellLoadInformation);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_CellLoadInformationGroup_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

void asn1Print__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1
   (const char* name, void* pvalue_)
{
   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1*) pvalue_;
   asn1Print_CellLoadInformationGroup (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  TraceReference                                            */
/*                                                            */
/**************************************************************/

void asn1Print_TraceReference
   (const char* name, TraceReference* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionReference                            */
/*                                                            */
/**************************************************************/

void asn1Print_TraceRecordingSessionReference
   (const char* name, TraceRecordingSessionReference* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

void asn1Print_TraceRecordingSessionInformation_iE_Extensions_element
   (const char* name, TraceRecordingSessionInformation_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < TraceRecordingSessionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TraceRecordingSessionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TraceRecordingSessionInformation_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      TraceRecordingSessionInformation_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions            */
/*                                                            */
/**************************************************************/

void asn1Print_TraceRecordingSessionInformation_iE_Extensions
   (const char* name, TraceRecordingSessionInformation_iE_Extensions* pvalue)
{
   TraceRecordingSessionInformation_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TraceRecordingSessionInformation_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TraceRecordingSessionInformation_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation                          */
/*                                                            */
/**************************************************************/

void asn1Print_TraceRecordingSessionInformation
   (const char* name, TraceRecordingSessionInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.traceReference", name);
   asn1Print_TraceReference (namebuf, &pvalue->traceReference);

   sprintf (namebuf, "%s.traceRecordingSessionReference", name);
   asn1Print_TraceRecordingSessionReference (namebuf, &pvalue->traceRecordingSessionReference);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_TraceRecordingSessionInformation_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

void asn1Print__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2
   (const char* name, void* pvalue_)
{
   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2*) pvalue_;
   asn1Print_TraceRecordingSessionInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSLinkingInformation                                    */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSLinkingInformation
   (const char* name, MBMSLinkingInformation* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("uE_has_joined_multicast_services\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

void asn1Print__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3
   (const char* name, void* pvalue_)
{
   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3*) pvalue_;
   asn1Print_MBMSLinkingInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

void asn1Print_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element
   (const char* name, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

void asn1Print_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions
   (const char* name, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions* pvalue)
{
   SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer                */
/*                                                            */
/**************************************************************/

void asn1Print_SourceRNC_ToTargetRNC_TransparentContainer
   (const char* name, SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   char namebuf[512];

   printf ("%s.m.chosenIntegrityProtectionAlgorithmPresent = %d\n", name, (int)pvalue->m.chosenIntegrityProtectionAlgorithmPresent);
   printf ("%s.m.integrityProtectionKeyPresent = %d\n", name, (int)pvalue->m.integrityProtectionKeyPresent);
   printf ("%s.m.chosenEncryptionAlgorithForSignallingPresent = %d\n", name, (int)pvalue->m.chosenEncryptionAlgorithForSignallingPresent);
   printf ("%s.m.cipheringKeyPresent = %d\n", name, (int)pvalue->m.cipheringKeyPresent);
   printf ("%s.m.chosenEncryptionAlgorithForCSPresent = %d\n", name, (int)pvalue->m.chosenEncryptionAlgorithForCSPresent);
   printf ("%s.m.chosenEncryptionAlgorithForPSPresent = %d\n", name, (int)pvalue->m.chosenEncryptionAlgorithForPSPresent);
   printf ("%s.m.d_RNTIPresent = %d\n", name, (int)pvalue->m.d_RNTIPresent);
   printf ("%s.m.targetCellIdPresent = %d\n", name, (int)pvalue->m.targetCellIdPresent);
   printf ("%s.m.rAB_TrCH_MappingPresent = %d\n", name, (int)pvalue->m.rAB_TrCH_MappingPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rRC_Container", name);
   asn1Print_RRC_Container (namebuf, &pvalue->rRC_Container);

   sprintf (namebuf, "%s.numberOfIuInstances", name);
   asn1Print_NumberOfIuInstances (namebuf, &pvalue->numberOfIuInstances);

   sprintf (namebuf, "%s.relocationType", name);
   asn1Print_RelocationType (namebuf, &pvalue->relocationType);

   if (pvalue->m.chosenIntegrityProtectionAlgorithmPresent) {
      sprintf (namebuf, "%s.chosenIntegrityProtectionAlgorithm", name);
      asn1Print_ChosenIntegrityProtectionAlgorithm (namebuf, &pvalue->chosenIntegrityProtectionAlgorithm);
   }

   if (pvalue->m.integrityProtectionKeyPresent) {
      sprintf (namebuf, "%s.integrityProtectionKey", name);
      asn1Print_IntegrityProtectionKey (namebuf, &pvalue->integrityProtectionKey);
   }

   if (pvalue->m.chosenEncryptionAlgorithForSignallingPresent) {
      sprintf (namebuf, "%s.chosenEncryptionAlgorithForSignalling", name);
      asn1Print_ChosenEncryptionAlgorithm (namebuf, &pvalue->chosenEncryptionAlgorithForSignalling);
   }

   if (pvalue->m.cipheringKeyPresent) {
      sprintf (namebuf, "%s.cipheringKey", name);
      asn1Print_EncryptionKey (namebuf, &pvalue->cipheringKey);
   }

   if (pvalue->m.chosenEncryptionAlgorithForCSPresent) {
      sprintf (namebuf, "%s.chosenEncryptionAlgorithForCS", name);
      asn1Print_ChosenEncryptionAlgorithm (namebuf, &pvalue->chosenEncryptionAlgorithForCS);
   }

   if (pvalue->m.chosenEncryptionAlgorithForPSPresent) {
      sprintf (namebuf, "%s.chosenEncryptionAlgorithForPS", name);
      asn1Print_ChosenEncryptionAlgorithm (namebuf, &pvalue->chosenEncryptionAlgorithForPS);
   }

   if (pvalue->m.d_RNTIPresent) {
      sprintf (namebuf, "%s.d_RNTI", name);
      asn1Print_D_RNTI (namebuf, &pvalue->d_RNTI);
   }

   if (pvalue->m.targetCellIdPresent) {
      sprintf (namebuf, "%s.targetCellId", name);
      asn1Print_TargetCellId (namebuf, &pvalue->targetCellId);
   }

   if (pvalue->m.rAB_TrCH_MappingPresent) {
      sprintf (namebuf, "%s.rAB_TrCH_Mapping", name);
      asn1Print_RAB_TrCH_Mapping (namebuf, &pvalue->rAB_TrCH_Mapping);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  OldBSS_ToNewBSS_Information                               */
/*                                                            */
/**************************************************************/

void asn1Print_OldBSS_ToNewBSS_Information
   (const char* name, OldBSS_ToNewBSS_Information* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  GERAN_Classmark                                           */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Classmark
   (const char* name, GERAN_Classmark* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  SourceBSS_ToTargetBSS_TransparentContainer                */
/*                                                            */
/**************************************************************/

void asn1Print_SourceBSS_ToTargetBSS_TransparentContainer
   (const char* name, SourceBSS_ToTargetBSS_TransparentContainer* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

void asn1Print_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element
   (const char* name, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

void asn1Print_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions
   (const char* name, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions* pvalue)
{
   TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer                */
/*                                                            */
/**************************************************************/

void asn1Print_TargetRNC_ToSourceRNC_TransparentContainer
   (const char* name, TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   char namebuf[512];

   printf ("%s.m.d_RNTIPresent = %d\n", name, (int)pvalue->m.d_RNTIPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rRC_Container", name);
   asn1Print_RRC_Container (namebuf, &pvalue->rRC_Container);

   if (pvalue->m.d_RNTIPresent) {
      sprintf (namebuf, "%s.d_RNTI", name);
      asn1Print_D_RNTI (namebuf, &pvalue->d_RNTI);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  L3_Information                                            */
/*                                                            */
/**************************************************************/

void asn1Print_L3_Information
   (const char* name, L3_Information* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TransportLayerAddress                                     */
/*                                                            */
/**************************************************************/

void asn1Print_TransportLayerAddress
   (const char* name, TransportLayerAddress* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  GTP_TEI                                                   */
/*                                                            */
/**************************************************************/

void asn1Print_GTP_TEI
   (const char* name, GTP_TEI* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  BindingID                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_BindingID
   (const char* name, BindingID* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  IuTransportAssociation                                    */
/*                                                            */
/**************************************************************/

void asn1Print_IuTransportAssociation
   (const char* name, IuTransportAssociation* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.gTP_TEI", name);
         asn1Print_GTP_TEI (namebuf, pvalue->u.gTP_TEI);
         break;

      case 2:
         sprintf (namebuf, "%s.u.bindingID", name);
         asn1Print_BindingID (namebuf, pvalue->u.bindingID);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

void asn1Print_InterSystemInformation_TransparentContainer_iE_Extensions_element
   (const char* name, InterSystemInformation_TransparentContainer_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InterSystemInformation_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InterSystemInformation_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InterSystemInformation_TransparentContainer_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      InterSystemInformation_TransparentContainer_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

void asn1Print_InterSystemInformation_TransparentContainer_iE_Extensions
   (const char* name, InterSystemInformation_TransparentContainer_iE_Extensions* pvalue)
{
   InterSystemInformation_TransparentContainer_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InterSystemInformation_TransparentContainer_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InterSystemInformation_TransparentContainer_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer               */
/*                                                            */
/**************************************************************/

void asn1Print_InterSystemInformation_TransparentContainer
   (const char* name, InterSystemInformation_TransparentContainer* pvalue)
{
   char namebuf[512];

   printf ("%s.m.downlinkCellLoadInformationPresent = %d\n", name, (int)pvalue->m.downlinkCellLoadInformationPresent);
   printf ("%s.m.uplinkCellLoadInformationPresent = %d\n", name, (int)pvalue->m.uplinkCellLoadInformationPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.downlinkCellLoadInformationPresent) {
      sprintf (namebuf, "%s.downlinkCellLoadInformation", name);
      asn1Print_CellLoadInformation (namebuf, &pvalue->downlinkCellLoadInformation);
   }

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      sprintf (namebuf, "%s.uplinkCellLoadInformation", name);
      asn1Print_CellLoadInformation (namebuf, &pvalue->uplinkCellLoadInformation);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_InterSystemInformation_TransparentContainer_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  TargetBSS_ToSourceBSS_TransparentContainer                */
/*                                                            */
/**************************************************************/

void asn1Print_TargetBSS_ToSourceBSS_TransparentContainer
   (const char* name, TargetBSS_ToSourceBSS_TransparentContainer* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  IMSI                                                      */
/*                                                            */
/**************************************************************/

void asn1Print_IMSI
   (const char* name, IMSI* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  PermanentNAS_UE_ID                                        */
/*                                                            */
/**************************************************************/

void asn1Print_PermanentNAS_UE_ID
   (const char* name, PermanentNAS_UE_ID* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.iMSI", name);
         asn1Print_IMSI (namebuf, pvalue->u.iMSI);
         break;

      case 2:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  NAS_SynchronisationIndicator                              */
/*                                                            */
/**************************************************************/

void asn1Print_NAS_SynchronisationIndicator
   (const char* name, NAS_SynchronisationIndicator* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TrafficClass                                              */
/*                                                            */
/**************************************************************/

void asn1Print_TrafficClass
   (const char* name, TrafficClass* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("conversational\n"); break;
      case 1: printf ("streaming\n"); break;
      case 2: printf ("interactive\n"); break;
      case 3: printf ("background\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_AsymmetryIndicator                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AsymmetryIndicator
   (const char* name, RAB_AsymmetryIndicator* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("symmetric_bidirectional\n"); break;
      case 1: printf ("asymmetric_unidirectional_downlink\n"); break;
      case 2: printf ("asymmetric_unidirectional_uplink\n"); break;
      case 3: printf ("asymmetric_bidirectional\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  MaxBitrate                                                */
/*                                                            */
/**************************************************************/

void asn1Print_MaxBitrate
   (const char* name, MaxBitrate* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameter_MaxBitrateList                              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_Parameter_MaxBitrateList
   (const char* name, RAB_Parameter_MaxBitrateList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GuaranteedBitrate                                         */
/*                                                            */
/**************************************************************/

void asn1Print_GuaranteedBitrate
   (const char* name, GuaranteedBitrate* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameter_GuaranteedBitrateList                       */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_Parameter_GuaranteedBitrateList
   (const char* name, RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DeliveryOrder                                             */
/*                                                            */
/**************************************************************/

void asn1Print_DeliveryOrder
   (const char* name, DeliveryOrder* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("delivery_order_requested\n"); break;
      case 1: printf ("delivery_order_not_requested\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  MaxSDU_Size                                               */
/*                                                            */
/**************************************************************/

void asn1Print_MaxSDU_Size
   (const char* name, MaxSDU_Size* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_ErrorRatio_iE_Extensions_element
   (const char* name, SDU_ErrorRatio_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SDU_ErrorRatio_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_ErrorRatio_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_ErrorRatio_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SDU_ErrorRatio_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions                              */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_ErrorRatio_iE_Extensions
   (const char* name, SDU_ErrorRatio_iE_Extensions* pvalue)
{
   SDU_ErrorRatio_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SDU_ErrorRatio_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SDU_ErrorRatio_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio                                            */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_ErrorRatio
   (const char* name, SDU_ErrorRatio* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.mantissa", name);
   rtPrintUnsigned (namebuf, pvalue->mantissa);

   sprintf (namebuf, "%s.exponent", name);
   rtPrintUnsigned (namebuf, pvalue->exponent);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SDU_ErrorRatio_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

void asn1Print_ResidualBitErrorRatio_iE_Extensions_element
   (const char* name, ResidualBitErrorRatio_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResidualBitErrorRatio_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResidualBitErrorRatio_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResidualBitErrorRatio_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ResidualBitErrorRatio_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions                       */
/*                                                            */
/**************************************************************/

void asn1Print_ResidualBitErrorRatio_iE_Extensions
   (const char* name, ResidualBitErrorRatio_iE_Extensions* pvalue)
{
   ResidualBitErrorRatio_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResidualBitErrorRatio_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResidualBitErrorRatio_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio                                     */
/*                                                            */
/**************************************************************/

void asn1Print_ResidualBitErrorRatio
   (const char* name, ResidualBitErrorRatio* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.mantissa", name);
   rtPrintUnsigned (namebuf, pvalue->mantissa);

   sprintf (namebuf, "%s.exponent", name);
   rtPrintUnsigned (namebuf, pvalue->exponent);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_ResidualBitErrorRatio_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  DeliveryOfErroneousSDU                                    */
/*                                                            */
/**************************************************************/

void asn1Print_DeliveryOfErroneousSDU
   (const char* name, DeliveryOfErroneousSDU* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("yes\n"); break;
      case 1: printf ("no\n"); break;
      case 2: printf ("no_error_detection_consideration\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  SubflowSDU_Size                                           */
/*                                                            */
/**************************************************************/

void asn1Print_SubflowSDU_Size
   (const char* name, SubflowSDU_Size* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SubflowCombinationBitRate                             */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SubflowCombinationBitRate
   (const char* name, RAB_SubflowCombinationBitRate* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions_el  */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_FormatInformationParameters_element_iE_Extensions_element
   (const char* name, SDU_FormatInformationParameters_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SDU_FormatInformationParameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_FormatInformationParameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_FormatInformationParameters_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SDU_FormatInformationParameters_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions     */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_FormatInformationParameters_element_iE_Extensions
   (const char* name, SDU_FormatInformationParameters_element_iE_Extensions* pvalue)
{
   SDU_FormatInformationParameters_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SDU_FormatInformationParameters_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SDU_FormatInformationParameters_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_FormatInformationParameters_element
   (const char* name, SDU_FormatInformationParameters_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.subflowSDU_SizePresent = %d\n", name, (int)pvalue->m.subflowSDU_SizePresent);
   printf ("%s.m.rAB_SubflowCombinationBitRatePresent = %d\n", name, (int)pvalue->m.rAB_SubflowCombinationBitRatePresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.subflowSDU_SizePresent) {
      sprintf (namebuf, "%s.subflowSDU_Size", name);
      asn1Print_SubflowSDU_Size (namebuf, &pvalue->subflowSDU_Size);
   }

   if (pvalue->m.rAB_SubflowCombinationBitRatePresent) {
      sprintf (namebuf, "%s.rAB_SubflowCombinationBitRate", name);
      asn1Print_RAB_SubflowCombinationBitRate (namebuf, &pvalue->rAB_SubflowCombinationBitRate);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SDU_FormatInformationParameters_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters                           */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_FormatInformationParameters
   (const char* name, SDU_FormatInformationParameters* pvalue)
{
   SDU_FormatInformationParameters_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SDU_FormatInformationParameters_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SDU_FormatInformationParameters_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_Parameters_element_iE_Extensions_element
   (const char* name, SDU_Parameters_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SDU_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_Parameters_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SDU_Parameters_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_Parameters_element_iE_Extensions
   (const char* name, SDU_Parameters_element_iE_Extensions* pvalue)
{
   SDU_Parameters_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SDU_Parameters_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SDU_Parameters_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element                                    */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_Parameters_element
   (const char* name, SDU_Parameters_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.sDU_ErrorRatioPresent = %d\n", name, (int)pvalue->m.sDU_ErrorRatioPresent);
   printf ("%s.m.sDU_FormatInformationParametersPresent = %d\n", name, (int)pvalue->m.sDU_FormatInformationParametersPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.sDU_ErrorRatioPresent) {
      sprintf (namebuf, "%s.sDU_ErrorRatio", name);
      asn1Print_SDU_ErrorRatio (namebuf, &pvalue->sDU_ErrorRatio);
   }

   sprintf (namebuf, "%s.residualBitErrorRatio", name);
   asn1Print_ResidualBitErrorRatio (namebuf, &pvalue->residualBitErrorRatio);

   sprintf (namebuf, "%s.deliveryOfErroneousSDU", name);
   asn1Print_DeliveryOfErroneousSDU (namebuf, &pvalue->deliveryOfErroneousSDU);

   if (pvalue->m.sDU_FormatInformationParametersPresent) {
      sprintf (namebuf, "%s.sDU_FormatInformationParameters", name);
      asn1Print_SDU_FormatInformationParameters (namebuf, &pvalue->sDU_FormatInformationParameters);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SDU_Parameters_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters                                            */
/*                                                            */
/**************************************************************/

void asn1Print_SDU_Parameters
   (const char* name, SDU_Parameters* pvalue)
{
   SDU_Parameters_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SDU_Parameters_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SDU_Parameters_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TransferDelay                                             */
/*                                                            */
/**************************************************************/

void asn1Print_TransferDelay
   (const char* name, TransferDelay* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  TrafficHandlingPriority                                   */
/*                                                            */
/**************************************************************/

void asn1Print_TrafficHandlingPriority
   (const char* name, TrafficHandlingPriority* pvalue)
{
   switch (*pvalue) {
      case 0: printf ("%s = spare_1\n", name); break;
      case 1: printf ("%s = highest_1\n", name); break;
      case 14: printf ("%s = lowest_1\n", name); break;
      case 15: printf ("%s = no_priority_used\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  PriorityLevel                                             */
/*                                                            */
/**************************************************************/

void asn1Print_PriorityLevel
   (const char* name, PriorityLevel* pvalue)
{
   switch (*pvalue) {
      case 0: printf ("%s = spare\n", name); break;
      case 1: printf ("%s = highest\n", name); break;
      case 14: printf ("%s = lowest\n", name); break;
      case 15: printf ("%s = no_priority\n", name); break;
      default: rtPrintUnsigned (name, *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionCapability                                     */
/*                                                            */
/**************************************************************/

void asn1Print_Pre_emptionCapability
   (const char* name, Pre_emptionCapability* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("shall_not_trigger_pre_emption\n"); break;
      case 1: printf ("may_trigger_pre_emption\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionVulnerability                                  */
/*                                                            */
/**************************************************************/

void asn1Print_Pre_emptionVulnerability
   (const char* name, Pre_emptionVulnerability* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("not_pre_emptable\n"); break;
      case 1: printf ("pre_emptable\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  QueuingAllowed                                            */
/*                                                            */
/**************************************************************/

void asn1Print_QueuingAllowed
   (const char* name, QueuingAllowed* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("queueing_not_allowed\n"); break;
      case 1: printf ("queueing_allowed\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions_element       */
/*                                                            */
/**************************************************************/

void asn1Print_AllocationOrRetentionPriority_iE_Extensions_element
   (const char* name, AllocationOrRetentionPriority_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < AllocationOrRetentionPriority_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &AllocationOrRetentionPriority_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == AllocationOrRetentionPriority_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      AllocationOrRetentionPriority_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions               */
/*                                                            */
/**************************************************************/

void asn1Print_AllocationOrRetentionPriority_iE_Extensions
   (const char* name, AllocationOrRetentionPriority_iE_Extensions* pvalue)
{
   AllocationOrRetentionPriority_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (AllocationOrRetentionPriority_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_AllocationOrRetentionPriority_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority                             */
/*                                                            */
/**************************************************************/

void asn1Print_AllocationOrRetentionPriority
   (const char* name, AllocationOrRetentionPriority* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.priorityLevel", name);
   asn1Print_PriorityLevel (namebuf, &pvalue->priorityLevel);

   sprintf (namebuf, "%s.pre_emptionCapability", name);
   asn1Print_Pre_emptionCapability (namebuf, &pvalue->pre_emptionCapability);

   sprintf (namebuf, "%s.pre_emptionVulnerability", name);
   asn1Print_Pre_emptionVulnerability (namebuf, &pvalue->pre_emptionVulnerability);

   sprintf (namebuf, "%s.queuingAllowed", name);
   asn1Print_QueuingAllowed (namebuf, &pvalue->queuingAllowed);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_AllocationOrRetentionPriority_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  SourceStatisticsDescriptor                                */
/*                                                            */
/**************************************************************/

void asn1Print_SourceStatisticsDescriptor
   (const char* name, SourceStatisticsDescriptor* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("speech\n"); break;
      case 1: printf ("unknown\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationRequirement                                     */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequirement
   (const char* name, RelocationRequirement* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("lossless\n"); break;
      case 1: printf ("none\n"); break;
      case 2: printf ("realtime\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  SignallingIndication                                      */
/*                                                            */
/**************************************************************/

void asn1Print_SignallingIndication
   (const char* name, SignallingIndication* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("signalling\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_Parameters_ExtIEs_Extension                          */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_Parameters_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _RAB_Parameters_ExtIEs_Extension *pvalue = (_RAB_Parameters_ExtIEs_Extension*) pvalue_;
   asn1Print_SignallingIndication (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_Parameters_iE_Extensions_element
   (const char* name, RAB_Parameters_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_Parameters_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_Parameters_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions                              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_Parameters_iE_Extensions
   (const char* name, RAB_Parameters_iE_Extensions* pvalue)
{
   RAB_Parameters_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_Parameters_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_Parameters_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_Parameters
   (const char* name, RAB_Parameters* pvalue)
{
   char namebuf[512];

   printf ("%s.m.guaranteedBitRatePresent = %d\n", name, (int)pvalue->m.guaranteedBitRatePresent);
   printf ("%s.m.transferDelayPresent = %d\n", name, (int)pvalue->m.transferDelayPresent);
   printf ("%s.m.trafficHandlingPriorityPresent = %d\n", name, (int)pvalue->m.trafficHandlingPriorityPresent);
   printf ("%s.m.allocationOrRetentionPriorityPresent = %d\n", name, (int)pvalue->m.allocationOrRetentionPriorityPresent);
   printf ("%s.m.sourceStatisticsDescriptorPresent = %d\n", name, (int)pvalue->m.sourceStatisticsDescriptorPresent);
   printf ("%s.m.relocationRequirementPresent = %d\n", name, (int)pvalue->m.relocationRequirementPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.trafficClass", name);
   asn1Print_TrafficClass (namebuf, &pvalue->trafficClass);

   sprintf (namebuf, "%s.rAB_AsymmetryIndicator", name);
   asn1Print_RAB_AsymmetryIndicator (namebuf, &pvalue->rAB_AsymmetryIndicator);

   sprintf (namebuf, "%s.maxBitrate", name);
   asn1Print_RAB_Parameter_MaxBitrateList (namebuf, &pvalue->maxBitrate);

   if (pvalue->m.guaranteedBitRatePresent) {
      sprintf (namebuf, "%s.guaranteedBitRate", name);
      asn1Print_RAB_Parameter_GuaranteedBitrateList (namebuf, &pvalue->guaranteedBitRate);
   }

   sprintf (namebuf, "%s.deliveryOrder", name);
   asn1Print_DeliveryOrder (namebuf, &pvalue->deliveryOrder);

   sprintf (namebuf, "%s.maxSDU_Size", name);
   asn1Print_MaxSDU_Size (namebuf, &pvalue->maxSDU_Size);

   sprintf (namebuf, "%s.sDU_Parameters", name);
   asn1Print_SDU_Parameters (namebuf, &pvalue->sDU_Parameters);

   if (pvalue->m.transferDelayPresent) {
      sprintf (namebuf, "%s.transferDelay", name);
      asn1Print_TransferDelay (namebuf, &pvalue->transferDelay);
   }

   if (pvalue->m.trafficHandlingPriorityPresent) {
      sprintf (namebuf, "%s.trafficHandlingPriority", name);
      asn1Print_TrafficHandlingPriority (namebuf, &pvalue->trafficHandlingPriority);
   }

   if (pvalue->m.allocationOrRetentionPriorityPresent) {
      sprintf (namebuf, "%s.allocationOrRetentionPriority", name);
      asn1Print_AllocationOrRetentionPriority (namebuf, &pvalue->allocationOrRetentionPriority);
   }

   if (pvalue->m.sourceStatisticsDescriptorPresent) {
      sprintf (namebuf, "%s.sourceStatisticsDescriptor", name);
      asn1Print_SourceStatisticsDescriptor (namebuf, &pvalue->sourceStatisticsDescriptor);
   }

   if (pvalue->m.relocationRequirementPresent) {
      sprintf (namebuf, "%s.relocationRequirement", name);
      asn1Print_RelocationRequirement (namebuf, &pvalue->relocationRequirement);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_Parameters_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportingIndication                             */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReportingIndication
   (const char* name, DataVolumeReportingIndication* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("do_report\n"); break;
      case 1: printf ("do_not_report\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  PDP_Type                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_PDP_Type
   (const char* name, PDP_Type* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("empty\n"); break;
      case 1: printf ("ppp\n"); break;
      case 2: printf ("osp_ihoss\n"); break;
      case 3: printf ("ipv4\n"); break;
      case 4: printf ("ipv6\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  PDP_TypeInformation                                       */
/*                                                            */
/**************************************************************/

void asn1Print_PDP_TypeInformation
   (const char* name, PDP_TypeInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_PDP_Type (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UserPlaneMode                                             */
/*                                                            */
/**************************************************************/

void asn1Print_UserPlaneMode
   (const char* name, UserPlaneMode* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("transparent_mode\n"); break;
      case 1: printf ("support_mode_for_predefined_SDU_sizes\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  UP_ModeVersions                                           */
/*                                                            */
/**************************************************************/

void asn1Print_UP_ModeVersions
   (const char* name, UP_ModeVersions* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  Service_Handover                                          */
/*                                                            */
/**************************************************************/

void asn1Print_Service_Handover
   (const char* name, Service_Handover* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("handover_to_GSM_should_be_performed\n"); break;
      case 1: printf ("handover_to_GSM_should_not_be_performed\n"); break;
      case 2: printf ("handover_to_GSM_shall_not_be_performed\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateType                          */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameter_MaxBitrateType
   (const char* name, Alt_RAB_Parameter_MaxBitrateType* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("unspecified_1\n"); break;
      case 1: printf ("value_range_1\n"); break;
      case 2: printf ("discrete_values_1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateList                          */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameter_MaxBitrateList
   (const char* name, Alt_RAB_Parameter_MaxBitrateList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrates                             */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameter_MaxBitrates
   (const char* name, Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   Alt_RAB_Parameter_MaxBitrateList* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Alt_RAB_Parameter_MaxBitrateList*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Alt_RAB_Parameter_MaxBitrateList (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateInf                           */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameter_MaxBitrateInf
   (const char* name, Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   char namebuf[512];

   printf ("%s.m.altMaxBitratesPresent = %d\n", name, (int)pvalue->m.altMaxBitratesPresent);
   sprintf (namebuf, "%s.altMaxBitrateType", name);
   asn1Print_Alt_RAB_Parameter_MaxBitrateType (namebuf, &pvalue->altMaxBitrateType);

   if (pvalue->m.altMaxBitratesPresent) {
      sprintf (namebuf, "%s.altMaxBitrates", name);
      asn1Print_Alt_RAB_Parameter_MaxBitrates (namebuf, &pvalue->altMaxBitrates);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateType                   */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameter_GuaranteedBitrateType
   (const char* name, Alt_RAB_Parameter_GuaranteedBitrateType* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("unspecified\n"); break;
      case 1: printf ("value_range\n"); break;
      case 2: printf ("discrete_values\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateList                   */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameter_GuaranteedBitrateList
   (const char* name, Alt_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrates                      */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameter_GuaranteedBitrates
   (const char* name, Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   Alt_RAB_Parameter_GuaranteedBitrateList* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Alt_RAB_Parameter_GuaranteedBitrateList*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Alt_RAB_Parameter_GuaranteedBitrateList (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateInf                    */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameter_GuaranteedBitrateInf
   (const char* name, Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   char namebuf[512];

   printf ("%s.m.altGuaranteedBitratesPresent = %d\n", name, (int)pvalue->m.altGuaranteedBitratesPresent);
   sprintf (namebuf, "%s.altGuaranteedBitrateType", name);
   asn1Print_Alt_RAB_Parameter_GuaranteedBitrateType (namebuf, &pvalue->altGuaranteedBitrateType);

   if (pvalue->m.altGuaranteedBitratesPresent) {
      sprintf (namebuf, "%s.altGuaranteedBitrates", name);
      asn1Print_Alt_RAB_Parameter_GuaranteedBitrates (namebuf, &pvalue->altGuaranteedBitrates);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _Alt_RAB_Parameters_ExtIEs_Extension                      */
/*                                                            */
/**************************************************************/

void asn1Print__Alt_RAB_Parameters_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _Alt_RAB_Parameters_ExtIEs_Extension *pvalue = (_Alt_RAB_Parameters_ExtIEs_Extension*) pvalue_;
   asn1Print_RAB_Parameters (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameters_iE_Extensions_element
   (const char* name, Alt_RAB_Parameters_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Alt_RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Alt_RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Alt_RAB_Parameters_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      Alt_RAB_Parameters_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions                          */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameters_iE_Extensions
   (const char* name, Alt_RAB_Parameters_iE_Extensions* pvalue)
{
   Alt_RAB_Parameters_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Alt_RAB_Parameters_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Alt_RAB_Parameters_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters                                        */
/*                                                            */
/**************************************************************/

void asn1Print_Alt_RAB_Parameters
   (const char* name, Alt_RAB_Parameters* pvalue)
{
   char namebuf[512];

   printf ("%s.m.altMaxBitrateInfPresent = %d\n", name, (int)pvalue->m.altMaxBitrateInfPresent);
   printf ("%s.m.altGuaranteedBitRateInfPresent = %d\n", name, (int)pvalue->m.altGuaranteedBitRateInfPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.altMaxBitrateInfPresent) {
      sprintf (namebuf, "%s.altMaxBitrateInf", name);
      asn1Print_Alt_RAB_Parameter_MaxBitrateInf (namebuf, &pvalue->altMaxBitrateInf);
   }

   if (pvalue->m.altGuaranteedBitRateInfPresent) {
      sprintf (namebuf, "%s.altGuaranteedBitRateInf", name);
      asn1Print_Alt_RAB_Parameter_GuaranteedBitrateInf (namebuf, &pvalue->altGuaranteedBitRateInf);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_Alt_RAB_Parameters_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GERAN_BSC_Container                                       */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_BSC_Container
   (const char* name, GERAN_BSC_Container* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  PermittedIntegrityProtectionAlgorithms                    */
/*                                                            */
/**************************************************************/

void asn1Print_PermittedIntegrityProtectionAlgorithms
   (const char* name, PermittedIntegrityProtectionAlgorithms* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_IntegrityProtectionAlgorithm (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

void asn1Print_IntegrityProtectionInformation_iE_Extensions_element
   (const char* name, IntegrityProtectionInformation_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < IntegrityProtectionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IntegrityProtectionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IntegrityProtectionInformation_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      IntegrityProtectionInformation_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions              */
/*                                                            */
/**************************************************************/

void asn1Print_IntegrityProtectionInformation_iE_Extensions
   (const char* name, IntegrityProtectionInformation_iE_Extensions* pvalue)
{
   IntegrityProtectionInformation_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (IntegrityProtectionInformation_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_IntegrityProtectionInformation_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation                            */
/*                                                            */
/**************************************************************/

void asn1Print_IntegrityProtectionInformation
   (const char* name, IntegrityProtectionInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.permittedAlgorithms", name);
   asn1Print_PermittedIntegrityProtectionAlgorithms (namebuf, &pvalue->permittedAlgorithms);

   sprintf (namebuf, "%s.key", name);
   asn1Print_IntegrityProtectionKey (namebuf, &pvalue->key);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_IntegrityProtectionInformation_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  PermittedEncryptionAlgorithms                             */
/*                                                            */
/**************************************************************/

void asn1Print_PermittedEncryptionAlgorithms
   (const char* name, PermittedEncryptionAlgorithms* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_EncryptionAlgorithm (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

void asn1Print_EncryptionInformation_iE_Extensions_element
   (const char* name, EncryptionInformation_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < EncryptionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &EncryptionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == EncryptionInformation_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      EncryptionInformation_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions                       */
/*                                                            */
/**************************************************************/

void asn1Print_EncryptionInformation_iE_Extensions
   (const char* name, EncryptionInformation_iE_Extensions* pvalue)
{
   EncryptionInformation_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (EncryptionInformation_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_EncryptionInformation_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation                                     */
/*                                                            */
/**************************************************************/

void asn1Print_EncryptionInformation
   (const char* name, EncryptionInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.permittedAlgorithms", name);
   asn1Print_PermittedEncryptionAlgorithms (namebuf, &pvalue->permittedAlgorithms);

   sprintf (namebuf, "%s.key", name);
   asn1Print_EncryptionKey (namebuf, &pvalue->key);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_EncryptionInformation_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  IuSignallingConnectionIdentifier                          */
/*                                                            */
/**************************************************************/

void asn1Print_IuSignallingConnectionIdentifier
   (const char* name, IuSignallingConnectionIdentifier* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  CN_ID                                                     */
/*                                                            */
/**************************************************************/

void asn1Print_CN_ID
   (const char* name, CN_ID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  GlobalCN_ID                                               */
/*                                                            */
/**************************************************************/

void asn1Print_GlobalCN_ID
   (const char* name, GlobalCN_ID* pvalue)
{
   char namebuf[512];

   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.cN_ID", name);
   asn1Print_CN_ID (namebuf, &pvalue->cN_ID);

}

/**************************************************************/
/*                                                            */
/*  SNAC                                                      */
/*                                                            */
/**************************************************************/

void asn1Print_SNAC
   (const char* name, SNAC* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedSNAs                                            */
/*                                                            */
/**************************************************************/

void asn1Print_AuthorisedSNAs
   (const char* name, AuthorisedSNAs* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SNAC (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_AuthorisedPLMNs_element_iE_Extensions_element
   (const char* name, AuthorisedPLMNs_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < AuthorisedPLMNs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &AuthorisedPLMNs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == AuthorisedPLMNs_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      AuthorisedPLMNs_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_AuthorisedPLMNs_element_iE_Extensions
   (const char* name, AuthorisedPLMNs_element_iE_Extensions* pvalue)
{
   AuthorisedPLMNs_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (AuthorisedPLMNs_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_AuthorisedPLMNs_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element                                   */
/*                                                            */
/**************************************************************/

void asn1Print_AuthorisedPLMNs_element
   (const char* name, AuthorisedPLMNs_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.authorisedSNAsListPresent = %d\n", name, (int)pvalue->m.authorisedSNAsListPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   if (pvalue->m.authorisedSNAsListPresent) {
      sprintf (namebuf, "%s.authorisedSNAsList", name);
      asn1Print_AuthorisedSNAs (namebuf, &pvalue->authorisedSNAsList);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_AuthorisedPLMNs_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs                                           */
/*                                                            */
/**************************************************************/

void asn1Print_AuthorisedPLMNs
   (const char* name, AuthorisedPLMNs* pvalue)
{
   AuthorisedPLMNs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (AuthorisedPLMNs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_AuthorisedPLMNs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_SNA_Access_Information_iE_Extensions_element
   (const char* name, SNA_Access_Information_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SNA_Access_Information_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SNA_Access_Information_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SNA_Access_Information_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SNA_Access_Information_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_SNA_Access_Information_iE_Extensions
   (const char* name, SNA_Access_Information_iE_Extensions* pvalue)
{
   SNA_Access_Information_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SNA_Access_Information_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SNA_Access_Information_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information                                    */
/*                                                            */
/**************************************************************/

void asn1Print_SNA_Access_Information
   (const char* name, SNA_Access_Information* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.authorisedPLMNs", name);
   asn1Print_AuthorisedPLMNs (namebuf, &pvalue->authorisedPLMNs);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_SNA_Access_Information_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  UESBI_IuA                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_UESBI_IuA
   (const char* name, UESBI_IuA* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  UESBI_IuB                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_UESBI_IuB
   (const char* name, UESBI_IuB* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

void asn1Print_UESBI_Iu_iE_Extensions_element
   (const char* name, UESBI_Iu_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UESBI_Iu_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESBI_Iu_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UESBI_Iu_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      UESBI_Iu_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions                                    */
/*                                                            */
/**************************************************************/

void asn1Print_UESBI_Iu_iE_Extensions
   (const char* name, UESBI_Iu_iE_Extensions* pvalue)
{
   UESBI_Iu_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UESBI_Iu_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UESBI_Iu_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_UESBI_Iu
   (const char* name, UESBI_Iu* pvalue)
{
   char namebuf[512];

   printf ("%s.m.uESBI_IuAPresent = %d\n", name, (int)pvalue->m.uESBI_IuAPresent);
   printf ("%s.m.uESBI_IuBPresent = %d\n", name, (int)pvalue->m.uESBI_IuBPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.uESBI_IuAPresent) {
      sprintf (namebuf, "%s.uESBI_IuA", name);
      asn1Print_UESBI_IuA (namebuf, &pvalue->uESBI_IuA);
   }

   if (pvalue->m.uESBI_IuBPresent) {
      sprintf (namebuf, "%s.uESBI_IuB", name);
      asn1Print_UESBI_IuB (namebuf, &pvalue->uESBI_IuB);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_UESBI_Iu_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  TMGI_serviceID                                            */
/*                                                            */
/**************************************************************/

void asn1Print_TMGI_serviceID
   (const char* name, TMGI_serviceID* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions_element                                */
/*                                                            */
/**************************************************************/

void asn1Print_TMGI_iE_Extensions_element
   (const char* name, TMGI_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < TMGI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TMGI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TMGI_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      TMGI_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions                                        */
/*                                                            */
/**************************************************************/

void asn1Print_TMGI_iE_Extensions
   (const char* name, TMGI_iE_Extensions* pvalue)
{
   TMGI_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TMGI_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TMGI_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TMGI                                                      */
/*                                                            */
/**************************************************************/

void asn1Print_TMGI
   (const char* name, TMGI* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.serviceID", name);
   asn1Print_TMGI_serviceID (namebuf, &pvalue->serviceID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_TMGI_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  MBMS_PTP_RAB_ID                                           */
/*                                                            */
/**************************************************************/

void asn1Print_MBMS_PTP_RAB_ID
   (const char* name, MBMS_PTP_RAB_ID* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameter_MaxBitrateList                          */
/*                                                            */
/**************************************************************/

void asn1Print_Ass_RAB_Parameter_MaxBitrateList
   (const char* name, Ass_RAB_Parameter_MaxBitrateList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameter_GuaranteedBitrateList                   */
/*                                                            */
/**************************************************************/

void asn1Print_Ass_RAB_Parameter_GuaranteedBitrateList
   (const char* name, Ass_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

void asn1Print_Ass_RAB_Parameters_iE_Extensions_element
   (const char* name, Ass_RAB_Parameters_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Ass_RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Ass_RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Ass_RAB_Parameters_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      Ass_RAB_Parameters_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions                          */
/*                                                            */
/**************************************************************/

void asn1Print_Ass_RAB_Parameters_iE_Extensions
   (const char* name, Ass_RAB_Parameters_iE_Extensions* pvalue)
{
   Ass_RAB_Parameters_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Ass_RAB_Parameters_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Ass_RAB_Parameters_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters                                        */
/*                                                            */
/**************************************************************/

void asn1Print_Ass_RAB_Parameters
   (const char* name, Ass_RAB_Parameters* pvalue)
{
   char namebuf[512];

   printf ("%s.m.assMaxBitrateInfPresent = %d\n", name, (int)pvalue->m.assMaxBitrateInfPresent);
   printf ("%s.m.assGuaranteedBitRateInfPresent = %d\n", name, (int)pvalue->m.assGuaranteedBitRateInfPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.assMaxBitrateInfPresent) {
      sprintf (namebuf, "%s.assMaxBitrateInf", name);
      asn1Print_Ass_RAB_Parameter_MaxBitrateList (namebuf, &pvalue->assMaxBitrateInf);
   }

   if (pvalue->m.assGuaranteedBitRateInfPresent) {
      sprintf (namebuf, "%s.assGuaranteedBitRateInf", name);
      asn1Print_Ass_RAB_Parameter_GuaranteedBitrateList (namebuf, &pvalue->assGuaranteedBitRateInf);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_Ass_RAB_Parameters_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  NewBSS_To_OldBSS_Information                              */
/*                                                            */
/**************************************************************/

void asn1Print_NewBSS_To_OldBSS_Information
   (const char* name, NewBSS_To_OldBSS_Information* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  DL_N_PDU_SequenceNumber                                   */
/*                                                            */
/**************************************************************/

void asn1Print_DL_N_PDU_SequenceNumber
   (const char* name, DL_N_PDU_SequenceNumber* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  UL_N_PDU_SequenceNumber                                   */
/*                                                            */
/**************************************************************/

void asn1Print_UL_N_PDU_SequenceNumber
   (const char* name, UL_N_PDU_SequenceNumber* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  KeyStatus                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_KeyStatus
   (const char* name, KeyStatus* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("old\n"); break;
      case 1: printf ("new_\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  GlobalRNC_ID                                              */
/*                                                            */
/**************************************************************/

void asn1Print_GlobalRNC_ID
   (const char* name, GlobalRNC_ID* pvalue)
{
   char namebuf[512];

   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.rNC_ID", name);
   asn1Print_RNC_ID (namebuf, &pvalue->rNC_ID);

}

/**************************************************************/
/*                                                            */
/*  TMSI                                                      */
/*                                                            */
/**************************************************************/

void asn1Print_TMSI
   (const char* name, TMSI* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  P_TMSI                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_P_TMSI
   (const char* name, P_TMSI* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TemporaryUE_ID                                            */
/*                                                            */
/**************************************************************/

void asn1Print_TemporaryUE_ID
   (const char* name, TemporaryUE_ID* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.tMSI", name);
         asn1Print_TMSI (namebuf, pvalue->u.tMSI);
         break;

      case 2:
         sprintf (namebuf, "%s.u.p_TMSI", name);
         asn1Print_P_TMSI (namebuf, pvalue->u.p_TMSI);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAI_iE_Extensions_element
   (const char* name, RAI_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAI_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAI_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

void asn1Print_RAI_iE_Extensions
   (const char* name, RAI_iE_Extensions* pvalue)
{
   RAI_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAI_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAI_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAI                                                       */
/*                                                            */
/**************************************************************/

void asn1Print_RAI
   (const char* name, RAI* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.lAI", name);
   asn1Print_LAI (namebuf, &pvalue->lAI);

   sprintf (namebuf, "%s.rAC", name);
   asn1Print_RAC (namebuf, &pvalue->rAC);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAI_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  PagingAreaID                                              */
/*                                                            */
/**************************************************************/

void asn1Print_PagingAreaID
   (const char* name, PagingAreaID* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.lAI", name);
         asn1Print_LAI (namebuf, pvalue->u.lAI);
         break;

      case 2:
         sprintf (namebuf, "%s.u.rAI", name);
         asn1Print_RAI (namebuf, pvalue->u.rAI);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  PagingCause                                               */
/*                                                            */
/**************************************************************/

void asn1Print_PagingCause
   (const char* name, PagingCause* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("terminating_conversational_call\n"); break;
      case 1: printf ("terminating_streaming_call\n"); break;
      case 2: printf ("terminating_interactive_call\n"); break;
      case 3: printf ("terminating_background_call\n"); break;
      case 4: printf ("terminating_low_priority_signalling\n"); break;
      case 5: printf ("terminating_high_priority_signalling\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  NonSearchingIndication                                    */
/*                                                            */
/**************************************************************/

void asn1Print_NonSearchingIndication
   (const char* name, NonSearchingIndication* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("non_searching\n"); break;
      case 1: printf ("searching\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  DRX_CycleLengthCoefficient                                */
/*                                                            */
/**************************************************************/

void asn1Print_DRX_CycleLengthCoefficient
   (const char* name, DRX_CycleLengthCoefficient* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  TraceType                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_TraceType
   (const char* name, TraceType* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TriggerID                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_TriggerID
   (const char* name, TriggerID* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  IMEI                                                      */
/*                                                            */
/**************************************************************/

void asn1Print_IMEI
   (const char* name, IMEI* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  IMEISV                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_IMEISV
   (const char* name, IMEISV* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  UE_ID                                                     */
/*                                                            */
/**************************************************************/

void asn1Print_UE_ID
   (const char* name, UE_ID* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.imsi", name);
         asn1Print_IMSI (namebuf, pvalue->u.imsi);
         break;

      case 2:
         sprintf (namebuf, "%s.u.imei", name);
         asn1Print_IMEI (namebuf, pvalue->u.imei);
         break;

      case 3:
         sprintf (namebuf, "%s.u.imeisv", name);
         asn1Print_IMEISV (namebuf, pvalue->u.imeisv);
         break;

      case 4:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  OMC_ID                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_OMC_ID
   (const char* name, OMC_ID* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  TraceDepth                                                */
/*                                                            */
/**************************************************************/

void asn1Print_TraceDepth
   (const char* name, TraceDepth* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("minimum\n"); break;
      case 1: printf ("medium\n"); break;
      case 2: printf ("maximum\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_interface_                          */
/*                                                            */
/**************************************************************/

void asn1Print_InterfacesToTraceItem_interface_
   (const char* name, InterfacesToTraceItem_interface_* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("iu_cs\n"); break;
      case 1: printf ("iu_ps\n"); break;
      case 2: printf ("iur\n"); break;
      case 3: printf ("iub\n"); break;
      case 4: printf ("uu\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

void asn1Print_InterfacesToTraceItem_iE_Extensions_element
   (const char* name, InterfacesToTraceItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InterfacesToTraceItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InterfacesToTraceItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InterfacesToTraceItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      InterfacesToTraceItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions                       */
/*                                                            */
/**************************************************************/

void asn1Print_InterfacesToTraceItem_iE_Extensions
   (const char* name, InterfacesToTraceItem_iE_Extensions* pvalue)
{
   InterfacesToTraceItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InterfacesToTraceItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InterfacesToTraceItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem                                     */
/*                                                            */
/**************************************************************/

void asn1Print_InterfacesToTraceItem
   (const char* name, InterfacesToTraceItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.interface_", name);
   asn1Print_InterfacesToTraceItem_interface_ (namebuf, &pvalue->interface_);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_InterfacesToTraceItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  ListOfInterfacesToTrace                                   */
/*                                                            */
/**************************************************************/

void asn1Print_ListOfInterfacesToTrace
   (const char* name, ListOfInterfacesToTrace* pvalue)
{
   InterfacesToTraceItem* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InterfacesToTraceItem*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InterfacesToTraceItem (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

void asn1Print_TracePropagationParameters_iE_Extensions_element
   (const char* name, TracePropagationParameters_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < TracePropagationParameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TracePropagationParameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TracePropagationParameters_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      TracePropagationParameters_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions                  */
/*                                                            */
/**************************************************************/

void asn1Print_TracePropagationParameters_iE_Extensions
   (const char* name, TracePropagationParameters_iE_Extensions* pvalue)
{
   TracePropagationParameters_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TracePropagationParameters_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TracePropagationParameters_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters                                */
/*                                                            */
/**************************************************************/

void asn1Print_TracePropagationParameters
   (const char* name, TracePropagationParameters* pvalue)
{
   char namebuf[512];

   printf ("%s.m.listOfInterfacesToTracePresent = %d\n", name, (int)pvalue->m.listOfInterfacesToTracePresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.traceRecordingSessionReference", name);
   asn1Print_TraceRecordingSessionReference (namebuf, &pvalue->traceRecordingSessionReference);

   sprintf (namebuf, "%s.traceDepth", name);
   asn1Print_TraceDepth (namebuf, &pvalue->traceDepth);

   if (pvalue->m.listOfInterfacesToTracePresent) {
      sprintf (namebuf, "%s.listOfInterfacesToTrace", name);
      asn1Print_ListOfInterfacesToTrace (namebuf, &pvalue->listOfInterfacesToTrace);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_TracePropagationParameters_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  Event                                                     */
/*                                                            */
/**************************************************************/

void asn1Print_Event
   (const char* name, Event* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("stop_change_of_service_area\n"); break;
      case 1: printf ("direct\n"); break;
      case 2: printf ("change_of_servicearea\n"); break;
      case 3: printf ("stop_direct\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  ReportArea                                                */
/*                                                            */
/**************************************************************/

void asn1Print_ReportArea
   (const char* name, ReportArea* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("service_area\n"); break;
      case 1: printf ("geographical_area\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RequestType                                               */
/*                                                            */
/**************************************************************/

void asn1Print_RequestType
   (const char* name, RequestType* pvalue)
{
   char namebuf[512];

   printf ("%s.m.accuracyCodePresent = %d\n", name, (int)pvalue->m.accuracyCodePresent);
   sprintf (namebuf, "%s.event", name);
   asn1Print_Event (namebuf, &pvalue->event);

   sprintf (namebuf, "%s.reportArea", name);
   asn1Print_ReportArea (namebuf, &pvalue->reportArea);

   if (pvalue->m.accuracyCodePresent) {
      sprintf (namebuf, "%s.accuracyCode", name);
      rtPrintUnsigned (namebuf, pvalue->accuracyCode);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  VerticalAccuracyCode                                      */
/*                                                            */
/**************************************************************/

void asn1Print_VerticalAccuracyCode
   (const char* name, VerticalAccuracyCode* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResponseTime                                              */
/*                                                            */
/**************************************************************/

void asn1Print_ResponseTime
   (const char* name, ResponseTime* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("lowdelay\n"); break;
      case 1: printf ("delaytolerant\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  PositioningPriority                                       */
/*                                                            */
/**************************************************************/

void asn1Print_PositioningPriority
   (const char* name, PositioningPriority* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("high_Priority\n"); break;
      case 1: printf ("normal_Priority\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  ClientType                                                */
/*                                                            */
/**************************************************************/

void asn1Print_ClientType
   (const char* name, ClientType* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("emergency_Services\n"); break;
      case 1: printf ("value_Added_Services\n"); break;
      case 2: printf ("pLMN_Operator_Services\n"); break;
      case 3: printf ("lawful_Intercept_Services\n"); break;
      case 4: printf ("pLMN_Operator_Broadcast_Services\n"); break;
      case 5: printf ("pLMN_Operator_O_et_M\n"); break;
      case 6: printf ("pLMN_Operator_Anonymous_Statistics\n"); break;
      case 7: printf ("pLMN_Operator_Target_MS_Service_Support\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_latitudeSign                      */
/*                                                            */
/**************************************************************/

void asn1Print_GeographicalCoordinates_latitudeSign
   (const char* name, GeographicalCoordinates_latitudeSign* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("north\n"); break;
      case 1: printf ("south\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_GeographicalCoordinates_iE_Extensions_element
   (const char* name, GeographicalCoordinates_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GeographicalCoordinates_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GeographicalCoordinates_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GeographicalCoordinates_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GeographicalCoordinates_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_GeographicalCoordinates_iE_Extensions
   (const char* name, GeographicalCoordinates_iE_Extensions* pvalue)
{
   GeographicalCoordinates_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GeographicalCoordinates_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GeographicalCoordinates_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates                                   */
/*                                                            */
/**************************************************************/

void asn1Print_GeographicalCoordinates
   (const char* name, GeographicalCoordinates* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.latitudeSign", name);
   asn1Print_GeographicalCoordinates_latitudeSign (namebuf, &pvalue->latitudeSign);

   sprintf (namebuf, "%s.latitude", name);
   rtPrintUnsigned (namebuf, pvalue->latitude);

   sprintf (namebuf, "%s.longitude", name);
   rtPrintInteger (namebuf, pvalue->longitude);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GeographicalCoordinates_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

void asn1Print_GA_Point_iE_Extensions_element
   (const char* name, GA_Point_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GA_Point_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_Point_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_Point_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GA_Point_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions                                    */
/*                                                            */
/**************************************************************/

void asn1Print_GA_Point_iE_Extensions
   (const char* name, GA_Point_iE_Extensions* pvalue)
{
   GA_Point_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GA_Point_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GA_Point_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GA_Point                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_GA_Point
   (const char* name, GA_Point* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.geographicalCoordinates", name);
   asn1Print_GeographicalCoordinates (namebuf, &pvalue->geographicalCoordinates);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GA_Point_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithUnCertainty_iE_Extensions_element
   (const char* name, GA_PointWithUnCertainty_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GA_PointWithUnCertainty_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithUnCertainty_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithUnCertainty_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GA_PointWithUnCertainty_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithUnCertainty_iE_Extensions
   (const char* name, GA_PointWithUnCertainty_iE_Extensions* pvalue)
{
   GA_PointWithUnCertainty_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GA_PointWithUnCertainty_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GA_PointWithUnCertainty_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty                                   */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithUnCertainty
   (const char* name, GA_PointWithUnCertainty* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.geographicalCoordinates", name);
   asn1Print_GeographicalCoordinates (namebuf, &pvalue->geographicalCoordinates);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GA_PointWithUnCertainty_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.uncertaintyCode", name);
   rtPrintUnsigned (namebuf, pvalue->uncertaintyCode);

}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

void asn1Print_GA_Polygon_element_iE_Extensions_element
   (const char* name, GA_Polygon_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GA_Polygon_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_Polygon_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_Polygon_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GA_Polygon_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions                          */
/*                                                            */
/**************************************************************/

void asn1Print_GA_Polygon_element_iE_Extensions
   (const char* name, GA_Polygon_element_iE_Extensions* pvalue)
{
   GA_Polygon_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GA_Polygon_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GA_Polygon_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element                                        */
/*                                                            */
/**************************************************************/

void asn1Print_GA_Polygon_element
   (const char* name, GA_Polygon_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.geographicalCoordinates", name);
   asn1Print_GeographicalCoordinates (namebuf, &pvalue->geographicalCoordinates);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GA_Polygon_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GA_Polygon                                                */
/*                                                            */
/**************************************************************/

void asn1Print_GA_Polygon
   (const char* name, GA_Polygon* pvalue)
{
   GA_Polygon_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GA_Polygon_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GA_Polygon_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GA_UncertaintyEllipse                                     */
/*                                                            */
/**************************************************************/

void asn1Print_GA_UncertaintyEllipse
   (const char* name, GA_UncertaintyEllipse* pvalue)
{
   char namebuf[512];

   sprintf (namebuf, "%s.uncertaintySemi_major", name);
   rtPrintUnsigned (namebuf, pvalue->uncertaintySemi_major);

   sprintf (namebuf, "%s.uncertaintySemi_minor", name);
   rtPrintUnsigned (namebuf, pvalue->uncertaintySemi_minor);

   sprintf (namebuf, "%s.orientationOfMajorAxis", name);
   rtPrintUnsigned (namebuf, pvalue->orientationOfMajorAxis);

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithUnCertaintyEllipse_iE_Extensions_element
   (const char* name, GA_PointWithUnCertaintyEllipse_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GA_PointWithUnCertaintyEllipse_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithUnCertaintyEllipse_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithUnCertaintyEllipse_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GA_PointWithUnCertaintyEllipse_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions              */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithUnCertaintyEllipse_iE_Extensions
   (const char* name, GA_PointWithUnCertaintyEllipse_iE_Extensions* pvalue)
{
   GA_PointWithUnCertaintyEllipse_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GA_PointWithUnCertaintyEllipse_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse                            */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithUnCertaintyEllipse
   (const char* name, GA_PointWithUnCertaintyEllipse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.geographicalCoordinates", name);
   asn1Print_GeographicalCoordinates (namebuf, &pvalue->geographicalCoordinates);

   sprintf (namebuf, "%s.uncertaintyEllipse", name);
   asn1Print_GA_UncertaintyEllipse (namebuf, &pvalue->uncertaintyEllipse);

   sprintf (namebuf, "%s.confidence", name);
   rtPrintUnsigned (namebuf, pvalue->confidence);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GA_PointWithUnCertaintyEllipse_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GA_AltitudeAndDirection_directionOfAltitude               */
/*                                                            */
/**************************************************************/

void asn1Print_GA_AltitudeAndDirection_directionOfAltitude
   (const char* name, GA_AltitudeAndDirection_directionOfAltitude* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("height\n"); break;
      case 1: printf ("depth\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  GA_AltitudeAndDirection                                   */
/*                                                            */
/**************************************************************/

void asn1Print_GA_AltitudeAndDirection
   (const char* name, GA_AltitudeAndDirection* pvalue)
{
   char namebuf[512];

   sprintf (namebuf, "%s.directionOfAltitude", name);
   asn1Print_GA_AltitudeAndDirection_directionOfAltitude (namebuf, &pvalue->directionOfAltitude);

   sprintf (namebuf, "%s.altitude", name);
   rtPrintUnsigned (namebuf, pvalue->altitude);

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithAltitude_iE_Extensions_element
   (const char* name, GA_PointWithAltitude_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GA_PointWithAltitude_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithAltitude_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithAltitude_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GA_PointWithAltitude_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions                        */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithAltitude_iE_Extensions
   (const char* name, GA_PointWithAltitude_iE_Extensions* pvalue)
{
   GA_PointWithAltitude_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GA_PointWithAltitude_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GA_PointWithAltitude_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude                                      */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithAltitude
   (const char* name, GA_PointWithAltitude* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.geographicalCoordinates", name);
   asn1Print_GeographicalCoordinates (namebuf, &pvalue->geographicalCoordinates);

   sprintf (namebuf, "%s.altitudeAndDirection", name);
   asn1Print_GA_AltitudeAndDirection (namebuf, &pvalue->altitudeAndDirection);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GA_PointWithAltitude_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element
   (const char* name, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions
   (const char* name, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions* pvalue)
{
   GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid               */
/*                                                            */
/**************************************************************/

void asn1Print_GA_PointWithAltitudeAndUncertaintyEllipsoid
   (const char* name, GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.geographicalCoordinates", name);
   asn1Print_GeographicalCoordinates (namebuf, &pvalue->geographicalCoordinates);

   sprintf (namebuf, "%s.altitudeAndDirection", name);
   asn1Print_GA_AltitudeAndDirection (namebuf, &pvalue->altitudeAndDirection);

   sprintf (namebuf, "%s.uncertaintyEllipse", name);
   asn1Print_GA_UncertaintyEllipse (namebuf, &pvalue->uncertaintyEllipse);

   sprintf (namebuf, "%s.uncertaintyAltitude", name);
   rtPrintUnsigned (namebuf, pvalue->uncertaintyAltitude);

   sprintf (namebuf, "%s.confidence", name);
   rtPrintUnsigned (namebuf, pvalue->confidence);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_GA_EllipsoidArc_iE_Extensions_element
   (const char* name, GA_EllipsoidArc_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GA_EllipsoidArc_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_EllipsoidArc_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_EllipsoidArc_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GA_EllipsoidArc_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions                             */
/*                                                            */
/**************************************************************/

void asn1Print_GA_EllipsoidArc_iE_Extensions
   (const char* name, GA_EllipsoidArc_iE_Extensions* pvalue)
{
   GA_EllipsoidArc_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GA_EllipsoidArc_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GA_EllipsoidArc_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc                                           */
/*                                                            */
/**************************************************************/

void asn1Print_GA_EllipsoidArc
   (const char* name, GA_EllipsoidArc* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.geographicalCoordinates", name);
   asn1Print_GeographicalCoordinates (namebuf, &pvalue->geographicalCoordinates);

   sprintf (namebuf, "%s.innerRadius", name);
   rtPrintUnsigned (namebuf, pvalue->innerRadius);

   sprintf (namebuf, "%s.uncertaintyRadius", name);
   rtPrintUnsigned (namebuf, pvalue->uncertaintyRadius);

   sprintf (namebuf, "%s.offsetAngle", name);
   rtPrintUnsigned (namebuf, pvalue->offsetAngle);

   sprintf (namebuf, "%s.includedAngle", name);
   rtPrintUnsigned (namebuf, pvalue->includedAngle);

   sprintf (namebuf, "%s.confidence", name);
   rtPrintUnsigned (namebuf, pvalue->confidence);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GA_EllipsoidArc_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  GeographicalArea                                          */
/*                                                            */
/**************************************************************/

void asn1Print_GeographicalArea
   (const char* name, GeographicalArea* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.point", name);
         asn1Print_GA_Point (namebuf, pvalue->u.point);
         break;

      case 2:
         sprintf (namebuf, "%s.u.pointWithUnCertainty", name);
         asn1Print_GA_PointWithUnCertainty (namebuf, pvalue->u.pointWithUnCertainty);
         break;

      case 3:
         sprintf (namebuf, "%s.u.polygon", name);
         asn1Print_GA_Polygon (namebuf, pvalue->u.polygon);
         break;

      case 4:
         sprintf (namebuf, "%s.u.pointWithUncertaintyEllipse", name);
         asn1Print_GA_PointWithUnCertaintyEllipse (namebuf, pvalue->u.pointWithUncertaintyEllipse);
         break;

      case 5:
         sprintf (namebuf, "%s.u.pointWithAltitude", name);
         asn1Print_GA_PointWithAltitude (namebuf, pvalue->u.pointWithAltitude);
         break;

      case 6:
         sprintf (namebuf, "%s.u.pointWithAltitudeAndUncertaintyEllipsoid", name);
         asn1Print_GA_PointWithAltitudeAndUncertaintyEllipsoid (namebuf, pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);
         break;

      case 7:
         sprintf (namebuf, "%s.u.ellipsoidArc", name);
         asn1Print_GA_EllipsoidArc (namebuf, pvalue->u.ellipsoidArc);
         break;

      case 8:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  AreaIdentity                                              */
/*                                                            */
/**************************************************************/

void asn1Print_AreaIdentity
   (const char* name, AreaIdentity* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.sAI", name);
         asn1Print_SAI (namebuf, pvalue->u.sAI);
         break;

      case 2:
         sprintf (namebuf, "%s.u.geographicalArea", name);
         asn1Print_GeographicalArea (namebuf, pvalue->u.geographicalArea);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

void asn1Print_LastKnownServiceArea_iE_Extensions_element
   (const char* name, LastKnownServiceArea_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LastKnownServiceArea_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LastKnownServiceArea_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LastKnownServiceArea_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LastKnownServiceArea_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions                        */
/*                                                            */
/**************************************************************/

void asn1Print_LastKnownServiceArea_iE_Extensions
   (const char* name, LastKnownServiceArea_iE_Extensions* pvalue)
{
   LastKnownServiceArea_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LastKnownServiceArea_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LastKnownServiceArea_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea                                      */
/*                                                            */
/**************************************************************/

void asn1Print_LastKnownServiceArea
   (const char* name, LastKnownServiceArea* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.sAI", name);
   asn1Print_SAI (namebuf, &pvalue->sAI);

   sprintf (namebuf, "%s.ageOfSAI", name);
   rtPrintUnsigned (namebuf, pvalue->ageOfSAI);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_LastKnownServiceArea_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  PositioningDataDiscriminator                              */
/*                                                            */
/**************************************************************/

void asn1Print_PositioningDataDiscriminator
   (const char* name, PositioningDataDiscriminator* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  PositioningMethodAndUsage                                 */
/*                                                            */
/**************************************************************/

void asn1Print_PositioningMethodAndUsage
   (const char* name, PositioningMethodAndUsage* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  PositioningDataSet                                        */
/*                                                            */
/**************************************************************/

void asn1Print_PositioningDataSet
   (const char* name, PositioningDataSet* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_PositioningMethodAndUsage (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_PositionData_iE_Extensions_element
   (const char* name, PositionData_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < PositionData_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PositionData_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PositionData_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      PositionData_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions                                */
/*                                                            */
/**************************************************************/

void asn1Print_PositionData_iE_Extensions
   (const char* name, PositionData_iE_Extensions* pvalue)
{
   PositionData_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (PositionData_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_PositionData_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  PositionData                                              */
/*                                                            */
/**************************************************************/

void asn1Print_PositionData
   (const char* name, PositionData* pvalue)
{
   char namebuf[512];

   printf ("%s.m.positioningDataSetPresent = %d\n", name, (int)pvalue->m.positioningDataSetPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.positioningDataDiscriminator", name);
   asn1Print_PositioningDataDiscriminator (namebuf, &pvalue->positioningDataDiscriminator);

   if (pvalue->m.positioningDataSetPresent) {
      sprintf (namebuf, "%s.positioningDataSet", name);
      asn1Print_PositioningDataSet (namebuf, &pvalue->positioningDataSet);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_PositionData_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  PositionDataSpecificToGERANIuMode                         */
/*                                                            */
/**************************************************************/

void asn1Print_PositionDataSpecificToGERANIuMode
   (const char* name, PositionDataSpecificToGERANIuMode* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  AccuracyFulfilmentIndicator                               */
/*                                                            */
/**************************************************************/

void asn1Print_AccuracyFulfilmentIndicator
   (const char* name, AccuracyFulfilmentIndicator* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("requested_Accuracy_Fulfilled\n"); break;
      case 1: printf ("requested_Accuracy_Not_Fulfilled\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  NAS_PDU                                                   */
/*                                                            */
/**************************************************************/

void asn1Print_NAS_PDU
   (const char* name, NAS_PDU* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  NAS_SequenceNumber                                        */
/*                                                            */
/**************************************************************/

void asn1Print_NAS_SequenceNumber
   (const char* name, NAS_SequenceNumber* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  SAPI                                                      */
/*                                                            */
/**************************************************************/

void asn1Print_SAPI
   (const char* name, SAPI* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sapi_0\n"); break;
      case 1: printf ("sapi_3\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RejectCauseValue                                          */
/*                                                            */
/**************************************************************/

void asn1Print_RejectCauseValue
   (const char* name, RejectCauseValue* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("pLMN_Not_Allowed\n"); break;
      case 1: printf ("location_Area_Not_Allowed\n"); break;
      case 2: printf ("roaming_Not_Allowed_In_This_Location_Area\n"); break;
      case 3: printf ("no_Suitable_Cell_In_Location_Area\n"); break;
      case 4: printf ("gPRS_Services_Not_Allowed_In_This_PLMN\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RedirectionCompleted                                      */
/*                                                            */
/**************************************************************/

void asn1Print_RedirectionCompleted
   (const char* name, RedirectionCompleted* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("redirection_completed\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  NumberOfSteps                                             */
/*                                                            */
/**************************************************************/

void asn1Print_NumberOfSteps
   (const char* name, NumberOfSteps* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_MaxBitrateList                    */
/*                                                            */
/**************************************************************/

void asn1Print_Requested_RAB_Parameter_MaxBitrateList
   (const char* name, Requested_RAB_Parameter_MaxBitrateList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_GuaranteedBitrateList             */
/*                                                            */
/**************************************************************/

void asn1Print_Requested_RAB_Parameter_GuaranteedBitrateList
   (const char* name, Requested_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  AlternativeRABConfigurationRequest                        */
/*                                                            */
/**************************************************************/

void asn1Print_AlternativeRABConfigurationRequest
   (const char* name, AlternativeRABConfigurationRequest* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("alternative_RAB_configuration_Requested\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  _Requested_RAB_Parameter_Values_ExtIEs_Extension          */
/*                                                            */
/**************************************************************/

void asn1Print__Requested_RAB_Parameter_Values_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _Requested_RAB_Parameter_Values_ExtIEs_Extension *pvalue = (_Requested_RAB_Parameter_Values_ExtIEs_Extension*) pvalue_;
   asn1Print_AlternativeRABConfigurationRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

void asn1Print_Requested_RAB_Parameter_Values_iE_Extensions_element
   (const char* name, Requested_RAB_Parameter_Values_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Requested_RAB_Parameter_Values_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Requested_RAB_Parameter_Values_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Requested_RAB_Parameter_Values_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      Requested_RAB_Parameter_Values_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions              */
/*                                                            */
/**************************************************************/

void asn1Print_Requested_RAB_Parameter_Values_iE_Extensions
   (const char* name, Requested_RAB_Parameter_Values_iE_Extensions* pvalue)
{
   Requested_RAB_Parameter_Values_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Requested_RAB_Parameter_Values_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Requested_RAB_Parameter_Values_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values                            */
/*                                                            */
/**************************************************************/

void asn1Print_Requested_RAB_Parameter_Values
   (const char* name, Requested_RAB_Parameter_Values* pvalue)
{
   char namebuf[512];

   printf ("%s.m.requestedMaxBitratesPresent = %d\n", name, (int)pvalue->m.requestedMaxBitratesPresent);
   printf ("%s.m.requestedGuaranteedBitratesPresent = %d\n", name, (int)pvalue->m.requestedGuaranteedBitratesPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.requestedMaxBitratesPresent) {
      sprintf (namebuf, "%s.requestedMaxBitrates", name);
      asn1Print_Requested_RAB_Parameter_MaxBitrateList (namebuf, &pvalue->requestedMaxBitrates);
   }

   if (pvalue->m.requestedGuaranteedBitratesPresent) {
      sprintf (namebuf, "%s.requestedGuaranteedBitrates", name);
      asn1Print_Requested_RAB_Parameter_GuaranteedBitrateList (namebuf, &pvalue->requestedGuaranteedBitrates);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_Requested_RAB_Parameter_Values_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RequestedLocationRelatedDataType                          */
/*                                                            */
/**************************************************************/

void asn1Print_RequestedLocationRelatedDataType
   (const char* name, RequestedLocationRelatedDataType* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("decipheringKeysUEBasedOTDOA\n"); break;
      case 1: printf ("decipheringKeysAssistedGPS\n"); break;
      case 2: printf ("dedicatedAssistanceDataUEBasedOTDOA\n"); break;
      case 3: printf ("dedicatedAssistanceDataAssistedGPS\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RequestedGPSAssistanceData                                */
/*                                                            */
/**************************************************************/

void asn1Print_RequestedGPSAssistanceData
   (const char* name, RequestedGPSAssistanceData* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestType                            */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataRequestType
   (const char* name, LocationRelatedDataRequestType* pvalue)
{
   char namebuf[512];

   printf ("%s.m.requestedGPSAssistanceDataPresent = %d\n", name, (int)pvalue->m.requestedGPSAssistanceDataPresent);
   sprintf (namebuf, "%s.requestedLocationRelatedDataType", name);
   asn1Print_RequestedLocationRelatedDataType (namebuf, &pvalue->requestedLocationRelatedDataType);

   if (pvalue->m.requestedGPSAssistanceDataPresent) {
      sprintf (namebuf, "%s.requestedGPSAssistanceData", name);
      asn1Print_RequestedGPSAssistanceData (namebuf, &pvalue->requestedGPSAssistanceData);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestTypeSpecificToGERANIuMode       */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataRequestTypeSpecificToGERANIuMode
   (const char* name, LocationRelatedDataRequestTypeSpecificToGERANIuMode* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("decipheringKeysEOTD\n"); break;
      case 1: printf ("dedicatedMobileAssistedEOTDAssistanceData\n"); break;
      case 2: printf ("dedicatedMobileBasedEOTDAssistanceData\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag   */
/*                                                            */
/**************************************************************/

void asn1Print_BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag
   (const char* name, BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_currentDecipherin  */
/*                                                            */
/**************************************************************/

void asn1Print_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey
   (const char* name, BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_nextDecipheringKe  */
/*                                                            */
/**************************************************************/

void asn1Print_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey
   (const char* name, BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys                    */
/*                                                            */
/**************************************************************/

void asn1Print_BroadcastAssistanceDataDecipheringKeys
   (const char* name, BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   char namebuf[512];

   sprintf (namebuf, "%s.cipheringKeyFlag", name);
   asn1Print_BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag (namebuf, &pvalue->cipheringKeyFlag);

   sprintf (namebuf, "%s.currentDecipheringKey", name);
   asn1Print_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (namebuf, &pvalue->currentDecipheringKey);

   sprintf (namebuf, "%s.nextDecipheringKey", name);
   asn1Print_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (namebuf, &pvalue->nextDecipheringKey);

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  InformationTransferID                                     */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferID
   (const char* name, InformationTransferID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  ListOF_SNAs                                               */
/*                                                            */
/**************************************************************/

void asn1Print_ListOF_SNAs
   (const char* name, ListOF_SNAs* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SNAC (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_LA_LIST_element_iE_Extensions_element
   (const char* name, LA_LIST_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LA_LIST_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LA_LIST_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LA_LIST_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LA_LIST_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions                             */
/*                                                            */
/**************************************************************/

void asn1Print_LA_LIST_element_iE_Extensions
   (const char* name, LA_LIST_element_iE_Extensions* pvalue)
{
   LA_LIST_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LA_LIST_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LA_LIST_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element                                           */
/*                                                            */
/**************************************************************/

void asn1Print_LA_LIST_element
   (const char* name, LA_LIST_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.lAC", name);
   asn1Print_LAC (namebuf, &pvalue->lAC);

   sprintf (namebuf, "%s.listOF_SNAs", name);
   asn1Print_ListOF_SNAs (namebuf, &pvalue->listOF_SNAs);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_LA_LIST_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  LA_LIST                                                   */
/*                                                            */
/**************************************************************/

void asn1Print_LA_LIST
   (const char* name, LA_LIST* pvalue)
{
   LA_LIST_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LA_LIST_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LA_LIST_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

void asn1Print_PLMNs_in_shared_network_element_iE_Extensions_element
   (const char* name, PLMNs_in_shared_network_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < PLMNs_in_shared_network_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PLMNs_in_shared_network_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PLMNs_in_shared_network_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      PLMNs_in_shared_network_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions             */
/*                                                            */
/**************************************************************/

void asn1Print_PLMNs_in_shared_network_element_iE_Extensions
   (const char* name, PLMNs_in_shared_network_element_iE_Extensions* pvalue)
{
   PLMNs_in_shared_network_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (PLMNs_in_shared_network_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_PLMNs_in_shared_network_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element                           */
/*                                                            */
/**************************************************************/

void asn1Print_PLMNs_in_shared_network_element
   (const char* name, PLMNs_in_shared_network_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNidentity", name);
   asn1Print_PLMNidentity (namebuf, &pvalue->pLMNidentity);

   sprintf (namebuf, "%s.lA_LIST", name);
   asn1Print_LA_LIST (namebuf, &pvalue->lA_LIST);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_PLMNs_in_shared_network_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network                                   */
/*                                                            */
/**************************************************************/

void asn1Print_PLMNs_in_shared_network
   (const char* name, PLMNs_in_shared_network* pvalue)
{
   PLMNs_in_shared_network_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (PLMNs_in_shared_network_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_PLMNs_in_shared_network_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

void asn1Print_Shared_Network_Information_iE_Extensions_element
   (const char* name, Shared_Network_Information_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Shared_Network_Information_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Shared_Network_Information_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Shared_Network_Information_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      Shared_Network_Information_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions                  */
/*                                                            */
/**************************************************************/

void asn1Print_Shared_Network_Information_iE_Extensions
   (const char* name, Shared_Network_Information_iE_Extensions* pvalue)
{
   Shared_Network_Information_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Shared_Network_Information_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Shared_Network_Information_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information                                */
/*                                                            */
/**************************************************************/

void asn1Print_Shared_Network_Information
   (const char* name, Shared_Network_Information* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.pLMNs_in_shared_network", name);
   asn1Print_PLMNs_in_shared_network (namebuf, &pvalue->pLMNs_in_shared_network);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_Shared_Network_Information_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  ProvidedData                                              */
/*                                                            */
/**************************************************************/

void asn1Print_ProvidedData
   (const char* name, ProvidedData* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.shared_network_information", name);
         asn1Print_Shared_Network_Information (namebuf, pvalue->u.shared_network_information);
         break;

      case 2:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  RIMInformation                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RIMInformation
   (const char* name, RIMInformation* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions_element                       */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Cell_ID_iE_Extensions_element
   (const char* name, GERAN_Cell_ID_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GERAN_Cell_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Cell_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Cell_ID_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GERAN_Cell_ID_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions                               */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Cell_ID_iE_Extensions
   (const char* name, GERAN_Cell_ID_iE_Extensions* pvalue)
{
   GERAN_Cell_ID_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GERAN_Cell_ID_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GERAN_Cell_ID_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID                                             */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Cell_ID
   (const char* name, GERAN_Cell_ID* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.lAI", name);
   asn1Print_LAI (namebuf, &pvalue->lAI);

   sprintf (namebuf, "%s.rAC", name);
   asn1Print_RAC (namebuf, &pvalue->rAC);

   sprintf (namebuf, "%s.cI", name);
   asn1Print_CI (namebuf, &pvalue->cI);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GERAN_Cell_ID_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  RIMRoutingAddress                                         */
/*                                                            */
/**************************************************************/

void asn1Print_RIMRoutingAddress
   (const char* name, RIMRoutingAddress* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.globalRNC_ID", name);
         asn1Print_GlobalRNC_ID (namebuf, pvalue->u.globalRNC_ID);
         break;

      case 2:
         sprintf (namebuf, "%s.u.gERAN_Cell_ID", name);
         asn1Print_GERAN_Cell_ID (namebuf, pvalue->u.gERAN_Cell_ID);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_RIM_Transfer_iE_Extensions_element
   (const char* name, RIM_Transfer_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RIM_Transfer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RIM_Transfer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RIM_Transfer_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RIM_Transfer_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions                                */
/*                                                            */
/**************************************************************/

void asn1Print_RIM_Transfer_iE_Extensions
   (const char* name, RIM_Transfer_iE_Extensions* pvalue)
{
   RIM_Transfer_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RIM_Transfer_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RIM_Transfer_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer                                              */
/*                                                            */
/**************************************************************/

void asn1Print_RIM_Transfer
   (const char* name, RIM_Transfer* pvalue)
{
   char namebuf[512];

   printf ("%s.m.rIMRoutingAddressPresent = %d\n", name, (int)pvalue->m.rIMRoutingAddressPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rIMInformation", name);
   asn1Print_RIMInformation (namebuf, &pvalue->rIMInformation);

   if (pvalue->m.rIMRoutingAddressPresent) {
      sprintf (namebuf, "%s.rIMRoutingAddress", name);
      asn1Print_RIMRoutingAddress (namebuf, &pvalue->rIMRoutingAddress);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RIM_Transfer_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  InterSystemInformationTransferType                        */
/*                                                            */
/**************************************************************/

void asn1Print_InterSystemInformationTransferType
   (const char* name, InterSystemInformationTransferType* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.rIM_Transfer", name);
         asn1Print_RIM_Transfer (namebuf, pvalue->u.rIM_Transfer);
         break;

      case 2:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeID                                     */
/*                                                            */
/**************************************************************/

void asn1Print_InformationExchangeID
   (const char* name, InformationExchangeID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeType                                   */
/*                                                            */
/**************************************************************/

void asn1Print_InformationExchangeType
   (const char* name, InformationExchangeType* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("transfer\n"); break;
      case 1: printf ("request\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_traceActivationIndicator              */
/*                                                            */
/**************************************************************/

void asn1Print_RNCTraceInformation_traceActivationIndicator
   (const char* name, RNCTraceInformation_traceActivationIndicator* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("activated\n"); break;
      case 1: printf ("deactivated\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  IMEIList                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_IMEIList
   (const char* name, IMEIList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_IMEI (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  IMEISVList                                                */
/*                                                            */
/**************************************************************/

void asn1Print_IMEISVList
   (const char* name, IMEISVList* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_IMEISV (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iMEIMask                                        */
/*                                                            */
/**************************************************************/

void asn1Print_IMEIGroup_iMEIMask
   (const char* name, IMEIGroup_iMEIMask* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions_element                           */
/*                                                            */
/**************************************************************/

void asn1Print_IMEIGroup_iE_Extensions_element
   (const char* name, IMEIGroup_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < IMEIGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IMEIGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IMEIGroup_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      IMEIGroup_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions                                   */
/*                                                            */
/**************************************************************/

void asn1Print_IMEIGroup_iE_Extensions
   (const char* name, IMEIGroup_iE_Extensions* pvalue)
{
   IMEIGroup_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (IMEIGroup_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_IMEIGroup_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_IMEIGroup
   (const char* name, IMEIGroup* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.iMEI", name);
   asn1Print_IMEI (namebuf, &pvalue->iMEI);

   sprintf (namebuf, "%s.iMEIMask", name);
   asn1Print_IMEIGroup_iMEIMask (namebuf, &pvalue->iMEIMask);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_IMEIGroup_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iMEISVMask                                    */
/*                                                            */
/**************************************************************/

void asn1Print_IMEISVGroup_iMEISVMask
   (const char* name, IMEISVGroup_iMEISVMask* pvalue)
{
   rtPrintBitStr (name, pvalue->numbits, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions_element                         */
/*                                                            */
/**************************************************************/

void asn1Print_IMEISVGroup_iE_Extensions_element
   (const char* name, IMEISVGroup_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < IMEISVGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IMEISVGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IMEISVGroup_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      IMEISVGroup_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions                                 */
/*                                                            */
/**************************************************************/

void asn1Print_IMEISVGroup_iE_Extensions
   (const char* name, IMEISVGroup_iE_Extensions* pvalue)
{
   IMEISVGroup_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (IMEISVGroup_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_IMEISVGroup_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup                                               */
/*                                                            */
/**************************************************************/

void asn1Print_IMEISVGroup
   (const char* name, IMEISVGroup* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.iMEISV", name);
   asn1Print_IMEISV (namebuf, &pvalue->iMEISV);

   sprintf (namebuf, "%s.iMEISVMask", name);
   asn1Print_IMEISVGroup_iMEISVMask (namebuf, &pvalue->iMEISVMask);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_IMEISVGroup_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  EquipmentsToBeTraced                                      */
/*                                                            */
/**************************************************************/

void asn1Print_EquipmentsToBeTraced
   (const char* name, EquipmentsToBeTraced* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.iMEIlist", name);
         asn1Print_IMEIList (namebuf, pvalue->u.iMEIlist);
         break;

      case 2:
         sprintf (namebuf, "%s.u.iMEISVlist", name);
         asn1Print_IMEISVList (namebuf, pvalue->u.iMEISVlist);
         break;

      case 3:
         sprintf (namebuf, "%s.u.iMEIgroup", name);
         asn1Print_IMEIGroup (namebuf, pvalue->u.iMEIgroup);
         break;

      case 4:
         sprintf (namebuf, "%s.u.iMEISVgroup", name);
         asn1Print_IMEISVGroup (namebuf, pvalue->u.iMEISVgroup);
         break;

      case 5:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_RNCTraceInformation_iE_Extensions_element
   (const char* name, RNCTraceInformation_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RNCTraceInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RNCTraceInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RNCTraceInformation_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RNCTraceInformation_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions                         */
/*                                                            */
/**************************************************************/

void asn1Print_RNCTraceInformation_iE_Extensions
   (const char* name, RNCTraceInformation_iE_Extensions* pvalue)
{
   RNCTraceInformation_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RNCTraceInformation_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RNCTraceInformation_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation                                       */
/*                                                            */
/**************************************************************/

void asn1Print_RNCTraceInformation
   (const char* name, RNCTraceInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.equipmentsToBeTracedPresent = %d\n", name, (int)pvalue->m.equipmentsToBeTracedPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.traceReference", name);
   asn1Print_TraceReference (namebuf, &pvalue->traceReference);

   sprintf (namebuf, "%s.traceActivationIndicator", name);
   asn1Print_RNCTraceInformation_traceActivationIndicator (namebuf, &pvalue->traceActivationIndicator);

   if (pvalue->m.equipmentsToBeTracedPresent) {
      sprintf (namebuf, "%s.equipmentsToBeTraced", name);
      asn1Print_EquipmentsToBeTraced (namebuf, &pvalue->equipmentsToBeTraced);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RNCTraceInformation_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  InformationTransferType                                   */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferType
   (const char* name, InformationTransferType* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.rNCTraceInformation", name);
         asn1Print_RNCTraceInformation (namebuf, pvalue->u.rNCTraceInformation);
         break;

      case 2:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNRequest                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSIPMulticastAddressandAPNRequest
   (const char* name, MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   TMGI* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TMGI*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TMGI (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InformationRequestType                                    */
/*                                                            */
/**************************************************************/

void asn1Print_InformationRequestType
   (const char* name, InformationRequestType* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.mBMSIPMulticastAddressandAPNRequest", name);
         asn1Print_MBMSIPMulticastAddressandAPNRequest (namebuf, pvalue->u.mBMSIPMulticastAddressandAPNRequest);
         break;

      case 2:
         sprintf (namebuf, "%s.u.permanentNAS_UE_ID", name);
         asn1Print_PermanentNAS_UE_ID (namebuf, pvalue->u.permanentNAS_UE_ID);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  IPMulticastAddress                                        */
/*                                                            */
/**************************************************************/

void asn1Print_IPMulticastAddress
   (const char* name, IPMulticastAddress* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  APN                                                       */
/*                                                            */
/**************************************************************/

void asn1Print_APN
   (const char* name, APN* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element
   (const char* name, MBMSIPMulticastAddressandAPNlist_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSIPMulticastAddressandAPNlist_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSIPMulticastAddressandAPNlist_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSIPMulticastAddressandAPNlist_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSIPMulticastAddressandAPNlist_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions            */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSIPMulticastAddressandAPNlist_iE_Extensions
   (const char* name, MBMSIPMulticastAddressandAPNlist_iE_Extensions* pvalue)
{
   MBMSIPMulticastAddressandAPNlist_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSIPMulticastAddressandAPNlist_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist                          */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSIPMulticastAddressandAPNlist
   (const char* name, MBMSIPMulticastAddressandAPNlist* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.tMGI", name);
   asn1Print_TMGI (namebuf, &pvalue->tMGI);

   sprintf (namebuf, "%s.iPMulticastAddress", name);
   asn1Print_IPMulticastAddress (namebuf, &pvalue->iPMulticastAddress);

   sprintf (namebuf, "%s.aPN", name);
   asn1Print_APN (namebuf, &pvalue->aPN);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_MBMSIPMulticastAddressandAPNlist_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RequestedMBMSIPMulticastAddressandAPNRequest              */
/*                                                            */
/**************************************************************/

void asn1Print_RequestedMBMSIPMulticastAddressandAPNRequest
   (const char* name, RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   MBMSIPMulticastAddressandAPNlist* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSIPMulticastAddressandAPNlist*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSIPMulticastAddressandAPNlist (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RequestedMulticastServiceList                             */
/*                                                            */
/**************************************************************/

void asn1Print_RequestedMulticastServiceList
   (const char* name, RequestedMulticastServiceList* pvalue)
{
   TMGI* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TMGI*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TMGI (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InformationRequested                                      */
/*                                                            */
/**************************************************************/

void asn1Print_InformationRequested
   (const char* name, InformationRequested* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.requestedMBMSIPMulticastAddressandAPNRequest", name);
         asn1Print_RequestedMBMSIPMulticastAddressandAPNRequest (namebuf, pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);
         break;

      case 2:
         sprintf (namebuf, "%s.u.requestedMulticastServiceList", name);
         asn1Print_RequestedMulticastServiceList (namebuf, pvalue->u.requestedMulticastServiceList);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionIdentity                                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionIdentity
   (const char* name, MBMSSessionIdentity* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  MBMSBearerServiceType                                     */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSBearerServiceType
   (const char* name, MBMSBearerServiceType* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("multicast\n"); break;
      case 1: printf ("broadcast\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionDuration                                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionDuration
   (const char* name, MBMSSessionDuration* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  MBMSServiceArea                                           */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSServiceArea
   (const char* name, MBMSServiceArea* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  FrequenceLayerConvergenceFlag                             */
/*                                                            */
/**************************************************************/

void asn1Print_FrequenceLayerConvergenceFlag
   (const char* name, FrequenceLayerConvergenceFlag* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("no_FLC_flag\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RAofIdleModeUEs                                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAofIdleModeUEs
   (const char* name, RAofIdleModeUEs* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAC (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

void asn1Print_NotEmptyRAListofIdleModeUEs_iE_Extensions_element
   (const char* name, NotEmptyRAListofIdleModeUEs_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < NotEmptyRAListofIdleModeUEs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &NotEmptyRAListofIdleModeUEs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == NotEmptyRAListofIdleModeUEs_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      NotEmptyRAListofIdleModeUEs_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions                 */
/*                                                            */
/**************************************************************/

void asn1Print_NotEmptyRAListofIdleModeUEs_iE_Extensions
   (const char* name, NotEmptyRAListofIdleModeUEs_iE_Extensions* pvalue)
{
   NotEmptyRAListofIdleModeUEs_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (NotEmptyRAListofIdleModeUEs_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs                               */
/*                                                            */
/**************************************************************/

void asn1Print_NotEmptyRAListofIdleModeUEs
   (const char* name, NotEmptyRAListofIdleModeUEs* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAofIdleModeUEs", name);
   asn1Print_RAofIdleModeUEs (namebuf, &pvalue->rAofIdleModeUEs);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_NotEmptyRAListofIdleModeUEs_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs          */
/*                                                            */
/**************************************************************/

void asn1Print_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs
   (const char* name, RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("emptylist\n"); break;
      case 1: printf ("fulllist\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RAListofIdleModeUEs                                       */
/*                                                            */
/**************************************************************/

void asn1Print_RAListofIdleModeUEs
   (const char* name, RAListofIdleModeUEs* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.notEmptyRAListofIdleModeUEs", name);
         asn1Print_NotEmptyRAListofIdleModeUEs (namebuf, pvalue->u.notEmptyRAListofIdleModeUEs);
         break;

      case 2:
         sprintf (namebuf, "%s.u.emptyFullRAListofIdleModeUEs", name);
         asn1Print_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (namebuf, &pvalue->u.emptyFullRAListofIdleModeUEs);
         break;

      case 3:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionRepetitionNumber                               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionRepetitionNumber
   (const char* name, MBMSSessionRepetitionNumber* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  TimeToMBMSDataTransfer                                    */
/*                                                            */
/**************************************************************/

void asn1Print_TimeToMBMSDataTransfer
   (const char* name, TimeToMBMSDataTransfer* pvalue)
{
   rtPrintOctStr (name, pvalue->numocts, pvalue->data, ".");
}

/**************************************************************/
/*                                                            */
/*  SessionUpdateID                                           */
/*                                                            */
/**************************************************************/

void asn1Print_SessionUpdateID
   (const char* name, SessionUpdateID* pvalue)
{
   rtPrintUnsigned (name, *pvalue);
}

/**************************************************************/
/*                                                            */
/*  NewRAListofIdleModeUEs                                    */
/*                                                            */
/**************************************************************/

void asn1Print_NewRAListofIdleModeUEs
   (const char* name, NewRAListofIdleModeUEs* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAC (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAListwithNoIdleModeUEsAnyMore                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAListwithNoIdleModeUEsAnyMore
   (const char* name, RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   char namebuf[512];

   printf ("%s.n = %d\n", name, pvalue->n);
   {
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAC (namebuf, &pvalue->elem[xx1]);
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

void asn1Print_DeltaRAListofIdleModeUEs_iE_Extensions_element
   (const char* name, DeltaRAListofIdleModeUEs_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DeltaRAListofIdleModeUEs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DeltaRAListofIdleModeUEs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DeltaRAListofIdleModeUEs_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      DeltaRAListofIdleModeUEs_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions                    */
/*                                                            */
/**************************************************************/

void asn1Print_DeltaRAListofIdleModeUEs_iE_Extensions
   (const char* name, DeltaRAListofIdleModeUEs_iE_Extensions* pvalue)
{
   DeltaRAListofIdleModeUEs_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DeltaRAListofIdleModeUEs_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DeltaRAListofIdleModeUEs_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs                                  */
/*                                                            */
/**************************************************************/

void asn1Print_DeltaRAListofIdleModeUEs
   (const char* name, DeltaRAListofIdleModeUEs* pvalue)
{
   char namebuf[512];

   printf ("%s.m.newRAListofIdleModeUEsPresent = %d\n", name, (int)pvalue->m.newRAListofIdleModeUEsPresent);
   printf ("%s.m.rAListwithNoIdleModeUEsAnyMorePresent = %d\n", name, (int)pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.newRAListofIdleModeUEsPresent) {
      sprintf (namebuf, "%s.newRAListofIdleModeUEs", name);
      asn1Print_NewRAListofIdleModeUEs (namebuf, &pvalue->newRAListofIdleModeUEs);
   }

   if (pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent) {
      sprintf (namebuf, "%s.rAListwithNoIdleModeUEsAnyMore", name);
      asn1Print_RAListwithNoIdleModeUEsAnyMore (namebuf, &pvalue->rAListwithNoIdleModeUEsAnyMore);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_DeltaRAListofIdleModeUEs_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_Registration                                     */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_Registration
   (const char* name, MBMSCNDe_Registration* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("normalsessionstop\n"); break;
      case 1: printf ("deregister\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequestType                               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationRequestType
   (const char* name, MBMSRegistrationRequestType* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("register_\n"); break;
      case 1: printf ("deregister_1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

/**************************************************************/
/*                                                            */
/*  RateControlAllowed                                        */
/*                                                            */
/**************************************************************/

void asn1Print_RateControlAllowed
   (const char* name, RateControlAllowed* pvalue)
{
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("not_allowed\n"); break;
      case 1: printf ("allowed\n"); break;
      default: printf ("???\n");
   }
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCommandIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCommandIEs_Value *pvalue = (_Iu_ReleaseCommandIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseCommand_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseCommand_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCommandIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, Iu_ReleaseCommandIEs[index].ValueSize);
   stat = Iu_ReleaseCommandIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseCommand_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseCommand_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseCommand_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Iu_ReleaseCommandExtensions[index].ExtensionSize);
   stat = Iu_ReleaseCommandExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseCommand_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseCommand_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseCommand_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand (ASN1CTXT* pctxt, Iu_ReleaseCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Iu_ReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Iu_ReleaseCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeList_element_iE_Extensions_element (ASN1CTXT* pctxt, DataVolumeList_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeList_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeList_element_iE_Extensions_element (ASN1CTXT* pctxt,
   DataVolumeList_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeList_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeList_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeList_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DataVolumeList_ExtIEs[index].ExtensionSize);
   stat = DataVolumeList_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeList_element_iE_Extensions (ASN1CTXT* pctxt, DataVolumeList_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeList_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeList_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeList_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeList_element (ASN1CTXT* pctxt, DataVolumeList_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataVolumeReferencePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode dl_UnsuccessfullyTransmittedDataVolume */

   stat = asn1PD_UnsuccessfullyTransmittedDataVolume (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dataVolumeReference */

   if (pvalue->m.dataVolumeReferencePresent) {
      stat = asn1PD_DataVolumeReference (pctxt, &pvalue->dataVolumeReference);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_DataVolumeList_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeList (ASN1CTXT* pctxt, DataVolumeList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   DataVolumeList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataVolumeReportItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataVolumeReportItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataVolumeReportItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_DataVolumeReportItem_ExtIEs[index].ExtensionSize);
   stat = RAB_DataVolumeReportItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataVolumeReportItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataVolumeReportItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportItem (ASN1CTXT* pctxt, RAB_DataVolumeReportItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dl_UnsuccessfullyTransmittedDataVolume */

   if (pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent) {
      stat = asn1PD_DataVolumeList (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_DataVolumeReportItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataVolumeReportItemIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataVolumeReportItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataVolumeReportItemIEs_Value *pvalue = (_RAB_DataVolumeReportItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportList_element_element (ASN1CTXT* pctxt, RAB_DataVolumeReportList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataVolumeReportList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataVolumeReportList_element_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_DataVolumeReportItemIEs[index].ValueSize);
   stat = RAB_DataVolumeReportItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportList_element (ASN1CTXT* pctxt, RAB_DataVolumeReportList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataVolumeReportList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportList (ASN1CTXT* pctxt, RAB_DataVolumeReportList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_DataVolumeReportList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseCompleteIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value *pvalue = (_Iu_ReleaseCompleteIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleasedItem_IuRelComp_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_IuRelComp_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_IuRelComp_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_IuRelComp_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ReleasedItem_IuRelComp_ExtIEs[index].ExtensionSize);
   stat = RAB_ReleasedItem_IuRelComp_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_IuRelComp_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleasedItem_IuRelComp_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedItem_IuRelComp_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_IuRelComp (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dL_GTP_PDU_SequenceNumber */

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uL_GTP_PDU_SequenceNumber */

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ReleasedItem_IuRelComp_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleasedItem_IuRelComp_IEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ReleasedItem_IuRelComp_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleasedItem_IuRelComp_IEs_Value *pvalue = (_RAB_ReleasedItem_IuRelComp_IEs_Value*) pvalue_;

   stat = asn1PD_RAB_ReleasedItem_IuRelComp (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_IuRelComp_element_element (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleasedList_IuRelComp_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleasedList_IuRelComp_element_element (ASN1CTXT* pctxt,
   RAB_ReleasedList_IuRelComp_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_IuRelComp_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_IuRelComp_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_IuRelComp_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ReleasedItem_IuRelComp_IEs[index].ValueSize);
   stat = RAB_ReleasedItem_IuRelComp_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_IuRelComp_element (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleasedList_IuRelComp_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedList_IuRelComp_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedList_IuRelComp_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_IuRelComp (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ReleasedList_IuRelComp_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedList_IuRelComp_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedList_IuRelComp_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseCompleteIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value_1 *pvalue = (_Iu_ReleaseCompleteIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ReleasedList_IuRelComp (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value_2                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseCompleteIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value_2 *pvalue = (_Iu_ReleaseCompleteIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseComplete_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseComplete_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCompleteIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, Iu_ReleaseCompleteIEs[index].ValueSize);
   stat = Iu_ReleaseCompleteIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseComplete_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseComplete_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseComplete_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseComplete_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Iu_ReleaseCompleteExtensions[index].ExtensionSize);
   stat = Iu_ReleaseCompleteExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseComplete_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseComplete_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseComplete_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete (ASN1CTXT* pctxt, Iu_ReleaseComplete* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Iu_ReleaseComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Iu_ReleaseComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value *pvalue = (_RelocationRequiredIEs_Value*) pvalue_;

   stat = asn1PD_RelocationType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_1 *pvalue = (_RelocationRequiredIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_2                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_2 *pvalue = (_RelocationRequiredIEs_Value_2*) pvalue_;

   stat = asn1PD_SourceID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_3                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_3 *pvalue = (_RelocationRequiredIEs_Value_3*) pvalue_;

   stat = asn1PD_TargetID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_4                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_4 *pvalue = (_RelocationRequiredIEs_Value_4*) pvalue_;

   stat = asn1PD_ClassmarkInformation2 (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_5                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_5 *pvalue = (_RelocationRequiredIEs_Value_5*) pvalue_;

   stat = asn1PD_ClassmarkInformation3 (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_6                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_6 *pvalue = (_RelocationRequiredIEs_Value_6*) pvalue_;

   stat = asn1PD_SourceRNC_ToTargetRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_7                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_7 *pvalue = (_RelocationRequiredIEs_Value_7*) pvalue_;

   stat = asn1PD_OldBSS_ToNewBSS_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequired_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequired_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequired_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequired_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequiredIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequiredIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequiredIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationRequiredIEs[index].ValueSize);
   stat = RelocationRequiredIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired_protocolIEs (ASN1CTXT* pctxt, RelocationRequired_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequired_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequired_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequired_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredExtensions_Extension                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredExtensions_Extension *pvalue = (_RelocationRequiredExtensions_Extension*) pvalue_;

   stat = asn1PD_GERAN_Classmark (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredExtensions_Extension_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredExtensions_Extension_1 *pvalue = (_RelocationRequiredExtensions_Extension_1*) pvalue_;

   stat = asn1PD_SourceBSS_ToTargetBSS_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequired_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequired_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequired_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequired_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequiredExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequiredExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequiredExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationRequiredExtensions[index].ExtensionSize);
   stat = RelocationRequiredExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired_protocolExtensions (ASN1CTXT* pctxt, RelocationRequired_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequired_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequired_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequired_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired (ASN1CTXT* pctxt, RelocationRequired* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationRequired_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value *pvalue = (_RelocationCommandIEs_Value*) pvalue_;

   stat = asn1PD_TargetRNC_ToSourceRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_1 *pvalue = (_RelocationCommandIEs_Value_1*) pvalue_;

   stat = asn1PD_L3_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_RelocationReleaseItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_RelocationReleaseItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_RelocationReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_RelocationReleaseItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_RelocationReleaseItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_RelocationReleaseItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_RelocationReleaseItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_RelocationReleaseItem_ExtIEs[index].ExtensionSize);
   stat = RAB_RelocationReleaseItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseItem_iE_Extensions (ASN1CTXT* pctxt, RAB_RelocationReleaseItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_RelocationReleaseItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_RelocationReleaseItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_RelocationReleaseItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseItem (ASN1CTXT* pctxt, RAB_RelocationReleaseItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_RelocationReleaseItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_RelocationReleaseItemIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_RelocationReleaseItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_RelocationReleaseItemIEs_Value *pvalue = (_RAB_RelocationReleaseItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_RelocationReleaseItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseList_element_element (ASN1CTXT* pctxt, RAB_RelocationReleaseList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_RelocationReleaseList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_RelocationReleaseList_element_element (ASN1CTXT* pctxt,
   RAB_RelocationReleaseList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_RelocationReleaseItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_RelocationReleaseItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_RelocationReleaseItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_RelocationReleaseItemIEs[index].ValueSize);
   stat = RAB_RelocationReleaseItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseList_element (ASN1CTXT* pctxt, RAB_RelocationReleaseList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_RelocationReleaseList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_RelocationReleaseList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_RelocationReleaseList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseList (ASN1CTXT* pctxt, RAB_RelocationReleaseList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_RelocationReleaseList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_RelocationReleaseList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_RelocationReleaseList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_2 *pvalue = (_RelocationCommandIEs_Value_2*) pvalue_;

   stat = asn1PD_RAB_RelocationReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_ExtIEs_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataForwardingItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_ExtIEs_Extension *pvalue = (_RAB_DataForwardingItem_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_TransportLayerAddress (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_ExtIEs_Extension_1                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataForwardingItem_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_ExtIEs_Extension_1 *pvalue = (_RAB_DataForwardingItem_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_IuTransportAssociation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataForwardingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataForwardingItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataForwardingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataForwardingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_DataForwardingItem_ExtIEs[index].ExtensionSize);
   stat = RAB_DataForwardingItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataForwardingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataForwardingItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem (ASN1CTXT* pctxt, RAB_DataForwardingItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transportLayerAddress */

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iuTransportAssociation */

   stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_DataForwardingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItemIEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataForwardingItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItemIEs_Value *pvalue = (_RAB_DataForwardingItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataForwardingItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_element_element (ASN1CTXT* pctxt, RAB_DataForwardingList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataForwardingList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataForwardingList_element_element (ASN1CTXT* pctxt,
   RAB_DataForwardingList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_DataForwardingItemIEs[index].ValueSize);
   stat = RAB_DataForwardingItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_element (ASN1CTXT* pctxt, RAB_DataForwardingList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataForwardingList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList (ASN1CTXT* pctxt, RAB_DataForwardingList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_DataForwardingList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_3 *pvalue = (_RelocationCommandIEs_Value_3*) pvalue_;

   stat = asn1PD_RAB_DataForwardingList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_4 *pvalue = (_RelocationCommandIEs_Value_4*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand_protocolIEs_element (ASN1CTXT* pctxt, RelocationCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCommand_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCommand_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCommandIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationCommandIEs[index].ValueSize);
   stat = RelocationCommandIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand_protocolIEs (ASN1CTXT* pctxt, RelocationCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCommand_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCommand_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandExtensions_Extension *pvalue = (_RelocationCommandExtensions_Extension*) pvalue_;

   stat = asn1PD_InterSystemInformation_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandExtensions_Extension_1 *pvalue = (_RelocationCommandExtensions_Extension_1*) pvalue_;

   stat = asn1PD_TargetBSS_ToSourceBSS_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCommand_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationCommandExtensions[index].ExtensionSize);
   stat = RelocationCommandExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand_protocolExtensions (ASN1CTXT* pctxt, RelocationCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCommand_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCommand_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCommand_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand (ASN1CTXT* pctxt, RelocationCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationPreparationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureIEs_Value *pvalue = (_RelocationPreparationFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationPreparationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureIEs_Value_1 *pvalue = (_RelocationPreparationFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure_protocolIEs_element (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationPreparationFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationPreparationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationPreparationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationPreparationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationPreparationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationPreparationFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationPreparationFailureIEs[index].ValueSize);
   stat = RelocationPreparationFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure_protocolIEs (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationPreparationFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationPreparationFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationPreparationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureExtensions_Extension         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationPreparationFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureExtensions_Extension *pvalue = (_RelocationPreparationFailureExtensions_Extension*) pvalue_;

   stat = asn1PD_InterSystemInformation_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure_protocolExtensions_element (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationPreparationFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationPreparationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationPreparationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationPreparationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationPreparationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationPreparationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationPreparationFailureExtensions[index].ExtensionSize);
   stat = RelocationPreparationFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure_protocolExtensions (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationPreparationFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationPreparationFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationPreparationFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure (ASN1CTXT* pctxt, RelocationPreparationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationPreparationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationPreparationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value *pvalue = (_RelocationRequestIEs_Value*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_1 *pvalue = (_RelocationRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_2 *pvalue = (_RelocationRequestIEs_Value_2*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_3 *pvalue = (_RelocationRequestIEs_Value_3*) pvalue_;

   stat = asn1PD_SourceRNC_ToTargetRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UserPlaneInformation_iE_Extensions_element (ASN1CTXT* pctxt, UserPlaneInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UserPlaneInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UserPlaneInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   UserPlaneInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UserPlaneInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UserPlaneInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UserPlaneInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UserPlaneInformation_ExtIEs[index].ExtensionSize);
   stat = UserPlaneInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UserPlaneInformation_iE_Extensions (ASN1CTXT* pctxt, UserPlaneInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UserPlaneInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UserPlaneInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UserPlaneInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UserPlaneInformation (ASN1CTXT* pctxt, UserPlaneInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode userPlaneMode */

   stat = asn1PD_UserPlaneMode (pctxt, &pvalue->userPlaneMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uP_ModeVersions */

   stat = asn1PD_UP_ModeVersions (pctxt, &pvalue->uP_ModeVersions);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_UserPlaneInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_ExtIEs_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReq_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_ExtIEs_Extension *pvalue = (_RAB_SetupItem_RelocReq_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_Alt_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_ExtIEs_Extension_1                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReq_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_ExtIEs_Extension_1 *pvalue = (_RAB_SetupItem_RelocReq_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_GERAN_BSC_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReq_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupItem_RelocReq_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupItem_RelocReq_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupItem_RelocReq_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReq_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReq_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReq_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupItem_RelocReq_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupItem_RelocReq_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReq_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupItem_RelocReq_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupItem_RelocReq_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupItem_RelocReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReq (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nAS_SynchronisationIndicatorPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataVolumeReportingIndicationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pDP_TypeInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.service_HandoverPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode nAS_SynchronisationIndicator */

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      stat = asn1PD_NAS_SynchronisationIndicator (pctxt, &pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAB_Parameters */

   stat = asn1PD_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      stat = asn1PD_DataVolumeReportingIndication (pctxt, &pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      stat = asn1PD_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode userPlaneInformation */

   stat = asn1PD_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transportLayerAddress */

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iuTransportAssociation */

   stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      stat = asn1PD_Service_Handover (pctxt, &pvalue->service_Handover);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupItem_RelocReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_IEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReq_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_IEs_Value *pvalue = (_RAB_SetupItem_RelocReq_IEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupItem_RelocReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReq_element_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReq_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupList_RelocReq_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupList_RelocReq_element_element (ASN1CTXT* pctxt,
   RAB_SetupList_RelocReq_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReq_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReq_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReq_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_SetupItem_RelocReq_IEs[index].ValueSize);
   stat = RAB_SetupItem_RelocReq_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReq_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReq_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupList_RelocReq_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupList_RelocReq_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupList_RelocReq_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReq (ASN1CTXT* pctxt, RAB_SetupList_RelocReq* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_SetupList_RelocReq_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupList_RelocReq_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupList_RelocReq_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_4 *pvalue = (_RelocationRequestIEs_Value_4*) pvalue_;

   stat = asn1PD_RAB_SetupList_RelocReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_5                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_5 *pvalue = (_RelocationRequestIEs_Value_5*) pvalue_;

   stat = asn1PD_IntegrityProtectionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_6                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_6 *pvalue = (_RelocationRequestIEs_Value_6*) pvalue_;

   stat = asn1PD_EncryptionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_7                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_7 *pvalue = (_RelocationRequestIEs_Value_7*) pvalue_;

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationRequestIEs[index].ValueSize);
   stat = RelocationRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest_protocolIEs (ASN1CTXT* pctxt, RelocationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension *pvalue = (_RelocationRequestExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_1 *pvalue = (_RelocationRequestExtensions_Extension_1*) pvalue_;

   stat = asn1PD_SNA_Access_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_2 *pvalue = (_RelocationRequestExtensions_Extension_2*) pvalue_;

   stat = asn1PD_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_3 *pvalue = (_RelocationRequestExtensions_Extension_3*) pvalue_;

   stat = asn1PD_PLMNidentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   JoinedMBMSBearerService_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < JoinedMBMSBearerService_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &JoinedMBMSBearerService_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == JoinedMBMSBearerService_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, JoinedMBMSBearerService_ExtIEs[index].ExtensionSize);
   stat = JoinedMBMSBearerService_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_JoinedMBMSBearerService_IEs_element_iE_Extensions (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   JoinedMBMSBearerService_IEs_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, JoinedMBMSBearerService_IEs_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_JoinedMBMSBearerService_IEs_element (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode tMGI */

   stat = asn1PD_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode mBMS_PTP_RAB_ID */

   stat = asn1PD_MBMS_PTP_RAB_ID (pctxt, &pvalue->mBMS_PTP_RAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_JoinedMBMSBearerService_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_JoinedMBMSBearerService_IEs (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   JoinedMBMSBearerService_IEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, JoinedMBMSBearerService_IEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_JoinedMBMSBearerService_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CNMBMSLinkingInformation_iE_Extensions_element (ASN1CTXT* pctxt, CNMBMSLinkingInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CNMBMSLinkingInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CNMBMSLinkingInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   CNMBMSLinkingInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CNMBMSLinkingInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CNMBMSLinkingInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CNMBMSLinkingInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CNMBMSLinkingInformation_ExtIEs[index].ExtensionSize);
   stat = CNMBMSLinkingInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CNMBMSLinkingInformation_iE_Extensions (ASN1CTXT* pctxt, CNMBMSLinkingInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CNMBMSLinkingInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CNMBMSLinkingInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CNMBMSLinkingInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CNMBMSLinkingInformation (ASN1CTXT* pctxt, CNMBMSLinkingInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode joinedMBMSBearerService_IEs */

   stat = asn1PD_JoinedMBMSBearerService_IEs (pctxt, &pvalue->joinedMBMSBearerService_IEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CNMBMSLinkingInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_4                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_4 *pvalue = (_RelocationRequestExtensions_Extension_4*) pvalue_;

   stat = asn1PD_CNMBMSLinkingInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationRequestExtensions[index].ExtensionSize);
   stat = RelocationRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest_protocolExtensions (ASN1CTXT* pctxt, RelocationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest (ASN1CTXT* pctxt, RelocationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value *pvalue = (_RelocationRequestAcknowledgeIEs_Value*) pvalue_;

   stat = asn1PD_TargetRNC_ToSourceRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_Ass_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1 *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_TransportLayerAddress (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2 *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2*) pvalue_;

   stat = asn1PD_IuTransportAssociation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReqAck_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupItem_RelocReqAck_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupItem_RelocReqAck_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupItem_RelocReqAck_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReqAck_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReqAck_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReqAck_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupItem_RelocReqAck_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupItem_RelocReqAck_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReqAck_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupItem_RelocReqAck_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupItem_RelocReqAck_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupItem_RelocReqAck_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReqAck (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iuTransportAssociationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iuTransportAssociation */

   if (pvalue->m.iuTransportAssociationPresent) {
      stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupItem_RelocReqAck_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_IEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReqAck_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_IEs_Value *pvalue = (_RAB_SetupItem_RelocReqAck_IEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupItem_RelocReqAck (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReqAck_element_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupList_RelocReqAck_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupList_RelocReqAck_element_element (ASN1CTXT* pctxt,
   RAB_SetupList_RelocReqAck_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReqAck_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReqAck_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReqAck_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_SetupItem_RelocReqAck_IEs[index].ValueSize);
   stat = RAB_SetupItem_RelocReqAck_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReqAck_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupList_RelocReqAck_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupList_RelocReqAck_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupList_RelocReqAck_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReqAck (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_SetupList_RelocReqAck_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupList_RelocReqAck_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupList_RelocReqAck_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_1 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_SetupList_RelocReqAck (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_FailedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_FailedItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_FailedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_FailedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_FailedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_FailedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_FailedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_FailedItem_ExtIEs[index].ExtensionSize);
   stat = RAB_FailedItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_FailedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_FailedItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedItem (ASN1CTXT* pctxt, RAB_FailedItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_FailedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_FailedItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_FailedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_FailedItemIEs_Value *pvalue = (_RAB_FailedItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_FailedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedList_element_element (ASN1CTXT* pctxt, RAB_FailedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_FailedList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_FailedList_element_element (ASN1CTXT* pctxt,
   RAB_FailedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_FailedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_FailedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_FailedItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_FailedItemIEs[index].ValueSize);
   stat = RAB_FailedItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedList_element (ASN1CTXT* pctxt, RAB_FailedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_FailedList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedList (ASN1CTXT* pctxt, RAB_FailedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_FailedList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_2 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_2*) pvalue_;

   stat = asn1PD_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_3 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_3*) pvalue_;

   stat = asn1PD_ChosenIntegrityProtectionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_4                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_4 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_4*) pvalue_;

   stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_5                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_5 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_5*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequestAcknowledge_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequestAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequestAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationRequestAcknowledgeIEs[index].ValueSize);
   stat = RelocationRequestAcknowledgeIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge_protocolIEs (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequestAcknowledge_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequestAcknowledge_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequestAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeExtensions_Extension         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeExtensions_Extension *pvalue = (_RelocationRequestAcknowledgeExtensions_Extension*) pvalue_;

   stat = asn1PD_NewBSS_To_OldBSS_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequestAcknowledge_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequestAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequestAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationRequestAcknowledgeExtensions[index].ExtensionSize);
   stat = RelocationRequestAcknowledgeExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge_protocolExtensions (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequestAcknowledge_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequestAcknowledge_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequestAcknowledge_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge (ASN1CTXT* pctxt, RelocationRequestAcknowledge* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationRequestAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureIEs_Value *pvalue = (_RelocationFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureIEs_Value_1 *pvalue = (_RelocationFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure_protocolIEs_element (ASN1CTXT* pctxt, RelocationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationFailureIEs[index].ValueSize);
   stat = RelocationFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure_protocolIEs (ASN1CTXT* pctxt, RelocationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureExtensions_Extension *pvalue = (_RelocationFailureExtensions_Extension*) pvalue_;

   stat = asn1PD_NewBSS_To_OldBSS_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationFailureExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureExtensions_Extension_1 *pvalue = (_RelocationFailureExtensions_Extension_1*) pvalue_;

   stat = asn1PD_GERAN_Classmark (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure_protocolExtensions_element (ASN1CTXT* pctxt, RelocationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationFailureExtensions[index].ExtensionSize);
   stat = RelocationFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure_protocolExtensions (ASN1CTXT* pctxt, RelocationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure (ASN1CTXT* pctxt, RelocationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCancelIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCancelIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCancelIEs_Value *pvalue = (_RelocationCancelIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel_protocolIEs_element (ASN1CTXT* pctxt, RelocationCancel_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCancel_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCancel_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCancel_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationCancelIEs[index].ValueSize);
   stat = RelocationCancelIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel_protocolIEs (ASN1CTXT* pctxt, RelocationCancel_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCancel_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCancel_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCancel_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCancel_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCancel_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCancel_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCancel_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationCancelExtensions[index].ExtensionSize);
   stat = RelocationCancelExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel_protocolExtensions (ASN1CTXT* pctxt, RelocationCancel_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCancel_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCancel_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCancel_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel (ASN1CTXT* pctxt, RelocationCancel* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationCancel_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationCancel_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCancelAcknowledgeIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCancelAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCancelAcknowledgeIEs_Value *pvalue = (_RelocationCancelAcknowledgeIEs_Value*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCancelAcknowledge_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCancelAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCancelAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationCancelAcknowledgeIEs[index].ValueSize);
   stat = RelocationCancelAcknowledgeIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge_protocolIEs (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCancelAcknowledge_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCancelAcknowledge_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCancelAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCancelAcknowledge_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCancelAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCancelAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationCancelAcknowledgeExtensions[index].ExtensionSize);
   stat = RelocationCancelAcknowledgeExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge_protocolExtensions (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCancelAcknowledge_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCancelAcknowledge_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCancelAcknowledge_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge (ASN1CTXT* pctxt, RelocationCancelAcknowledge* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationCancelAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationCancelAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].ExtensionSize);
   stat = RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_SRNS_CtxReq (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value *pvalue = (_RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataForwardingItem_SRNS_CtxReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_SRNS_CtxReq_element_element (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataForwardingList_SRNS_CtxReq_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataForwardingList_SRNS_CtxReq_element_element (ASN1CTXT* pctxt,
   RAB_DataForwardingList_SRNS_CtxReq_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].ValueSize);
   stat = RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_SRNS_CtxReq_element (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataForwardingList_SRNS_CtxReq_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingList_SRNS_CtxReq_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingList_SRNS_CtxReq_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_SRNS_CtxReq (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_DataForwardingList_SRNS_CtxReq_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingList_SRNS_CtxReq_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingList_SRNS_CtxReq_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextRequestIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_ContextRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextRequestIEs_Value *pvalue = (_SRNS_ContextRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataForwardingList_SRNS_CtxReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest_protocolIEs_element (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_ContextRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_ContextRequest_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_ContextRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SRNS_ContextRequestIEs[index].ValueSize);
   stat = SRNS_ContextRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest_protocolIEs (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_ContextRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_ContextRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_ContextRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_ContextRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_ContextRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_ContextRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SRNS_ContextRequestExtensions[index].ExtensionSize);
   stat = SRNS_ContextRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest_protocolExtensions (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_ContextRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_ContextRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_ContextRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest (ASN1CTXT* pctxt, SRNS_ContextRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SRNS_ContextRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SRNS_ContextRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ContextItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ContextItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ContextItem_ExtIEs[index].ExtensionSize);
   stat = RAB_ContextItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ContextItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem (ASN1CTXT* pctxt, RAB_ContextItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ContextItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ContextItemIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ContextItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ContextItemIEs_Value *pvalue = (_RAB_ContextItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ContextItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_element_element (ASN1CTXT* pctxt, RAB_ContextList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextList_element_element (ASN1CTXT* pctxt,
   RAB_ContextList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ContextItemIEs[index].ValueSize);
   stat = RAB_ContextItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_element (ASN1CTXT* pctxt, RAB_ContextList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList (ASN1CTXT* pctxt, RAB_ContextList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ContextList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_ContextResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value *pvalue = (_SRNS_ContextResponseIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ContextList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_ContextFailedtoTransferItem_iE_Extensions_element (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RABs_ContextFailedtoTransferItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RABs_ContextFailedtoTransferItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RABs_ContextFailedtoTransferItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_ContextFailedtoTransferItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_ContextFailedtoTransferItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_ContextFailedtoTransferItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RABs_ContextFailedtoTransferItem_ExtIEs[index].ExtensionSize);
   stat = RABs_ContextFailedtoTransferItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_ContextFailedtoTransferItem_iE_Extensions (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RABs_ContextFailedtoTransferItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RABs_ContextFailedtoTransferItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RABs_ContextFailedtoTransferItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_ContextFailedtoTransferItem (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RABs_ContextFailedtoTransferItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RABs_ContextFailedtoTransferItemIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RABs_ContextFailedtoTransferItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RABs_ContextFailedtoTransferItemIEs_Value *pvalue = (_RABs_ContextFailedtoTransferItemIEs_Value*) pvalue_;

   stat = asn1PD_RABs_ContextFailedtoTransferItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextFailedtoTransferList_element_element (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextFailedtoTransferList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextFailedtoTransferList_element_element (ASN1CTXT* pctxt,
   RAB_ContextFailedtoTransferList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_ContextFailedtoTransferItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_ContextFailedtoTransferItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_ContextFailedtoTransferItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RABs_ContextFailedtoTransferItemIEs[index].ValueSize);
   stat = RABs_ContextFailedtoTransferItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextFailedtoTransferList_element (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextFailedtoTransferList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextFailedtoTransferList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextFailedtoTransferList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextFailedtoTransferList (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ContextFailedtoTransferList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextFailedtoTransferList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextFailedtoTransferList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_ContextResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value_1 *pvalue = (_SRNS_ContextResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ContextFailedtoTransferList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value_2                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_ContextResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value_2 *pvalue = (_SRNS_ContextResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse_protocolIEs_element (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_ContextResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_ContextResponse_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_ContextResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SRNS_ContextResponseIEs[index].ValueSize);
   stat = SRNS_ContextResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse_protocolIEs (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_ContextResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_ContextResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_ContextResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_ContextResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_ContextResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_ContextResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SRNS_ContextResponseExtensions[index].ExtensionSize);
   stat = SRNS_ContextResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse_protocolExtensions (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_ContextResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_ContextResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_ContextResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse (ASN1CTXT* pctxt, SRNS_ContextResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SRNS_ContextResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SRNS_ContextResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value *pvalue = (_SecurityModeCommandIEs_Value*) pvalue_;

   stat = asn1PD_IntegrityProtectionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCommandIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value_1 *pvalue = (_SecurityModeCommandIEs_Value_1*) pvalue_;

   stat = asn1PD_EncryptionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value_2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCommandIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value_2 *pvalue = (_SecurityModeCommandIEs_Value_2*) pvalue_;

   stat = asn1PD_KeyStatus (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeCommand_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeCommand_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCommandIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SecurityModeCommandIEs[index].ValueSize);
   stat = SecurityModeCommandIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand_protocolIEs (ASN1CTXT* pctxt, SecurityModeCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeCommand_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeCommand_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeCommand_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SecurityModeCommandExtensions[index].ExtensionSize);
   stat = SecurityModeCommandExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand_protocolExtensions (ASN1CTXT* pctxt, SecurityModeCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeCommand_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeCommand_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeCommand_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand (ASN1CTXT* pctxt, SecurityModeCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SecurityModeCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SecurityModeCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCompleteIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value *pvalue = (_SecurityModeCompleteIEs_Value*) pvalue_;

   stat = asn1PD_ChosenIntegrityProtectionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCompleteIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value_1 *pvalue = (_SecurityModeCompleteIEs_Value_1*) pvalue_;

   stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value_2                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCompleteIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value_2 *pvalue = (_SecurityModeCompleteIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeComplete_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeComplete_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCompleteIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SecurityModeCompleteIEs[index].ValueSize);
   stat = SecurityModeCompleteIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete_protocolIEs (ASN1CTXT* pctxt, SecurityModeComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeComplete_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeComplete_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeComplete_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeComplete_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SecurityModeCompleteExtensions[index].ExtensionSize);
   stat = SecurityModeCompleteExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete_protocolExtensions (ASN1CTXT* pctxt, SecurityModeComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeComplete_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeComplete_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeComplete_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete (ASN1CTXT* pctxt, SecurityModeComplete* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SecurityModeComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SecurityModeComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeRejectIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeRejectIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeRejectIEs_Value *pvalue = (_SecurityModeRejectIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeRejectIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeRejectIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeRejectIEs_Value_1 *pvalue = (_SecurityModeRejectIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeReject_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeReject_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeReject_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeReject_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeRejectIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeRejectIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeRejectIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SecurityModeRejectIEs[index].ValueSize);
   stat = SecurityModeRejectIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject_protocolIEs (ASN1CTXT* pctxt, SecurityModeReject_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeReject_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeReject_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeReject_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeReject_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeReject_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeReject_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeReject_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeRejectExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeRejectExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeRejectExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SecurityModeRejectExtensions[index].ExtensionSize);
   stat = SecurityModeRejectExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject_protocolExtensions (ASN1CTXT* pctxt, SecurityModeReject_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeReject_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeReject_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeReject_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject (ASN1CTXT* pctxt, SecurityModeReject* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SecurityModeReject_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SecurityModeReject_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataVolumeReportRequestItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataVolumeReportRequestItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportRequestItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportRequestItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportRequestItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportRequestItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_DataVolumeReportRequestItem_ExtIEs[index].ExtensionSize);
   stat = RAB_DataVolumeReportRequestItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataVolumeReportRequestItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportRequestItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportRequestItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestItem (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_DataVolumeReportRequestItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataVolumeReportRequestItemIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataVolumeReportRequestItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataVolumeReportRequestItemIEs_Value *pvalue = (_RAB_DataVolumeReportRequestItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportRequestItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestList_element_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataVolumeReportRequestList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataVolumeReportRequestList_element_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportRequestList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportRequestItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportRequestItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportRequestItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_DataVolumeReportRequestItemIEs[index].ValueSize);
   stat = RAB_DataVolumeReportRequestItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestList_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataVolumeReportRequestList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportRequestList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportRequestList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestList (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_DataVolumeReportRequestList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportRequestList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportRequestList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportRequestIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DataVolumeReportRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportRequestIEs_Value *pvalue = (_DataVolumeReportRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportRequestList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest_protocolIEs_element (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeReportRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeReportRequest_protocolIEs_element (ASN1CTXT* pctxt,
   DataVolumeReportRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DataVolumeReportRequestIEs[index].ValueSize);
   stat = DataVolumeReportRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest_protocolIEs (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeReportRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeReportRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeReportRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest_protocolExtensions_element (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeReportRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeReportRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   DataVolumeReportRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DataVolumeReportRequestExtensions[index].ExtensionSize);
   stat = DataVolumeReportRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest_protocolExtensions (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeReportRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeReportRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeReportRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest (ASN1CTXT* pctxt, DataVolumeReportRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_DataVolumeReportRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_DataVolumeReportRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DataVolumeReportIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value *pvalue = (_DataVolumeReportIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_failed_to_reportItem_iE_Extensions_element (ASN1CTXT* pctxt, RABs_failed_to_reportItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RABs_failed_to_reportItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RABs_failed_to_reportItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RABs_failed_to_reportItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_failed_to_reportItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_failed_to_reportItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_failed_to_reportItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RABs_failed_to_reportItem_ExtIEs[index].ExtensionSize);
   stat = RABs_failed_to_reportItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_failed_to_reportItem_iE_Extensions (ASN1CTXT* pctxt, RABs_failed_to_reportItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RABs_failed_to_reportItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RABs_failed_to_reportItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RABs_failed_to_reportItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_failed_to_reportItem (ASN1CTXT* pctxt, RABs_failed_to_reportItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RABs_failed_to_reportItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RABs_failed_to_reportItemIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RABs_failed_to_reportItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RABs_failed_to_reportItemIEs_Value *pvalue = (_RABs_failed_to_reportItemIEs_Value*) pvalue_;

   stat = asn1PD_RABs_failed_to_reportItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedtoReportList_element_element (ASN1CTXT* pctxt, RAB_FailedtoReportList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_FailedtoReportList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_FailedtoReportList_element_element (ASN1CTXT* pctxt,
   RAB_FailedtoReportList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_failed_to_reportItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_failed_to_reportItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_failed_to_reportItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RABs_failed_to_reportItemIEs[index].ValueSize);
   stat = RABs_failed_to_reportItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedtoReportList_element (ASN1CTXT* pctxt, RAB_FailedtoReportList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_FailedtoReportList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedtoReportList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedtoReportList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedtoReportList (ASN1CTXT* pctxt, RAB_FailedtoReportList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_FailedtoReportList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedtoReportList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedtoReportList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DataVolumeReportIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value_1 *pvalue = (_DataVolumeReportIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_FailedtoReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DataVolumeReportIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value_2 *pvalue = (_DataVolumeReportIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport_protocolIEs_element (ASN1CTXT* pctxt, DataVolumeReport_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeReport_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeReport_protocolIEs_element (ASN1CTXT* pctxt,
   DataVolumeReport_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DataVolumeReportIEs[index].ValueSize);
   stat = DataVolumeReportIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport_protocolIEs (ASN1CTXT* pctxt, DataVolumeReport_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeReport_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeReport_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport_protocolExtensions_element (ASN1CTXT* pctxt, DataVolumeReport_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeReport_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeReport_protocolExtensions_element (ASN1CTXT* pctxt,
   DataVolumeReport_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DataVolumeReportExtensions[index].ExtensionSize);
   stat = DataVolumeReportExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport_protocolExtensions (ASN1CTXT* pctxt, DataVolumeReport_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeReport_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeReport_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeReport_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport (ASN1CTXT* pctxt, DataVolumeReport* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_DataVolumeReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_DataVolumeReport_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value *pvalue = (_ResetIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value_1 *pvalue = (_ResetIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value_2                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value_2 *pvalue = (_ResetIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset_protocolIEs_element (ASN1CTXT* pctxt, Reset_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Reset_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Reset_protocolIEs_element (ASN1CTXT* pctxt,
   Reset_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetIEs[index].ValueSize);
   stat = ResetIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset_protocolIEs (ASN1CTXT* pctxt, Reset_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Reset_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Reset_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Reset_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetExtensions_Extension                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetExtensions_Extension *pvalue = (_ResetExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset_protocolExtensions_element (ASN1CTXT* pctxt, Reset_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Reset_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Reset_protocolExtensions_element (ASN1CTXT* pctxt,
   Reset_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetExtensions[index].ExtensionSize);
   stat = ResetExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset_protocolExtensions (ASN1CTXT* pctxt, Reset_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Reset_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Reset_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Reset_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset (ASN1CTXT* pctxt, Reset* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Reset_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Reset_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value *pvalue = (_ResetAcknowledgeIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value_1 *pvalue = (_ResetAcknowledgeIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value_2 *pvalue = (_ResetAcknowledgeIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, ResetAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetAcknowledge_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   ResetAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetAcknowledgeIEs[index].ValueSize);
   stat = ResetAcknowledgeIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge_protocolIEs (ASN1CTXT* pctxt, ResetAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetAcknowledge_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetAcknowledge_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeExtensions_Extension                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeExtensions_Extension *pvalue = (_ResetAcknowledgeExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, ResetAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetAcknowledge_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetAcknowledgeExtensions[index].ExtensionSize);
   stat = ResetAcknowledgeExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge_protocolExtensions (ASN1CTXT* pctxt, ResetAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetAcknowledge_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetAcknowledge_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetAcknowledge_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge (ASN1CTXT* pctxt, ResetAcknowledge* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ResetAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ResetAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleaseItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleaseItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleaseItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ReleaseItem_ExtIEs[index].ExtensionSize);
   stat = RAB_ReleaseItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleaseItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleaseItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseItem (ASN1CTXT* pctxt, RAB_ReleaseItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ReleaseItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleaseItemIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ReleaseItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleaseItemIEs_Value *pvalue = (_RAB_ReleaseItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ReleaseItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseList_element_element (ASN1CTXT* pctxt, RAB_ReleaseList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleaseList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleaseList_element_element (ASN1CTXT* pctxt,
   RAB_ReleaseList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ReleaseItemIEs[index].ValueSize);
   stat = RAB_ReleaseItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseList_element (ASN1CTXT* pctxt, RAB_ReleaseList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleaseList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseList (ASN1CTXT* pctxt, RAB_ReleaseList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ReleaseList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleaseRequestIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleaseRequestIEs_Value *pvalue = (_RAB_ReleaseRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleaseRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_ReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ReleaseRequestIEs[index].ValueSize);
   stat = RAB_ReleaseRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest_protocolIEs (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleaseRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleaseRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_ReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ReleaseRequestExtensions[index].ExtensionSize);
   stat = RAB_ReleaseRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleaseRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest (ASN1CTXT* pctxt, RAB_ReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RAB_ReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RAB_ReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseRequestIEs_Value *pvalue = (_Iu_ReleaseRequestIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, Iu_ReleaseRequestIEs[index].ValueSize);
   stat = Iu_ReleaseRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Iu_ReleaseRequestExtensions[index].ExtensionSize);
   stat = Iu_ReleaseRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest (ASN1CTXT* pctxt, Iu_ReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Iu_ReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Iu_ReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect_protocolIEs_element (ASN1CTXT* pctxt, RelocationDetect_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationDetect_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationDetect_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationDetect_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationDetectIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationDetectIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationDetectIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationDetectIEs[index].ValueSize);
   stat = RelocationDetectIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect_protocolIEs (ASN1CTXT* pctxt, RelocationDetect_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationDetect_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationDetect_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationDetect_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect_protocolExtensions_element (ASN1CTXT* pctxt, RelocationDetect_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationDetect_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationDetect_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationDetect_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationDetectExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationDetectExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationDetectExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationDetectExtensions[index].ExtensionSize);
   stat = RelocationDetectExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect_protocolExtensions (ASN1CTXT* pctxt, RelocationDetect_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationDetect_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationDetect_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationDetect_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect (ASN1CTXT* pctxt, RelocationDetect* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationDetect_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationDetect_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete_protocolIEs_element (ASN1CTXT* pctxt, RelocationComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationComplete_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationComplete_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCompleteIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationCompleteIEs[index].ValueSize);
   stat = RelocationCompleteIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete_protocolIEs (ASN1CTXT* pctxt, RelocationComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationComplete_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationComplete_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationComplete_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete_protocolExtensions_element (ASN1CTXT* pctxt, RelocationComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationComplete_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationCompleteExtensions[index].ExtensionSize);
   stat = RelocationCompleteExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete_protocolExtensions (ASN1CTXT* pctxt, RelocationComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationComplete_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationComplete_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationComplete_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete (ASN1CTXT* pctxt, RelocationComplete* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value *pvalue = (_PagingIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_1                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_1 *pvalue = (_PagingIEs_Value_1*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_2                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_2 *pvalue = (_PagingIEs_Value_2*) pvalue_;

   stat = asn1PD_TemporaryUE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_3                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_3 *pvalue = (_PagingIEs_Value_3*) pvalue_;

   stat = asn1PD_PagingAreaID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_4                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_4 *pvalue = (_PagingIEs_Value_4*) pvalue_;

   stat = asn1PD_PagingCause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_5                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_5 *pvalue = (_PagingIEs_Value_5*) pvalue_;

   stat = asn1PD_NonSearchingIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_6                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_6 *pvalue = (_PagingIEs_Value_6*) pvalue_;

   stat = asn1PD_DRX_CycleLengthCoefficient (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging_protocolIEs_element (ASN1CTXT* pctxt, Paging_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Paging_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Paging_protocolIEs_element (ASN1CTXT* pctxt,
   Paging_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PagingIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PagingIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PagingIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, PagingIEs[index].ValueSize);
   stat = PagingIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging_protocolIEs (ASN1CTXT* pctxt, Paging_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Paging_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Paging_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Paging_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingExtensions_Extension                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingExtensions_Extension *pvalue = (_PagingExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging_protocolExtensions_element (ASN1CTXT* pctxt, Paging_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Paging_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Paging_protocolExtensions_element (ASN1CTXT* pctxt,
   Paging_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PagingExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PagingExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == PagingExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, PagingExtensions[index].ExtensionSize);
   stat = PagingExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging_protocolExtensions (ASN1CTXT* pctxt, Paging_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Paging_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Paging_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Paging_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging (ASN1CTXT* pctxt, Paging* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Paging_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Paging_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonID_IEs_Value                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CommonID_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonID_IEs_Value *pvalue = (_CommonID_IEs_Value*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID_protocolIEs_element (ASN1CTXT* pctxt, CommonID_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CommonID_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CommonID_protocolIEs_element (ASN1CTXT* pctxt,
   CommonID_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CommonID_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CommonID_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == CommonID_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, CommonID_IEs[index].ValueSize);
   stat = CommonID_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID_protocolIEs (ASN1CTXT* pctxt, CommonID_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   CommonID_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CommonID_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CommonID_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CommonIDExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension *pvalue = (_CommonIDExtensions_Extension*) pvalue_;

   stat = asn1PD_SNA_Access_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CommonIDExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension_1 *pvalue = (_CommonIDExtensions_Extension_1*) pvalue_;

   stat = asn1PD_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension_2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CommonIDExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension_2 *pvalue = (_CommonIDExtensions_Extension_2*) pvalue_;

   stat = asn1PD_PLMNidentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID_protocolExtensions_element (ASN1CTXT* pctxt, CommonID_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CommonID_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CommonID_protocolExtensions_element (ASN1CTXT* pctxt,
   CommonID_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CommonIDExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CommonIDExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CommonIDExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CommonIDExtensions[index].ExtensionSize);
   stat = CommonIDExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID_protocolExtensions (ASN1CTXT* pctxt, CommonID_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CommonID_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CommonID_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CommonID_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID (ASN1CTXT* pctxt, CommonID* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_CommonID_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_CommonID_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value *pvalue = (_CN_InvokeTraceIEs_Value*) pvalue_;

   stat = asn1PD_TraceType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_1 *pvalue = (_CN_InvokeTraceIEs_Value_1*) pvalue_;

   stat = asn1PD_TraceReference (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_2 *pvalue = (_CN_InvokeTraceIEs_Value_2*) pvalue_;

   stat = asn1PD_TriggerID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_3                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_3 *pvalue = (_CN_InvokeTraceIEs_Value_3*) pvalue_;

   stat = asn1PD_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_4                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_4 *pvalue = (_CN_InvokeTraceIEs_Value_4*) pvalue_;

   stat = asn1PD_OMC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace_protocolIEs_element (ASN1CTXT* pctxt, CN_InvokeTrace_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CN_InvokeTrace_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CN_InvokeTrace_protocolIEs_element (ASN1CTXT* pctxt,
   CN_InvokeTrace_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_InvokeTraceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_InvokeTraceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CN_InvokeTraceIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, CN_InvokeTraceIEs[index].ValueSize);
   stat = CN_InvokeTraceIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace_protocolIEs (ASN1CTXT* pctxt, CN_InvokeTrace_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   CN_InvokeTrace_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CN_InvokeTrace_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CN_InvokeTrace_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceExtensions_Extension *pvalue = (_CN_InvokeTraceExtensions_Extension*) pvalue_;

   stat = asn1PD_TracePropagationParameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace_protocolExtensions_element (ASN1CTXT* pctxt, CN_InvokeTrace_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CN_InvokeTrace_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CN_InvokeTrace_protocolExtensions_element (ASN1CTXT* pctxt,
   CN_InvokeTrace_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_InvokeTraceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_InvokeTraceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CN_InvokeTraceExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CN_InvokeTraceExtensions[index].ExtensionSize);
   stat = CN_InvokeTraceExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace_protocolExtensions (ASN1CTXT* pctxt, CN_InvokeTrace_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CN_InvokeTrace_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CN_InvokeTrace_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CN_InvokeTrace_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace (ASN1CTXT* pctxt, CN_InvokeTrace* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_CN_InvokeTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_CN_InvokeTrace_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_DeactivateTraceIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_DeactivateTraceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_DeactivateTraceIEs_Value *pvalue = (_CN_DeactivateTraceIEs_Value*) pvalue_;

   stat = asn1PD_TraceReference (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_DeactivateTraceIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_DeactivateTraceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_DeactivateTraceIEs_Value_1 *pvalue = (_CN_DeactivateTraceIEs_Value_1*) pvalue_;

   stat = asn1PD_TriggerID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace_protocolIEs_element (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CN_DeactivateTrace_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CN_DeactivateTrace_protocolIEs_element (ASN1CTXT* pctxt,
   CN_DeactivateTrace_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_DeactivateTraceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_DeactivateTraceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CN_DeactivateTraceIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, CN_DeactivateTraceIEs[index].ValueSize);
   stat = CN_DeactivateTraceIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace_protocolIEs (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   CN_DeactivateTrace_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CN_DeactivateTrace_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CN_DeactivateTrace_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace_protocolExtensions_element (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CN_DeactivateTrace_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CN_DeactivateTrace_protocolExtensions_element (ASN1CTXT* pctxt,
   CN_DeactivateTrace_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_DeactivateTraceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_DeactivateTraceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CN_DeactivateTraceExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CN_DeactivateTraceExtensions[index].ExtensionSize);
   stat = CN_DeactivateTraceExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace_protocolExtensions (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CN_DeactivateTrace_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CN_DeactivateTrace_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CN_DeactivateTrace_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace (ASN1CTXT* pctxt, CN_DeactivateTrace* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_CN_DeactivateTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_CN_DeactivateTrace_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlIEs_Value *pvalue = (_LocationReportingControlIEs_Value*) pvalue_;

   stat = asn1PD_RequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl_protocolIEs_element (ASN1CTXT* pctxt, LocationReportingControl_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationReportingControl_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationReportingControl_protocolIEs_element (ASN1CTXT* pctxt,
   LocationReportingControl_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportingControlIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportingControlIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportingControlIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationReportingControlIEs[index].ValueSize);
   stat = LocationReportingControlIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl_protocolIEs (ASN1CTXT* pctxt, LocationReportingControl_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationReportingControl_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationReportingControl_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationReportingControl_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension *pvalue = (_LocationReportingControlExtensions_Extension*) pvalue_;

   stat = asn1PD_VerticalAccuracyCode (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_1           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_1 *pvalue = (_LocationReportingControlExtensions_Extension_1*) pvalue_;

   stat = asn1PD_ResponseTime (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_2           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_2 *pvalue = (_LocationReportingControlExtensions_Extension_2*) pvalue_;

   stat = asn1PD_PositioningPriority (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_3           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_3 *pvalue = (_LocationReportingControlExtensions_Extension_3*) pvalue_;

   stat = asn1PD_ClientType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl_protocolExtensions_element (ASN1CTXT* pctxt, LocationReportingControl_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationReportingControl_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationReportingControl_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationReportingControl_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportingControlExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportingControlExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportingControlExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationReportingControlExtensions[index].ExtensionSize);
   stat = LocationReportingControlExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl_protocolExtensions (ASN1CTXT* pctxt, LocationReportingControl_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationReportingControl_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationReportingControl_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationReportingControl_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl (ASN1CTXT* pctxt, LocationReportingControl* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationReportingControl_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationReportingControl_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value *pvalue = (_LocationReportIEs_Value*) pvalue_;

   stat = asn1PD_AreaIdentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value_1 *pvalue = (_LocationReportIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value_2 *pvalue = (_LocationReportIEs_Value_2*) pvalue_;

   stat = asn1PD_RequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport_protocolIEs_element (ASN1CTXT* pctxt, LocationReport_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationReport_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationReport_protocolIEs_element (ASN1CTXT* pctxt,
   LocationReport_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationReportIEs[index].ValueSize);
   stat = LocationReportIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport_protocolIEs (ASN1CTXT* pctxt, LocationReport_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationReport_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationReport_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension *pvalue = (_LocationReportExtensions_Extension*) pvalue_;

   stat = asn1PD_LastKnownServiceArea (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_1 *pvalue = (_LocationReportExtensions_Extension_1*) pvalue_;

   stat = asn1PD_PositionData (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_2 *pvalue = (_LocationReportExtensions_Extension_2*) pvalue_;

   stat = asn1PD_PositionDataSpecificToGERANIuMode (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_3 *pvalue = (_LocationReportExtensions_Extension_3*) pvalue_;

   stat = asn1PD_AccuracyFulfilmentIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport_protocolExtensions_element (ASN1CTXT* pctxt, LocationReport_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationReport_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationReport_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationReport_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationReportExtensions[index].ExtensionSize);
   stat = LocationReportExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport_protocolExtensions (ASN1CTXT* pctxt, LocationReport_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationReport_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationReport_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationReport_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport (ASN1CTXT* pctxt, LocationReport* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationReport_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value *pvalue = (_InitialUE_MessageIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_1 *pvalue = (_InitialUE_MessageIEs_Value_1*) pvalue_;

   stat = asn1PD_LAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_2 *pvalue = (_InitialUE_MessageIEs_Value_2*) pvalue_;

   stat = asn1PD_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_3 *pvalue = (_InitialUE_MessageIEs_Value_3*) pvalue_;

   stat = asn1PD_SAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_4 *pvalue = (_InitialUE_MessageIEs_Value_4*) pvalue_;

   stat = asn1PD_NAS_PDU (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_5                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_5 *pvalue = (_InitialUE_MessageIEs_Value_5*) pvalue_;

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_6                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_6 *pvalue = (_InitialUE_MessageIEs_Value_6*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message_protocolIEs_element (ASN1CTXT* pctxt, InitialUE_Message_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InitialUE_Message_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InitialUE_Message_protocolIEs_element (ASN1CTXT* pctxt,
   InitialUE_Message_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InitialUE_MessageIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InitialUE_MessageIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InitialUE_MessageIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, InitialUE_MessageIEs[index].ValueSize);
   stat = InitialUE_MessageIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message_protocolIEs (ASN1CTXT* pctxt, InitialUE_Message_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   InitialUE_Message_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InitialUE_Message_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InitialUE_Message_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension *pvalue = (_InitialUE_MessageExtensions_Extension*) pvalue_;

   stat = asn1PD_GERAN_Classmark (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_1 *pvalue = (_InitialUE_MessageExtensions_Extension_1*) pvalue_;

   stat = asn1PD_PLMNidentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_2 *pvalue = (_InitialUE_MessageExtensions_Extension_2*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_3 *pvalue = (_InitialUE_MessageExtensions_Extension_3*) pvalue_;

   stat = asn1PD_NAS_SequenceNumber (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message_protocolExtensions_element (ASN1CTXT* pctxt, InitialUE_Message_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InitialUE_Message_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InitialUE_Message_protocolExtensions_element (ASN1CTXT* pctxt,
   InitialUE_Message_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InitialUE_MessageExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InitialUE_MessageExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InitialUE_MessageExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InitialUE_MessageExtensions[index].ExtensionSize);
   stat = InitialUE_MessageExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message_protocolExtensions (ASN1CTXT* pctxt, InitialUE_Message_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InitialUE_Message_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InitialUE_Message_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InitialUE_Message_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message (ASN1CTXT* pctxt, InitialUE_Message* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_InitialUE_Message_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_InitialUE_Message_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value *pvalue = (_DirectTransferIEs_Value*) pvalue_;

   stat = asn1PD_NAS_PDU (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_1 *pvalue = (_DirectTransferIEs_Value_1*) pvalue_;

   stat = asn1PD_LAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_2 *pvalue = (_DirectTransferIEs_Value_2*) pvalue_;

   stat = asn1PD_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_3                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_3 *pvalue = (_DirectTransferIEs_Value_3*) pvalue_;

   stat = asn1PD_SAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_4                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_4 *pvalue = (_DirectTransferIEs_Value_4*) pvalue_;

   stat = asn1PD_SAPI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer_protocolIEs_element (ASN1CTXT* pctxt, DirectTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectTransfer_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectTransfer_protocolIEs_element (ASN1CTXT* pctxt,
   DirectTransfer_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DirectTransferIEs[index].ValueSize);
   stat = DirectTransferIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer_protocolIEs (ASN1CTXT* pctxt, DirectTransfer_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectTransfer_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransfer_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RedirectionIndication_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value *pvalue = (_RedirectionIndication_IEs_Value*) pvalue_;

   stat = asn1PD_NAS_PDU (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_1                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RedirectionIndication_IEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_1 *pvalue = (_RedirectionIndication_IEs_Value_1*) pvalue_;

   stat = asn1PD_RejectCauseValue (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_2                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RedirectionIndication_IEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_2 *pvalue = (_RedirectionIndication_IEs_Value_2*) pvalue_;

   stat = asn1PD_NAS_SequenceNumber (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_3                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RedirectionIndication_IEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_3 *pvalue = (_RedirectionIndication_IEs_Value_3*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RedirectionIndication_element (ASN1CTXT* pctxt, RedirectionIndication_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RedirectionIndication_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RedirectionIndication_element (ASN1CTXT* pctxt,
   RedirectionIndication_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RedirectionIndication_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RedirectionIndication_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RedirectionIndication_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RedirectionIndication_IEs[index].ValueSize);
   stat = RedirectionIndication_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RedirectionIndication (ASN1CTXT* pctxt, RedirectionIndication* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RedirectionIndication_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RedirectionIndication_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RedirectionIndication_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferExtensions_Extension *pvalue = (_DirectTransferExtensions_Extension*) pvalue_;

   stat = asn1PD_RedirectionIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferExtensions_Extension_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferExtensions_Extension_1 *pvalue = (_DirectTransferExtensions_Extension_1*) pvalue_;

   stat = asn1PD_RedirectionCompleted (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer_protocolExtensions_element (ASN1CTXT* pctxt, DirectTransfer_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectTransfer_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectTransfer_protocolExtensions_element (ASN1CTXT* pctxt,
   DirectTransfer_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DirectTransferExtensions[index].ExtensionSize);
   stat = DirectTransferExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer_protocolExtensions (ASN1CTXT* pctxt, DirectTransfer_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectTransfer_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransfer_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransfer_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer (ASN1CTXT* pctxt, DirectTransfer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_DirectTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_DirectTransfer_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadIEs_Value                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__OverloadIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadIEs_Value *pvalue = (_OverloadIEs_Value*) pvalue_;

   stat = asn1PD_NumberOfSteps (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadIEs_Value_1                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__OverloadIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadIEs_Value_1 *pvalue = (_OverloadIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload_protocolIEs_element (ASN1CTXT* pctxt, Overload_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Overload_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Overload_protocolIEs_element (ASN1CTXT* pctxt,
   Overload_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < OverloadIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &OverloadIEs[index].id) == 0) {
         break;
      }
   }
   if(index == OverloadIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, OverloadIEs[index].ValueSize);
   stat = OverloadIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload_protocolIEs (ASN1CTXT* pctxt, Overload_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Overload_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Overload_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Overload_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadExtensions_Extension                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__OverloadExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadExtensions_Extension *pvalue = (_OverloadExtensions_Extension*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadExtensions_Extension_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__OverloadExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadExtensions_Extension_1 *pvalue = (_OverloadExtensions_Extension_1*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload_protocolExtensions_element (ASN1CTXT* pctxt, Overload_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Overload_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Overload_protocolExtensions_element (ASN1CTXT* pctxt,
   Overload_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < OverloadExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &OverloadExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == OverloadExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, OverloadExtensions[index].ExtensionSize);
   stat = OverloadExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload_protocolExtensions (ASN1CTXT* pctxt, Overload_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Overload_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Overload_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Overload_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload (ASN1CTXT* pctxt, Overload* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Overload_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Overload_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value *pvalue = (_ErrorIndicationIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_1 *pvalue = (_ErrorIndicationIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_2                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_2 *pvalue = (_ErrorIndicationIEs_Value_2*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_3                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_3 *pvalue = (_ErrorIndicationIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication_protocolIEs_element (ASN1CTXT* pctxt, ErrorIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ErrorIndication_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ErrorIndication_protocolIEs_element (ASN1CTXT* pctxt,
   ErrorIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ErrorIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ErrorIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ErrorIndicationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ErrorIndicationIEs[index].ValueSize);
   stat = ErrorIndicationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication_protocolIEs (ASN1CTXT* pctxt, ErrorIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ErrorIndication_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ErrorIndication_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ErrorIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationExtensions_Extension                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationExtensions_Extension *pvalue = (_ErrorIndicationExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication_protocolExtensions_element (ASN1CTXT* pctxt, ErrorIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ErrorIndication_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ErrorIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   ErrorIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ErrorIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ErrorIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ErrorIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ErrorIndicationExtensions[index].ExtensionSize);
   stat = ErrorIndicationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication_protocolExtensions (ASN1CTXT* pctxt, ErrorIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ErrorIndication_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ErrorIndication_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ErrorIndication_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication (ASN1CTXT* pctxt, ErrorIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ErrorIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_DataForwardCommandIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_DataForwardCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_DataForwardCommandIEs_Value *pvalue = (_SRNS_DataForwardCommandIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataForwardingList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand_protocolIEs_element (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_DataForwardCommand_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_DataForwardCommand_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_DataForwardCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_DataForwardCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_DataForwardCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_DataForwardCommandIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SRNS_DataForwardCommandIEs[index].ValueSize);
   stat = SRNS_DataForwardCommandIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand_protocolIEs (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_DataForwardCommand_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_DataForwardCommand_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_DataForwardCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_DataForwardCommand_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_DataForwardCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_DataForwardCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_DataForwardCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_DataForwardCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_DataForwardCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SRNS_DataForwardCommandExtensions[index].ExtensionSize);
   stat = SRNS_DataForwardCommandExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand_protocolExtensions (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_DataForwardCommand_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_DataForwardCommand_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_DataForwardCommand_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand (ASN1CTXT* pctxt, SRNS_DataForwardCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SRNS_DataForwardCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SRNS_DataForwardCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ForwardSRNS_ContextIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ForwardSRNS_ContextIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ForwardSRNS_ContextIEs_Value *pvalue = (_ForwardSRNS_ContextIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ContextList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context_protocolIEs_element (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ForwardSRNS_Context_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ForwardSRNS_Context_protocolIEs_element (ASN1CTXT* pctxt,
   ForwardSRNS_Context_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ForwardSRNS_ContextIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ForwardSRNS_ContextIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ForwardSRNS_ContextIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ForwardSRNS_ContextIEs[index].ValueSize);
   stat = ForwardSRNS_ContextIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context_protocolIEs (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ForwardSRNS_Context_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ForwardSRNS_Context_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ForwardSRNS_Context_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ForwardSRNS_ContextExtensions_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ForwardSRNS_ContextExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ForwardSRNS_ContextExtensions_Extension *pvalue = (_ForwardSRNS_ContextExtensions_Extension*) pvalue_;

   stat = asn1PD_RRC_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context_protocolExtensions_element (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ForwardSRNS_Context_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ForwardSRNS_Context_protocolExtensions_element (ASN1CTXT* pctxt,
   ForwardSRNS_Context_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ForwardSRNS_ContextExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ForwardSRNS_ContextExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ForwardSRNS_ContextExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ForwardSRNS_ContextExtensions[index].ExtensionSize);
   stat = ForwardSRNS_ContextExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context_protocolExtensions (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ForwardSRNS_Context_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ForwardSRNS_Context_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ForwardSRNS_Context_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context (ASN1CTXT* pctxt, ForwardSRNS_Context* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ForwardSRNS_Context_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ForwardSRNS_Context_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerInformation_iE_Extensions_element (ASN1CTXT* pctxt, TransportLayerInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TransportLayerInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TransportLayerInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   TransportLayerInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TransportLayerInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TransportLayerInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TransportLayerInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TransportLayerInformation_ExtIEs[index].ExtensionSize);
   stat = TransportLayerInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerInformation_iE_Extensions (ASN1CTXT* pctxt, TransportLayerInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TransportLayerInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TransportLayerInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TransportLayerInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerInformation (ASN1CTXT* pctxt, TransportLayerInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode transportLayerAddress */

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iuTransportAssociation */

   stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TransportLayerInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemFirst_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifyItemFirst_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifyItemFirst_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyItemFirst_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItemFirst_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItemFirst_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItemFirst_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifyItemFirst_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupOrModifyItemFirst_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemFirst_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifyItemFirst_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifyItemFirst_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifyItemFirst_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemFirst (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nAS_SynchronisationIndicatorPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rAB_ParametersPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.userPlaneInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.service_HandoverPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode nAS_SynchronisationIndicator */

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      stat = asn1PD_NAS_SynchronisationIndicator (pctxt, &pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAB_Parameters */

   if (pvalue->m.rAB_ParametersPresent) {
      stat = asn1PD_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode userPlaneInformation */

   if (pvalue->m.userPlaneInformationPresent) {
      stat = asn1PD_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode transportLayerInformation */

   if (pvalue->m.transportLayerInformationPresent) {
      stat = asn1PD_TransportLayerInformation (pctxt, &pvalue->transportLayerInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      stat = asn1PD_Service_Handover (pctxt, &pvalue->service_Handover);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupOrModifyItemFirst_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItem_IEs_FirstValue                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifyItem_IEs_FirstValue (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItem_IEs_FirstValue *pvalue = (_RAB_SetupOrModifyItem_IEs_FirstValue*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifyItemFirst (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItemSecond_ExtIEs_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifyItemSecond_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItemSecond_ExtIEs_Extension *pvalue = (_RAB_SetupOrModifyItemSecond_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_Alt_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1 *pvalue = (_RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_GERAN_BSC_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemSecond_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifyItemSecond_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifyItemSecond_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyItemSecond_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItemSecond_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItemSecond_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItemSecond_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifyItemSecond_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupOrModifyItemSecond_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemSecond_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifyItemSecond_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifyItemSecond_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifyItemSecond_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemSecond (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pDP_TypeInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataVolumeReportingIndicationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      stat = asn1PD_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      stat = asn1PD_DataVolumeReportingIndication (pctxt, &pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupOrModifyItemSecond_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItem_IEs_SecondValue                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifyItem_IEs_SecondValue (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItem_IEs_SecondValue *pvalue = (_RAB_SetupOrModifyItem_IEs_SecondValue*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifyItemSecond (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyList_element_element (ASN1CTXT* pctxt, RAB_SetupOrModifyList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode firstCriticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->firstCriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode firstValue */

   stat = pd_OpenType (pctxt, &pvalue->firstValue.encoded.data, &pvalue->firstValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode secondCriticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->secondCriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode secondValue */

   stat = pd_OpenType (pctxt, &pvalue->secondValue.encoded.data, &pvalue->secondValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifyList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifyList_element_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItem_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItem_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItem_IEs_Size) return 0;

   /* check secondValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->secondValue.encoded.data,
         pvalue->secondValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->secondValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifyItem_IEs[index].SecondValueSize);
   stat = RAB_SetupOrModifyItem_IEs[index].decodeSecondValue(pctxt, pvalue->secondValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "secondCriticality" element */
   /* check firstValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->firstValue.encoded.data,
         pvalue->firstValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->firstValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifyItem_IEs[index].FirstValueSize);
   stat = RAB_SetupOrModifyItem_IEs[index].decodeFirstValue(pctxt, pvalue->firstValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "firstCriticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyList_element (ASN1CTXT* pctxt, RAB_SetupOrModifyList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifyList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifyList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifyList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyList (ASN1CTXT* pctxt, RAB_SetupOrModifyList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_SetupOrModifyList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifyList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifyList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentRequestIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentRequestIEs_Value *pvalue = (_RAB_AssignmentRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifyList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentRequestIEs_Value_1                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentRequestIEs_Value_1 *pvalue = (_RAB_AssignmentRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_AssignmentRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_AssignmentRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_AssignmentRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_AssignmentRequestIEs[index].ValueSize);
   stat = RAB_AssignmentRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest_protocolIEs (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_AssignmentRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_AssignmentRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_AssignmentRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_AssignmentRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_AssignmentRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_AssignmentRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_AssignmentRequestExtensions[index].ExtensionSize);
   stat = RAB_AssignmentRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_AssignmentRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_AssignmentRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_AssignmentRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest (ASN1CTXT* pctxt, RAB_AssignmentRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RAB_AssignmentRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RAB_AssignmentRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifiedItem_ExtIEs_Extension                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifiedItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifiedItem_ExtIEs_Extension *pvalue = (_RAB_SetupOrModifiedItem_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_Ass_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifiedItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifiedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifiedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifiedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifiedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifiedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifiedItem_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupOrModifiedItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifiedItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifiedItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifiedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedItem (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iuTransportAssociationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_dataVolumesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iuTransportAssociation */

   if (pvalue->m.iuTransportAssociationPresent) {
      stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_dataVolumes */

   if (pvalue->m.dl_dataVolumesPresent) {
      stat = asn1PD_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupOrModifiedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifiedItemIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifiedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifiedItemIEs_Value *pvalue = (_RAB_SetupOrModifiedItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifiedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedList_element_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifiedList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifiedList_element_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifiedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifiedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifiedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifiedItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifiedItemIEs[index].ValueSize);
   stat = RAB_SetupOrModifiedItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedList_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifiedList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifiedList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifiedList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedList (ASN1CTXT* pctxt, RAB_SetupOrModifiedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_SetupOrModifiedList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifiedList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifiedList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value *pvalue = (_RAB_AssignmentResponseIEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifiedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleasedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleasedItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleasedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleasedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ReleasedItem_ExtIEs[index].ExtensionSize);
   stat = RAB_ReleasedItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleasedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleasedItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem (ASN1CTXT* pctxt, RAB_ReleasedItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_dataVolumesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dl_dataVolumes */

   if (pvalue->m.dl_dataVolumesPresent) {
      stat = asn1PD_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dL_GTP_PDU_SequenceNumber */

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uL_GTP_PDU_SequenceNumber */

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ReleasedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleasedItemIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ReleasedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleasedItemIEs_Value *pvalue = (_RAB_ReleasedItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ReleasedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_element_element (ASN1CTXT* pctxt, RAB_ReleasedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleasedList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleasedList_element_element (ASN1CTXT* pctxt,
   RAB_ReleasedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ReleasedItemIEs[index].ValueSize);
   stat = RAB_ReleasedItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_element (ASN1CTXT* pctxt, RAB_ReleasedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleasedList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList (ASN1CTXT* pctxt, RAB_ReleasedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ReleasedList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_1                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_1 *pvalue = (_RAB_AssignmentResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ReleasedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_QueuedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_QueuedItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_QueuedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_QueuedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_QueuedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_QueuedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_QueuedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_QueuedItem_ExtIEs[index].ExtensionSize);
   stat = RAB_QueuedItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_QueuedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_QueuedItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_QueuedItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_QueuedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedItem (ASN1CTXT* pctxt, RAB_QueuedItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_QueuedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_QueuedItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_QueuedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_QueuedItemIEs_Value *pvalue = (_RAB_QueuedItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_QueuedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedList_element_element (ASN1CTXT* pctxt, RAB_QueuedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_QueuedList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_QueuedList_element_element (ASN1CTXT* pctxt,
   RAB_QueuedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_QueuedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_QueuedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_QueuedItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_QueuedItemIEs[index].ValueSize);
   stat = RAB_QueuedItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedList_element (ASN1CTXT* pctxt, RAB_QueuedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_QueuedList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_QueuedList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_QueuedList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedList (ASN1CTXT* pctxt, RAB_QueuedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_QueuedList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_QueuedList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_QueuedList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_2                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_2 *pvalue = (_RAB_AssignmentResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_RAB_QueuedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_3                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_3 *pvalue = (_RAB_AssignmentResponseIEs_Value_3*) pvalue_;

   stat = asn1PD_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseFailedList                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseFailedList (ASN1CTXT* pctxt, RAB_ReleaseFailedList* pvalue)
{
   int stat = 0;

   stat = asn1PD_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_4                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_4 *pvalue = (_RAB_AssignmentResponseIEs_Value_4*) pvalue_;

   stat = asn1PD_RAB_ReleaseFailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_5                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_5 *pvalue = (_RAB_AssignmentResponseIEs_Value_5*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse_protocolIEs_element (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_AssignmentResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_AssignmentResponse_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_AssignmentResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_AssignmentResponseIEs[index].ValueSize);
   stat = RAB_AssignmentResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse_protocolIEs (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_AssignmentResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_AssignmentResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_AssignmentResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (ASN1CTXT* pctxt,
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].ExtensionSize);
   stat = GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gERAN_ClassmarkPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode gERAN_Classmark */

   if (pvalue->m.gERAN_ClassmarkPresent) {
      stat = asn1PD_GERAN_Classmark (pctxt, &pvalue->gERAN_Classmark);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value *pvalue = (_GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value*) pvalue_;

   stat = asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (ASN1CTXT* pctxt,
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].ValueSize);
   stat = GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseExtensions_Extension               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseExtensions_Extension *pvalue = (_RAB_AssignmentResponseExtensions_Extension*) pvalue_;

   stat = asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse_protocolExtensions_element (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_AssignmentResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_AssignmentResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_AssignmentResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_AssignmentResponseExtensions[index].ExtensionSize);
   stat = RAB_AssignmentResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse_protocolExtensions (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_AssignmentResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_AssignmentResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_AssignmentResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse (ASN1CTXT* pctxt, RAB_AssignmentResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RAB_AssignmentResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RAB_AssignmentResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrivateMessage_privateIEs_element (ASN1CTXT* pctxt, PrivateMessage_privateIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_PrivateMessage_privateIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_PrivateMessage_privateIEs_element (ASN1CTXT* pctxt,
   PrivateMessage_privateIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PrivateMessage_IEs_Size; index++) {
      if(asn1CmpTC_PrivateIE_ID(&pvalue->id, &PrivateMessage_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == PrivateMessage_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, PrivateMessage_IEs[index].ValueSize);
   stat = PrivateMessage_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrivateMessage_privateIEs (ASN1CTXT* pctxt, PrivateMessage_privateIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   PrivateMessage_privateIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PrivateMessage_privateIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PrivateMessage_privateIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrivateMessage (ASN1CTXT* pctxt, PrivateMessage* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   rtDListInit (&pvalue->extElem1);

   /* decode privateIEs */

   stat = asn1PD_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value *pvalue = (_ResetResourceIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_1                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_1 *pvalue = (_ResetResourceIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceItem_iE_Extensions_element (ASN1CTXT* pctxt, ResetResourceItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceItem_iE_Extensions_element (ASN1CTXT* pctxt,
   ResetResourceItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetResourceItem_ExtIEs[index].ExtensionSize);
   stat = ResetResourceItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceItem_iE_Extensions (ASN1CTXT* pctxt, ResetResourceItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceItem (ASN1CTXT* pctxt, ResetResourceItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iuSigConId */

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, &pvalue->iuSigConId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_ResetResourceItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceItemIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceItemIEs_Value *pvalue = (_ResetResourceItemIEs_Value*) pvalue_;

   stat = asn1PD_ResetResourceItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceList_element_element (ASN1CTXT* pctxt, ResetResourceList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceList_element_element (ASN1CTXT* pctxt,
   ResetResourceList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetResourceItemIEs[index].ValueSize);
   stat = ResetResourceItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceList_element (ASN1CTXT* pctxt, ResetResourceList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceList (ASN1CTXT* pctxt, ResetResourceList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(250), 0 };
   int stat = 0;
   ResetResourceList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_2                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_2 *pvalue = (_ResetResourceIEs_Value_2*) pvalue_;

   stat = asn1PD_ResetResourceList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_3                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_3 *pvalue = (_ResetResourceIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource_protocolIEs_element (ASN1CTXT* pctxt, ResetResource_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResource_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResource_protocolIEs_element (ASN1CTXT* pctxt,
   ResetResource_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetResourceIEs[index].ValueSize);
   stat = ResetResourceIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource_protocolIEs (ASN1CTXT* pctxt, ResetResource_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResource_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResource_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResource_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceExtensions_Extension                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceExtensions_Extension *pvalue = (_ResetResourceExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource_protocolExtensions_element (ASN1CTXT* pctxt, ResetResource_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResource_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResource_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetResource_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetResourceExtensions[index].ExtensionSize);
   stat = ResetResourceExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource_protocolExtensions (ASN1CTXT* pctxt, ResetResource_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResource_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResource_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResource_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource (ASN1CTXT* pctxt, ResetResource* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ResetResource_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ResetResource_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value *pvalue = (_ResetResourceAcknowledgeIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckItem_iE_Extensions_element (ASN1CTXT* pctxt, ResetResourceAckItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceAckItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceAckItem_iE_Extensions_element (ASN1CTXT* pctxt,
   ResetResourceAckItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAckItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAckItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAckItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetResourceAckItem_ExtIEs[index].ExtensionSize);
   stat = ResetResourceAckItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckItem_iE_Extensions (ASN1CTXT* pctxt, ResetResourceAckItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceAckItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAckItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAckItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckItem (ASN1CTXT* pctxt, ResetResourceAckItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iuSigConId */

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, &pvalue->iuSigConId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_ResetResourceAckItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAckItemIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAckItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAckItemIEs_Value *pvalue = (_ResetResourceAckItemIEs_Value*) pvalue_;

   stat = asn1PD_ResetResourceAckItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckList_element_element (ASN1CTXT* pctxt, ResetResourceAckList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceAckList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceAckList_element_element (ASN1CTXT* pctxt,
   ResetResourceAckList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAckItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAckItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAckItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetResourceAckItemIEs[index].ValueSize);
   stat = ResetResourceAckItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckList_element (ASN1CTXT* pctxt, ResetResourceAckList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceAckList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAckList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAckList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckList (ASN1CTXT* pctxt, ResetResourceAckList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(250), 0 };
   int stat = 0;
   ResetResourceAckList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAckList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAckList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_1 *pvalue = (_ResetResourceAcknowledgeIEs_Value_1*) pvalue_;

   stat = asn1PD_ResetResourceAckList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_2 *pvalue = (_ResetResourceAcknowledgeIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_3                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_3 *pvalue = (_ResetResourceAcknowledgeIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceAcknowledge_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   ResetResourceAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetResourceAcknowledgeIEs[index].ValueSize);
   stat = ResetResourceAcknowledgeIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge_protocolIEs (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceAcknowledge_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAcknowledge_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeExtensions_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeExtensions_Extension *pvalue = (_ResetResourceAcknowledgeExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceAcknowledge_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetResourceAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetResourceAcknowledgeExtensions[index].ExtensionSize);
   stat = ResetResourceAcknowledgeExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge_protocolExtensions (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceAcknowledge_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAcknowledge_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAcknowledge_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge (ASN1CTXT* pctxt, ResetResourceAcknowledge* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ResetResourceAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ResetResourceAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt,
   DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].ExtensionSize);
   stat = RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationItem_RANAP_RelocInf (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode nAS_PDU */

   stat = asn1PD_NAS_PDU (pctxt, &pvalue->nAS_PDU);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode sAPI */

   stat = asn1PD_SAPI (pctxt, &pvalue->sAPI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cN_DomainIndicator */

   stat = asn1PD_CN_DomainIndicator (pctxt, &pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferInformationItemIEs_RANAP_RelocInf_Value    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferInformationItemIEs_RANAP_RelocInf_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferInformationItemIEs_RANAP_RelocInf_Value *pvalue = (_DirectTransferInformationItemIEs_RANAP_RelocInf_Value*) pvalue_;

   stat = asn1PD_DirectTransferInformationItem_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectTransferInformationList_RANAP_RelocInf_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectTransferInformationList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt,
   DirectTransferInformationList_RANAP_RelocInf_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferInformationItemIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferInformationItemIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferInformationItemIEs_RANAP_RelocInf_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DirectTransferInformationItemIEs_RANAP_RelocInf[index].ValueSize);
   stat = DirectTransferInformationItemIEs_RANAP_RelocInf[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationList_RANAP_RelocInf_element (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectTransferInformationList_RANAP_RelocInf_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransferInformationList_RANAP_RelocInf_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransferInformationList_RANAP_RelocInf_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationList_RANAP_RelocInf (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   DirectTransferInformationList_RANAP_RelocInf_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransferInformationList_RANAP_RelocInf_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransferInformationList_RANAP_RelocInf_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RANAP_RelocationInformationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationIEs_Value *pvalue = (_RANAP_RelocationInformationIEs_Value*) pvalue_;

   stat = asn1PD_DirectTransferInformationList_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].ExtensionSize);
   stat = RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_RANAP_RelocInf_iE_Extensions (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_RANAP_RelocInf (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ContextItem_RANAP_RelocInf_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ContextItemIEs_RANAP_RelocInf_Value                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ContextItemIEs_RANAP_RelocInf_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ContextItemIEs_RANAP_RelocInf_Value *pvalue = (_RAB_ContextItemIEs_RANAP_RelocInf_Value*) pvalue_;

   stat = asn1PD_RAB_ContextItem_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextList_RANAP_RelocInf_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt,
   RAB_ContextList_RANAP_RelocInf_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItemIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItemIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItemIEs_RANAP_RelocInf_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ContextItemIEs_RANAP_RelocInf[index].ValueSize);
   stat = RAB_ContextItemIEs_RANAP_RelocInf[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_RANAP_RelocInf_element (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextList_RANAP_RelocInf_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextList_RANAP_RelocInf_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextList_RANAP_RelocInf_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_RANAP_RelocInf (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ContextList_RANAP_RelocInf_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextList_RANAP_RelocInf_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextList_RANAP_RelocInf_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationIEs_Value_1                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RANAP_RelocationInformationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationIEs_Value_1 *pvalue = (_RANAP_RelocationInformationIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ContextList_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation_protocolIEs_element (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RANAP_RelocationInformation_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RANAP_RelocationInformation_protocolIEs_element (ASN1CTXT* pctxt,
   RANAP_RelocationInformation_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_RelocationInformationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_RelocationInformationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_RelocationInformationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RANAP_RelocationInformationIEs[index].ValueSize);
   stat = RANAP_RelocationInformationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation_protocolIEs (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RANAP_RelocationInformation_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RANAP_RelocationInformation_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RANAP_RelocationInformation_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationExtensions_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RANAP_RelocationInformationExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationExtensions_Extension *pvalue = (_RANAP_RelocationInformationExtensions_Extension*) pvalue_;

   stat = asn1PD_RRC_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation_protocolExtensions_element (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RANAP_RelocationInformation_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RANAP_RelocationInformation_protocolExtensions_element (ASN1CTXT* pctxt,
   RANAP_RelocationInformation_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_RelocationInformationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_RelocationInformationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_RelocationInformationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RANAP_RelocationInformationExtensions[index].ExtensionSize);
   stat = RANAP_RelocationInformationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation_protocolExtensions (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RANAP_RelocationInformation_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RANAP_RelocationInformation_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RANAP_RelocationInformation_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation (ASN1CTXT* pctxt, RANAP_RelocationInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RANAP_RelocationInformation_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RANAP_RelocationInformation_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ModifyItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ModifyItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ModifyItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ModifyItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ModifyItem_ExtIEs[index].ExtensionSize);
   stat = RAB_ModifyItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ModifyItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ModifyItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyItem (ASN1CTXT* pctxt, RAB_ModifyItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode requested_RAB_Parameter_Values */

   stat = asn1PD_Requested_RAB_Parameter_Values (pctxt, &pvalue->requested_RAB_Parameter_Values);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ModifyItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ModifyItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ModifyItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ModifyItemIEs_Value *pvalue = (_RAB_ModifyItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ModifyItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyList_element_element (ASN1CTXT* pctxt, RAB_ModifyList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ModifyList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ModifyList_element_element (ASN1CTXT* pctxt,
   RAB_ModifyList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ModifyItemIEs[index].ValueSize);
   stat = RAB_ModifyItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyList_element (ASN1CTXT* pctxt, RAB_ModifyList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ModifyList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyList (ASN1CTXT* pctxt, RAB_ModifyList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ModifyList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ModifyRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ModifyRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ModifyRequestIEs_Value *pvalue = (_RAB_ModifyRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ModifyList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ModifyRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ModifyRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_ModifyRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ModifyRequestIEs[index].ValueSize);
   stat = RAB_ModifyRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest_protocolIEs (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ModifyRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ModifyRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ModifyRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_ModifyRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ModifyRequestExtensions[index].ExtensionSize);
   stat = RAB_ModifyRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ModifyRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest (ASN1CTXT* pctxt, RAB_ModifyRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RAB_ModifyRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RAB_ModifyRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataRequestIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataRequestIEs_Value *pvalue = (_LocationRelatedDataRequestIEs_Value*) pvalue_;

   stat = asn1PD_LocationRelatedDataRequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataRequest_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationRelatedDataRequestIEs[index].ValueSize);
   stat = LocationRelatedDataRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataRequestExtensions_Extension           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataRequestExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataRequestExtensions_Extension *pvalue = (_LocationRelatedDataRequestExtensions_Extension*) pvalue_;

   stat = asn1PD_LocationRelatedDataRequestTypeSpecificToGERANIuMode (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationRelatedDataRequestExtensions[index].ExtensionSize);
   stat = LocationRelatedDataRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest (ASN1CTXT* pctxt, LocationRelatedDataRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationRelatedDataRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationRelatedDataRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataResponseIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataResponseIEs_Value *pvalue = (_LocationRelatedDataResponseIEs_Value*) pvalue_;

   stat = asn1PD_BroadcastAssistanceDataDecipheringKeys (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataResponse_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationRelatedDataResponseIEs[index].ValueSize);
   stat = LocationRelatedDataResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataResponseExtensions_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataResponseExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataResponseExtensions_Extension *pvalue = (_LocationRelatedDataResponseExtensions_Extension*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationRelatedDataResponseExtensions[index].ExtensionSize);
   stat = LocationRelatedDataResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse (ASN1CTXT* pctxt, LocationRelatedDataResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationRelatedDataResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationRelatedDataResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataFailureIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataFailureIEs_Value *pvalue = (_LocationRelatedDataFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataFailure_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationRelatedDataFailureIEs[index].ValueSize);
   stat = LocationRelatedDataFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataFailureExtensions_Extension           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataFailureExtensions_Extension *pvalue = (_LocationRelatedDataFailureExtensions_Extension*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationRelatedDataFailureExtensions[index].ExtensionSize);
   stat = LocationRelatedDataFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure (ASN1CTXT* pctxt, LocationRelatedDataFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationRelatedDataFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationRelatedDataFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value *pvalue = (_InformationTransferIndicationIEs_Value*) pvalue_;

   stat = asn1PD_InformationTransferID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferIndicationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_1 *pvalue = (_InformationTransferIndicationIEs_Value_1*) pvalue_;

   stat = asn1PD_ProvidedData (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_2                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferIndicationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_2 *pvalue = (_InformationTransferIndicationIEs_Value_2*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_3                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferIndicationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_3 *pvalue = (_InformationTransferIndicationIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferIndication_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferIndication_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferIndicationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, InformationTransferIndicationIEs[index].ValueSize);
   stat = InformationTransferIndicationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication_protocolIEs (ASN1CTXT* pctxt, InformationTransferIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferIndication_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferIndication_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferIndication_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InformationTransferIndicationExtensions[index].ExtensionSize);
   stat = InformationTransferIndicationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication_protocolExtensions (ASN1CTXT* pctxt, InformationTransferIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferIndication_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferIndication_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferIndication_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication (ASN1CTXT* pctxt, InformationTransferIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_InformationTransferIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_InformationTransferIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferConfirmationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value *pvalue = (_InformationTransferConfirmationIEs_Value*) pvalue_;

   stat = asn1PD_InformationTransferID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_1               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferConfirmationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_1 *pvalue = (_InformationTransferConfirmationIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_2               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferConfirmationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_2 *pvalue = (_InformationTransferConfirmationIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_3               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferConfirmationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_3 *pvalue = (_InformationTransferConfirmationIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferConfirmation_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferConfirmation_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferConfirmation_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferConfirmationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferConfirmationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferConfirmationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, InformationTransferConfirmationIEs[index].ValueSize);
   stat = InformationTransferConfirmationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation_protocolIEs (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferConfirmation_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferConfirmation_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferConfirmation_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferConfirmation_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferConfirmation_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferConfirmation_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferConfirmationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferConfirmationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferConfirmationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InformationTransferConfirmationExtensions[index].ExtensionSize);
   stat = InformationTransferConfirmationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation_protocolExtensions (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferConfirmation_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferConfirmation_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferConfirmation_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation (ASN1CTXT* pctxt, InformationTransferConfirmation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_InformationTransferConfirmation_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_InformationTransferConfirmation_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value *pvalue = (_InformationTransferFailureIEs_Value*) pvalue_;

   stat = asn1PD_InformationTransferID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_1                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_1 *pvalue = (_InformationTransferFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_2                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_2 *pvalue = (_InformationTransferFailureIEs_Value_2*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_3                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_3 *pvalue = (_InformationTransferFailureIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_4                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_4 *pvalue = (_InformationTransferFailureIEs_Value_4*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferFailure_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, InformationTransferFailureIEs[index].ValueSize);
   stat = InformationTransferFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure_protocolIEs (ASN1CTXT* pctxt, InformationTransferFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InformationTransferFailureExtensions[index].ExtensionSize);
   stat = InformationTransferFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure_protocolExtensions (ASN1CTXT* pctxt, InformationTransferFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure (ASN1CTXT* pctxt, InformationTransferFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_InformationTransferFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_InformationTransferFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UESpecificInformationIndicationIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UESpecificInformationIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UESpecificInformationIndicationIEs_Value *pvalue = (_UESpecificInformationIndicationIEs_Value*) pvalue_;

   stat = asn1PD_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication_protocolIEs_element (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UESpecificInformationIndication_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UESpecificInformationIndication_protocolIEs_element (ASN1CTXT* pctxt,
   UESpecificInformationIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESpecificInformationIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESpecificInformationIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UESpecificInformationIndicationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, UESpecificInformationIndicationIEs[index].ValueSize);
   stat = UESpecificInformationIndicationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication_protocolIEs (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   UESpecificInformationIndication_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UESpecificInformationIndication_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UESpecificInformationIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication_protocolExtensions_element (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UESpecificInformationIndication_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UESpecificInformationIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   UESpecificInformationIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESpecificInformationIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESpecificInformationIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UESpecificInformationIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UESpecificInformationIndicationExtensions[index].ExtensionSize);
   stat = UESpecificInformationIndicationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication_protocolExtensions (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UESpecificInformationIndication_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UESpecificInformationIndication_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UESpecificInformationIndication_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication (ASN1CTXT* pctxt, UESpecificInformationIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_UESpecificInformationIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_UESpecificInformationIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectInformationTransferIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value *pvalue = (_DirectInformationTransferIEs_Value*) pvalue_;

   stat = asn1PD_InterSystemInformationTransferType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectInformationTransferIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_1 *pvalue = (_DirectInformationTransferIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectInformationTransferIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_2 *pvalue = (_DirectInformationTransferIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectInformationTransferIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_3 *pvalue = (_DirectInformationTransferIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer_protocolIEs_element (ASN1CTXT* pctxt, DirectInformationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectInformationTransfer_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectInformationTransfer_protocolIEs_element (ASN1CTXT* pctxt,
   DirectInformationTransfer_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectInformationTransferIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectInformationTransferIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DirectInformationTransferIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DirectInformationTransferIEs[index].ValueSize);
   stat = DirectInformationTransferIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer_protocolIEs (ASN1CTXT* pctxt, DirectInformationTransfer_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectInformationTransfer_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectInformationTransfer_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectInformationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer_protocolExtensions_element (ASN1CTXT* pctxt, DirectInformationTransfer_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectInformationTransfer_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectInformationTransfer_protocolExtensions_element (ASN1CTXT* pctxt,
   DirectInformationTransfer_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectInformationTransferExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectInformationTransferExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DirectInformationTransferExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DirectInformationTransferExtensions[index].ExtensionSize);
   stat = DirectInformationTransferExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer_protocolExtensions (ASN1CTXT* pctxt, DirectInformationTransfer_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectInformationTransfer_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectInformationTransfer_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectInformationTransfer_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer (ASN1CTXT* pctxt, DirectInformationTransfer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_DirectInformationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_DirectInformationTransfer_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value *pvalue = (_UplinkInformationExchangeRequestIEs_Value*) pvalue_;

   stat = asn1PD_InformationExchangeID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_1              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_1 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_InformationExchangeType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_2              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_2 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_2*) pvalue_;

   stat = asn1PD_InformationTransferType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_3              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_3 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_3*) pvalue_;

   stat = asn1PD_InformationRequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_4              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_4 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_4*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_5              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_5 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_5*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeRequest_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeRequestIEs[index].ValueSize);
   stat = UplinkInformationExchangeRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeRequestExtensions[index].ExtensionSize);
   stat = UplinkInformationExchangeRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest (ASN1CTXT* pctxt, UplinkInformationExchangeRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_UplinkInformationExchangeRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_UplinkInformationExchangeRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value *pvalue = (_UplinkInformationExchangeResponseIEs_Value*) pvalue_;

   stat = asn1PD_InformationExchangeID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_1             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_1 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_InformationRequested (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_2             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_2 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_3             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_3 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_4             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_4 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_4*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeResponse_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeResponseIEs[index].ValueSize);
   stat = UplinkInformationExchangeResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeResponseExtensions[index].ExtensionSize);
   stat = UplinkInformationExchangeResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse (ASN1CTXT* pctxt, UplinkInformationExchangeResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_UplinkInformationExchangeResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_UplinkInformationExchangeResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value *pvalue = (_UplinkInformationExchangeFailureIEs_Value*) pvalue_;

   stat = asn1PD_InformationExchangeID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_1              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_1 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_2              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_2 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_3              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_3 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_3*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_4              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_4 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_4*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeFailure_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeFailureIEs[index].ValueSize);
   stat = UplinkInformationExchangeFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeFailureExtensions[index].ExtensionSize);
   stat = UplinkInformationExchangeFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure (ASN1CTXT* pctxt, UplinkInformationExchangeFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_UplinkInformationExchangeFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_UplinkInformationExchangeFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value *pvalue = (_MBMSSessionStartIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_1 *pvalue = (_MBMSSessionStartIEs_Value_1*) pvalue_;

   stat = asn1PD_MBMSSessionIdentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_2 *pvalue = (_MBMSSessionStartIEs_Value_2*) pvalue_;

   stat = asn1PD_MBMSBearerServiceType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_3                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_3 *pvalue = (_MBMSSessionStartIEs_Value_3*) pvalue_;

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_4                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_4 *pvalue = (_MBMSSessionStartIEs_Value_4*) pvalue_;

   stat = asn1PD_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_5                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_5 *pvalue = (_MBMSSessionStartIEs_Value_5*) pvalue_;

   stat = asn1PD_PDP_TypeInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_6                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_6 *pvalue = (_MBMSSessionStartIEs_Value_6*) pvalue_;

   stat = asn1PD_MBMSSessionDuration (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_7                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_7 *pvalue = (_MBMSSessionStartIEs_Value_7*) pvalue_;

   stat = asn1PD_MBMSServiceArea (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_8                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_8 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_8 *pvalue = (_MBMSSessionStartIEs_Value_8*) pvalue_;

   stat = asn1PD_FrequenceLayerConvergenceFlag (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_9                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_9 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_9 *pvalue = (_MBMSSessionStartIEs_Value_9*) pvalue_;

   stat = asn1PD_RAListofIdleModeUEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_10                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_10 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_10 *pvalue = (_MBMSSessionStartIEs_Value_10*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_11                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_11 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_11 *pvalue = (_MBMSSessionStartIEs_Value_11*) pvalue_;

   stat = asn1PD_MBMSSessionRepetitionNumber (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_12                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_12 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_12 *pvalue = (_MBMSSessionStartIEs_Value_12*) pvalue_;

   stat = asn1PD_TimeToMBMSDataTransfer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStart_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStart_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStart_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStart_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStartIEs[index].ValueSize);
   stat = MBMSSessionStartIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStart_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStart_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStart_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStart_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStart_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStart_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStart_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStart_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStartExtensions[index].ExtensionSize);
   stat = MBMSSessionStartExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStart_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStart_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStart_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStart_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart (ASN1CTXT* pctxt, MBMSSessionStart* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStart_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value *pvalue = (_MBMSSessionStartResponseIEs_Value*) pvalue_;

   stat = asn1PD_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value_1 *pvalue = (_MBMSSessionStartResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value_2 *pvalue = (_MBMSSessionStartResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStartResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStartResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStartResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStartResponseIEs[index].ValueSize);
   stat = MBMSSessionStartResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStartResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStartResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStartResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStartResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStartResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStartResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStartResponseExtensions[index].ExtensionSize);
   stat = MBMSSessionStartResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStartResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStartResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStartResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse (ASN1CTXT* pctxt, MBMSSessionStartResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStartResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStartResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartFailureIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartFailureIEs_Value *pvalue = (_MBMSSessionStartFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartFailureIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartFailureIEs_Value_1 *pvalue = (_MBMSSessionStartFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStartFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStartFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStartFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStartFailureIEs[index].ValueSize);
   stat = MBMSSessionStartFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStartFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStartFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStartFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStartFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStartFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStartFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStartFailureExtensions[index].ExtensionSize);
   stat = MBMSSessionStartFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStartFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStartFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStartFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure (ASN1CTXT* pctxt, MBMSSessionStartFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStartFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStartFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateIEs_Value *pvalue = (_MBMSSessionUpdateIEs_Value*) pvalue_;

   stat = asn1PD_SessionUpdateID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateIEs_Value_1 *pvalue = (_MBMSSessionUpdateIEs_Value_1*) pvalue_;

   stat = asn1PD_DeltaRAListofIdleModeUEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdate_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdate_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdate_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateIEs[index].ValueSize);
   stat = MBMSSessionUpdateIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdate_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdate_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdate_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdate_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdate_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdate_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateExtensions[index].ExtensionSize);
   stat = MBMSSessionUpdateExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdate_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdate_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdate_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate (ASN1CTXT* pctxt, MBMSSessionUpdate* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionUpdate_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value *pvalue = (_MBMSSessionUpdateResponseIEs_Value*) pvalue_;

   stat = asn1PD_SessionUpdateID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_1 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_2 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_3 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdateResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdateResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateResponseIEs[index].ValueSize);
   stat = MBMSSessionUpdateResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdateResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdateResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdateResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdateResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdateResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateResponseExtensions[index].ExtensionSize);
   stat = MBMSSessionUpdateResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdateResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdateResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdateResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse (ASN1CTXT* pctxt, MBMSSessionUpdateResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionUpdateResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionUpdateResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value *pvalue = (_MBMSSessionUpdateFailureIEs_Value*) pvalue_;

   stat = asn1PD_SessionUpdateID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value_1 *pvalue = (_MBMSSessionUpdateFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value_2 *pvalue = (_MBMSSessionUpdateFailureIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdateFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdateFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateFailureIEs[index].ValueSize);
   stat = MBMSSessionUpdateFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdateFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdateFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdateFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdateFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdateFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateFailureExtensions[index].ExtensionSize);
   stat = MBMSSessionUpdateFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdateFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdateFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdateFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure (ASN1CTXT* pctxt, MBMSSessionUpdateFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionUpdateFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStopIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopIEs_Value *pvalue = (_MBMSSessionStopIEs_Value*) pvalue_;

   stat = asn1PD_MBMSCNDe_Registration (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStop_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStop_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStop_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStop_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStopIEs[index].ValueSize);
   stat = MBMSSessionStopIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStop_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStop_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStop_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStop_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStop_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStop_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStop_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStop_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStopExtensions[index].ExtensionSize);
   stat = MBMSSessionStopExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStop_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStop_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStop_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStop_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop (ASN1CTXT* pctxt, MBMSSessionStop* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStop_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStop_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopResponseIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStopResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopResponseIEs_Value *pvalue = (_MBMSSessionStopResponseIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopResponseIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStopResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopResponseIEs_Value_1 *pvalue = (_MBMSSessionStopResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStopResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStopResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStopResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStopResponseIEs[index].ValueSize);
   stat = MBMSSessionStopResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStopResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStopResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStopResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStopResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStopResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStopResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStopResponseExtensions[index].ExtensionSize);
   stat = MBMSSessionStopResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStopResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStopResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStopResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse (ASN1CTXT* pctxt, MBMSSessionStopResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStopResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStopResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingRequestIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSUELinkingRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingRequestIEs_Value *pvalue = (_MBMSUELinkingRequestIEs_Value*) pvalue_;

   stat = asn1PD_JoinedMBMSBearerService_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LeftMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LeftMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LeftMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   LeftMBMSBearerService_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LeftMBMSBearerService_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LeftMBMSBearerService_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LeftMBMSBearerService_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LeftMBMSBearerService_ExtIEs[index].ExtensionSize);
   stat = LeftMBMSBearerService_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LeftMBMSBearerService_IEs_element_iE_Extensions (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LeftMBMSBearerService_IEs_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LeftMBMSBearerService_IEs_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LeftMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LeftMBMSBearerService_IEs_element (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode tMGI */

   stat = asn1PD_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_LeftMBMSBearerService_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LeftMBMSBearerService_IEs (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   LeftMBMSBearerService_IEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LeftMBMSBearerService_IEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LeftMBMSBearerService_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingRequestIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSUELinkingRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingRequestIEs_Value_1 *pvalue = (_MBMSUELinkingRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_LeftMBMSBearerService_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSUELinkingRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSUELinkingRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSUELinkingRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSUELinkingRequestIEs[index].ValueSize);
   stat = MBMSUELinkingRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest_protocolIEs (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSUELinkingRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSUELinkingRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSUELinkingRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSUELinkingRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSUELinkingRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSUELinkingRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSUELinkingRequestExtensions[index].ExtensionSize);
   stat = MBMSUELinkingRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSUELinkingRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSUELinkingRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSUELinkingRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest (ASN1CTXT* pctxt, MBMSUELinkingRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSUELinkingRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSUELinkingRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulLinking_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UnsuccessfulLinking_IEs_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UnsuccessfulLinking_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   UnsuccessfulLinking_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UnsuccessfulLinking_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UnsuccessfulLinking_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UnsuccessfulLinking_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UnsuccessfulLinking_ExtIEs[index].ExtensionSize);
   stat = UnsuccessfulLinking_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulLinking_IEs_element_iE_Extensions (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UnsuccessfulLinking_IEs_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UnsuccessfulLinking_IEs_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UnsuccessfulLinking_IEs_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulLinking_IEs_element (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode tMGI */

   stat = asn1PD_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_UnsuccessfulLinking_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulLinking_IEs (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   UnsuccessfulLinking_IEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UnsuccessfulLinking_IEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UnsuccessfulLinking_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingResponseIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSUELinkingResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingResponseIEs_Value *pvalue = (_MBMSUELinkingResponseIEs_Value*) pvalue_;

   stat = asn1PD_UnsuccessfulLinking_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingResponseIEs_Value_1                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSUELinkingResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingResponseIEs_Value_1 *pvalue = (_MBMSUELinkingResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSUELinkingResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSUELinkingResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSUELinkingResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSUELinkingResponseIEs[index].ValueSize);
   stat = MBMSUELinkingResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse_protocolIEs (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSUELinkingResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSUELinkingResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSUELinkingResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSUELinkingResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSUELinkingResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSUELinkingResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSUELinkingResponseExtensions[index].ExtensionSize);
   stat = MBMSUELinkingResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSUELinkingResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSUELinkingResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSUELinkingResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse (ASN1CTXT* pctxt, MBMSUELinkingResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSUELinkingResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSUELinkingResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value *pvalue = (_MBMSRegistrationRequestIEs_Value*) pvalue_;

   stat = asn1PD_MBMSRegistrationRequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_1 *pvalue = (_MBMSRegistrationRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_2                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_2 *pvalue = (_MBMSRegistrationRequestIEs_Value_2*) pvalue_;

   stat = asn1PD_IPMulticastAddress (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_3                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_3 *pvalue = (_MBMSRegistrationRequestIEs_Value_3*) pvalue_;

   stat = asn1PD_APN (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_4                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_4 *pvalue = (_MBMSRegistrationRequestIEs_Value_4*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRegistrationRequestIEs[index].ValueSize);
   stat = MBMSRegistrationRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRegistrationRequestExtensions[index].ExtensionSize);
   stat = MBMSRegistrationRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest (ASN1CTXT* pctxt, MBMSRegistrationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRegistrationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRegistrationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value *pvalue = (_MBMSRegistrationResponseIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value_1 *pvalue = (_MBMSRegistrationResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value_2 *pvalue = (_MBMSRegistrationResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRegistrationResponseIEs[index].ValueSize);
   stat = MBMSRegistrationResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRegistrationResponseExtensions[index].ExtensionSize);
   stat = MBMSRegistrationResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse (ASN1CTXT* pctxt, MBMSRegistrationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRegistrationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRegistrationResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value *pvalue = (_MBMSRegistrationFailureIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_1 *pvalue = (_MBMSRegistrationFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_2                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_2 *pvalue = (_MBMSRegistrationFailureIEs_Value_2*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_3                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_3 *pvalue = (_MBMSRegistrationFailureIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRegistrationFailureIEs[index].ValueSize);
   stat = MBMSRegistrationFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRegistrationFailureExtensions[index].ExtensionSize);
   stat = MBMSRegistrationFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure (ASN1CTXT* pctxt, MBMSRegistrationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRegistrationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRegistrationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationRequestIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationRequestIEs_Value *pvalue = (_MBMSCNDe_RegistrationRequestIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationRequestIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationRequestIEs_Value_1 *pvalue = (_MBMSCNDe_RegistrationRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSCNDe_RegistrationRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSCNDe_RegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSCNDe_RegistrationRequestIEs[index].ValueSize);
   stat = MBMSCNDe_RegistrationRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest_protocolIEs (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSCNDe_RegistrationRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSCNDe_RegistrationRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSCNDe_RegistrationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSCNDe_RegistrationRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSCNDe_RegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSCNDe_RegistrationRequestExtensions[index].ExtensionSize);
   stat = MBMSCNDe_RegistrationRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSCNDe_RegistrationRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSCNDe_RegistrationRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSCNDe_RegistrationRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSCNDe_RegistrationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSCNDe_RegistrationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_1 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_2                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_2 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_3                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_3 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSCNDe_RegistrationResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSCNDe_RegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSCNDe_RegistrationResponseIEs[index].ValueSize);
   stat = MBMSCNDe_RegistrationResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse_protocolIEs (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSCNDe_RegistrationResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSCNDe_RegistrationResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSCNDe_RegistrationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSCNDe_RegistrationResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSCNDe_RegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSCNDe_RegistrationResponseExtensions[index].ExtensionSize);
   stat = MBMSCNDe_RegistrationResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSCNDe_RegistrationResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSCNDe_RegistrationResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSCNDe_RegistrationResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSCNDe_RegistrationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSCNDe_RegistrationResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABEstablishmentIndicationIEs_Value                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRABEstablishmentIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABEstablishmentIndicationIEs_Value *pvalue = (_MBMSRABEstablishmentIndicationIEs_Value*) pvalue_;

   stat = asn1PD_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABEstablishmentIndication_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABEstablishmentIndication_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABEstablishmentIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABEstablishmentIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABEstablishmentIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABEstablishmentIndicationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRABEstablishmentIndicationIEs[index].ValueSize);
   stat = MBMSRABEstablishmentIndicationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication_protocolIEs (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABEstablishmentIndication_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABEstablishmentIndication_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABEstablishmentIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABEstablishmentIndication_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABEstablishmentIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABEstablishmentIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABEstablishmentIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABEstablishmentIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABEstablishmentIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRABEstablishmentIndicationExtensions[index].ExtensionSize);
   stat = MBMSRABEstablishmentIndicationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication_protocolExtensions (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABEstablishmentIndication_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABEstablishmentIndication_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABEstablishmentIndication_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRABEstablishmentIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRABEstablishmentIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseRequestIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRABReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseRequestIEs_Value *pvalue = (_MBMSRABReleaseRequestIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABReleaseRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRABReleaseRequestIEs[index].ValueSize);
   stat = MBMSRABReleaseRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest_protocolIEs (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABReleaseRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABReleaseRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABReleaseRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRABReleaseRequestExtensions[index].ExtensionSize);
   stat = MBMSRABReleaseRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABReleaseRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABReleaseRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABReleaseRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest (ASN1CTXT* pctxt, MBMSRABReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRABReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRABReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRABReleaseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseIEs_Value *pvalue = (_MBMSRABReleaseIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABRelease_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABRelease_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABRelease_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABRelease_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRABReleaseIEs[index].ValueSize);
   stat = MBMSRABReleaseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease_protocolIEs (ASN1CTXT* pctxt, MBMSRABRelease_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABRelease_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABRelease_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABRelease_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABRelease_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABRelease_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABRelease_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABRelease_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRABReleaseExtensions[index].ExtensionSize);
   stat = MBMSRABReleaseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease_protocolExtensions (ASN1CTXT* pctxt, MBMSRABRelease_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABRelease_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABRelease_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABRelease_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease (ASN1CTXT* pctxt, MBMSRABRelease* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRABRelease_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRABRelease_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseFailureIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRABReleaseFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseFailureIEs_Value *pvalue = (_MBMSRABReleaseFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABReleaseFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABReleaseFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABReleaseFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRABReleaseFailureIEs[index].ValueSize);
   stat = MBMSRABReleaseFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure_protocolIEs (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABReleaseFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABReleaseFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABReleaseFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABReleaseFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABReleaseFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABReleaseFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRABReleaseFailureExtensions[index].ExtensionSize);
   stat = MBMSRABReleaseFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABReleaseFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABReleaseFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABReleaseFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure (ASN1CTXT* pctxt, MBMSRABReleaseFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRABReleaseFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRABReleaseFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

extern void init_Iu_ReleaseCommandIEs(ASN1CTXT *pctxt);
extern void init_Iu_ReleaseCommandExtensions(ASN1CTXT *pctxt);
extern void init_Iu_ReleaseCompleteIEs(ASN1CTXT *pctxt);
extern void init_RAB_DataVolumeReportItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_DataVolumeReportItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_ReleasedItem_IuRelComp_IEs(ASN1CTXT *pctxt);
extern void init_RAB_ReleasedItem_IuRelComp_ExtIEs(ASN1CTXT *pctxt);
extern void init_Iu_ReleaseCompleteExtensions(ASN1CTXT *pctxt);
extern void init_RelocationRequiredIEs(ASN1CTXT *pctxt);
extern void init_RelocationRequiredExtensions(ASN1CTXT *pctxt);
extern void init_RelocationCommandIEs(ASN1CTXT *pctxt);
extern void init_RAB_RelocationReleaseItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_RelocationReleaseItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_DataForwardingItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_DataForwardingItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RelocationCommandExtensions(ASN1CTXT *pctxt);
extern void init_RelocationPreparationFailureIEs(ASN1CTXT *pctxt);
extern void init_RelocationPreparationFailureExtensions(ASN1CTXT *pctxt);
extern void init_RelocationRequestIEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupItem_RelocReq_IEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupItem_RelocReq_ExtIEs(ASN1CTXT *pctxt);
extern void init_UserPlaneInformation_ExtIEs(ASN1CTXT *pctxt);
extern void init_RelocationRequestExtensions(ASN1CTXT *pctxt);
extern void init_CNMBMSLinkingInformation_ExtIEs(ASN1CTXT *pctxt);
extern void init_JoinedMBMSBearerService_ExtIEs(ASN1CTXT *pctxt);
extern void init_RelocationRequestAcknowledgeIEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupItem_RelocReqAck_IEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupItem_RelocReqAck_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_FailedItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_FailedItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RelocationRequestAcknowledgeExtensions(ASN1CTXT *pctxt);
extern void init_RelocationFailureIEs(ASN1CTXT *pctxt);
extern void init_RelocationFailureExtensions(ASN1CTXT *pctxt);
extern void init_RelocationCancelIEs(ASN1CTXT *pctxt);
extern void init_RelocationCancelExtensions(ASN1CTXT *pctxt);
extern void init_RelocationCancelAcknowledgeIEs(ASN1CTXT *pctxt);
extern void init_RelocationCancelAcknowledgeExtensions(ASN1CTXT *pctxt);
extern void init_SRNS_ContextRequestIEs(ASN1CTXT *pctxt);
extern void init_RAB_DataForwardingItem_SRNS_CtxReq_IEs(ASN1CTXT *pctxt);
extern void init_RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs(ASN1CTXT *pctxt);
extern void init_SRNS_ContextRequestExtensions(ASN1CTXT *pctxt);
extern void init_SRNS_ContextResponseIEs(ASN1CTXT *pctxt);
extern void init_RAB_ContextItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_ContextItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RABs_ContextFailedtoTransferItemIEs(ASN1CTXT *pctxt);
extern void init_RABs_ContextFailedtoTransferItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_SRNS_ContextResponseExtensions(ASN1CTXT *pctxt);
extern void init_SecurityModeCommandIEs(ASN1CTXT *pctxt);
extern void init_SecurityModeCommandExtensions(ASN1CTXT *pctxt);
extern void init_SecurityModeCompleteIEs(ASN1CTXT *pctxt);
extern void init_SecurityModeCompleteExtensions(ASN1CTXT *pctxt);
extern void init_SecurityModeRejectIEs(ASN1CTXT *pctxt);
extern void init_SecurityModeRejectExtensions(ASN1CTXT *pctxt);
extern void init_DataVolumeReportRequestIEs(ASN1CTXT *pctxt);
extern void init_RAB_DataVolumeReportRequestItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_DataVolumeReportRequestItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_DataVolumeReportRequestExtensions(ASN1CTXT *pctxt);
extern void init_DataVolumeReportIEs(ASN1CTXT *pctxt);
extern void init_DataVolumeReportExtensions(ASN1CTXT *pctxt);
extern void init_RABs_failed_to_reportItemIEs(ASN1CTXT *pctxt);
extern void init_RABs_failed_to_reportItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_ResetIEs(ASN1CTXT *pctxt);
extern void init_ResetExtensions(ASN1CTXT *pctxt);
extern void init_ResetAcknowledgeIEs(ASN1CTXT *pctxt);
extern void init_ResetAcknowledgeExtensions(ASN1CTXT *pctxt);
extern void init_ResetResourceIEs(ASN1CTXT *pctxt);
extern void init_ResetResourceItemIEs(ASN1CTXT *pctxt);
extern void init_ResetResourceItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_ResetResourceExtensions(ASN1CTXT *pctxt);
extern void init_ResetResourceAcknowledgeIEs(ASN1CTXT *pctxt);
extern void init_ResetResourceAckItemIEs(ASN1CTXT *pctxt);
extern void init_ResetResourceAckItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_ResetResourceAcknowledgeExtensions(ASN1CTXT *pctxt);
extern void init_RAB_ReleaseRequestIEs(ASN1CTXT *pctxt);
extern void init_RAB_ReleaseItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_ReleaseItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_ReleaseRequestExtensions(ASN1CTXT *pctxt);
extern void init_Iu_ReleaseRequestIEs(ASN1CTXT *pctxt);
extern void init_Iu_ReleaseRequestExtensions(ASN1CTXT *pctxt);
extern void init_RelocationDetectIEs(ASN1CTXT *pctxt);
extern void init_RelocationDetectExtensions(ASN1CTXT *pctxt);
extern void init_RelocationCompleteIEs(ASN1CTXT *pctxt);
extern void init_RelocationCompleteExtensions(ASN1CTXT *pctxt);
extern void init_PagingIEs(ASN1CTXT *pctxt);
extern void init_PagingExtensions(ASN1CTXT *pctxt);
extern void init_CommonID_IEs(ASN1CTXT *pctxt);
extern void init_CommonIDExtensions(ASN1CTXT *pctxt);
extern void init_CN_InvokeTraceIEs(ASN1CTXT *pctxt);
extern void init_CN_InvokeTraceExtensions(ASN1CTXT *pctxt);
extern void init_CN_DeactivateTraceIEs(ASN1CTXT *pctxt);
extern void init_CN_DeactivateTraceExtensions(ASN1CTXT *pctxt);
extern void init_LocationReportingControlIEs(ASN1CTXT *pctxt);
extern void init_LocationReportingControlExtensions(ASN1CTXT *pctxt);
extern void init_LocationReportIEs(ASN1CTXT *pctxt);
extern void init_LocationReportExtensions(ASN1CTXT *pctxt);
extern void init_InitialUE_MessageIEs(ASN1CTXT *pctxt);
extern void init_InitialUE_MessageExtensions(ASN1CTXT *pctxt);
extern void init_DirectTransferIEs(ASN1CTXT *pctxt);
extern void init_DirectTransferExtensions(ASN1CTXT *pctxt);
extern void init_RedirectionIndication_IEs(ASN1CTXT *pctxt);
extern void init_OverloadIEs(ASN1CTXT *pctxt);
extern void init_OverloadExtensions(ASN1CTXT *pctxt);
extern void init_ErrorIndicationIEs(ASN1CTXT *pctxt);
extern void init_ErrorIndicationExtensions(ASN1CTXT *pctxt);
extern void init_SRNS_DataForwardCommandIEs(ASN1CTXT *pctxt);
extern void init_SRNS_DataForwardCommandExtensions(ASN1CTXT *pctxt);
extern void init_ForwardSRNS_ContextIEs(ASN1CTXT *pctxt);
extern void init_ForwardSRNS_ContextExtensions(ASN1CTXT *pctxt);
extern void init_RAB_AssignmentRequestIEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupOrModifyItem_IEs(ASN1CTXT *pctxt);
extern void init_TransportLayerInformation_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupOrModifyItemFirst_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupOrModifyItemSecond_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_AssignmentRequestExtensions(ASN1CTXT *pctxt);
extern void init_RAB_AssignmentResponseIEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupOrModifiedItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_SetupOrModifiedItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_ReleasedItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_ReleasedItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_DataVolumeList_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_QueuedItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_QueuedItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_AssignmentResponseExtensions(ASN1CTXT *pctxt);
extern void init_GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs(ASN1CTXT *pctxt);
extern void init_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs(ASN1CTXT *pctxt);
extern void init_PrivateMessage_IEs(ASN1CTXT *pctxt);
extern void init_RANAP_RelocationInformationIEs(ASN1CTXT *pctxt);
extern void init_DirectTransferInformationItemIEs_RANAP_RelocInf(ASN1CTXT *pctxt);
extern void init_RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf(ASN1CTXT *pctxt);
extern void init_RAB_ContextItemIEs_RANAP_RelocInf(ASN1CTXT *pctxt);
extern void init_RAB_ContextItem_ExtIEs_RANAP_RelocInf(ASN1CTXT *pctxt);
extern void init_RANAP_RelocationInformationExtensions(ASN1CTXT *pctxt);
extern void init_RAB_ModifyRequestIEs(ASN1CTXT *pctxt);
extern void init_RAB_ModifyItemIEs(ASN1CTXT *pctxt);
extern void init_RAB_ModifyItem_ExtIEs(ASN1CTXT *pctxt);
extern void init_RAB_ModifyRequestExtensions(ASN1CTXT *pctxt);
extern void init_LocationRelatedDataRequestIEs(ASN1CTXT *pctxt);
extern void init_LocationRelatedDataRequestExtensions(ASN1CTXT *pctxt);
extern void init_LocationRelatedDataResponseIEs(ASN1CTXT *pctxt);
extern void init_LocationRelatedDataResponseExtensions(ASN1CTXT *pctxt);
extern void init_LocationRelatedDataFailureIEs(ASN1CTXT *pctxt);
extern void init_LocationRelatedDataFailureExtensions(ASN1CTXT *pctxt);
extern void init_InformationTransferIndicationIEs(ASN1CTXT *pctxt);
extern void init_InformationTransferIndicationExtensions(ASN1CTXT *pctxt);
extern void init_InformationTransferConfirmationIEs(ASN1CTXT *pctxt);
extern void init_InformationTransferConfirmationExtensions(ASN1CTXT *pctxt);
extern void init_InformationTransferFailureIEs(ASN1CTXT *pctxt);
extern void init_InformationTransferFailureExtensions(ASN1CTXT *pctxt);
extern void init_UESpecificInformationIndicationIEs(ASN1CTXT *pctxt);
extern void init_UESpecificInformationIndicationExtensions(ASN1CTXT *pctxt);
extern void init_DirectInformationTransferIEs(ASN1CTXT *pctxt);
extern void init_DirectInformationTransferExtensions(ASN1CTXT *pctxt);
extern void init_UplinkInformationExchangeRequestIEs(ASN1CTXT *pctxt);
extern void init_UplinkInformationExchangeRequestExtensions(ASN1CTXT *pctxt);
extern void init_UplinkInformationExchangeResponseIEs(ASN1CTXT *pctxt);
extern void init_UplinkInformationExchangeResponseExtensions(ASN1CTXT *pctxt);
extern void init_UplinkInformationExchangeFailureIEs(ASN1CTXT *pctxt);
extern void init_UplinkInformationExchangeFailureExtensions(ASN1CTXT *pctxt);
extern void init_MBMSSessionStartIEs(ASN1CTXT *pctxt);
extern void init_MBMSSessionStartExtensions(ASN1CTXT *pctxt);
extern void init_MBMSSessionStartResponseIEs(ASN1CTXT *pctxt);
extern void init_MBMSSessionStartResponseExtensions(ASN1CTXT *pctxt);
extern void init_MBMSSessionStartFailureIEs(ASN1CTXT *pctxt);
extern void init_MBMSSessionStartFailureExtensions(ASN1CTXT *pctxt);
extern void init_MBMSSessionUpdateIEs(ASN1CTXT *pctxt);
extern void init_MBMSSessionUpdateExtensions(ASN1CTXT *pctxt);
extern void init_MBMSSessionUpdateResponseIEs(ASN1CTXT *pctxt);
extern void init_MBMSSessionUpdateResponseExtensions(ASN1CTXT *pctxt);
extern void init_MBMSSessionUpdateFailureIEs(ASN1CTXT *pctxt);
extern void init_MBMSSessionUpdateFailureExtensions(ASN1CTXT *pctxt);
extern void init_MBMSSessionStopIEs(ASN1CTXT *pctxt);
extern void init_MBMSSessionStopExtensions(ASN1CTXT *pctxt);
extern void init_MBMSSessionStopResponseIEs(ASN1CTXT *pctxt);
extern void init_MBMSSessionStopResponseExtensions(ASN1CTXT *pctxt);
extern void init_MBMSUELinkingRequestIEs(ASN1CTXT *pctxt);
extern void init_LeftMBMSBearerService_ExtIEs(ASN1CTXT *pctxt);
extern void init_MBMSUELinkingRequestExtensions(ASN1CTXT *pctxt);
extern void init_MBMSUELinkingResponseIEs(ASN1CTXT *pctxt);
extern void init_UnsuccessfulLinking_ExtIEs(ASN1CTXT *pctxt);
extern void init_MBMSUELinkingResponseExtensions(ASN1CTXT *pctxt);
extern void init_MBMSRegistrationRequestIEs(ASN1CTXT *pctxt);
extern void init_MBMSRegistrationRequestExtensions(ASN1CTXT *pctxt);
extern void init_MBMSRegistrationResponseIEs(ASN1CTXT *pctxt);
extern void init_MBMSRegistrationResponseExtensions(ASN1CTXT *pctxt);
extern void init_MBMSRegistrationFailureIEs(ASN1CTXT *pctxt);
extern void init_MBMSRegistrationFailureExtensions(ASN1CTXT *pctxt);
extern void init_MBMSCNDe_RegistrationRequestIEs(ASN1CTXT *pctxt);
extern void init_MBMSCNDe_RegistrationRequestExtensions(ASN1CTXT *pctxt);
extern void init_MBMSCNDe_RegistrationResponseIEs(ASN1CTXT *pctxt);
extern void init_MBMSCNDe_RegistrationResponseExtensions(ASN1CTXT *pctxt);
extern void init_MBMSRABEstablishmentIndicationIEs(ASN1CTXT *pctxt);
extern void init_MBMSRABEstablishmentIndicationExtensions(ASN1CTXT *pctxt);
extern void init_MBMSRABReleaseRequestIEs(ASN1CTXT *pctxt);
extern void init_MBMSRABReleaseRequestExtensions(ASN1CTXT *pctxt);
extern void init_MBMSRABReleaseIEs(ASN1CTXT *pctxt);
extern void init_MBMSRABReleaseExtensions(ASN1CTXT *pctxt);
extern void init_MBMSRABReleaseFailureIEs(ASN1CTXT *pctxt);
extern void init_MBMSRABReleaseFailureExtensions(ASN1CTXT *pctxt);

void RANAP_PDU_Contents_init(ASN1CTXT *pctxt)
{
   init_Iu_ReleaseCommandIEs(pctxt);
   init_Iu_ReleaseCommandExtensions(pctxt);
   init_Iu_ReleaseCompleteIEs(pctxt);
   init_RAB_DataVolumeReportItemIEs(pctxt);
   init_RAB_DataVolumeReportItem_ExtIEs(pctxt);
   init_RAB_ReleasedItem_IuRelComp_IEs(pctxt);
   init_RAB_ReleasedItem_IuRelComp_ExtIEs(pctxt);
   init_Iu_ReleaseCompleteExtensions(pctxt);
   init_RelocationRequiredIEs(pctxt);
   init_RelocationRequiredExtensions(pctxt);
   init_RelocationCommandIEs(pctxt);
   init_RAB_RelocationReleaseItemIEs(pctxt);
   init_RAB_RelocationReleaseItem_ExtIEs(pctxt);
   init_RAB_DataForwardingItemIEs(pctxt);
   init_RAB_DataForwardingItem_ExtIEs(pctxt);
   init_RelocationCommandExtensions(pctxt);
   init_RelocationPreparationFailureIEs(pctxt);
   init_RelocationPreparationFailureExtensions(pctxt);
   init_RelocationRequestIEs(pctxt);
   init_RAB_SetupItem_RelocReq_IEs(pctxt);
   init_RAB_SetupItem_RelocReq_ExtIEs(pctxt);
   init_UserPlaneInformation_ExtIEs(pctxt);
   init_RelocationRequestExtensions(pctxt);
   init_CNMBMSLinkingInformation_ExtIEs(pctxt);
   init_JoinedMBMSBearerService_ExtIEs(pctxt);
   init_RelocationRequestAcknowledgeIEs(pctxt);
   init_RAB_SetupItem_RelocReqAck_IEs(pctxt);
   init_RAB_SetupItem_RelocReqAck_ExtIEs(pctxt);
   init_RAB_FailedItemIEs(pctxt);
   init_RAB_FailedItem_ExtIEs(pctxt);
   init_RelocationRequestAcknowledgeExtensions(pctxt);
   init_RelocationFailureIEs(pctxt);
   init_RelocationFailureExtensions(pctxt);
   init_RelocationCancelIEs(pctxt);
   init_RelocationCancelExtensions(pctxt);
   init_RelocationCancelAcknowledgeIEs(pctxt);
   init_RelocationCancelAcknowledgeExtensions(pctxt);
   init_SRNS_ContextRequestIEs(pctxt);
   init_RAB_DataForwardingItem_SRNS_CtxReq_IEs(pctxt);
   init_RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs(pctxt);
   init_SRNS_ContextRequestExtensions(pctxt);
   init_SRNS_ContextResponseIEs(pctxt);
   init_RAB_ContextItemIEs(pctxt);
   init_RAB_ContextItem_ExtIEs(pctxt);
   init_RABs_ContextFailedtoTransferItemIEs(pctxt);
   init_RABs_ContextFailedtoTransferItem_ExtIEs(pctxt);
   init_SRNS_ContextResponseExtensions(pctxt);
   init_SecurityModeCommandIEs(pctxt);
   init_SecurityModeCommandExtensions(pctxt);
   init_SecurityModeCompleteIEs(pctxt);
   init_SecurityModeCompleteExtensions(pctxt);
   init_SecurityModeRejectIEs(pctxt);
   init_SecurityModeRejectExtensions(pctxt);
   init_DataVolumeReportRequestIEs(pctxt);
   init_RAB_DataVolumeReportRequestItemIEs(pctxt);
   init_RAB_DataVolumeReportRequestItem_ExtIEs(pctxt);
   init_DataVolumeReportRequestExtensions(pctxt);
   init_DataVolumeReportIEs(pctxt);
   init_DataVolumeReportExtensions(pctxt);
   init_RABs_failed_to_reportItemIEs(pctxt);
   init_RABs_failed_to_reportItem_ExtIEs(pctxt);
   init_ResetIEs(pctxt);
   init_ResetExtensions(pctxt);
   init_ResetAcknowledgeIEs(pctxt);
   init_ResetAcknowledgeExtensions(pctxt);
   init_ResetResourceIEs(pctxt);
   init_ResetResourceItemIEs(pctxt);
   init_ResetResourceItem_ExtIEs(pctxt);
   init_ResetResourceExtensions(pctxt);
   init_ResetResourceAcknowledgeIEs(pctxt);
   init_ResetResourceAckItemIEs(pctxt);
   init_ResetResourceAckItem_ExtIEs(pctxt);
   init_ResetResourceAcknowledgeExtensions(pctxt);
   init_RAB_ReleaseRequestIEs(pctxt);
   init_RAB_ReleaseItemIEs(pctxt);
   init_RAB_ReleaseItem_ExtIEs(pctxt);
   init_RAB_ReleaseRequestExtensions(pctxt);
   init_Iu_ReleaseRequestIEs(pctxt);
   init_Iu_ReleaseRequestExtensions(pctxt);
   init_RelocationDetectIEs(pctxt);
   init_RelocationDetectExtensions(pctxt);
   init_RelocationCompleteIEs(pctxt);
   init_RelocationCompleteExtensions(pctxt);
   init_PagingIEs(pctxt);
   init_PagingExtensions(pctxt);
   init_CommonID_IEs(pctxt);
   init_CommonIDExtensions(pctxt);
   init_CN_InvokeTraceIEs(pctxt);
   init_CN_InvokeTraceExtensions(pctxt);
   init_CN_DeactivateTraceIEs(pctxt);
   init_CN_DeactivateTraceExtensions(pctxt);
   init_LocationReportingControlIEs(pctxt);
   init_LocationReportingControlExtensions(pctxt);
   init_LocationReportIEs(pctxt);
   init_LocationReportExtensions(pctxt);
   init_InitialUE_MessageIEs(pctxt);
   init_InitialUE_MessageExtensions(pctxt);
   init_DirectTransferIEs(pctxt);
   init_DirectTransferExtensions(pctxt);
   init_RedirectionIndication_IEs(pctxt);
   init_OverloadIEs(pctxt);
   init_OverloadExtensions(pctxt);
   init_ErrorIndicationIEs(pctxt);
   init_ErrorIndicationExtensions(pctxt);
   init_SRNS_DataForwardCommandIEs(pctxt);
   init_SRNS_DataForwardCommandExtensions(pctxt);
   init_ForwardSRNS_ContextIEs(pctxt);
   init_ForwardSRNS_ContextExtensions(pctxt);
   init_RAB_AssignmentRequestIEs(pctxt);
   init_RAB_SetupOrModifyItem_IEs(pctxt);
   init_TransportLayerInformation_ExtIEs(pctxt);
   init_RAB_SetupOrModifyItemFirst_ExtIEs(pctxt);
   init_RAB_SetupOrModifyItemSecond_ExtIEs(pctxt);
   init_RAB_AssignmentRequestExtensions(pctxt);
   init_RAB_AssignmentResponseIEs(pctxt);
   init_RAB_SetupOrModifiedItemIEs(pctxt);
   init_RAB_SetupOrModifiedItem_ExtIEs(pctxt);
   init_RAB_ReleasedItemIEs(pctxt);
   init_RAB_ReleasedItem_ExtIEs(pctxt);
   init_DataVolumeList_ExtIEs(pctxt);
   init_RAB_QueuedItemIEs(pctxt);
   init_RAB_QueuedItem_ExtIEs(pctxt);
   init_RAB_AssignmentResponseExtensions(pctxt);
   init_GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs(pctxt);
   init_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs(pctxt);
   init_PrivateMessage_IEs(pctxt);
   init_RANAP_RelocationInformationIEs(pctxt);
   init_DirectTransferInformationItemIEs_RANAP_RelocInf(pctxt);
   init_RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf(pctxt);
   init_RAB_ContextItemIEs_RANAP_RelocInf(pctxt);
   init_RAB_ContextItem_ExtIEs_RANAP_RelocInf(pctxt);
   init_RANAP_RelocationInformationExtensions(pctxt);
   init_RAB_ModifyRequestIEs(pctxt);
   init_RAB_ModifyItemIEs(pctxt);
   init_RAB_ModifyItem_ExtIEs(pctxt);
   init_RAB_ModifyRequestExtensions(pctxt);
   init_LocationRelatedDataRequestIEs(pctxt);
   init_LocationRelatedDataRequestExtensions(pctxt);
   init_LocationRelatedDataResponseIEs(pctxt);
   init_LocationRelatedDataResponseExtensions(pctxt);
   init_LocationRelatedDataFailureIEs(pctxt);
   init_LocationRelatedDataFailureExtensions(pctxt);
   init_InformationTransferIndicationIEs(pctxt);
   init_InformationTransferIndicationExtensions(pctxt);
   init_InformationTransferConfirmationIEs(pctxt);
   init_InformationTransferConfirmationExtensions(pctxt);
   init_InformationTransferFailureIEs(pctxt);
   init_InformationTransferFailureExtensions(pctxt);
   init_UESpecificInformationIndicationIEs(pctxt);
   init_UESpecificInformationIndicationExtensions(pctxt);
   init_DirectInformationTransferIEs(pctxt);
   init_DirectInformationTransferExtensions(pctxt);
   init_UplinkInformationExchangeRequestIEs(pctxt);
   init_UplinkInformationExchangeRequestExtensions(pctxt);
   init_UplinkInformationExchangeResponseIEs(pctxt);
   init_UplinkInformationExchangeResponseExtensions(pctxt);
   init_UplinkInformationExchangeFailureIEs(pctxt);
   init_UplinkInformationExchangeFailureExtensions(pctxt);
   init_MBMSSessionStartIEs(pctxt);
   init_MBMSSessionStartExtensions(pctxt);
   init_MBMSSessionStartResponseIEs(pctxt);
   init_MBMSSessionStartResponseExtensions(pctxt);
   init_MBMSSessionStartFailureIEs(pctxt);
   init_MBMSSessionStartFailureExtensions(pctxt);
   init_MBMSSessionUpdateIEs(pctxt);
   init_MBMSSessionUpdateExtensions(pctxt);
   init_MBMSSessionUpdateResponseIEs(pctxt);
   init_MBMSSessionUpdateResponseExtensions(pctxt);
   init_MBMSSessionUpdateFailureIEs(pctxt);
   init_MBMSSessionUpdateFailureExtensions(pctxt);
   init_MBMSSessionStopIEs(pctxt);
   init_MBMSSessionStopExtensions(pctxt);
   init_MBMSSessionStopResponseIEs(pctxt);
   init_MBMSSessionStopResponseExtensions(pctxt);
   init_MBMSUELinkingRequestIEs(pctxt);
   init_LeftMBMSBearerService_ExtIEs(pctxt);
   init_MBMSUELinkingRequestExtensions(pctxt);
   init_MBMSUELinkingResponseIEs(pctxt);
   init_UnsuccessfulLinking_ExtIEs(pctxt);
   init_MBMSUELinkingResponseExtensions(pctxt);
   init_MBMSRegistrationRequestIEs(pctxt);
   init_MBMSRegistrationRequestExtensions(pctxt);
   init_MBMSRegistrationResponseIEs(pctxt);
   init_MBMSRegistrationResponseExtensions(pctxt);
   init_MBMSRegistrationFailureIEs(pctxt);
   init_MBMSRegistrationFailureExtensions(pctxt);
   init_MBMSCNDe_RegistrationRequestIEs(pctxt);
   init_MBMSCNDe_RegistrationRequestExtensions(pctxt);
   init_MBMSCNDe_RegistrationResponseIEs(pctxt);
   init_MBMSCNDe_RegistrationResponseExtensions(pctxt);
   init_MBMSRABEstablishmentIndicationIEs(pctxt);
   init_MBMSRABEstablishmentIndicationExtensions(pctxt);
   init_MBMSRABReleaseRequestIEs(pctxt);
   init_MBMSRABReleaseRequestExtensions(pctxt);
   init_MBMSRABReleaseIEs(pctxt);
   init_MBMSRABReleaseExtensions(pctxt);
   init_MBMSRABReleaseFailureIEs(pctxt);
   init_MBMSRABReleaseFailureExtensions(pctxt);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommandIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES Iu_ReleaseCommandIEs[1];
int Iu_ReleaseCommandIEs_Size = 1;

void init_Iu_ReleaseCommandIEs(ASN1CTXT *pctxt)
{

   Iu_ReleaseCommandIEs[0].id = 4;
   Iu_ReleaseCommandIEs[0].criticality = ignore;
   Iu_ReleaseCommandIEs[0].ValueSize = sizeof(_Iu_ReleaseCommandIEs_Value);
   Iu_ReleaseCommandIEs[0].decodeValue = &asn1PD__Iu_ReleaseCommandIEs_Value;
   Iu_ReleaseCommandIEs[0].printValue = &asn1Print__Iu_ReleaseCommandIEs_Value;
   Iu_ReleaseCommandIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommandExtensions                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION Iu_ReleaseCommandExtensions[1];
int Iu_ReleaseCommandExtensions_Size = 0;

void init_Iu_ReleaseCommandExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCompleteIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES Iu_ReleaseCompleteIEs[3];
int Iu_ReleaseCompleteIEs_Size = 3;

void init_Iu_ReleaseCompleteIEs(ASN1CTXT *pctxt)
{

   Iu_ReleaseCompleteIEs[0].id = 31;
   Iu_ReleaseCompleteIEs[0].criticality = ignore;
   Iu_ReleaseCompleteIEs[0].ValueSize = sizeof(_Iu_ReleaseCompleteIEs_Value);
   Iu_ReleaseCompleteIEs[0].decodeValue = &asn1PD__Iu_ReleaseCompleteIEs_Value;
   Iu_ReleaseCompleteIEs[0].printValue = &asn1Print__Iu_ReleaseCompleteIEs_Value;
   Iu_ReleaseCompleteIEs[0].presence = optional;

   Iu_ReleaseCompleteIEs[1].id = 44;
   Iu_ReleaseCompleteIEs[1].criticality = ignore;
   Iu_ReleaseCompleteIEs[1].ValueSize = sizeof(_Iu_ReleaseCompleteIEs_Value_1);
   Iu_ReleaseCompleteIEs[1].decodeValue = &asn1PD__Iu_ReleaseCompleteIEs_Value_1;
   Iu_ReleaseCompleteIEs[1].printValue = &asn1Print__Iu_ReleaseCompleteIEs_Value_1;
   Iu_ReleaseCompleteIEs[1].presence = optional;

   Iu_ReleaseCompleteIEs[2].id = 9;
   Iu_ReleaseCompleteIEs[2].criticality = ignore;
   Iu_ReleaseCompleteIEs[2].ValueSize = sizeof(_Iu_ReleaseCompleteIEs_Value_2);
   Iu_ReleaseCompleteIEs[2].decodeValue = &asn1PD__Iu_ReleaseCompleteIEs_Value_2;
   Iu_ReleaseCompleteIEs[2].printValue = &asn1Print__Iu_ReleaseCompleteIEs_Value_2;
   Iu_ReleaseCompleteIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItemIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_DataVolumeReportItemIEs[1];
int RAB_DataVolumeReportItemIEs_Size = 1;

void init_RAB_DataVolumeReportItemIEs(ASN1CTXT *pctxt)
{

   RAB_DataVolumeReportItemIEs[0].id = 30;
   RAB_DataVolumeReportItemIEs[0].criticality = ignore;
   RAB_DataVolumeReportItemIEs[0].ValueSize = sizeof(_RAB_DataVolumeReportItemIEs_Value);
   RAB_DataVolumeReportItemIEs[0].decodeValue = &asn1PD__RAB_DataVolumeReportItemIEs_Value;
   RAB_DataVolumeReportItemIEs[0].printValue = &asn1Print__RAB_DataVolumeReportItemIEs_Value;
   RAB_DataVolumeReportItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_ExtIEs                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_DataVolumeReportItem_ExtIEs[1];
int RAB_DataVolumeReportItem_ExtIEs_Size = 0;

void init_RAB_DataVolumeReportItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_IEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_ReleasedItem_IuRelComp_IEs[1];
int RAB_ReleasedItem_IuRelComp_IEs_Size = 1;

void init_RAB_ReleasedItem_IuRelComp_IEs(ASN1CTXT *pctxt)
{

   RAB_ReleasedItem_IuRelComp_IEs[0].id = 87;
   RAB_ReleasedItem_IuRelComp_IEs[0].criticality = ignore;
   RAB_ReleasedItem_IuRelComp_IEs[0].ValueSize = sizeof(_RAB_ReleasedItem_IuRelComp_IEs_Value);
   RAB_ReleasedItem_IuRelComp_IEs[0].decodeValue = &asn1PD__RAB_ReleasedItem_IuRelComp_IEs_Value;
   RAB_ReleasedItem_IuRelComp_IEs[0].printValue = &asn1Print__RAB_ReleasedItem_IuRelComp_IEs_Value;
   RAB_ReleasedItem_IuRelComp_IEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_ExtIEs                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_ReleasedItem_IuRelComp_ExtIEs[1];
int RAB_ReleasedItem_IuRelComp_ExtIEs_Size = 0;

void init_RAB_ReleasedItem_IuRelComp_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCompleteExtensions                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION Iu_ReleaseCompleteExtensions[1];
int Iu_ReleaseCompleteExtensions_Size = 0;

void init_Iu_ReleaseCompleteExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationRequiredIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationRequiredIEs[8];
int RelocationRequiredIEs_Size = 8;

void init_RelocationRequiredIEs(ASN1CTXT *pctxt)
{

   RelocationRequiredIEs[0].id = 56;
   RelocationRequiredIEs[0].criticality = reject;
   RelocationRequiredIEs[0].ValueSize = sizeof(_RelocationRequiredIEs_Value);
   RelocationRequiredIEs[0].decodeValue = &asn1PD__RelocationRequiredIEs_Value;
   RelocationRequiredIEs[0].printValue = &asn1Print__RelocationRequiredIEs_Value;
   RelocationRequiredIEs[0].presence = mandatory;

   RelocationRequiredIEs[1].id = 4;
   RelocationRequiredIEs[1].criticality = ignore;
   RelocationRequiredIEs[1].ValueSize = sizeof(_RelocationRequiredIEs_Value_1);
   RelocationRequiredIEs[1].decodeValue = &asn1PD__RelocationRequiredIEs_Value_1;
   RelocationRequiredIEs[1].printValue = &asn1Print__RelocationRequiredIEs_Value_1;
   RelocationRequiredIEs[1].presence = mandatory;

   RelocationRequiredIEs[2].id = 60;
   RelocationRequiredIEs[2].criticality = ignore;
   RelocationRequiredIEs[2].ValueSize = sizeof(_RelocationRequiredIEs_Value_2);
   RelocationRequiredIEs[2].decodeValue = &asn1PD__RelocationRequiredIEs_Value_2;
   RelocationRequiredIEs[2].printValue = &asn1Print__RelocationRequiredIEs_Value_2;
   RelocationRequiredIEs[2].presence = mandatory;

   RelocationRequiredIEs[3].id = 62;
   RelocationRequiredIEs[3].criticality = reject;
   RelocationRequiredIEs[3].ValueSize = sizeof(_RelocationRequiredIEs_Value_3);
   RelocationRequiredIEs[3].decodeValue = &asn1PD__RelocationRequiredIEs_Value_3;
   RelocationRequiredIEs[3].printValue = &asn1Print__RelocationRequiredIEs_Value_3;
   RelocationRequiredIEs[3].presence = mandatory;

   RelocationRequiredIEs[4].id = 7;
   RelocationRequiredIEs[4].criticality = reject;
   RelocationRequiredIEs[4].ValueSize = sizeof(_RelocationRequiredIEs_Value_4);
   RelocationRequiredIEs[4].decodeValue = &asn1PD__RelocationRequiredIEs_Value_4;
   RelocationRequiredIEs[4].printValue = &asn1Print__RelocationRequiredIEs_Value_4;
   RelocationRequiredIEs[4].presence = conditional;

   RelocationRequiredIEs[5].id = 8;
   RelocationRequiredIEs[5].criticality = ignore;
   RelocationRequiredIEs[5].ValueSize = sizeof(_RelocationRequiredIEs_Value_5);
   RelocationRequiredIEs[5].decodeValue = &asn1PD__RelocationRequiredIEs_Value_5;
   RelocationRequiredIEs[5].printValue = &asn1Print__RelocationRequiredIEs_Value_5;
   RelocationRequiredIEs[5].presence = conditional;

   RelocationRequiredIEs[6].id = 61;
   RelocationRequiredIEs[6].criticality = reject;
   RelocationRequiredIEs[6].ValueSize = sizeof(_RelocationRequiredIEs_Value_6);
   RelocationRequiredIEs[6].decodeValue = &asn1PD__RelocationRequiredIEs_Value_6;
   RelocationRequiredIEs[6].printValue = &asn1Print__RelocationRequiredIEs_Value_6;
   RelocationRequiredIEs[6].presence = conditional;

   RelocationRequiredIEs[7].id = 20;
   RelocationRequiredIEs[7].criticality = ignore;
   RelocationRequiredIEs[7].ValueSize = sizeof(_RelocationRequiredIEs_Value_7);
   RelocationRequiredIEs[7].decodeValue = &asn1PD__RelocationRequiredIEs_Value_7;
   RelocationRequiredIEs[7].printValue = &asn1Print__RelocationRequiredIEs_Value_7;
   RelocationRequiredIEs[7].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationRequiredExtensions                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationRequiredExtensions[2];
int RelocationRequiredExtensions_Size = 2;

void init_RelocationRequiredExtensions(ASN1CTXT *pctxt)
{

   RelocationRequiredExtensions[0].id = 108;
   RelocationRequiredExtensions[0].criticality = ignore;
   RelocationRequiredExtensions[0].ExtensionSize = sizeof(_RelocationRequiredExtensions_Extension);
   RelocationRequiredExtensions[0].decodeExtension = &asn1PD__RelocationRequiredExtensions_Extension;
   RelocationRequiredExtensions[0].printExtension = &asn1Print__RelocationRequiredExtensions_Extension;
   RelocationRequiredExtensions[0].presence = optional;

   RelocationRequiredExtensions[1].id = 161;
   RelocationRequiredExtensions[1].criticality = ignore;
   RelocationRequiredExtensions[1].ExtensionSize = sizeof(_RelocationRequiredExtensions_Extension_1);
   RelocationRequiredExtensions[1].decodeExtension = &asn1PD__RelocationRequiredExtensions_Extension_1;
   RelocationRequiredExtensions[1].printExtension = &asn1Print__RelocationRequiredExtensions_Extension_1;
   RelocationRequiredExtensions[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationCommandIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationCommandIEs[5];
int RelocationCommandIEs_Size = 5;

void init_RelocationCommandIEs(ASN1CTXT *pctxt)
{

   RelocationCommandIEs[0].id = 63;
   RelocationCommandIEs[0].criticality = reject;
   RelocationCommandIEs[0].ValueSize = sizeof(_RelocationCommandIEs_Value);
   RelocationCommandIEs[0].decodeValue = &asn1PD__RelocationCommandIEs_Value;
   RelocationCommandIEs[0].printValue = &asn1Print__RelocationCommandIEs_Value;
   RelocationCommandIEs[0].presence = optional;

   RelocationCommandIEs[1].id = 14;
   RelocationCommandIEs[1].criticality = ignore;
   RelocationCommandIEs[1].ValueSize = sizeof(_RelocationCommandIEs_Value_1);
   RelocationCommandIEs[1].decodeValue = &asn1PD__RelocationCommandIEs_Value_1;
   RelocationCommandIEs[1].printValue = &asn1Print__RelocationCommandIEs_Value_1;
   RelocationCommandIEs[1].presence = optional;

   RelocationCommandIEs[2].id = 46;
   RelocationCommandIEs[2].criticality = ignore;
   RelocationCommandIEs[2].ValueSize = sizeof(_RelocationCommandIEs_Value_2);
   RelocationCommandIEs[2].decodeValue = &asn1PD__RelocationCommandIEs_Value_2;
   RelocationCommandIEs[2].printValue = &asn1Print__RelocationCommandIEs_Value_2;
   RelocationCommandIEs[2].presence = optional;

   RelocationCommandIEs[3].id = 28;
   RelocationCommandIEs[3].criticality = ignore;
   RelocationCommandIEs[3].ValueSize = sizeof(_RelocationCommandIEs_Value_3);
   RelocationCommandIEs[3].decodeValue = &asn1PD__RelocationCommandIEs_Value_3;
   RelocationCommandIEs[3].printValue = &asn1Print__RelocationCommandIEs_Value_3;
   RelocationCommandIEs[3].presence = optional;

   RelocationCommandIEs[4].id = 9;
   RelocationCommandIEs[4].criticality = ignore;
   RelocationCommandIEs[4].ValueSize = sizeof(_RelocationCommandIEs_Value_4);
   RelocationCommandIEs[4].decodeValue = &asn1PD__RelocationCommandIEs_Value_4;
   RelocationCommandIEs[4].printValue = &asn1Print__RelocationCommandIEs_Value_4;
   RelocationCommandIEs[4].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItemIEs                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_RelocationReleaseItemIEs[1];
int RAB_RelocationReleaseItemIEs_Size = 1;

void init_RAB_RelocationReleaseItemIEs(ASN1CTXT *pctxt)
{

   RAB_RelocationReleaseItemIEs[0].id = 45;
   RAB_RelocationReleaseItemIEs[0].criticality = ignore;
   RAB_RelocationReleaseItemIEs[0].ValueSize = sizeof(_RAB_RelocationReleaseItemIEs_Value);
   RAB_RelocationReleaseItemIEs[0].decodeValue = &asn1PD__RAB_RelocationReleaseItemIEs_Value;
   RAB_RelocationReleaseItemIEs[0].printValue = &asn1Print__RAB_RelocationReleaseItemIEs_Value;
   RAB_RelocationReleaseItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_ExtIEs                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_RelocationReleaseItem_ExtIEs[1];
int RAB_RelocationReleaseItem_ExtIEs_Size = 0;

void init_RAB_RelocationReleaseItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItemIEs                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_DataForwardingItemIEs[1];
int RAB_DataForwardingItemIEs_Size = 1;

void init_RAB_DataForwardingItemIEs(ASN1CTXT *pctxt)
{

   RAB_DataForwardingItemIEs[0].id = 26;
   RAB_DataForwardingItemIEs[0].criticality = ignore;
   RAB_DataForwardingItemIEs[0].ValueSize = sizeof(_RAB_DataForwardingItemIEs_Value);
   RAB_DataForwardingItemIEs[0].decodeValue = &asn1PD__RAB_DataForwardingItemIEs_Value;
   RAB_DataForwardingItemIEs[0].printValue = &asn1Print__RAB_DataForwardingItemIEs_Value;
   RAB_DataForwardingItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_ExtIEs                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_DataForwardingItem_ExtIEs[2];
int RAB_DataForwardingItem_ExtIEs_Size = 2;

void init_RAB_DataForwardingItem_ExtIEs(ASN1CTXT *pctxt)
{

   RAB_DataForwardingItem_ExtIEs[0].id = 67;
   RAB_DataForwardingItem_ExtIEs[0].criticality = ignore;
   RAB_DataForwardingItem_ExtIEs[0].ExtensionSize = sizeof(_RAB_DataForwardingItem_ExtIEs_Extension);
   RAB_DataForwardingItem_ExtIEs[0].decodeExtension = &asn1PD__RAB_DataForwardingItem_ExtIEs_Extension;
   RAB_DataForwardingItem_ExtIEs[0].printExtension = &asn1Print__RAB_DataForwardingItem_ExtIEs_Extension;
   RAB_DataForwardingItem_ExtIEs[0].presence = optional;

   RAB_DataForwardingItem_ExtIEs[1].id = 13;
   RAB_DataForwardingItem_ExtIEs[1].criticality = ignore;
   RAB_DataForwardingItem_ExtIEs[1].ExtensionSize = sizeof(_RAB_DataForwardingItem_ExtIEs_Extension_1);
   RAB_DataForwardingItem_ExtIEs[1].decodeExtension = &asn1PD__RAB_DataForwardingItem_ExtIEs_Extension_1;
   RAB_DataForwardingItem_ExtIEs[1].printExtension = &asn1Print__RAB_DataForwardingItem_ExtIEs_Extension_1;
   RAB_DataForwardingItem_ExtIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationCommandExtensions                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationCommandExtensions[2];
int RelocationCommandExtensions_Size = 2;

void init_RelocationCommandExtensions(ASN1CTXT *pctxt)
{

   RelocationCommandExtensions[0].id = 99;
   RelocationCommandExtensions[0].criticality = ignore;
   RelocationCommandExtensions[0].ExtensionSize = sizeof(_RelocationCommandExtensions_Extension);
   RelocationCommandExtensions[0].decodeExtension = &asn1PD__RelocationCommandExtensions_Extension;
   RelocationCommandExtensions[0].printExtension = &asn1Print__RelocationCommandExtensions_Extension;
   RelocationCommandExtensions[0].presence = optional;

   RelocationCommandExtensions[1].id = 162;
   RelocationCommandExtensions[1].criticality = ignore;
   RelocationCommandExtensions[1].ExtensionSize = sizeof(_RelocationCommandExtensions_Extension_1);
   RelocationCommandExtensions[1].decodeExtension = &asn1PD__RelocationCommandExtensions_Extension_1;
   RelocationCommandExtensions[1].printExtension = &asn1Print__RelocationCommandExtensions_Extension_1;
   RelocationCommandExtensions[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailureIEs                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationPreparationFailureIEs[2];
int RelocationPreparationFailureIEs_Size = 2;

void init_RelocationPreparationFailureIEs(ASN1CTXT *pctxt)
{

   RelocationPreparationFailureIEs[0].id = 4;
   RelocationPreparationFailureIEs[0].criticality = ignore;
   RelocationPreparationFailureIEs[0].ValueSize = sizeof(_RelocationPreparationFailureIEs_Value);
   RelocationPreparationFailureIEs[0].decodeValue = &asn1PD__RelocationPreparationFailureIEs_Value;
   RelocationPreparationFailureIEs[0].printValue = &asn1Print__RelocationPreparationFailureIEs_Value;
   RelocationPreparationFailureIEs[0].presence = mandatory;

   RelocationPreparationFailureIEs[1].id = 9;
   RelocationPreparationFailureIEs[1].criticality = ignore;
   RelocationPreparationFailureIEs[1].ValueSize = sizeof(_RelocationPreparationFailureIEs_Value_1);
   RelocationPreparationFailureIEs[1].decodeValue = &asn1PD__RelocationPreparationFailureIEs_Value_1;
   RelocationPreparationFailureIEs[1].printValue = &asn1Print__RelocationPreparationFailureIEs_Value_1;
   RelocationPreparationFailureIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailureExtensions                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationPreparationFailureExtensions[1];
int RelocationPreparationFailureExtensions_Size = 1;

void init_RelocationPreparationFailureExtensions(ASN1CTXT *pctxt)
{

   RelocationPreparationFailureExtensions[0].id = 99;
   RelocationPreparationFailureExtensions[0].criticality = ignore;
   RelocationPreparationFailureExtensions[0].ExtensionSize = sizeof(_RelocationPreparationFailureExtensions_Extension);
   RelocationPreparationFailureExtensions[0].decodeExtension = &asn1PD__RelocationPreparationFailureExtensions_Extension;
   RelocationPreparationFailureExtensions[0].printExtension = &asn1Print__RelocationPreparationFailureExtensions_Extension;
   RelocationPreparationFailureExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationRequestIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationRequestIEs[8];
int RelocationRequestIEs_Size = 8;

void init_RelocationRequestIEs(ASN1CTXT *pctxt)
{

   RelocationRequestIEs[0].id = 23;
   RelocationRequestIEs[0].criticality = ignore;
   RelocationRequestIEs[0].ValueSize = sizeof(_RelocationRequestIEs_Value);
   RelocationRequestIEs[0].decodeValue = &asn1PD__RelocationRequestIEs_Value;
   RelocationRequestIEs[0].printValue = &asn1Print__RelocationRequestIEs_Value;
   RelocationRequestIEs[0].presence = optional;

   RelocationRequestIEs[1].id = 4;
   RelocationRequestIEs[1].criticality = ignore;
   RelocationRequestIEs[1].ValueSize = sizeof(_RelocationRequestIEs_Value_1);
   RelocationRequestIEs[1].decodeValue = &asn1PD__RelocationRequestIEs_Value_1;
   RelocationRequestIEs[1].printValue = &asn1Print__RelocationRequestIEs_Value_1;
   RelocationRequestIEs[1].presence = mandatory;

   RelocationRequestIEs[2].id = 3;
   RelocationRequestIEs[2].criticality = reject;
   RelocationRequestIEs[2].ValueSize = sizeof(_RelocationRequestIEs_Value_2);
   RelocationRequestIEs[2].decodeValue = &asn1PD__RelocationRequestIEs_Value_2;
   RelocationRequestIEs[2].printValue = &asn1Print__RelocationRequestIEs_Value_2;
   RelocationRequestIEs[2].presence = mandatory;

   RelocationRequestIEs[3].id = 61;
   RelocationRequestIEs[3].criticality = reject;
   RelocationRequestIEs[3].ValueSize = sizeof(_RelocationRequestIEs_Value_3);
   RelocationRequestIEs[3].decodeValue = &asn1PD__RelocationRequestIEs_Value_3;
   RelocationRequestIEs[3].printValue = &asn1Print__RelocationRequestIEs_Value_3;
   RelocationRequestIEs[3].presence = mandatory;

   RelocationRequestIEs[4].id = 49;
   RelocationRequestIEs[4].criticality = reject;
   RelocationRequestIEs[4].ValueSize = sizeof(_RelocationRequestIEs_Value_4);
   RelocationRequestIEs[4].decodeValue = &asn1PD__RelocationRequestIEs_Value_4;
   RelocationRequestIEs[4].printValue = &asn1Print__RelocationRequestIEs_Value_4;
   RelocationRequestIEs[4].presence = optional;

   RelocationRequestIEs[5].id = 12;
   RelocationRequestIEs[5].criticality = ignore;
   RelocationRequestIEs[5].ValueSize = sizeof(_RelocationRequestIEs_Value_5);
   RelocationRequestIEs[5].decodeValue = &asn1PD__RelocationRequestIEs_Value_5;
   RelocationRequestIEs[5].printValue = &asn1Print__RelocationRequestIEs_Value_5;
   RelocationRequestIEs[5].presence = optional;

   RelocationRequestIEs[6].id = 11;
   RelocationRequestIEs[6].criticality = ignore;
   RelocationRequestIEs[6].ValueSize = sizeof(_RelocationRequestIEs_Value_6);
   RelocationRequestIEs[6].decodeValue = &asn1PD__RelocationRequestIEs_Value_6;
   RelocationRequestIEs[6].printValue = &asn1Print__RelocationRequestIEs_Value_6;
   RelocationRequestIEs[6].presence = optional;

   RelocationRequestIEs[7].id = 79;
   RelocationRequestIEs[7].criticality = ignore;
   RelocationRequestIEs[7].ValueSize = sizeof(_RelocationRequestIEs_Value_7);
   RelocationRequestIEs[7].decodeValue = &asn1PD__RelocationRequestIEs_Value_7;
   RelocationRequestIEs[7].printValue = &asn1Print__RelocationRequestIEs_Value_7;
   RelocationRequestIEs[7].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_IEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_SetupItem_RelocReq_IEs[1];
int RAB_SetupItem_RelocReq_IEs_Size = 1;

void init_RAB_SetupItem_RelocReq_IEs(ASN1CTXT *pctxt)
{

   RAB_SetupItem_RelocReq_IEs[0].id = 47;
   RAB_SetupItem_RelocReq_IEs[0].criticality = reject;
   RAB_SetupItem_RelocReq_IEs[0].ValueSize = sizeof(_RAB_SetupItem_RelocReq_IEs_Value);
   RAB_SetupItem_RelocReq_IEs[0].decodeValue = &asn1PD__RAB_SetupItem_RelocReq_IEs_Value;
   RAB_SetupItem_RelocReq_IEs[0].printValue = &asn1Print__RAB_SetupItem_RelocReq_IEs_Value;
   RAB_SetupItem_RelocReq_IEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_ExtIEs                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_SetupItem_RelocReq_ExtIEs[2];
int RAB_SetupItem_RelocReq_ExtIEs_Size = 2;

void init_RAB_SetupItem_RelocReq_ExtIEs(ASN1CTXT *pctxt)
{

   RAB_SetupItem_RelocReq_ExtIEs[0].id = 89;
   RAB_SetupItem_RelocReq_ExtIEs[0].criticality = ignore;
   RAB_SetupItem_RelocReq_ExtIEs[0].ExtensionSize = sizeof(_RAB_SetupItem_RelocReq_ExtIEs_Extension);
   RAB_SetupItem_RelocReq_ExtIEs[0].decodeExtension = &asn1PD__RAB_SetupItem_RelocReq_ExtIEs_Extension;
   RAB_SetupItem_RelocReq_ExtIEs[0].printExtension = &asn1Print__RAB_SetupItem_RelocReq_ExtIEs_Extension;
   RAB_SetupItem_RelocReq_ExtIEs[0].presence = optional;

   RAB_SetupItem_RelocReq_ExtIEs[1].id = 107;
   RAB_SetupItem_RelocReq_ExtIEs[1].criticality = ignore;
   RAB_SetupItem_RelocReq_ExtIEs[1].ExtensionSize = sizeof(_RAB_SetupItem_RelocReq_ExtIEs_Extension_1);
   RAB_SetupItem_RelocReq_ExtIEs[1].decodeExtension = &asn1PD__RAB_SetupItem_RelocReq_ExtIEs_Extension_1;
   RAB_SetupItem_RelocReq_ExtIEs[1].printExtension = &asn1Print__RAB_SetupItem_RelocReq_ExtIEs_Extension_1;
   RAB_SetupItem_RelocReq_ExtIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_ExtIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION UserPlaneInformation_ExtIEs[1];
int UserPlaneInformation_ExtIEs_Size = 0;

void init_UserPlaneInformation_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationRequestExtensions                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationRequestExtensions[5];
int RelocationRequestExtensions_Size = 5;

void init_RelocationRequestExtensions(ASN1CTXT *pctxt)
{

   RelocationRequestExtensions[0].id = 96;
   RelocationRequestExtensions[0].criticality = reject;
   RelocationRequestExtensions[0].ExtensionSize = sizeof(_RelocationRequestExtensions_Extension);
   RelocationRequestExtensions[0].decodeExtension = &asn1PD__RelocationRequestExtensions_Extension;
   RelocationRequestExtensions[0].printExtension = &asn1Print__RelocationRequestExtensions_Extension;
   RelocationRequestExtensions[0].presence = optional;

   RelocationRequestExtensions[1].id = 105;
   RelocationRequestExtensions[1].criticality = ignore;
   RelocationRequestExtensions[1].ExtensionSize = sizeof(_RelocationRequestExtensions_Extension_1);
   RelocationRequestExtensions[1].decodeExtension = &asn1PD__RelocationRequestExtensions_Extension_1;
   RelocationRequestExtensions[1].printExtension = &asn1Print__RelocationRequestExtensions_Extension_1;
   RelocationRequestExtensions[1].presence = optional;

   RelocationRequestExtensions[2].id = 118;
   RelocationRequestExtensions[2].criticality = ignore;
   RelocationRequestExtensions[2].ExtensionSize = sizeof(_RelocationRequestExtensions_Extension_2);
   RelocationRequestExtensions[2].decodeExtension = &asn1PD__RelocationRequestExtensions_Extension_2;
   RelocationRequestExtensions[2].printExtension = &asn1Print__RelocationRequestExtensions_Extension_2;
   RelocationRequestExtensions[2].presence = optional;

   RelocationRequestExtensions[3].id = 127;
   RelocationRequestExtensions[3].criticality = ignore;
   RelocationRequestExtensions[3].ExtensionSize = sizeof(_RelocationRequestExtensions_Extension_3);
   RelocationRequestExtensions[3].decodeExtension = &asn1PD__RelocationRequestExtensions_Extension_3;
   RelocationRequestExtensions[3].printExtension = &asn1Print__RelocationRequestExtensions_Extension_3;
   RelocationRequestExtensions[3].presence = optional;

   RelocationRequestExtensions[4].id = 133;
   RelocationRequestExtensions[4].criticality = ignore;
   RelocationRequestExtensions[4].ExtensionSize = sizeof(_RelocationRequestExtensions_Extension_4);
   RelocationRequestExtensions[4].decodeExtension = &asn1PD__RelocationRequestExtensions_Extension_4;
   RelocationRequestExtensions[4].printExtension = &asn1Print__RelocationRequestExtensions_Extension_4;
   RelocationRequestExtensions[4].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_ExtIEs                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CNMBMSLinkingInformation_ExtIEs[1];
int CNMBMSLinkingInformation_ExtIEs_Size = 0;

void init_CNMBMSLinkingInformation_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_ExtIEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION JoinedMBMSBearerService_ExtIEs[1];
int JoinedMBMSBearerService_ExtIEs_Size = 0;

void init_JoinedMBMSBearerService_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledgeIEs                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationRequestAcknowledgeIEs[6];
int RelocationRequestAcknowledgeIEs_Size = 6;

void init_RelocationRequestAcknowledgeIEs(ASN1CTXT *pctxt)
{

   RelocationRequestAcknowledgeIEs[0].id = 63;
   RelocationRequestAcknowledgeIEs[0].criticality = ignore;
   RelocationRequestAcknowledgeIEs[0].ValueSize = sizeof(_RelocationRequestAcknowledgeIEs_Value);
   RelocationRequestAcknowledgeIEs[0].decodeValue = &asn1PD__RelocationRequestAcknowledgeIEs_Value;
   RelocationRequestAcknowledgeIEs[0].printValue = &asn1Print__RelocationRequestAcknowledgeIEs_Value;
   RelocationRequestAcknowledgeIEs[0].presence = optional;

   RelocationRequestAcknowledgeIEs[1].id = 50;
   RelocationRequestAcknowledgeIEs[1].criticality = ignore;
   RelocationRequestAcknowledgeIEs[1].ValueSize = sizeof(_RelocationRequestAcknowledgeIEs_Value_1);
   RelocationRequestAcknowledgeIEs[1].decodeValue = &asn1PD__RelocationRequestAcknowledgeIEs_Value_1;
   RelocationRequestAcknowledgeIEs[1].printValue = &asn1Print__RelocationRequestAcknowledgeIEs_Value_1;
   RelocationRequestAcknowledgeIEs[1].presence = optional;

   RelocationRequestAcknowledgeIEs[2].id = 35;
   RelocationRequestAcknowledgeIEs[2].criticality = ignore;
   RelocationRequestAcknowledgeIEs[2].ValueSize = sizeof(_RelocationRequestAcknowledgeIEs_Value_2);
   RelocationRequestAcknowledgeIEs[2].decodeValue = &asn1PD__RelocationRequestAcknowledgeIEs_Value_2;
   RelocationRequestAcknowledgeIEs[2].printValue = &asn1Print__RelocationRequestAcknowledgeIEs_Value_2;
   RelocationRequestAcknowledgeIEs[2].presence = optional;

   RelocationRequestAcknowledgeIEs[3].id = 6;
   RelocationRequestAcknowledgeIEs[3].criticality = ignore;
   RelocationRequestAcknowledgeIEs[3].ValueSize = sizeof(_RelocationRequestAcknowledgeIEs_Value_3);
   RelocationRequestAcknowledgeIEs[3].decodeValue = &asn1PD__RelocationRequestAcknowledgeIEs_Value_3;
   RelocationRequestAcknowledgeIEs[3].printValue = &asn1Print__RelocationRequestAcknowledgeIEs_Value_3;
   RelocationRequestAcknowledgeIEs[3].presence = optional;

   RelocationRequestAcknowledgeIEs[4].id = 5;
   RelocationRequestAcknowledgeIEs[4].criticality = ignore;
   RelocationRequestAcknowledgeIEs[4].ValueSize = sizeof(_RelocationRequestAcknowledgeIEs_Value_4);
   RelocationRequestAcknowledgeIEs[4].decodeValue = &asn1PD__RelocationRequestAcknowledgeIEs_Value_4;
   RelocationRequestAcknowledgeIEs[4].printValue = &asn1Print__RelocationRequestAcknowledgeIEs_Value_4;
   RelocationRequestAcknowledgeIEs[4].presence = optional;

   RelocationRequestAcknowledgeIEs[5].id = 9;
   RelocationRequestAcknowledgeIEs[5].criticality = ignore;
   RelocationRequestAcknowledgeIEs[5].ValueSize = sizeof(_RelocationRequestAcknowledgeIEs_Value_5);
   RelocationRequestAcknowledgeIEs[5].decodeValue = &asn1PD__RelocationRequestAcknowledgeIEs_Value_5;
   RelocationRequestAcknowledgeIEs[5].printValue = &asn1Print__RelocationRequestAcknowledgeIEs_Value_5;
   RelocationRequestAcknowledgeIEs[5].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_IEs                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_SetupItem_RelocReqAck_IEs[1];
int RAB_SetupItem_RelocReqAck_IEs_Size = 1;

void init_RAB_SetupItem_RelocReqAck_IEs(ASN1CTXT *pctxt)
{

   RAB_SetupItem_RelocReqAck_IEs[0].id = 48;
   RAB_SetupItem_RelocReqAck_IEs[0].criticality = reject;
   RAB_SetupItem_RelocReqAck_IEs[0].ValueSize = sizeof(_RAB_SetupItem_RelocReqAck_IEs_Value);
   RAB_SetupItem_RelocReqAck_IEs[0].decodeValue = &asn1PD__RAB_SetupItem_RelocReqAck_IEs_Value;
   RAB_SetupItem_RelocReqAck_IEs[0].printValue = &asn1Print__RAB_SetupItem_RelocReqAck_IEs_Value;
   RAB_SetupItem_RelocReqAck_IEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_ExtIEs                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_SetupItem_RelocReqAck_ExtIEs[3];
int RAB_SetupItem_RelocReqAck_ExtIEs_Size = 3;

void init_RAB_SetupItem_RelocReqAck_ExtIEs(ASN1CTXT *pctxt)
{

   RAB_SetupItem_RelocReqAck_ExtIEs[0].id = 90;
   RAB_SetupItem_RelocReqAck_ExtIEs[0].criticality = ignore;
   RAB_SetupItem_RelocReqAck_ExtIEs[0].ExtensionSize = sizeof(_RAB_SetupItem_RelocReqAck_ExtIEs_Extension);
   RAB_SetupItem_RelocReqAck_ExtIEs[0].decodeExtension = &asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension;
   RAB_SetupItem_RelocReqAck_ExtIEs[0].printExtension = &asn1Print__RAB_SetupItem_RelocReqAck_ExtIEs_Extension;
   RAB_SetupItem_RelocReqAck_ExtIEs[0].presence = optional;

   RAB_SetupItem_RelocReqAck_ExtIEs[1].id = 67;
   RAB_SetupItem_RelocReqAck_ExtIEs[1].criticality = ignore;
   RAB_SetupItem_RelocReqAck_ExtIEs[1].ExtensionSize = sizeof(_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1);
   RAB_SetupItem_RelocReqAck_ExtIEs[1].decodeExtension = &asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1;
   RAB_SetupItem_RelocReqAck_ExtIEs[1].printExtension = &asn1Print__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1;
   RAB_SetupItem_RelocReqAck_ExtIEs[1].presence = optional;

   RAB_SetupItem_RelocReqAck_ExtIEs[2].id = 13;
   RAB_SetupItem_RelocReqAck_ExtIEs[2].criticality = ignore;
   RAB_SetupItem_RelocReqAck_ExtIEs[2].ExtensionSize = sizeof(_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2);
   RAB_SetupItem_RelocReqAck_ExtIEs[2].decodeExtension = &asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2;
   RAB_SetupItem_RelocReqAck_ExtIEs[2].printExtension = &asn1Print__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2;
   RAB_SetupItem_RelocReqAck_ExtIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItemIEs                                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_FailedItemIEs[1];
int RAB_FailedItemIEs_Size = 1;

void init_RAB_FailedItemIEs(ASN1CTXT *pctxt)
{

   RAB_FailedItemIEs[0].id = 34;
   RAB_FailedItemIEs[0].criticality = ignore;
   RAB_FailedItemIEs[0].ValueSize = sizeof(_RAB_FailedItemIEs_Value);
   RAB_FailedItemIEs[0].decodeValue = &asn1PD__RAB_FailedItemIEs_Value;
   RAB_FailedItemIEs[0].printValue = &asn1Print__RAB_FailedItemIEs_Value;
   RAB_FailedItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_ExtIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_FailedItem_ExtIEs[1];
int RAB_FailedItem_ExtIEs_Size = 0;

void init_RAB_FailedItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledgeExtensions                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationRequestAcknowledgeExtensions[1];
int RelocationRequestAcknowledgeExtensions_Size = 1;

void init_RelocationRequestAcknowledgeExtensions(ASN1CTXT *pctxt)
{

   RelocationRequestAcknowledgeExtensions[0].id = 100;
   RelocationRequestAcknowledgeExtensions[0].criticality = ignore;
   RelocationRequestAcknowledgeExtensions[0].ExtensionSize = sizeof(_RelocationRequestAcknowledgeExtensions_Extension);
   RelocationRequestAcknowledgeExtensions[0].decodeExtension = &asn1PD__RelocationRequestAcknowledgeExtensions_Extension;
   RelocationRequestAcknowledgeExtensions[0].printExtension = &asn1Print__RelocationRequestAcknowledgeExtensions_Extension;
   RelocationRequestAcknowledgeExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationFailureIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationFailureIEs[2];
int RelocationFailureIEs_Size = 2;

void init_RelocationFailureIEs(ASN1CTXT *pctxt)
{

   RelocationFailureIEs[0].id = 4;
   RelocationFailureIEs[0].criticality = ignore;
   RelocationFailureIEs[0].ValueSize = sizeof(_RelocationFailureIEs_Value);
   RelocationFailureIEs[0].decodeValue = &asn1PD__RelocationFailureIEs_Value;
   RelocationFailureIEs[0].printValue = &asn1Print__RelocationFailureIEs_Value;
   RelocationFailureIEs[0].presence = mandatory;

   RelocationFailureIEs[1].id = 9;
   RelocationFailureIEs[1].criticality = ignore;
   RelocationFailureIEs[1].ValueSize = sizeof(_RelocationFailureIEs_Value_1);
   RelocationFailureIEs[1].decodeValue = &asn1PD__RelocationFailureIEs_Value_1;
   RelocationFailureIEs[1].printValue = &asn1Print__RelocationFailureIEs_Value_1;
   RelocationFailureIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationFailureExtensions                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationFailureExtensions[2];
int RelocationFailureExtensions_Size = 2;

void init_RelocationFailureExtensions(ASN1CTXT *pctxt)
{

   RelocationFailureExtensions[0].id = 100;
   RelocationFailureExtensions[0].criticality = ignore;
   RelocationFailureExtensions[0].ExtensionSize = sizeof(_RelocationFailureExtensions_Extension);
   RelocationFailureExtensions[0].decodeExtension = &asn1PD__RelocationFailureExtensions_Extension;
   RelocationFailureExtensions[0].printExtension = &asn1Print__RelocationFailureExtensions_Extension;
   RelocationFailureExtensions[0].presence = optional;

   RelocationFailureExtensions[1].id = 108;
   RelocationFailureExtensions[1].criticality = ignore;
   RelocationFailureExtensions[1].ExtensionSize = sizeof(_RelocationFailureExtensions_Extension_1);
   RelocationFailureExtensions[1].decodeExtension = &asn1PD__RelocationFailureExtensions_Extension_1;
   RelocationFailureExtensions[1].printExtension = &asn1Print__RelocationFailureExtensions_Extension_1;
   RelocationFailureExtensions[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationCancelIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationCancelIEs[1];
int RelocationCancelIEs_Size = 1;

void init_RelocationCancelIEs(ASN1CTXT *pctxt)
{

   RelocationCancelIEs[0].id = 4;
   RelocationCancelIEs[0].criticality = ignore;
   RelocationCancelIEs[0].ValueSize = sizeof(_RelocationCancelIEs_Value);
   RelocationCancelIEs[0].decodeValue = &asn1PD__RelocationCancelIEs_Value;
   RelocationCancelIEs[0].printValue = &asn1Print__RelocationCancelIEs_Value;
   RelocationCancelIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RelocationCancelExtensions                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationCancelExtensions[1];
int RelocationCancelExtensions_Size = 0;

void init_RelocationCancelExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledgeIEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationCancelAcknowledgeIEs[1];
int RelocationCancelAcknowledgeIEs_Size = 1;

void init_RelocationCancelAcknowledgeIEs(ASN1CTXT *pctxt)
{

   RelocationCancelAcknowledgeIEs[0].id = 9;
   RelocationCancelAcknowledgeIEs[0].criticality = ignore;
   RelocationCancelAcknowledgeIEs[0].ValueSize = sizeof(_RelocationCancelAcknowledgeIEs_Value);
   RelocationCancelAcknowledgeIEs[0].decodeValue = &asn1PD__RelocationCancelAcknowledgeIEs_Value;
   RelocationCancelAcknowledgeIEs[0].printValue = &asn1Print__RelocationCancelAcknowledgeIEs_Value;
   RelocationCancelAcknowledgeIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledgeExtensions                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationCancelAcknowledgeExtensions[1];
int RelocationCancelAcknowledgeExtensions_Size = 0;

void init_RelocationCancelAcknowledgeExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequestIEs                                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES SRNS_ContextRequestIEs[1];
int SRNS_ContextRequestIEs_Size = 1;

void init_SRNS_ContextRequestIEs(ASN1CTXT *pctxt)
{

   SRNS_ContextRequestIEs[0].id = 29;
   SRNS_ContextRequestIEs[0].criticality = ignore;
   SRNS_ContextRequestIEs[0].ValueSize = sizeof(_SRNS_ContextRequestIEs_Value);
   SRNS_ContextRequestIEs[0].decodeValue = &asn1PD__SRNS_ContextRequestIEs_Value;
   SRNS_ContextRequestIEs[0].printValue = &asn1Print__SRNS_ContextRequestIEs_Value;
   SRNS_ContextRequestIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_IEs                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_DataForwardingItem_SRNS_CtxReq_IEs[1];
int RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size = 1;

void init_RAB_DataForwardingItem_SRNS_CtxReq_IEs(ASN1CTXT *pctxt)
{

   RAB_DataForwardingItem_SRNS_CtxReq_IEs[0].id = 27;
   RAB_DataForwardingItem_SRNS_CtxReq_IEs[0].criticality = reject;
   RAB_DataForwardingItem_SRNS_CtxReq_IEs[0].ValueSize = sizeof(_RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value);
   RAB_DataForwardingItem_SRNS_CtxReq_IEs[0].decodeValue = &asn1PD__RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value;
   RAB_DataForwardingItem_SRNS_CtxReq_IEs[0].printValue = &asn1Print__RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value;
   RAB_DataForwardingItem_SRNS_CtxReq_IEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[1];
int RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size = 0;

void init_RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequestExtensions                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SRNS_ContextRequestExtensions[1];
int SRNS_ContextRequestExtensions_Size = 0;

void init_SRNS_ContextRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponseIEs                                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES SRNS_ContextResponseIEs[3];
int SRNS_ContextResponseIEs_Size = 3;

void init_SRNS_ContextResponseIEs(ASN1CTXT *pctxt)
{

   SRNS_ContextResponseIEs[0].id = 25;
   SRNS_ContextResponseIEs[0].criticality = ignore;
   SRNS_ContextResponseIEs[0].ValueSize = sizeof(_SRNS_ContextResponseIEs_Value);
   SRNS_ContextResponseIEs[0].decodeValue = &asn1PD__SRNS_ContextResponseIEs_Value;
   SRNS_ContextResponseIEs[0].printValue = &asn1Print__SRNS_ContextResponseIEs_Value;
   SRNS_ContextResponseIEs[0].presence = optional;

   SRNS_ContextResponseIEs[1].id = 85;
   SRNS_ContextResponseIEs[1].criticality = ignore;
   SRNS_ContextResponseIEs[1].ValueSize = sizeof(_SRNS_ContextResponseIEs_Value_1);
   SRNS_ContextResponseIEs[1].decodeValue = &asn1PD__SRNS_ContextResponseIEs_Value_1;
   SRNS_ContextResponseIEs[1].printValue = &asn1Print__SRNS_ContextResponseIEs_Value_1;
   SRNS_ContextResponseIEs[1].presence = optional;

   SRNS_ContextResponseIEs[2].id = 9;
   SRNS_ContextResponseIEs[2].criticality = ignore;
   SRNS_ContextResponseIEs[2].ValueSize = sizeof(_SRNS_ContextResponseIEs_Value_2);
   SRNS_ContextResponseIEs[2].decodeValue = &asn1PD__SRNS_ContextResponseIEs_Value_2;
   SRNS_ContextResponseIEs[2].printValue = &asn1Print__SRNS_ContextResponseIEs_Value_2;
   SRNS_ContextResponseIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItemIEs                                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_ContextItemIEs[1];
int RAB_ContextItemIEs_Size = 1;

void init_RAB_ContextItemIEs(ASN1CTXT *pctxt)
{

   RAB_ContextItemIEs[0].id = 24;
   RAB_ContextItemIEs[0].criticality = ignore;
   RAB_ContextItemIEs[0].ValueSize = sizeof(_RAB_ContextItemIEs_Value);
   RAB_ContextItemIEs[0].decodeValue = &asn1PD__RAB_ContextItemIEs_Value;
   RAB_ContextItemIEs[0].printValue = &asn1Print__RAB_ContextItemIEs_Value;
   RAB_ContextItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_ExtIEs                                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_ContextItem_ExtIEs[1];
int RAB_ContextItem_ExtIEs_Size = 0;

void init_RAB_ContextItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItemIEs                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RABs_ContextFailedtoTransferItemIEs[1];
int RABs_ContextFailedtoTransferItemIEs_Size = 1;

void init_RABs_ContextFailedtoTransferItemIEs(ASN1CTXT *pctxt)
{

   RABs_ContextFailedtoTransferItemIEs[0].id = 84;
   RABs_ContextFailedtoTransferItemIEs[0].criticality = ignore;
   RABs_ContextFailedtoTransferItemIEs[0].ValueSize = sizeof(_RABs_ContextFailedtoTransferItemIEs_Value);
   RABs_ContextFailedtoTransferItemIEs[0].decodeValue = &asn1PD__RABs_ContextFailedtoTransferItemIEs_Value;
   RABs_ContextFailedtoTransferItemIEs[0].printValue = &asn1Print__RABs_ContextFailedtoTransferItemIEs_Value;
   RABs_ContextFailedtoTransferItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_ExtIEs                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RABs_ContextFailedtoTransferItem_ExtIEs[1];
int RABs_ContextFailedtoTransferItem_ExtIEs_Size = 0;

void init_RABs_ContextFailedtoTransferItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponseExtensions                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SRNS_ContextResponseExtensions[1];
int SRNS_ContextResponseExtensions_Size = 0;

void init_SRNS_ContextResponseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommandIEs                                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES SecurityModeCommandIEs[3];
int SecurityModeCommandIEs_Size = 3;

void init_SecurityModeCommandIEs(ASN1CTXT *pctxt)
{

   SecurityModeCommandIEs[0].id = 12;
   SecurityModeCommandIEs[0].criticality = reject;
   SecurityModeCommandIEs[0].ValueSize = sizeof(_SecurityModeCommandIEs_Value);
   SecurityModeCommandIEs[0].decodeValue = &asn1PD__SecurityModeCommandIEs_Value;
   SecurityModeCommandIEs[0].printValue = &asn1Print__SecurityModeCommandIEs_Value;
   SecurityModeCommandIEs[0].presence = mandatory;

   SecurityModeCommandIEs[1].id = 11;
   SecurityModeCommandIEs[1].criticality = ignore;
   SecurityModeCommandIEs[1].ValueSize = sizeof(_SecurityModeCommandIEs_Value_1);
   SecurityModeCommandIEs[1].decodeValue = &asn1PD__SecurityModeCommandIEs_Value_1;
   SecurityModeCommandIEs[1].printValue = &asn1Print__SecurityModeCommandIEs_Value_1;
   SecurityModeCommandIEs[1].presence = optional;

   SecurityModeCommandIEs[2].id = 75;
   SecurityModeCommandIEs[2].criticality = reject;
   SecurityModeCommandIEs[2].ValueSize = sizeof(_SecurityModeCommandIEs_Value_2);
   SecurityModeCommandIEs[2].decodeValue = &asn1PD__SecurityModeCommandIEs_Value_2;
   SecurityModeCommandIEs[2].printValue = &asn1Print__SecurityModeCommandIEs_Value_2;
   SecurityModeCommandIEs[2].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommandExtensions                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SecurityModeCommandExtensions[1];
int SecurityModeCommandExtensions_Size = 0;

void init_SecurityModeCommandExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SecurityModeCompleteIEs                                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES SecurityModeCompleteIEs[3];
int SecurityModeCompleteIEs_Size = 3;

void init_SecurityModeCompleteIEs(ASN1CTXT *pctxt)
{

   SecurityModeCompleteIEs[0].id = 6;
   SecurityModeCompleteIEs[0].criticality = reject;
   SecurityModeCompleteIEs[0].ValueSize = sizeof(_SecurityModeCompleteIEs_Value);
   SecurityModeCompleteIEs[0].decodeValue = &asn1PD__SecurityModeCompleteIEs_Value;
   SecurityModeCompleteIEs[0].printValue = &asn1Print__SecurityModeCompleteIEs_Value;
   SecurityModeCompleteIEs[0].presence = mandatory;

   SecurityModeCompleteIEs[1].id = 5;
   SecurityModeCompleteIEs[1].criticality = ignore;
   SecurityModeCompleteIEs[1].ValueSize = sizeof(_SecurityModeCompleteIEs_Value_1);
   SecurityModeCompleteIEs[1].decodeValue = &asn1PD__SecurityModeCompleteIEs_Value_1;
   SecurityModeCompleteIEs[1].printValue = &asn1Print__SecurityModeCompleteIEs_Value_1;
   SecurityModeCompleteIEs[1].presence = optional;

   SecurityModeCompleteIEs[2].id = 9;
   SecurityModeCompleteIEs[2].criticality = ignore;
   SecurityModeCompleteIEs[2].ValueSize = sizeof(_SecurityModeCompleteIEs_Value_2);
   SecurityModeCompleteIEs[2].decodeValue = &asn1PD__SecurityModeCompleteIEs_Value_2;
   SecurityModeCompleteIEs[2].printValue = &asn1Print__SecurityModeCompleteIEs_Value_2;
   SecurityModeCompleteIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  SecurityModeCompleteExtensions                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SecurityModeCompleteExtensions[1];
int SecurityModeCompleteExtensions_Size = 0;

void init_SecurityModeCompleteExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  SecurityModeRejectIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES SecurityModeRejectIEs[2];
int SecurityModeRejectIEs_Size = 2;

void init_SecurityModeRejectIEs(ASN1CTXT *pctxt)
{

   SecurityModeRejectIEs[0].id = 4;
   SecurityModeRejectIEs[0].criticality = ignore;
   SecurityModeRejectIEs[0].ValueSize = sizeof(_SecurityModeRejectIEs_Value);
   SecurityModeRejectIEs[0].decodeValue = &asn1PD__SecurityModeRejectIEs_Value;
   SecurityModeRejectIEs[0].printValue = &asn1Print__SecurityModeRejectIEs_Value;
   SecurityModeRejectIEs[0].presence = mandatory;

   SecurityModeRejectIEs[1].id = 9;
   SecurityModeRejectIEs[1].criticality = ignore;
   SecurityModeRejectIEs[1].ValueSize = sizeof(_SecurityModeRejectIEs_Value_1);
   SecurityModeRejectIEs[1].decodeValue = &asn1PD__SecurityModeRejectIEs_Value_1;
   SecurityModeRejectIEs[1].printValue = &asn1Print__SecurityModeRejectIEs_Value_1;
   SecurityModeRejectIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  SecurityModeRejectExtensions                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SecurityModeRejectExtensions[1];
int SecurityModeRejectExtensions_Size = 0;

void init_SecurityModeRejectExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequestIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES DataVolumeReportRequestIEs[1];
int DataVolumeReportRequestIEs_Size = 1;

void init_DataVolumeReportRequestIEs(ASN1CTXT *pctxt)
{

   DataVolumeReportRequestIEs[0].id = 33;
   DataVolumeReportRequestIEs[0].criticality = ignore;
   DataVolumeReportRequestIEs[0].ValueSize = sizeof(_DataVolumeReportRequestIEs_Value);
   DataVolumeReportRequestIEs[0].decodeValue = &asn1PD__DataVolumeReportRequestIEs_Value;
   DataVolumeReportRequestIEs[0].printValue = &asn1Print__DataVolumeReportRequestIEs_Value;
   DataVolumeReportRequestIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItemIEs                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_DataVolumeReportRequestItemIEs[1];
int RAB_DataVolumeReportRequestItemIEs_Size = 1;

void init_RAB_DataVolumeReportRequestItemIEs(ASN1CTXT *pctxt)
{

   RAB_DataVolumeReportRequestItemIEs[0].id = 32;
   RAB_DataVolumeReportRequestItemIEs[0].criticality = reject;
   RAB_DataVolumeReportRequestItemIEs[0].ValueSize = sizeof(_RAB_DataVolumeReportRequestItemIEs_Value);
   RAB_DataVolumeReportRequestItemIEs[0].decodeValue = &asn1PD__RAB_DataVolumeReportRequestItemIEs_Value;
   RAB_DataVolumeReportRequestItemIEs[0].printValue = &asn1Print__RAB_DataVolumeReportRequestItemIEs_Value;
   RAB_DataVolumeReportRequestItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_ExtIEs                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_DataVolumeReportRequestItem_ExtIEs[1];
int RAB_DataVolumeReportRequestItem_ExtIEs_Size = 0;

void init_RAB_DataVolumeReportRequestItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequestExtensions                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION DataVolumeReportRequestExtensions[1];
int DataVolumeReportRequestExtensions_Size = 0;

void init_DataVolumeReportRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES DataVolumeReportIEs[3];
int DataVolumeReportIEs_Size = 3;

void init_DataVolumeReportIEs(ASN1CTXT *pctxt)
{

   DataVolumeReportIEs[0].id = 31;
   DataVolumeReportIEs[0].criticality = ignore;
   DataVolumeReportIEs[0].ValueSize = sizeof(_DataVolumeReportIEs_Value);
   DataVolumeReportIEs[0].decodeValue = &asn1PD__DataVolumeReportIEs_Value;
   DataVolumeReportIEs[0].printValue = &asn1Print__DataVolumeReportIEs_Value;
   DataVolumeReportIEs[0].presence = optional;

   DataVolumeReportIEs[1].id = 72;
   DataVolumeReportIEs[1].criticality = ignore;
   DataVolumeReportIEs[1].ValueSize = sizeof(_DataVolumeReportIEs_Value_1);
   DataVolumeReportIEs[1].decodeValue = &asn1PD__DataVolumeReportIEs_Value_1;
   DataVolumeReportIEs[1].printValue = &asn1Print__DataVolumeReportIEs_Value_1;
   DataVolumeReportIEs[1].presence = optional;

   DataVolumeReportIEs[2].id = 9;
   DataVolumeReportIEs[2].criticality = ignore;
   DataVolumeReportIEs[2].ValueSize = sizeof(_DataVolumeReportIEs_Value_2);
   DataVolumeReportIEs[2].decodeValue = &asn1PD__DataVolumeReportIEs_Value_2;
   DataVolumeReportIEs[2].printValue = &asn1Print__DataVolumeReportIEs_Value_2;
   DataVolumeReportIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportExtensions                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION DataVolumeReportExtensions[1];
int DataVolumeReportExtensions_Size = 0;

void init_DataVolumeReportExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItemIEs                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RABs_failed_to_reportItemIEs[1];
int RABs_failed_to_reportItemIEs_Size = 1;

void init_RABs_failed_to_reportItemIEs(ASN1CTXT *pctxt)
{

   RABs_failed_to_reportItemIEs[0].id = 71;
   RABs_failed_to_reportItemIEs[0].criticality = ignore;
   RABs_failed_to_reportItemIEs[0].ValueSize = sizeof(_RABs_failed_to_reportItemIEs_Value);
   RABs_failed_to_reportItemIEs[0].decodeValue = &asn1PD__RABs_failed_to_reportItemIEs_Value;
   RABs_failed_to_reportItemIEs[0].printValue = &asn1Print__RABs_failed_to_reportItemIEs_Value;
   RABs_failed_to_reportItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_ExtIEs                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RABs_failed_to_reportItem_ExtIEs[1];
int RABs_failed_to_reportItem_ExtIEs_Size = 0;

void init_RABs_failed_to_reportItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  ResetIEs                                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES ResetIEs[3];
int ResetIEs_Size = 3;

void init_ResetIEs(ASN1CTXT *pctxt)
{

   ResetIEs[0].id = 4;
   ResetIEs[0].criticality = ignore;
   ResetIEs[0].ValueSize = sizeof(_ResetIEs_Value);
   ResetIEs[0].decodeValue = &asn1PD__ResetIEs_Value;
   ResetIEs[0].printValue = &asn1Print__ResetIEs_Value;
   ResetIEs[0].presence = mandatory;

   ResetIEs[1].id = 3;
   ResetIEs[1].criticality = reject;
   ResetIEs[1].ValueSize = sizeof(_ResetIEs_Value_1);
   ResetIEs[1].decodeValue = &asn1PD__ResetIEs_Value_1;
   ResetIEs[1].printValue = &asn1Print__ResetIEs_Value_1;
   ResetIEs[1].presence = mandatory;

   ResetIEs[2].id = 86;
   ResetIEs[2].criticality = ignore;
   ResetIEs[2].ValueSize = sizeof(_ResetIEs_Value_2);
   ResetIEs[2].decodeValue = &asn1PD__ResetIEs_Value_2;
   ResetIEs[2].printValue = &asn1Print__ResetIEs_Value_2;
   ResetIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ResetExtensions                                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ResetExtensions[1];
int ResetExtensions_Size = 1;

void init_ResetExtensions(ASN1CTXT *pctxt)
{

   ResetExtensions[0].id = 96;
   ResetExtensions[0].criticality = ignore;
   ResetExtensions[0].ExtensionSize = sizeof(_ResetExtensions_Extension);
   ResetExtensions[0].decodeExtension = &asn1PD__ResetExtensions_Extension;
   ResetExtensions[0].printExtension = &asn1Print__ResetExtensions_Extension;
   ResetExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledgeIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES ResetAcknowledgeIEs[3];
int ResetAcknowledgeIEs_Size = 3;

void init_ResetAcknowledgeIEs(ASN1CTXT *pctxt)
{

   ResetAcknowledgeIEs[0].id = 3;
   ResetAcknowledgeIEs[0].criticality = reject;
   ResetAcknowledgeIEs[0].ValueSize = sizeof(_ResetAcknowledgeIEs_Value);
   ResetAcknowledgeIEs[0].decodeValue = &asn1PD__ResetAcknowledgeIEs_Value;
   ResetAcknowledgeIEs[0].printValue = &asn1Print__ResetAcknowledgeIEs_Value;
   ResetAcknowledgeIEs[0].presence = mandatory;

   ResetAcknowledgeIEs[1].id = 9;
   ResetAcknowledgeIEs[1].criticality = ignore;
   ResetAcknowledgeIEs[1].ValueSize = sizeof(_ResetAcknowledgeIEs_Value_1);
   ResetAcknowledgeIEs[1].decodeValue = &asn1PD__ResetAcknowledgeIEs_Value_1;
   ResetAcknowledgeIEs[1].printValue = &asn1Print__ResetAcknowledgeIEs_Value_1;
   ResetAcknowledgeIEs[1].presence = optional;

   ResetAcknowledgeIEs[2].id = 86;
   ResetAcknowledgeIEs[2].criticality = ignore;
   ResetAcknowledgeIEs[2].ValueSize = sizeof(_ResetAcknowledgeIEs_Value_2);
   ResetAcknowledgeIEs[2].decodeValue = &asn1PD__ResetAcknowledgeIEs_Value_2;
   ResetAcknowledgeIEs[2].printValue = &asn1Print__ResetAcknowledgeIEs_Value_2;
   ResetAcknowledgeIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledgeExtensions                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ResetAcknowledgeExtensions[1];
int ResetAcknowledgeExtensions_Size = 1;

void init_ResetAcknowledgeExtensions(ASN1CTXT *pctxt)
{

   ResetAcknowledgeExtensions[0].id = 96;
   ResetAcknowledgeExtensions[0].criticality = ignore;
   ResetAcknowledgeExtensions[0].ExtensionSize = sizeof(_ResetAcknowledgeExtensions_Extension);
   ResetAcknowledgeExtensions[0].decodeExtension = &asn1PD__ResetAcknowledgeExtensions_Extension;
   ResetAcknowledgeExtensions[0].printExtension = &asn1Print__ResetAcknowledgeExtensions_Extension;
   ResetAcknowledgeExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ResetResourceIEs                                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES ResetResourceIEs[4];
int ResetResourceIEs_Size = 4;

void init_ResetResourceIEs(ASN1CTXT *pctxt)
{

   ResetResourceIEs[0].id = 3;
   ResetResourceIEs[0].criticality = reject;
   ResetResourceIEs[0].ValueSize = sizeof(_ResetResourceIEs_Value);
   ResetResourceIEs[0].decodeValue = &asn1PD__ResetResourceIEs_Value;
   ResetResourceIEs[0].printValue = &asn1Print__ResetResourceIEs_Value;
   ResetResourceIEs[0].presence = mandatory;

   ResetResourceIEs[1].id = 4;
   ResetResourceIEs[1].criticality = ignore;
   ResetResourceIEs[1].ValueSize = sizeof(_ResetResourceIEs_Value_1);
   ResetResourceIEs[1].decodeValue = &asn1PD__ResetResourceIEs_Value_1;
   ResetResourceIEs[1].printValue = &asn1Print__ResetResourceIEs_Value_1;
   ResetResourceIEs[1].presence = mandatory;

   ResetResourceIEs[2].id = 77;
   ResetResourceIEs[2].criticality = ignore;
   ResetResourceIEs[2].ValueSize = sizeof(_ResetResourceIEs_Value_2);
   ResetResourceIEs[2].decodeValue = &asn1PD__ResetResourceIEs_Value_2;
   ResetResourceIEs[2].printValue = &asn1Print__ResetResourceIEs_Value_2;
   ResetResourceIEs[2].presence = mandatory;

   ResetResourceIEs[3].id = 86;
   ResetResourceIEs[3].criticality = ignore;
   ResetResourceIEs[3].ValueSize = sizeof(_ResetResourceIEs_Value_3);
   ResetResourceIEs[3].decodeValue = &asn1PD__ResetResourceIEs_Value_3;
   ResetResourceIEs[3].printValue = &asn1Print__ResetResourceIEs_Value_3;
   ResetResourceIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ResetResourceItemIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES ResetResourceItemIEs[1];
int ResetResourceItemIEs_Size = 1;

void init_ResetResourceItemIEs(ASN1CTXT *pctxt)
{

   ResetResourceItemIEs[0].id = 78;
   ResetResourceItemIEs[0].criticality = reject;
   ResetResourceItemIEs[0].ValueSize = sizeof(_ResetResourceItemIEs_Value);
   ResetResourceItemIEs[0].decodeValue = &asn1PD__ResetResourceItemIEs_Value;
   ResetResourceItemIEs[0].printValue = &asn1Print__ResetResourceItemIEs_Value;
   ResetResourceItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_ExtIEs                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ResetResourceItem_ExtIEs[1];
int ResetResourceItem_ExtIEs_Size = 0;

void init_ResetResourceItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  ResetResourceExtensions                                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ResetResourceExtensions[1];
int ResetResourceExtensions_Size = 1;

void init_ResetResourceExtensions(ASN1CTXT *pctxt)
{

   ResetResourceExtensions[0].id = 96;
   ResetResourceExtensions[0].criticality = ignore;
   ResetResourceExtensions[0].ExtensionSize = sizeof(_ResetResourceExtensions_Extension);
   ResetResourceExtensions[0].decodeExtension = &asn1PD__ResetResourceExtensions_Extension;
   ResetResourceExtensions[0].printExtension = &asn1Print__ResetResourceExtensions_Extension;
   ResetResourceExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledgeIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES ResetResourceAcknowledgeIEs[4];
int ResetResourceAcknowledgeIEs_Size = 4;

void init_ResetResourceAcknowledgeIEs(ASN1CTXT *pctxt)
{

   ResetResourceAcknowledgeIEs[0].id = 3;
   ResetResourceAcknowledgeIEs[0].criticality = reject;
   ResetResourceAcknowledgeIEs[0].ValueSize = sizeof(_ResetResourceAcknowledgeIEs_Value);
   ResetResourceAcknowledgeIEs[0].decodeValue = &asn1PD__ResetResourceAcknowledgeIEs_Value;
   ResetResourceAcknowledgeIEs[0].printValue = &asn1Print__ResetResourceAcknowledgeIEs_Value;
   ResetResourceAcknowledgeIEs[0].presence = mandatory;

   ResetResourceAcknowledgeIEs[1].id = 77;
   ResetResourceAcknowledgeIEs[1].criticality = ignore;
   ResetResourceAcknowledgeIEs[1].ValueSize = sizeof(_ResetResourceAcknowledgeIEs_Value_1);
   ResetResourceAcknowledgeIEs[1].decodeValue = &asn1PD__ResetResourceAcknowledgeIEs_Value_1;
   ResetResourceAcknowledgeIEs[1].printValue = &asn1Print__ResetResourceAcknowledgeIEs_Value_1;
   ResetResourceAcknowledgeIEs[1].presence = mandatory;

   ResetResourceAcknowledgeIEs[2].id = 86;
   ResetResourceAcknowledgeIEs[2].criticality = ignore;
   ResetResourceAcknowledgeIEs[2].ValueSize = sizeof(_ResetResourceAcknowledgeIEs_Value_2);
   ResetResourceAcknowledgeIEs[2].decodeValue = &asn1PD__ResetResourceAcknowledgeIEs_Value_2;
   ResetResourceAcknowledgeIEs[2].printValue = &asn1Print__ResetResourceAcknowledgeIEs_Value_2;
   ResetResourceAcknowledgeIEs[2].presence = optional;

   ResetResourceAcknowledgeIEs[3].id = 9;
   ResetResourceAcknowledgeIEs[3].criticality = ignore;
   ResetResourceAcknowledgeIEs[3].ValueSize = sizeof(_ResetResourceAcknowledgeIEs_Value_3);
   ResetResourceAcknowledgeIEs[3].decodeValue = &asn1PD__ResetResourceAcknowledgeIEs_Value_3;
   ResetResourceAcknowledgeIEs[3].printValue = &asn1Print__ResetResourceAcknowledgeIEs_Value_3;
   ResetResourceAcknowledgeIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItemIEs                                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES ResetResourceAckItemIEs[1];
int ResetResourceAckItemIEs_Size = 1;

void init_ResetResourceAckItemIEs(ASN1CTXT *pctxt)
{

   ResetResourceAckItemIEs[0].id = 78;
   ResetResourceAckItemIEs[0].criticality = reject;
   ResetResourceAckItemIEs[0].ValueSize = sizeof(_ResetResourceAckItemIEs_Value);
   ResetResourceAckItemIEs[0].decodeValue = &asn1PD__ResetResourceAckItemIEs_Value;
   ResetResourceAckItemIEs[0].printValue = &asn1Print__ResetResourceAckItemIEs_Value;
   ResetResourceAckItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_ExtIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ResetResourceAckItem_ExtIEs[1];
int ResetResourceAckItem_ExtIEs_Size = 0;

void init_ResetResourceAckItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledgeExtensions                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ResetResourceAcknowledgeExtensions[1];
int ResetResourceAcknowledgeExtensions_Size = 1;

void init_ResetResourceAcknowledgeExtensions(ASN1CTXT *pctxt)
{

   ResetResourceAcknowledgeExtensions[0].id = 96;
   ResetResourceAcknowledgeExtensions[0].criticality = ignore;
   ResetResourceAcknowledgeExtensions[0].ExtensionSize = sizeof(_ResetResourceAcknowledgeExtensions_Extension);
   ResetResourceAcknowledgeExtensions[0].decodeExtension = &asn1PD__ResetResourceAcknowledgeExtensions_Extension;
   ResetResourceAcknowledgeExtensions[0].printExtension = &asn1Print__ResetResourceAcknowledgeExtensions_Extension;
   ResetResourceAcknowledgeExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequestIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_ReleaseRequestIEs[1];
int RAB_ReleaseRequestIEs_Size = 1;

void init_RAB_ReleaseRequestIEs(ASN1CTXT *pctxt)
{

   RAB_ReleaseRequestIEs[0].id = 41;
   RAB_ReleaseRequestIEs[0].criticality = ignore;
   RAB_ReleaseRequestIEs[0].ValueSize = sizeof(_RAB_ReleaseRequestIEs_Value);
   RAB_ReleaseRequestIEs[0].decodeValue = &asn1PD__RAB_ReleaseRequestIEs_Value;
   RAB_ReleaseRequestIEs[0].printValue = &asn1Print__RAB_ReleaseRequestIEs_Value;
   RAB_ReleaseRequestIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItemIEs                                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_ReleaseItemIEs[1];
int RAB_ReleaseItemIEs_Size = 1;

void init_RAB_ReleaseItemIEs(ASN1CTXT *pctxt)
{

   RAB_ReleaseItemIEs[0].id = 40;
   RAB_ReleaseItemIEs[0].criticality = ignore;
   RAB_ReleaseItemIEs[0].ValueSize = sizeof(_RAB_ReleaseItemIEs_Value);
   RAB_ReleaseItemIEs[0].decodeValue = &asn1PD__RAB_ReleaseItemIEs_Value;
   RAB_ReleaseItemIEs[0].printValue = &asn1Print__RAB_ReleaseItemIEs_Value;
   RAB_ReleaseItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_ExtIEs                                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_ReleaseItem_ExtIEs[1];
int RAB_ReleaseItem_ExtIEs_Size = 0;

void init_RAB_ReleaseItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequestExtensions                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_ReleaseRequestExtensions[1];
int RAB_ReleaseRequestExtensions_Size = 0;

void init_RAB_ReleaseRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequestIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES Iu_ReleaseRequestIEs[1];
int Iu_ReleaseRequestIEs_Size = 1;

void init_Iu_ReleaseRequestIEs(ASN1CTXT *pctxt)
{

   Iu_ReleaseRequestIEs[0].id = 4;
   Iu_ReleaseRequestIEs[0].criticality = ignore;
   Iu_ReleaseRequestIEs[0].ValueSize = sizeof(_Iu_ReleaseRequestIEs_Value);
   Iu_ReleaseRequestIEs[0].decodeValue = &asn1PD__Iu_ReleaseRequestIEs_Value;
   Iu_ReleaseRequestIEs[0].printValue = &asn1Print__Iu_ReleaseRequestIEs_Value;
   Iu_ReleaseRequestIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequestExtensions                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION Iu_ReleaseRequestExtensions[1];
int Iu_ReleaseRequestExtensions_Size = 0;

void init_Iu_ReleaseRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationDetectIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationDetectIEs[1];
int RelocationDetectIEs_Size = 0;

void init_RelocationDetectIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationDetectExtensions                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationDetectExtensions[1];
int RelocationDetectExtensions_Size = 0;

void init_RelocationDetectExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationCompleteIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RelocationCompleteIEs[1];
int RelocationCompleteIEs_Size = 0;

void init_RelocationCompleteIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RelocationCompleteExtensions                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RelocationCompleteExtensions[1];
int RelocationCompleteExtensions_Size = 0;

void init_RelocationCompleteExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  PagingIEs                                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES PagingIEs[7];
int PagingIEs_Size = 7;

void init_PagingIEs(ASN1CTXT *pctxt)
{

   PagingIEs[0].id = 3;
   PagingIEs[0].criticality = ignore;
   PagingIEs[0].ValueSize = sizeof(_PagingIEs_Value);
   PagingIEs[0].decodeValue = &asn1PD__PagingIEs_Value;
   PagingIEs[0].printValue = &asn1Print__PagingIEs_Value;
   PagingIEs[0].presence = mandatory;

   PagingIEs[1].id = 23;
   PagingIEs[1].criticality = ignore;
   PagingIEs[1].ValueSize = sizeof(_PagingIEs_Value_1);
   PagingIEs[1].decodeValue = &asn1PD__PagingIEs_Value_1;
   PagingIEs[1].printValue = &asn1Print__PagingIEs_Value_1;
   PagingIEs[1].presence = mandatory;

   PagingIEs[2].id = 64;
   PagingIEs[2].criticality = ignore;
   PagingIEs[2].ValueSize = sizeof(_PagingIEs_Value_2);
   PagingIEs[2].decodeValue = &asn1PD__PagingIEs_Value_2;
   PagingIEs[2].printValue = &asn1Print__PagingIEs_Value_2;
   PagingIEs[2].presence = optional;

   PagingIEs[3].id = 21;
   PagingIEs[3].criticality = ignore;
   PagingIEs[3].ValueSize = sizeof(_PagingIEs_Value_3);
   PagingIEs[3].decodeValue = &asn1PD__PagingIEs_Value_3;
   PagingIEs[3].printValue = &asn1Print__PagingIEs_Value_3;
   PagingIEs[3].presence = optional;

   PagingIEs[4].id = 22;
   PagingIEs[4].criticality = ignore;
   PagingIEs[4].ValueSize = sizeof(_PagingIEs_Value_4);
   PagingIEs[4].decodeValue = &asn1PD__PagingIEs_Value_4;
   PagingIEs[4].printValue = &asn1Print__PagingIEs_Value_4;
   PagingIEs[4].presence = optional;

   PagingIEs[5].id = 17;
   PagingIEs[5].criticality = ignore;
   PagingIEs[5].ValueSize = sizeof(_PagingIEs_Value_5);
   PagingIEs[5].decodeValue = &asn1PD__PagingIEs_Value_5;
   PagingIEs[5].printValue = &asn1Print__PagingIEs_Value_5;
   PagingIEs[5].presence = optional;

   PagingIEs[6].id = 76;
   PagingIEs[6].criticality = ignore;
   PagingIEs[6].ValueSize = sizeof(_PagingIEs_Value_6);
   PagingIEs[6].decodeValue = &asn1PD__PagingIEs_Value_6;
   PagingIEs[6].printValue = &asn1Print__PagingIEs_Value_6;
   PagingIEs[6].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  PagingExtensions                                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION PagingExtensions[1];
int PagingExtensions_Size = 1;

void init_PagingExtensions(ASN1CTXT *pctxt)
{

   PagingExtensions[0].id = 96;
   PagingExtensions[0].criticality = ignore;
   PagingExtensions[0].ExtensionSize = sizeof(_PagingExtensions_Extension);
   PagingExtensions[0].decodeExtension = &asn1PD__PagingExtensions_Extension;
   PagingExtensions[0].printExtension = &asn1Print__PagingExtensions_Extension;
   PagingExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  CommonID_IEs                                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES CommonID_IEs[1];
int CommonID_IEs_Size = 1;

void init_CommonID_IEs(ASN1CTXT *pctxt)
{

   CommonID_IEs[0].id = 23;
   CommonID_IEs[0].criticality = ignore;
   CommonID_IEs[0].ValueSize = sizeof(_CommonID_IEs_Value);
   CommonID_IEs[0].decodeValue = &asn1PD__CommonID_IEs_Value;
   CommonID_IEs[0].printValue = &asn1Print__CommonID_IEs_Value;
   CommonID_IEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  CommonIDExtensions                                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CommonIDExtensions[3];
int CommonIDExtensions_Size = 3;

void init_CommonIDExtensions(ASN1CTXT *pctxt)
{

   CommonIDExtensions[0].id = 105;
   CommonIDExtensions[0].criticality = ignore;
   CommonIDExtensions[0].ExtensionSize = sizeof(_CommonIDExtensions_Extension);
   CommonIDExtensions[0].decodeExtension = &asn1PD__CommonIDExtensions_Extension;
   CommonIDExtensions[0].printExtension = &asn1Print__CommonIDExtensions_Extension;
   CommonIDExtensions[0].presence = optional;

   CommonIDExtensions[1].id = 118;
   CommonIDExtensions[1].criticality = ignore;
   CommonIDExtensions[1].ExtensionSize = sizeof(_CommonIDExtensions_Extension_1);
   CommonIDExtensions[1].decodeExtension = &asn1PD__CommonIDExtensions_Extension_1;
   CommonIDExtensions[1].printExtension = &asn1Print__CommonIDExtensions_Extension_1;
   CommonIDExtensions[1].presence = optional;

   CommonIDExtensions[2].id = 127;
   CommonIDExtensions[2].criticality = ignore;
   CommonIDExtensions[2].ExtensionSize = sizeof(_CommonIDExtensions_Extension_2);
   CommonIDExtensions[2].decodeExtension = &asn1PD__CommonIDExtensions_Extension_2;
   CommonIDExtensions[2].printExtension = &asn1Print__CommonIDExtensions_Extension_2;
   CommonIDExtensions[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTraceIEs                                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES CN_InvokeTraceIEs[5];
int CN_InvokeTraceIEs_Size = 5;

void init_CN_InvokeTraceIEs(ASN1CTXT *pctxt)
{

   CN_InvokeTraceIEs[0].id = 66;
   CN_InvokeTraceIEs[0].criticality = ignore;
   CN_InvokeTraceIEs[0].ValueSize = sizeof(_CN_InvokeTraceIEs_Value);
   CN_InvokeTraceIEs[0].decodeValue = &asn1PD__CN_InvokeTraceIEs_Value;
   CN_InvokeTraceIEs[0].printValue = &asn1Print__CN_InvokeTraceIEs_Value;
   CN_InvokeTraceIEs[0].presence = optional;

   CN_InvokeTraceIEs[1].id = 65;
   CN_InvokeTraceIEs[1].criticality = ignore;
   CN_InvokeTraceIEs[1].ValueSize = sizeof(_CN_InvokeTraceIEs_Value_1);
   CN_InvokeTraceIEs[1].decodeValue = &asn1PD__CN_InvokeTraceIEs_Value_1;
   CN_InvokeTraceIEs[1].printValue = &asn1Print__CN_InvokeTraceIEs_Value_1;
   CN_InvokeTraceIEs[1].presence = mandatory;

   CN_InvokeTraceIEs[2].id = 68;
   CN_InvokeTraceIEs[2].criticality = ignore;
   CN_InvokeTraceIEs[2].ValueSize = sizeof(_CN_InvokeTraceIEs_Value_2);
   CN_InvokeTraceIEs[2].decodeValue = &asn1PD__CN_InvokeTraceIEs_Value_2;
   CN_InvokeTraceIEs[2].printValue = &asn1Print__CN_InvokeTraceIEs_Value_2;
   CN_InvokeTraceIEs[2].presence = optional;

   CN_InvokeTraceIEs[3].id = 69;
   CN_InvokeTraceIEs[3].criticality = ignore;
   CN_InvokeTraceIEs[3].ValueSize = sizeof(_CN_InvokeTraceIEs_Value_3);
   CN_InvokeTraceIEs[3].decodeValue = &asn1PD__CN_InvokeTraceIEs_Value_3;
   CN_InvokeTraceIEs[3].printValue = &asn1Print__CN_InvokeTraceIEs_Value_3;
   CN_InvokeTraceIEs[3].presence = optional;

   CN_InvokeTraceIEs[4].id = 19;
   CN_InvokeTraceIEs[4].criticality = ignore;
   CN_InvokeTraceIEs[4].ValueSize = sizeof(_CN_InvokeTraceIEs_Value_4);
   CN_InvokeTraceIEs[4].decodeValue = &asn1PD__CN_InvokeTraceIEs_Value_4;
   CN_InvokeTraceIEs[4].printValue = &asn1Print__CN_InvokeTraceIEs_Value_4;
   CN_InvokeTraceIEs[4].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTraceExtensions                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CN_InvokeTraceExtensions[1];
int CN_InvokeTraceExtensions_Size = 1;

void init_CN_InvokeTraceExtensions(ASN1CTXT *pctxt)
{

   CN_InvokeTraceExtensions[0].id = 125;
   CN_InvokeTraceExtensions[0].criticality = ignore;
   CN_InvokeTraceExtensions[0].ExtensionSize = sizeof(_CN_InvokeTraceExtensions_Extension);
   CN_InvokeTraceExtensions[0].decodeExtension = &asn1PD__CN_InvokeTraceExtensions_Extension;
   CN_InvokeTraceExtensions[0].printExtension = &asn1Print__CN_InvokeTraceExtensions_Extension;
   CN_InvokeTraceExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTraceIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES CN_DeactivateTraceIEs[2];
int CN_DeactivateTraceIEs_Size = 2;

void init_CN_DeactivateTraceIEs(ASN1CTXT *pctxt)
{

   CN_DeactivateTraceIEs[0].id = 65;
   CN_DeactivateTraceIEs[0].criticality = ignore;
   CN_DeactivateTraceIEs[0].ValueSize = sizeof(_CN_DeactivateTraceIEs_Value);
   CN_DeactivateTraceIEs[0].decodeValue = &asn1PD__CN_DeactivateTraceIEs_Value;
   CN_DeactivateTraceIEs[0].printValue = &asn1Print__CN_DeactivateTraceIEs_Value;
   CN_DeactivateTraceIEs[0].presence = mandatory;

   CN_DeactivateTraceIEs[1].id = 68;
   CN_DeactivateTraceIEs[1].criticality = ignore;
   CN_DeactivateTraceIEs[1].ValueSize = sizeof(_CN_DeactivateTraceIEs_Value_1);
   CN_DeactivateTraceIEs[1].decodeValue = &asn1PD__CN_DeactivateTraceIEs_Value_1;
   CN_DeactivateTraceIEs[1].printValue = &asn1Print__CN_DeactivateTraceIEs_Value_1;
   CN_DeactivateTraceIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTraceExtensions                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION CN_DeactivateTraceExtensions[1];
int CN_DeactivateTraceExtensions_Size = 0;

void init_CN_DeactivateTraceExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  LocationReportingControlIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES LocationReportingControlIEs[1];
int LocationReportingControlIEs_Size = 1;

void init_LocationReportingControlIEs(ASN1CTXT *pctxt)
{

   LocationReportingControlIEs[0].id = 57;
   LocationReportingControlIEs[0].criticality = ignore;
   LocationReportingControlIEs[0].ValueSize = sizeof(_LocationReportingControlIEs_Value);
   LocationReportingControlIEs[0].decodeValue = &asn1PD__LocationReportingControlIEs_Value;
   LocationReportingControlIEs[0].printValue = &asn1Print__LocationReportingControlIEs_Value;
   LocationReportingControlIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  LocationReportingControlExtensions                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LocationReportingControlExtensions[4];
int LocationReportingControlExtensions_Size = 4;

void init_LocationReportingControlExtensions(ASN1CTXT *pctxt)
{

   LocationReportingControlExtensions[0].id = 111;
   LocationReportingControlExtensions[0].criticality = ignore;
   LocationReportingControlExtensions[0].ExtensionSize = sizeof(_LocationReportingControlExtensions_Extension);
   LocationReportingControlExtensions[0].decodeExtension = &asn1PD__LocationReportingControlExtensions_Extension;
   LocationReportingControlExtensions[0].printExtension = &asn1Print__LocationReportingControlExtensions_Extension;
   LocationReportingControlExtensions[0].presence = optional;

   LocationReportingControlExtensions[1].id = 112;
   LocationReportingControlExtensions[1].criticality = ignore;
   LocationReportingControlExtensions[1].ExtensionSize = sizeof(_LocationReportingControlExtensions_Extension_1);
   LocationReportingControlExtensions[1].decodeExtension = &asn1PD__LocationReportingControlExtensions_Extension_1;
   LocationReportingControlExtensions[1].printExtension = &asn1Print__LocationReportingControlExtensions_Extension_1;
   LocationReportingControlExtensions[1].presence = optional;

   LocationReportingControlExtensions[2].id = 113;
   LocationReportingControlExtensions[2].criticality = ignore;
   LocationReportingControlExtensions[2].ExtensionSize = sizeof(_LocationReportingControlExtensions_Extension_2);
   LocationReportingControlExtensions[2].decodeExtension = &asn1PD__LocationReportingControlExtensions_Extension_2;
   LocationReportingControlExtensions[2].printExtension = &asn1Print__LocationReportingControlExtensions_Extension_2;
   LocationReportingControlExtensions[2].presence = optional;

   LocationReportingControlExtensions[3].id = 114;
   LocationReportingControlExtensions[3].criticality = ignore;
   LocationReportingControlExtensions[3].ExtensionSize = sizeof(_LocationReportingControlExtensions_Extension_3);
   LocationReportingControlExtensions[3].decodeExtension = &asn1PD__LocationReportingControlExtensions_Extension_3;
   LocationReportingControlExtensions[3].printExtension = &asn1Print__LocationReportingControlExtensions_Extension_3;
   LocationReportingControlExtensions[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  LocationReportIEs                                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES LocationReportIEs[3];
int LocationReportIEs_Size = 3;

void init_LocationReportIEs(ASN1CTXT *pctxt)
{

   LocationReportIEs[0].id = 0;
   LocationReportIEs[0].criticality = ignore;
   LocationReportIEs[0].ValueSize = sizeof(_LocationReportIEs_Value);
   LocationReportIEs[0].decodeValue = &asn1PD__LocationReportIEs_Value;
   LocationReportIEs[0].printValue = &asn1Print__LocationReportIEs_Value;
   LocationReportIEs[0].presence = optional;

   LocationReportIEs[1].id = 4;
   LocationReportIEs[1].criticality = ignore;
   LocationReportIEs[1].ValueSize = sizeof(_LocationReportIEs_Value_1);
   LocationReportIEs[1].decodeValue = &asn1PD__LocationReportIEs_Value_1;
   LocationReportIEs[1].printValue = &asn1Print__LocationReportIEs_Value_1;
   LocationReportIEs[1].presence = optional;

   LocationReportIEs[2].id = 57;
   LocationReportIEs[2].criticality = ignore;
   LocationReportIEs[2].ValueSize = sizeof(_LocationReportIEs_Value_2);
   LocationReportIEs[2].decodeValue = &asn1PD__LocationReportIEs_Value_2;
   LocationReportIEs[2].printValue = &asn1Print__LocationReportIEs_Value_2;
   LocationReportIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  LocationReportExtensions                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LocationReportExtensions[4];
int LocationReportExtensions_Size = 4;

void init_LocationReportExtensions(ASN1CTXT *pctxt)
{

   LocationReportExtensions[0].id = 97;
   LocationReportExtensions[0].criticality = ignore;
   LocationReportExtensions[0].ExtensionSize = sizeof(_LocationReportExtensions_Extension);
   LocationReportExtensions[0].decodeExtension = &asn1PD__LocationReportExtensions_Extension;
   LocationReportExtensions[0].printExtension = &asn1Print__LocationReportExtensions_Extension;
   LocationReportExtensions[0].presence = optional;

   LocationReportExtensions[1].id = 119;
   LocationReportExtensions[1].criticality = ignore;
   LocationReportExtensions[1].ExtensionSize = sizeof(_LocationReportExtensions_Extension_1);
   LocationReportExtensions[1].decodeExtension = &asn1PD__LocationReportExtensions_Extension_1;
   LocationReportExtensions[1].printExtension = &asn1Print__LocationReportExtensions_Extension_1;
   LocationReportExtensions[1].presence = optional;

   LocationReportExtensions[2].id = 120;
   LocationReportExtensions[2].criticality = ignore;
   LocationReportExtensions[2].ExtensionSize = sizeof(_LocationReportExtensions_Extension_2);
   LocationReportExtensions[2].decodeExtension = &asn1PD__LocationReportExtensions_Extension_2;
   LocationReportExtensions[2].printExtension = &asn1Print__LocationReportExtensions_Extension_2;
   LocationReportExtensions[2].presence = optional;

   LocationReportExtensions[3].id = 122;
   LocationReportExtensions[3].criticality = ignore;
   LocationReportExtensions[3].ExtensionSize = sizeof(_LocationReportExtensions_Extension_3);
   LocationReportExtensions[3].decodeExtension = &asn1PD__LocationReportExtensions_Extension_3;
   LocationReportExtensions[3].printExtension = &asn1Print__LocationReportExtensions_Extension_3;
   LocationReportExtensions[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  InitialUE_MessageIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES InitialUE_MessageIEs[7];
int InitialUE_MessageIEs_Size = 7;

void init_InitialUE_MessageIEs(ASN1CTXT *pctxt)
{

   InitialUE_MessageIEs[0].id = 3;
   InitialUE_MessageIEs[0].criticality = ignore;
   InitialUE_MessageIEs[0].ValueSize = sizeof(_InitialUE_MessageIEs_Value);
   InitialUE_MessageIEs[0].decodeValue = &asn1PD__InitialUE_MessageIEs_Value;
   InitialUE_MessageIEs[0].printValue = &asn1Print__InitialUE_MessageIEs_Value;
   InitialUE_MessageIEs[0].presence = mandatory;

   InitialUE_MessageIEs[1].id = 15;
   InitialUE_MessageIEs[1].criticality = ignore;
   InitialUE_MessageIEs[1].ValueSize = sizeof(_InitialUE_MessageIEs_Value_1);
   InitialUE_MessageIEs[1].decodeValue = &asn1PD__InitialUE_MessageIEs_Value_1;
   InitialUE_MessageIEs[1].printValue = &asn1Print__InitialUE_MessageIEs_Value_1;
   InitialUE_MessageIEs[1].presence = mandatory;

   InitialUE_MessageIEs[2].id = 55;
   InitialUE_MessageIEs[2].criticality = ignore;
   InitialUE_MessageIEs[2].ValueSize = sizeof(_InitialUE_MessageIEs_Value_2);
   InitialUE_MessageIEs[2].decodeValue = &asn1PD__InitialUE_MessageIEs_Value_2;
   InitialUE_MessageIEs[2].printValue = &asn1Print__InitialUE_MessageIEs_Value_2;
   InitialUE_MessageIEs[2].presence = conditional;

   InitialUE_MessageIEs[3].id = 58;
   InitialUE_MessageIEs[3].criticality = ignore;
   InitialUE_MessageIEs[3].ValueSize = sizeof(_InitialUE_MessageIEs_Value_3);
   InitialUE_MessageIEs[3].decodeValue = &asn1PD__InitialUE_MessageIEs_Value_3;
   InitialUE_MessageIEs[3].printValue = &asn1Print__InitialUE_MessageIEs_Value_3;
   InitialUE_MessageIEs[3].presence = mandatory;

   InitialUE_MessageIEs[4].id = 16;
   InitialUE_MessageIEs[4].criticality = ignore;
   InitialUE_MessageIEs[4].ValueSize = sizeof(_InitialUE_MessageIEs_Value_4);
   InitialUE_MessageIEs[4].decodeValue = &asn1PD__InitialUE_MessageIEs_Value_4;
   InitialUE_MessageIEs[4].printValue = &asn1Print__InitialUE_MessageIEs_Value_4;
   InitialUE_MessageIEs[4].presence = mandatory;

   InitialUE_MessageIEs[5].id = 79;
   InitialUE_MessageIEs[5].criticality = ignore;
   InitialUE_MessageIEs[5].ValueSize = sizeof(_InitialUE_MessageIEs_Value_5);
   InitialUE_MessageIEs[5].decodeValue = &asn1PD__InitialUE_MessageIEs_Value_5;
   InitialUE_MessageIEs[5].printValue = &asn1Print__InitialUE_MessageIEs_Value_5;
   InitialUE_MessageIEs[5].presence = mandatory;

   InitialUE_MessageIEs[6].id = 86;
   InitialUE_MessageIEs[6].criticality = ignore;
   InitialUE_MessageIEs[6].ValueSize = sizeof(_InitialUE_MessageIEs_Value_6);
   InitialUE_MessageIEs[6].decodeValue = &asn1PD__InitialUE_MessageIEs_Value_6;
   InitialUE_MessageIEs[6].printValue = &asn1Print__InitialUE_MessageIEs_Value_6;
   InitialUE_MessageIEs[6].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  InitialUE_MessageExtensions                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION InitialUE_MessageExtensions[4];
int InitialUE_MessageExtensions_Size = 4;

void init_InitialUE_MessageExtensions(ASN1CTXT *pctxt)
{

   InitialUE_MessageExtensions[0].id = 108;
   InitialUE_MessageExtensions[0].criticality = ignore;
   InitialUE_MessageExtensions[0].ExtensionSize = sizeof(_InitialUE_MessageExtensions_Extension);
   InitialUE_MessageExtensions[0].decodeExtension = &asn1PD__InitialUE_MessageExtensions_Extension;
   InitialUE_MessageExtensions[0].printExtension = &asn1Print__InitialUE_MessageExtensions_Extension;
   InitialUE_MessageExtensions[0].presence = optional;

   InitialUE_MessageExtensions[1].id = 127;
   InitialUE_MessageExtensions[1].criticality = ignore;
   InitialUE_MessageExtensions[1].ExtensionSize = sizeof(_InitialUE_MessageExtensions_Extension_1);
   InitialUE_MessageExtensions[1].decodeExtension = &asn1PD__InitialUE_MessageExtensions_Extension_1;
   InitialUE_MessageExtensions[1].printExtension = &asn1Print__InitialUE_MessageExtensions_Extension_1;
   InitialUE_MessageExtensions[1].presence = optional;

   InitialUE_MessageExtensions[2].id = 23;
   InitialUE_MessageExtensions[2].criticality = ignore;
   InitialUE_MessageExtensions[2].ExtensionSize = sizeof(_InitialUE_MessageExtensions_Extension_2);
   InitialUE_MessageExtensions[2].decodeExtension = &asn1PD__InitialUE_MessageExtensions_Extension_2;
   InitialUE_MessageExtensions[2].printExtension = &asn1Print__InitialUE_MessageExtensions_Extension_2;
   InitialUE_MessageExtensions[2].presence = optional;

   InitialUE_MessageExtensions[3].id = 130;
   InitialUE_MessageExtensions[3].criticality = ignore;
   InitialUE_MessageExtensions[3].ExtensionSize = sizeof(_InitialUE_MessageExtensions_Extension_3);
   InitialUE_MessageExtensions[3].decodeExtension = &asn1PD__InitialUE_MessageExtensions_Extension_3;
   InitialUE_MessageExtensions[3].printExtension = &asn1Print__InitialUE_MessageExtensions_Extension_3;
   InitialUE_MessageExtensions[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  DirectTransferIEs                                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES DirectTransferIEs[5];
int DirectTransferIEs_Size = 5;

void init_DirectTransferIEs(ASN1CTXT *pctxt)
{

   DirectTransferIEs[0].id = 16;
   DirectTransferIEs[0].criticality = ignore;
   DirectTransferIEs[0].ValueSize = sizeof(_DirectTransferIEs_Value);
   DirectTransferIEs[0].decodeValue = &asn1PD__DirectTransferIEs_Value;
   DirectTransferIEs[0].printValue = &asn1Print__DirectTransferIEs_Value;
   DirectTransferIEs[0].presence = mandatory;

   DirectTransferIEs[1].id = 15;
   DirectTransferIEs[1].criticality = ignore;
   DirectTransferIEs[1].ValueSize = sizeof(_DirectTransferIEs_Value_1);
   DirectTransferIEs[1].decodeValue = &asn1PD__DirectTransferIEs_Value_1;
   DirectTransferIEs[1].printValue = &asn1Print__DirectTransferIEs_Value_1;
   DirectTransferIEs[1].presence = optional;

   DirectTransferIEs[2].id = 55;
   DirectTransferIEs[2].criticality = ignore;
   DirectTransferIEs[2].ValueSize = sizeof(_DirectTransferIEs_Value_2);
   DirectTransferIEs[2].decodeValue = &asn1PD__DirectTransferIEs_Value_2;
   DirectTransferIEs[2].printValue = &asn1Print__DirectTransferIEs_Value_2;
   DirectTransferIEs[2].presence = optional;

   DirectTransferIEs[3].id = 58;
   DirectTransferIEs[3].criticality = ignore;
   DirectTransferIEs[3].ValueSize = sizeof(_DirectTransferIEs_Value_3);
   DirectTransferIEs[3].decodeValue = &asn1PD__DirectTransferIEs_Value_3;
   DirectTransferIEs[3].printValue = &asn1Print__DirectTransferIEs_Value_3;
   DirectTransferIEs[3].presence = optional;

   DirectTransferIEs[4].id = 59;
   DirectTransferIEs[4].criticality = ignore;
   DirectTransferIEs[4].ValueSize = sizeof(_DirectTransferIEs_Value_4);
   DirectTransferIEs[4].decodeValue = &asn1PD__DirectTransferIEs_Value_4;
   DirectTransferIEs[4].printValue = &asn1Print__DirectTransferIEs_Value_4;
   DirectTransferIEs[4].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  DirectTransferExtensions                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION DirectTransferExtensions[2];
int DirectTransferExtensions_Size = 2;

void init_DirectTransferExtensions(ASN1CTXT *pctxt)
{

   DirectTransferExtensions[0].id = 129;
   DirectTransferExtensions[0].criticality = ignore;
   DirectTransferExtensions[0].ExtensionSize = sizeof(_DirectTransferExtensions_Extension);
   DirectTransferExtensions[0].decodeExtension = &asn1PD__DirectTransferExtensions_Extension;
   DirectTransferExtensions[0].printExtension = &asn1Print__DirectTransferExtensions_Extension;
   DirectTransferExtensions[0].presence = optional;

   DirectTransferExtensions[1].id = 128;
   DirectTransferExtensions[1].criticality = ignore;
   DirectTransferExtensions[1].ExtensionSize = sizeof(_DirectTransferExtensions_Extension_1);
   DirectTransferExtensions[1].decodeExtension = &asn1PD__DirectTransferExtensions_Extension_1;
   DirectTransferExtensions[1].printExtension = &asn1Print__DirectTransferExtensions_Extension_1;
   DirectTransferExtensions[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication_IEs                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RedirectionIndication_IEs[4];
int RedirectionIndication_IEs_Size = 4;

void init_RedirectionIndication_IEs(ASN1CTXT *pctxt)
{

   RedirectionIndication_IEs[0].id = 16;
   RedirectionIndication_IEs[0].criticality = ignore;
   RedirectionIndication_IEs[0].ValueSize = sizeof(_RedirectionIndication_IEs_Value);
   RedirectionIndication_IEs[0].decodeValue = &asn1PD__RedirectionIndication_IEs_Value;
   RedirectionIndication_IEs[0].printValue = &asn1Print__RedirectionIndication_IEs_Value;
   RedirectionIndication_IEs[0].presence = mandatory;

   RedirectionIndication_IEs[1].id = 131;
   RedirectionIndication_IEs[1].criticality = ignore;
   RedirectionIndication_IEs[1].ValueSize = sizeof(_RedirectionIndication_IEs_Value_1);
   RedirectionIndication_IEs[1].decodeValue = &asn1PD__RedirectionIndication_IEs_Value_1;
   RedirectionIndication_IEs[1].printValue = &asn1Print__RedirectionIndication_IEs_Value_1;
   RedirectionIndication_IEs[1].presence = mandatory;

   RedirectionIndication_IEs[2].id = 130;
   RedirectionIndication_IEs[2].criticality = ignore;
   RedirectionIndication_IEs[2].ValueSize = sizeof(_RedirectionIndication_IEs_Value_2);
   RedirectionIndication_IEs[2].decodeValue = &asn1PD__RedirectionIndication_IEs_Value_2;
   RedirectionIndication_IEs[2].printValue = &asn1Print__RedirectionIndication_IEs_Value_2;
   RedirectionIndication_IEs[2].presence = optional;

   RedirectionIndication_IEs[3].id = 23;
   RedirectionIndication_IEs[3].criticality = ignore;
   RedirectionIndication_IEs[3].ValueSize = sizeof(_RedirectionIndication_IEs_Value_3);
   RedirectionIndication_IEs[3].decodeValue = &asn1PD__RedirectionIndication_IEs_Value_3;
   RedirectionIndication_IEs[3].printValue = &asn1Print__RedirectionIndication_IEs_Value_3;
   RedirectionIndication_IEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  OverloadIEs                                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES OverloadIEs[2];
int OverloadIEs_Size = 2;

void init_OverloadIEs(ASN1CTXT *pctxt)
{

   OverloadIEs[0].id = 18;
   OverloadIEs[0].criticality = ignore;
   OverloadIEs[0].ValueSize = sizeof(_OverloadIEs_Value);
   OverloadIEs[0].decodeValue = &asn1PD__OverloadIEs_Value;
   OverloadIEs[0].printValue = &asn1Print__OverloadIEs_Value;
   OverloadIEs[0].presence = optional;

   OverloadIEs[1].id = 86;
   OverloadIEs[1].criticality = ignore;
   OverloadIEs[1].ValueSize = sizeof(_OverloadIEs_Value_1);
   OverloadIEs[1].decodeValue = &asn1PD__OverloadIEs_Value_1;
   OverloadIEs[1].printValue = &asn1Print__OverloadIEs_Value_1;
   OverloadIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  OverloadExtensions                                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION OverloadExtensions[2];
int OverloadExtensions_Size = 2;

void init_OverloadExtensions(ASN1CTXT *pctxt)
{

   OverloadExtensions[0].id = 3;
   OverloadExtensions[0].criticality = ignore;
   OverloadExtensions[0].ExtensionSize = sizeof(_OverloadExtensions_Extension);
   OverloadExtensions[0].decodeExtension = &asn1PD__OverloadExtensions_Extension;
   OverloadExtensions[0].printExtension = &asn1Print__OverloadExtensions_Extension;
   OverloadExtensions[0].presence = optional;

   OverloadExtensions[1].id = 96;
   OverloadExtensions[1].criticality = ignore;
   OverloadExtensions[1].ExtensionSize = sizeof(_OverloadExtensions_Extension_1);
   OverloadExtensions[1].decodeExtension = &asn1PD__OverloadExtensions_Extension_1;
   OverloadExtensions[1].printExtension = &asn1Print__OverloadExtensions_Extension_1;
   OverloadExtensions[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ErrorIndicationIEs                                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES ErrorIndicationIEs[4];
int ErrorIndicationIEs_Size = 4;

void init_ErrorIndicationIEs(ASN1CTXT *pctxt)
{

   ErrorIndicationIEs[0].id = 4;
   ErrorIndicationIEs[0].criticality = ignore;
   ErrorIndicationIEs[0].ValueSize = sizeof(_ErrorIndicationIEs_Value);
   ErrorIndicationIEs[0].decodeValue = &asn1PD__ErrorIndicationIEs_Value;
   ErrorIndicationIEs[0].printValue = &asn1Print__ErrorIndicationIEs_Value;
   ErrorIndicationIEs[0].presence = optional;

   ErrorIndicationIEs[1].id = 9;
   ErrorIndicationIEs[1].criticality = ignore;
   ErrorIndicationIEs[1].ValueSize = sizeof(_ErrorIndicationIEs_Value_1);
   ErrorIndicationIEs[1].decodeValue = &asn1PD__ErrorIndicationIEs_Value_1;
   ErrorIndicationIEs[1].printValue = &asn1Print__ErrorIndicationIEs_Value_1;
   ErrorIndicationIEs[1].presence = optional;

   ErrorIndicationIEs[2].id = 3;
   ErrorIndicationIEs[2].criticality = ignore;
   ErrorIndicationIEs[2].ValueSize = sizeof(_ErrorIndicationIEs_Value_2);
   ErrorIndicationIEs[2].decodeValue = &asn1PD__ErrorIndicationIEs_Value_2;
   ErrorIndicationIEs[2].printValue = &asn1Print__ErrorIndicationIEs_Value_2;
   ErrorIndicationIEs[2].presence = optional;

   ErrorIndicationIEs[3].id = 86;
   ErrorIndicationIEs[3].criticality = ignore;
   ErrorIndicationIEs[3].ValueSize = sizeof(_ErrorIndicationIEs_Value_3);
   ErrorIndicationIEs[3].decodeValue = &asn1PD__ErrorIndicationIEs_Value_3;
   ErrorIndicationIEs[3].printValue = &asn1Print__ErrorIndicationIEs_Value_3;
   ErrorIndicationIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  ErrorIndicationExtensions                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ErrorIndicationExtensions[1];
int ErrorIndicationExtensions_Size = 1;

void init_ErrorIndicationExtensions(ASN1CTXT *pctxt)
{

   ErrorIndicationExtensions[0].id = 96;
   ErrorIndicationExtensions[0].criticality = ignore;
   ErrorIndicationExtensions[0].ExtensionSize = sizeof(_ErrorIndicationExtensions_Extension);
   ErrorIndicationExtensions[0].decodeExtension = &asn1PD__ErrorIndicationExtensions_Extension;
   ErrorIndicationExtensions[0].printExtension = &asn1Print__ErrorIndicationExtensions_Extension;
   ErrorIndicationExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommandIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES SRNS_DataForwardCommandIEs[1];
int SRNS_DataForwardCommandIEs_Size = 1;

void init_SRNS_DataForwardCommandIEs(ASN1CTXT *pctxt)
{

   SRNS_DataForwardCommandIEs[0].id = 28;
   SRNS_DataForwardCommandIEs[0].criticality = ignore;
   SRNS_DataForwardCommandIEs[0].ValueSize = sizeof(_SRNS_DataForwardCommandIEs_Value);
   SRNS_DataForwardCommandIEs[0].decodeValue = &asn1PD__SRNS_DataForwardCommandIEs_Value;
   SRNS_DataForwardCommandIEs[0].printValue = &asn1Print__SRNS_DataForwardCommandIEs_Value;
   SRNS_DataForwardCommandIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommandExtensions                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION SRNS_DataForwardCommandExtensions[1];
int SRNS_DataForwardCommandExtensions_Size = 0;

void init_SRNS_DataForwardCommandExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_ContextIEs                                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES ForwardSRNS_ContextIEs[1];
int ForwardSRNS_ContextIEs_Size = 1;

void init_ForwardSRNS_ContextIEs(ASN1CTXT *pctxt)
{

   ForwardSRNS_ContextIEs[0].id = 25;
   ForwardSRNS_ContextIEs[0].criticality = ignore;
   ForwardSRNS_ContextIEs[0].ValueSize = sizeof(_ForwardSRNS_ContextIEs_Value);
   ForwardSRNS_ContextIEs[0].decodeValue = &asn1PD__ForwardSRNS_ContextIEs_Value;
   ForwardSRNS_ContextIEs[0].printValue = &asn1Print__ForwardSRNS_ContextIEs_Value;
   ForwardSRNS_ContextIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_ContextExtensions                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION ForwardSRNS_ContextExtensions[1];
int ForwardSRNS_ContextExtensions_Size = 1;

void init_ForwardSRNS_ContextExtensions(ASN1CTXT *pctxt)
{

   ForwardSRNS_ContextExtensions[0].id = 103;
   ForwardSRNS_ContextExtensions[0].criticality = ignore;
   ForwardSRNS_ContextExtensions[0].ExtensionSize = sizeof(_ForwardSRNS_ContextExtensions_Extension);
   ForwardSRNS_ContextExtensions[0].decodeExtension = &asn1PD__ForwardSRNS_ContextExtensions_Extension;
   ForwardSRNS_ContextExtensions[0].printExtension = &asn1Print__ForwardSRNS_ContextExtensions_Extension;
   ForwardSRNS_ContextExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequestIEs                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_AssignmentRequestIEs[2];
int RAB_AssignmentRequestIEs_Size = 2;

void init_RAB_AssignmentRequestIEs(ASN1CTXT *pctxt)
{

   RAB_AssignmentRequestIEs[0].id = 54;
   RAB_AssignmentRequestIEs[0].criticality = ignore;
   RAB_AssignmentRequestIEs[0].ValueSize = sizeof(_RAB_AssignmentRequestIEs_Value);
   RAB_AssignmentRequestIEs[0].decodeValue = &asn1PD__RAB_AssignmentRequestIEs_Value;
   RAB_AssignmentRequestIEs[0].printValue = &asn1Print__RAB_AssignmentRequestIEs_Value;
   RAB_AssignmentRequestIEs[0].presence = optional;

   RAB_AssignmentRequestIEs[1].id = 41;
   RAB_AssignmentRequestIEs[1].criticality = ignore;
   RAB_AssignmentRequestIEs[1].ValueSize = sizeof(_RAB_AssignmentRequestIEs_Value_1);
   RAB_AssignmentRequestIEs[1].decodeValue = &asn1PD__RAB_AssignmentRequestIEs_Value_1;
   RAB_AssignmentRequestIEs[1].printValue = &asn1Print__RAB_AssignmentRequestIEs_Value_1;
   RAB_AssignmentRequestIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItem_IEs                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES_PAIR RAB_SetupOrModifyItem_IEs[1];
int RAB_SetupOrModifyItem_IEs_Size = 1;

void init_RAB_SetupOrModifyItem_IEs(ASN1CTXT *pctxt)
{

   RAB_SetupOrModifyItem_IEs[0].id = 53;
   RAB_SetupOrModifyItem_IEs[0].firstCriticality = reject;
   RAB_SetupOrModifyItem_IEs[0].FirstValueSize = sizeof(_RAB_SetupOrModifyItem_IEs_FirstValue);
   RAB_SetupOrModifyItem_IEs[0].decodeFirstValue = &asn1PD__RAB_SetupOrModifyItem_IEs_FirstValue;
   RAB_SetupOrModifyItem_IEs[0].printFirstValue = &asn1Print__RAB_SetupOrModifyItem_IEs_FirstValue;
   RAB_SetupOrModifyItem_IEs[0].secondCriticality = ignore;
   RAB_SetupOrModifyItem_IEs[0].SecondValueSize = sizeof(_RAB_SetupOrModifyItem_IEs_SecondValue);
   RAB_SetupOrModifyItem_IEs[0].decodeSecondValue = &asn1PD__RAB_SetupOrModifyItem_IEs_SecondValue;
   RAB_SetupOrModifyItem_IEs[0].printSecondValue = &asn1Print__RAB_SetupOrModifyItem_IEs_SecondValue;
   RAB_SetupOrModifyItem_IEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_ExtIEs                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION TransportLayerInformation_ExtIEs[1];
int TransportLayerInformation_ExtIEs_Size = 0;

void init_TransportLayerInformation_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_ExtIEs                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_SetupOrModifyItemFirst_ExtIEs[1];
int RAB_SetupOrModifyItemFirst_ExtIEs_Size = 0;

void init_RAB_SetupOrModifyItemFirst_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_ExtIEs                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_SetupOrModifyItemSecond_ExtIEs[2];
int RAB_SetupOrModifyItemSecond_ExtIEs_Size = 2;

void init_RAB_SetupOrModifyItemSecond_ExtIEs(ASN1CTXT *pctxt)
{

   RAB_SetupOrModifyItemSecond_ExtIEs[0].id = 89;
   RAB_SetupOrModifyItemSecond_ExtIEs[0].criticality = ignore;
   RAB_SetupOrModifyItemSecond_ExtIEs[0].ExtensionSize = sizeof(_RAB_SetupOrModifyItemSecond_ExtIEs_Extension);
   RAB_SetupOrModifyItemSecond_ExtIEs[0].decodeExtension = &asn1PD__RAB_SetupOrModifyItemSecond_ExtIEs_Extension;
   RAB_SetupOrModifyItemSecond_ExtIEs[0].printExtension = &asn1Print__RAB_SetupOrModifyItemSecond_ExtIEs_Extension;
   RAB_SetupOrModifyItemSecond_ExtIEs[0].presence = optional;

   RAB_SetupOrModifyItemSecond_ExtIEs[1].id = 107;
   RAB_SetupOrModifyItemSecond_ExtIEs[1].criticality = ignore;
   RAB_SetupOrModifyItemSecond_ExtIEs[1].ExtensionSize = sizeof(_RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1);
   RAB_SetupOrModifyItemSecond_ExtIEs[1].decodeExtension = &asn1PD__RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1;
   RAB_SetupOrModifyItemSecond_ExtIEs[1].printExtension = &asn1Print__RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1;
   RAB_SetupOrModifyItemSecond_ExtIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequestExtensions                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_AssignmentRequestExtensions[1];
int RAB_AssignmentRequestExtensions_Size = 0;

void init_RAB_AssignmentRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponseIEs                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_AssignmentResponseIEs[6];
int RAB_AssignmentResponseIEs_Size = 6;

void init_RAB_AssignmentResponseIEs(ASN1CTXT *pctxt)
{

   RAB_AssignmentResponseIEs[0].id = 52;
   RAB_AssignmentResponseIEs[0].criticality = ignore;
   RAB_AssignmentResponseIEs[0].ValueSize = sizeof(_RAB_AssignmentResponseIEs_Value);
   RAB_AssignmentResponseIEs[0].decodeValue = &asn1PD__RAB_AssignmentResponseIEs_Value;
   RAB_AssignmentResponseIEs[0].printValue = &asn1Print__RAB_AssignmentResponseIEs_Value;
   RAB_AssignmentResponseIEs[0].presence = optional;

   RAB_AssignmentResponseIEs[1].id = 43;
   RAB_AssignmentResponseIEs[1].criticality = ignore;
   RAB_AssignmentResponseIEs[1].ValueSize = sizeof(_RAB_AssignmentResponseIEs_Value_1);
   RAB_AssignmentResponseIEs[1].decodeValue = &asn1PD__RAB_AssignmentResponseIEs_Value_1;
   RAB_AssignmentResponseIEs[1].printValue = &asn1Print__RAB_AssignmentResponseIEs_Value_1;
   RAB_AssignmentResponseIEs[1].presence = optional;

   RAB_AssignmentResponseIEs[2].id = 38;
   RAB_AssignmentResponseIEs[2].criticality = ignore;
   RAB_AssignmentResponseIEs[2].ValueSize = sizeof(_RAB_AssignmentResponseIEs_Value_2);
   RAB_AssignmentResponseIEs[2].decodeValue = &asn1PD__RAB_AssignmentResponseIEs_Value_2;
   RAB_AssignmentResponseIEs[2].printValue = &asn1Print__RAB_AssignmentResponseIEs_Value_2;
   RAB_AssignmentResponseIEs[2].presence = optional;

   RAB_AssignmentResponseIEs[3].id = 35;
   RAB_AssignmentResponseIEs[3].criticality = ignore;
   RAB_AssignmentResponseIEs[3].ValueSize = sizeof(_RAB_AssignmentResponseIEs_Value_3);
   RAB_AssignmentResponseIEs[3].decodeValue = &asn1PD__RAB_AssignmentResponseIEs_Value_3;
   RAB_AssignmentResponseIEs[3].printValue = &asn1Print__RAB_AssignmentResponseIEs_Value_3;
   RAB_AssignmentResponseIEs[3].presence = optional;

   RAB_AssignmentResponseIEs[4].id = 39;
   RAB_AssignmentResponseIEs[4].criticality = ignore;
   RAB_AssignmentResponseIEs[4].ValueSize = sizeof(_RAB_AssignmentResponseIEs_Value_4);
   RAB_AssignmentResponseIEs[4].decodeValue = &asn1PD__RAB_AssignmentResponseIEs_Value_4;
   RAB_AssignmentResponseIEs[4].printValue = &asn1Print__RAB_AssignmentResponseIEs_Value_4;
   RAB_AssignmentResponseIEs[4].presence = optional;

   RAB_AssignmentResponseIEs[5].id = 9;
   RAB_AssignmentResponseIEs[5].criticality = ignore;
   RAB_AssignmentResponseIEs[5].ValueSize = sizeof(_RAB_AssignmentResponseIEs_Value_5);
   RAB_AssignmentResponseIEs[5].decodeValue = &asn1PD__RAB_AssignmentResponseIEs_Value_5;
   RAB_AssignmentResponseIEs[5].printValue = &asn1Print__RAB_AssignmentResponseIEs_Value_5;
   RAB_AssignmentResponseIEs[5].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItemIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_SetupOrModifiedItemIEs[1];
int RAB_SetupOrModifiedItemIEs_Size = 1;

void init_RAB_SetupOrModifiedItemIEs(ASN1CTXT *pctxt)
{

   RAB_SetupOrModifiedItemIEs[0].id = 51;
   RAB_SetupOrModifiedItemIEs[0].criticality = ignore;
   RAB_SetupOrModifiedItemIEs[0].ValueSize = sizeof(_RAB_SetupOrModifiedItemIEs_Value);
   RAB_SetupOrModifiedItemIEs[0].decodeValue = &asn1PD__RAB_SetupOrModifiedItemIEs_Value;
   RAB_SetupOrModifiedItemIEs[0].printValue = &asn1Print__RAB_SetupOrModifiedItemIEs_Value;
   RAB_SetupOrModifiedItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_ExtIEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_SetupOrModifiedItem_ExtIEs[1];
int RAB_SetupOrModifiedItem_ExtIEs_Size = 1;

void init_RAB_SetupOrModifiedItem_ExtIEs(ASN1CTXT *pctxt)
{

   RAB_SetupOrModifiedItem_ExtIEs[0].id = 90;
   RAB_SetupOrModifiedItem_ExtIEs[0].criticality = ignore;
   RAB_SetupOrModifiedItem_ExtIEs[0].ExtensionSize = sizeof(_RAB_SetupOrModifiedItem_ExtIEs_Extension);
   RAB_SetupOrModifiedItem_ExtIEs[0].decodeExtension = &asn1PD__RAB_SetupOrModifiedItem_ExtIEs_Extension;
   RAB_SetupOrModifiedItem_ExtIEs[0].printExtension = &asn1Print__RAB_SetupOrModifiedItem_ExtIEs_Extension;
   RAB_SetupOrModifiedItem_ExtIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItemIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_ReleasedItemIEs[1];
int RAB_ReleasedItemIEs_Size = 1;

void init_RAB_ReleasedItemIEs(ASN1CTXT *pctxt)
{

   RAB_ReleasedItemIEs[0].id = 42;
   RAB_ReleasedItemIEs[0].criticality = ignore;
   RAB_ReleasedItemIEs[0].ValueSize = sizeof(_RAB_ReleasedItemIEs_Value);
   RAB_ReleasedItemIEs[0].decodeValue = &asn1PD__RAB_ReleasedItemIEs_Value;
   RAB_ReleasedItemIEs[0].printValue = &asn1Print__RAB_ReleasedItemIEs_Value;
   RAB_ReleasedItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_ExtIEs                                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_ReleasedItem_ExtIEs[1];
int RAB_ReleasedItem_ExtIEs_Size = 0;

void init_RAB_ReleasedItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_ExtIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION DataVolumeList_ExtIEs[1];
int DataVolumeList_ExtIEs_Size = 0;

void init_DataVolumeList_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItemIEs                                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_QueuedItemIEs[1];
int RAB_QueuedItemIEs_Size = 1;

void init_RAB_QueuedItemIEs(ASN1CTXT *pctxt)
{

   RAB_QueuedItemIEs[0].id = 37;
   RAB_QueuedItemIEs[0].criticality = ignore;
   RAB_QueuedItemIEs[0].ValueSize = sizeof(_RAB_QueuedItemIEs_Value);
   RAB_QueuedItemIEs[0].decodeValue = &asn1PD__RAB_QueuedItemIEs_Value;
   RAB_QueuedItemIEs[0].printValue = &asn1Print__RAB_QueuedItemIEs_Value;
   RAB_QueuedItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_ExtIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_QueuedItem_ExtIEs[1];
int RAB_QueuedItem_ExtIEs_Size = 0;

void init_RAB_QueuedItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponseExtensions                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_AssignmentResponseExtensions[1];
int RAB_AssignmentResponseExtensions_Size = 1;

void init_RAB_AssignmentResponseExtensions(ASN1CTXT *pctxt)
{

   RAB_AssignmentResponseExtensions[0].id = 110;
   RAB_AssignmentResponseExtensions[0].criticality = ignore;
   RAB_AssignmentResponseExtensions[0].ExtensionSize = sizeof(_RAB_AssignmentResponseExtensions_Extension);
   RAB_AssignmentResponseExtensions[0].decodeExtension = &asn1PD__RAB_AssignmentResponseExtensions_Extension;
   RAB_AssignmentResponseExtensions[0].printExtension = &asn1Print__RAB_AssignmentResponseExtensions_Extension;
   RAB_AssignmentResponseExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[1];
int GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size = 1;

void init_GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs(ASN1CTXT *pctxt)
{

   GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[0].id = 109;
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[0].criticality = ignore;
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[0].ValueSize = sizeof(_GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value);
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[0].decodeValue = &asn1PD__GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value;
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[0].printValue = &asn1Print__GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value;
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[1];
int GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size = 0;

void init_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_IEs                                        */
/*                                                            */
/**************************************************************/

RANAP_PRIVATE_IES PrivateMessage_IEs[1];
int PrivateMessage_IEs_Size = 0;

void init_PrivateMessage_IEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformationIEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RANAP_RelocationInformationIEs[2];
int RANAP_RelocationInformationIEs_Size = 2;

void init_RANAP_RelocationInformationIEs(ASN1CTXT *pctxt)
{

   RANAP_RelocationInformationIEs[0].id = 81;
   RANAP_RelocationInformationIEs[0].criticality = ignore;
   RANAP_RelocationInformationIEs[0].ValueSize = sizeof(_RANAP_RelocationInformationIEs_Value);
   RANAP_RelocationInformationIEs[0].decodeValue = &asn1PD__RANAP_RelocationInformationIEs_Value;
   RANAP_RelocationInformationIEs[0].printValue = &asn1Print__RANAP_RelocationInformationIEs_Value;
   RANAP_RelocationInformationIEs[0].presence = optional;

   RANAP_RelocationInformationIEs[1].id = 83;
   RANAP_RelocationInformationIEs[1].criticality = ignore;
   RANAP_RelocationInformationIEs[1].ValueSize = sizeof(_RANAP_RelocationInformationIEs_Value_1);
   RANAP_RelocationInformationIEs[1].decodeValue = &asn1PD__RANAP_RelocationInformationIEs_Value_1;
   RANAP_RelocationInformationIEs[1].printValue = &asn1Print__RANAP_RelocationInformationIEs_Value_1;
   RANAP_RelocationInformationIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItemIEs_RANAP_RelocInf           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES DirectTransferInformationItemIEs_RANAP_RelocInf[1];
int DirectTransferInformationItemIEs_RANAP_RelocInf_Size = 1;

void init_DirectTransferInformationItemIEs_RANAP_RelocInf(ASN1CTXT *pctxt)
{

   DirectTransferInformationItemIEs_RANAP_RelocInf[0].id = 80;
   DirectTransferInformationItemIEs_RANAP_RelocInf[0].criticality = ignore;
   DirectTransferInformationItemIEs_RANAP_RelocInf[0].ValueSize = sizeof(_DirectTransferInformationItemIEs_RANAP_RelocInf_Value);
   DirectTransferInformationItemIEs_RANAP_RelocInf[0].decodeValue = &asn1PD__DirectTransferInformationItemIEs_RANAP_RelocInf_Value;
   DirectTransferInformationItemIEs_RANAP_RelocInf[0].printValue = &asn1Print__DirectTransferInformationItemIEs_RANAP_RelocInf_Value;
   DirectTransferInformationItemIEs_RANAP_RelocInf[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocIn  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[1];
int RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size = 0;

void init_RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItemIEs_RANAP_RelocInf                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_ContextItemIEs_RANAP_RelocInf[1];
int RAB_ContextItemIEs_RANAP_RelocInf_Size = 1;

void init_RAB_ContextItemIEs_RANAP_RelocInf(ASN1CTXT *pctxt)
{

   RAB_ContextItemIEs_RANAP_RelocInf[0].id = 82;
   RAB_ContextItemIEs_RANAP_RelocInf[0].criticality = ignore;
   RAB_ContextItemIEs_RANAP_RelocInf[0].ValueSize = sizeof(_RAB_ContextItemIEs_RANAP_RelocInf_Value);
   RAB_ContextItemIEs_RANAP_RelocInf[0].decodeValue = &asn1PD__RAB_ContextItemIEs_RANAP_RelocInf_Value;
   RAB_ContextItemIEs_RANAP_RelocInf[0].printValue = &asn1Print__RAB_ContextItemIEs_RANAP_RelocInf_Value;
   RAB_ContextItemIEs_RANAP_RelocInf[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_ExtIEs_RANAP_RelocInf                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_ContextItem_ExtIEs_RANAP_RelocInf[1];
int RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size = 0;

void init_RAB_ContextItem_ExtIEs_RANAP_RelocInf(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformationExtensions                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RANAP_RelocationInformationExtensions[1];
int RANAP_RelocationInformationExtensions_Size = 1;

void init_RANAP_RelocationInformationExtensions(ASN1CTXT *pctxt)
{

   RANAP_RelocationInformationExtensions[0].id = 103;
   RANAP_RelocationInformationExtensions[0].criticality = ignore;
   RANAP_RelocationInformationExtensions[0].ExtensionSize = sizeof(_RANAP_RelocationInformationExtensions_Extension);
   RANAP_RelocationInformationExtensions[0].decodeExtension = &asn1PD__RANAP_RelocationInformationExtensions_Extension;
   RANAP_RelocationInformationExtensions[0].printExtension = &asn1Print__RANAP_RelocationInformationExtensions_Extension;
   RANAP_RelocationInformationExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequestIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_ModifyRequestIEs[1];
int RAB_ModifyRequestIEs_Size = 1;

void init_RAB_ModifyRequestIEs(ASN1CTXT *pctxt)
{

   RAB_ModifyRequestIEs[0].id = 91;
   RAB_ModifyRequestIEs[0].criticality = ignore;
   RAB_ModifyRequestIEs[0].ValueSize = sizeof(_RAB_ModifyRequestIEs_Value);
   RAB_ModifyRequestIEs[0].decodeValue = &asn1PD__RAB_ModifyRequestIEs_Value;
   RAB_ModifyRequestIEs[0].printValue = &asn1Print__RAB_ModifyRequestIEs_Value;
   RAB_ModifyRequestIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItemIEs                                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES RAB_ModifyItemIEs[1];
int RAB_ModifyItemIEs_Size = 1;

void init_RAB_ModifyItemIEs(ASN1CTXT *pctxt)
{

   RAB_ModifyItemIEs[0].id = 92;
   RAB_ModifyItemIEs[0].criticality = ignore;
   RAB_ModifyItemIEs[0].ValueSize = sizeof(_RAB_ModifyItemIEs_Value);
   RAB_ModifyItemIEs[0].decodeValue = &asn1PD__RAB_ModifyItemIEs_Value;
   RAB_ModifyItemIEs[0].printValue = &asn1Print__RAB_ModifyItemIEs_Value;
   RAB_ModifyItemIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_ExtIEs                                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_ModifyItem_ExtIEs[1];
int RAB_ModifyItem_ExtIEs_Size = 0;

void init_RAB_ModifyItem_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequestExtensions                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION RAB_ModifyRequestExtensions[1];
int RAB_ModifyRequestExtensions_Size = 0;

void init_RAB_ModifyRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestIEs                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES LocationRelatedDataRequestIEs[1];
int LocationRelatedDataRequestIEs_Size = 1;

void init_LocationRelatedDataRequestIEs(ASN1CTXT *pctxt)
{

   LocationRelatedDataRequestIEs[0].id = 95;
   LocationRelatedDataRequestIEs[0].criticality = reject;
   LocationRelatedDataRequestIEs[0].ValueSize = sizeof(_LocationRelatedDataRequestIEs_Value);
   LocationRelatedDataRequestIEs[0].decodeValue = &asn1PD__LocationRelatedDataRequestIEs_Value;
   LocationRelatedDataRequestIEs[0].printValue = &asn1Print__LocationRelatedDataRequestIEs_Value;
   LocationRelatedDataRequestIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestExtensions                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LocationRelatedDataRequestExtensions[1];
int LocationRelatedDataRequestExtensions_Size = 1;

void init_LocationRelatedDataRequestExtensions(ASN1CTXT *pctxt)
{

   LocationRelatedDataRequestExtensions[0].id = 115;
   LocationRelatedDataRequestExtensions[0].criticality = reject;
   LocationRelatedDataRequestExtensions[0].ExtensionSize = sizeof(_LocationRelatedDataRequestExtensions_Extension);
   LocationRelatedDataRequestExtensions[0].decodeExtension = &asn1PD__LocationRelatedDataRequestExtensions_Extension;
   LocationRelatedDataRequestExtensions[0].printExtension = &asn1Print__LocationRelatedDataRequestExtensions_Extension;
   LocationRelatedDataRequestExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponseIEs                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES LocationRelatedDataResponseIEs[1];
int LocationRelatedDataResponseIEs_Size = 1;

void init_LocationRelatedDataResponseIEs(ASN1CTXT *pctxt)
{

   LocationRelatedDataResponseIEs[0].id = 94;
   LocationRelatedDataResponseIEs[0].criticality = ignore;
   LocationRelatedDataResponseIEs[0].ValueSize = sizeof(_LocationRelatedDataResponseIEs_Value);
   LocationRelatedDataResponseIEs[0].decodeValue = &asn1PD__LocationRelatedDataResponseIEs_Value;
   LocationRelatedDataResponseIEs[0].printValue = &asn1Print__LocationRelatedDataResponseIEs_Value;
   LocationRelatedDataResponseIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponseExtensions                     */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LocationRelatedDataResponseExtensions[1];
int LocationRelatedDataResponseExtensions_Size = 1;

void init_LocationRelatedDataResponseExtensions(ASN1CTXT *pctxt)
{

   LocationRelatedDataResponseExtensions[0].id = 9;
   LocationRelatedDataResponseExtensions[0].criticality = ignore;
   LocationRelatedDataResponseExtensions[0].ExtensionSize = sizeof(_LocationRelatedDataResponseExtensions_Extension);
   LocationRelatedDataResponseExtensions[0].decodeExtension = &asn1PD__LocationRelatedDataResponseExtensions_Extension;
   LocationRelatedDataResponseExtensions[0].printExtension = &asn1Print__LocationRelatedDataResponseExtensions_Extension;
   LocationRelatedDataResponseExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailureIEs                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES LocationRelatedDataFailureIEs[1];
int LocationRelatedDataFailureIEs_Size = 1;

void init_LocationRelatedDataFailureIEs(ASN1CTXT *pctxt)
{

   LocationRelatedDataFailureIEs[0].id = 4;
   LocationRelatedDataFailureIEs[0].criticality = ignore;
   LocationRelatedDataFailureIEs[0].ValueSize = sizeof(_LocationRelatedDataFailureIEs_Value);
   LocationRelatedDataFailureIEs[0].decodeValue = &asn1PD__LocationRelatedDataFailureIEs_Value;
   LocationRelatedDataFailureIEs[0].printValue = &asn1Print__LocationRelatedDataFailureIEs_Value;
   LocationRelatedDataFailureIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailureExtensions                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LocationRelatedDataFailureExtensions[1];
int LocationRelatedDataFailureExtensions_Size = 1;

void init_LocationRelatedDataFailureExtensions(ASN1CTXT *pctxt)
{

   LocationRelatedDataFailureExtensions[0].id = 9;
   LocationRelatedDataFailureExtensions[0].criticality = ignore;
   LocationRelatedDataFailureExtensions[0].ExtensionSize = sizeof(_LocationRelatedDataFailureExtensions_Extension);
   LocationRelatedDataFailureExtensions[0].decodeExtension = &asn1PD__LocationRelatedDataFailureExtensions_Extension;
   LocationRelatedDataFailureExtensions[0].printExtension = &asn1Print__LocationRelatedDataFailureExtensions_Extension;
   LocationRelatedDataFailureExtensions[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndicationIEs                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES InformationTransferIndicationIEs[4];
int InformationTransferIndicationIEs_Size = 4;

void init_InformationTransferIndicationIEs(ASN1CTXT *pctxt)
{

   InformationTransferIndicationIEs[0].id = 104;
   InformationTransferIndicationIEs[0].criticality = reject;
   InformationTransferIndicationIEs[0].ValueSize = sizeof(_InformationTransferIndicationIEs_Value);
   InformationTransferIndicationIEs[0].decodeValue = &asn1PD__InformationTransferIndicationIEs_Value;
   InformationTransferIndicationIEs[0].printValue = &asn1Print__InformationTransferIndicationIEs_Value;
   InformationTransferIndicationIEs[0].presence = mandatory;

   InformationTransferIndicationIEs[1].id = 106;
   InformationTransferIndicationIEs[1].criticality = reject;
   InformationTransferIndicationIEs[1].ValueSize = sizeof(_InformationTransferIndicationIEs_Value_1);
   InformationTransferIndicationIEs[1].decodeValue = &asn1PD__InformationTransferIndicationIEs_Value_1;
   InformationTransferIndicationIEs[1].printValue = &asn1Print__InformationTransferIndicationIEs_Value_1;
   InformationTransferIndicationIEs[1].presence = mandatory;

   InformationTransferIndicationIEs[2].id = 3;
   InformationTransferIndicationIEs[2].criticality = reject;
   InformationTransferIndicationIEs[2].ValueSize = sizeof(_InformationTransferIndicationIEs_Value_2);
   InformationTransferIndicationIEs[2].decodeValue = &asn1PD__InformationTransferIndicationIEs_Value_2;
   InformationTransferIndicationIEs[2].printValue = &asn1Print__InformationTransferIndicationIEs_Value_2;
   InformationTransferIndicationIEs[2].presence = mandatory;

   InformationTransferIndicationIEs[3].id = 96;
   InformationTransferIndicationIEs[3].criticality = ignore;
   InformationTransferIndicationIEs[3].ValueSize = sizeof(_InformationTransferIndicationIEs_Value_3);
   InformationTransferIndicationIEs[3].decodeValue = &asn1PD__InformationTransferIndicationIEs_Value_3;
   InformationTransferIndicationIEs[3].printValue = &asn1Print__InformationTransferIndicationIEs_Value_3;
   InformationTransferIndicationIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndicationExtensions                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION InformationTransferIndicationExtensions[1];
int InformationTransferIndicationExtensions_Size = 0;

void init_InformationTransferIndicationExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmationIEs                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES InformationTransferConfirmationIEs[4];
int InformationTransferConfirmationIEs_Size = 4;

void init_InformationTransferConfirmationIEs(ASN1CTXT *pctxt)
{

   InformationTransferConfirmationIEs[0].id = 104;
   InformationTransferConfirmationIEs[0].criticality = ignore;
   InformationTransferConfirmationIEs[0].ValueSize = sizeof(_InformationTransferConfirmationIEs_Value);
   InformationTransferConfirmationIEs[0].decodeValue = &asn1PD__InformationTransferConfirmationIEs_Value;
   InformationTransferConfirmationIEs[0].printValue = &asn1Print__InformationTransferConfirmationIEs_Value;
   InformationTransferConfirmationIEs[0].presence = mandatory;

   InformationTransferConfirmationIEs[1].id = 3;
   InformationTransferConfirmationIEs[1].criticality = ignore;
   InformationTransferConfirmationIEs[1].ValueSize = sizeof(_InformationTransferConfirmationIEs_Value_1);
   InformationTransferConfirmationIEs[1].decodeValue = &asn1PD__InformationTransferConfirmationIEs_Value_1;
   InformationTransferConfirmationIEs[1].printValue = &asn1Print__InformationTransferConfirmationIEs_Value_1;
   InformationTransferConfirmationIEs[1].presence = mandatory;

   InformationTransferConfirmationIEs[2].id = 9;
   InformationTransferConfirmationIEs[2].criticality = ignore;
   InformationTransferConfirmationIEs[2].ValueSize = sizeof(_InformationTransferConfirmationIEs_Value_2);
   InformationTransferConfirmationIEs[2].decodeValue = &asn1PD__InformationTransferConfirmationIEs_Value_2;
   InformationTransferConfirmationIEs[2].printValue = &asn1Print__InformationTransferConfirmationIEs_Value_2;
   InformationTransferConfirmationIEs[2].presence = optional;

   InformationTransferConfirmationIEs[3].id = 86;
   InformationTransferConfirmationIEs[3].criticality = ignore;
   InformationTransferConfirmationIEs[3].ValueSize = sizeof(_InformationTransferConfirmationIEs_Value_3);
   InformationTransferConfirmationIEs[3].decodeValue = &asn1PD__InformationTransferConfirmationIEs_Value_3;
   InformationTransferConfirmationIEs[3].printValue = &asn1Print__InformationTransferConfirmationIEs_Value_3;
   InformationTransferConfirmationIEs[3].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmationExtensions                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION InformationTransferConfirmationExtensions[1];
int InformationTransferConfirmationExtensions_Size = 0;

void init_InformationTransferConfirmationExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailureIEs                             */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES InformationTransferFailureIEs[5];
int InformationTransferFailureIEs_Size = 5;

void init_InformationTransferFailureIEs(ASN1CTXT *pctxt)
{

   InformationTransferFailureIEs[0].id = 104;
   InformationTransferFailureIEs[0].criticality = ignore;
   InformationTransferFailureIEs[0].ValueSize = sizeof(_InformationTransferFailureIEs_Value);
   InformationTransferFailureIEs[0].decodeValue = &asn1PD__InformationTransferFailureIEs_Value;
   InformationTransferFailureIEs[0].printValue = &asn1Print__InformationTransferFailureIEs_Value;
   InformationTransferFailureIEs[0].presence = mandatory;

   InformationTransferFailureIEs[1].id = 3;
   InformationTransferFailureIEs[1].criticality = ignore;
   InformationTransferFailureIEs[1].ValueSize = sizeof(_InformationTransferFailureIEs_Value_1);
   InformationTransferFailureIEs[1].decodeValue = &asn1PD__InformationTransferFailureIEs_Value_1;
   InformationTransferFailureIEs[1].printValue = &asn1Print__InformationTransferFailureIEs_Value_1;
   InformationTransferFailureIEs[1].presence = mandatory;

   InformationTransferFailureIEs[2].id = 4;
   InformationTransferFailureIEs[2].criticality = ignore;
   InformationTransferFailureIEs[2].ValueSize = sizeof(_InformationTransferFailureIEs_Value_2);
   InformationTransferFailureIEs[2].decodeValue = &asn1PD__InformationTransferFailureIEs_Value_2;
   InformationTransferFailureIEs[2].printValue = &asn1Print__InformationTransferFailureIEs_Value_2;
   InformationTransferFailureIEs[2].presence = mandatory;

   InformationTransferFailureIEs[3].id = 9;
   InformationTransferFailureIEs[3].criticality = ignore;
   InformationTransferFailureIEs[3].ValueSize = sizeof(_InformationTransferFailureIEs_Value_3);
   InformationTransferFailureIEs[3].decodeValue = &asn1PD__InformationTransferFailureIEs_Value_3;
   InformationTransferFailureIEs[3].printValue = &asn1Print__InformationTransferFailureIEs_Value_3;
   InformationTransferFailureIEs[3].presence = optional;

   InformationTransferFailureIEs[4].id = 86;
   InformationTransferFailureIEs[4].criticality = ignore;
   InformationTransferFailureIEs[4].ValueSize = sizeof(_InformationTransferFailureIEs_Value_4);
   InformationTransferFailureIEs[4].decodeValue = &asn1PD__InformationTransferFailureIEs_Value_4;
   InformationTransferFailureIEs[4].printValue = &asn1Print__InformationTransferFailureIEs_Value_4;
   InformationTransferFailureIEs[4].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailureExtensions                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION InformationTransferFailureExtensions[1];
int InformationTransferFailureExtensions_Size = 0;

void init_InformationTransferFailureExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndicationIEs                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES UESpecificInformationIndicationIEs[1];
int UESpecificInformationIndicationIEs_Size = 1;

void init_UESpecificInformationIndicationIEs(ASN1CTXT *pctxt)
{

   UESpecificInformationIndicationIEs[0].id = 118;
   UESpecificInformationIndicationIEs[0].criticality = ignore;
   UESpecificInformationIndicationIEs[0].ValueSize = sizeof(_UESpecificInformationIndicationIEs_Value);
   UESpecificInformationIndicationIEs[0].decodeValue = &asn1PD__UESpecificInformationIndicationIEs_Value;
   UESpecificInformationIndicationIEs[0].printValue = &asn1Print__UESpecificInformationIndicationIEs_Value;
   UESpecificInformationIndicationIEs[0].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndicationExtensions                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION UESpecificInformationIndicationExtensions[1];
int UESpecificInformationIndicationExtensions_Size = 0;

void init_UESpecificInformationIndicationExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransferIEs                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES DirectInformationTransferIEs[4];
int DirectInformationTransferIEs_Size = 4;

void init_DirectInformationTransferIEs(ASN1CTXT *pctxt)
{

   DirectInformationTransferIEs[0].id = 126;
   DirectInformationTransferIEs[0].criticality = ignore;
   DirectInformationTransferIEs[0].ValueSize = sizeof(_DirectInformationTransferIEs_Value);
   DirectInformationTransferIEs[0].decodeValue = &asn1PD__DirectInformationTransferIEs_Value;
   DirectInformationTransferIEs[0].printValue = &asn1Print__DirectInformationTransferIEs_Value;
   DirectInformationTransferIEs[0].presence = optional;

   DirectInformationTransferIEs[1].id = 3;
   DirectInformationTransferIEs[1].criticality = ignore;
   DirectInformationTransferIEs[1].ValueSize = sizeof(_DirectInformationTransferIEs_Value_1);
   DirectInformationTransferIEs[1].decodeValue = &asn1PD__DirectInformationTransferIEs_Value_1;
   DirectInformationTransferIEs[1].printValue = &asn1Print__DirectInformationTransferIEs_Value_1;
   DirectInformationTransferIEs[1].presence = mandatory;

   DirectInformationTransferIEs[2].id = 86;
   DirectInformationTransferIEs[2].criticality = ignore;
   DirectInformationTransferIEs[2].ValueSize = sizeof(_DirectInformationTransferIEs_Value_2);
   DirectInformationTransferIEs[2].decodeValue = &asn1PD__DirectInformationTransferIEs_Value_2;
   DirectInformationTransferIEs[2].printValue = &asn1Print__DirectInformationTransferIEs_Value_2;
   DirectInformationTransferIEs[2].presence = optional;

   DirectInformationTransferIEs[3].id = 96;
   DirectInformationTransferIEs[3].criticality = ignore;
   DirectInformationTransferIEs[3].ValueSize = sizeof(_DirectInformationTransferIEs_Value_3);
   DirectInformationTransferIEs[3].decodeValue = &asn1PD__DirectInformationTransferIEs_Value_3;
   DirectInformationTransferIEs[3].printValue = &asn1Print__DirectInformationTransferIEs_Value_3;
   DirectInformationTransferIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransferExtensions                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION DirectInformationTransferExtensions[1];
int DirectInformationTransferExtensions_Size = 0;

void init_DirectInformationTransferExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequestIEs                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES UplinkInformationExchangeRequestIEs[6];
int UplinkInformationExchangeRequestIEs_Size = 6;

void init_UplinkInformationExchangeRequestIEs(ASN1CTXT *pctxt)
{

   UplinkInformationExchangeRequestIEs[0].id = 136;
   UplinkInformationExchangeRequestIEs[0].criticality = reject;
   UplinkInformationExchangeRequestIEs[0].ValueSize = sizeof(_UplinkInformationExchangeRequestIEs_Value);
   UplinkInformationExchangeRequestIEs[0].decodeValue = &asn1PD__UplinkInformationExchangeRequestIEs_Value;
   UplinkInformationExchangeRequestIEs[0].printValue = &asn1Print__UplinkInformationExchangeRequestIEs_Value;
   UplinkInformationExchangeRequestIEs[0].presence = mandatory;

   UplinkInformationExchangeRequestIEs[1].id = 137;
   UplinkInformationExchangeRequestIEs[1].criticality = reject;
   UplinkInformationExchangeRequestIEs[1].ValueSize = sizeof(_UplinkInformationExchangeRequestIEs_Value_1);
   UplinkInformationExchangeRequestIEs[1].decodeValue = &asn1PD__UplinkInformationExchangeRequestIEs_Value_1;
   UplinkInformationExchangeRequestIEs[1].printValue = &asn1Print__UplinkInformationExchangeRequestIEs_Value_1;
   UplinkInformationExchangeRequestIEs[1].presence = mandatory;

   UplinkInformationExchangeRequestIEs[2].id = 123;
   UplinkInformationExchangeRequestIEs[2].criticality = reject;
   UplinkInformationExchangeRequestIEs[2].ValueSize = sizeof(_UplinkInformationExchangeRequestIEs_Value_2);
   UplinkInformationExchangeRequestIEs[2].decodeValue = &asn1PD__UplinkInformationExchangeRequestIEs_Value_2;
   UplinkInformationExchangeRequestIEs[2].printValue = &asn1Print__UplinkInformationExchangeRequestIEs_Value_2;
   UplinkInformationExchangeRequestIEs[2].presence = conditional;

   UplinkInformationExchangeRequestIEs[3].id = 139;
   UplinkInformationExchangeRequestIEs[3].criticality = reject;
   UplinkInformationExchangeRequestIEs[3].ValueSize = sizeof(_UplinkInformationExchangeRequestIEs_Value_3);
   UplinkInformationExchangeRequestIEs[3].decodeValue = &asn1PD__UplinkInformationExchangeRequestIEs_Value_3;
   UplinkInformationExchangeRequestIEs[3].printValue = &asn1Print__UplinkInformationExchangeRequestIEs_Value_3;
   UplinkInformationExchangeRequestIEs[3].presence = conditional;

   UplinkInformationExchangeRequestIEs[4].id = 3;
   UplinkInformationExchangeRequestIEs[4].criticality = reject;
   UplinkInformationExchangeRequestIEs[4].ValueSize = sizeof(_UplinkInformationExchangeRequestIEs_Value_4);
   UplinkInformationExchangeRequestIEs[4].decodeValue = &asn1PD__UplinkInformationExchangeRequestIEs_Value_4;
   UplinkInformationExchangeRequestIEs[4].printValue = &asn1Print__UplinkInformationExchangeRequestIEs_Value_4;
   UplinkInformationExchangeRequestIEs[4].presence = mandatory;

   UplinkInformationExchangeRequestIEs[5].id = 86;
   UplinkInformationExchangeRequestIEs[5].criticality = reject;
   UplinkInformationExchangeRequestIEs[5].ValueSize = sizeof(_UplinkInformationExchangeRequestIEs_Value_5);
   UplinkInformationExchangeRequestIEs[5].decodeValue = &asn1PD__UplinkInformationExchangeRequestIEs_Value_5;
   UplinkInformationExchangeRequestIEs[5].printValue = &asn1Print__UplinkInformationExchangeRequestIEs_Value_5;
   UplinkInformationExchangeRequestIEs[5].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequestExtensions                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION UplinkInformationExchangeRequestExtensions[1];
int UplinkInformationExchangeRequestExtensions_Size = 0;

void init_UplinkInformationExchangeRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponseIEs                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES UplinkInformationExchangeResponseIEs[5];
int UplinkInformationExchangeResponseIEs_Size = 5;

void init_UplinkInformationExchangeResponseIEs(ASN1CTXT *pctxt)
{

   UplinkInformationExchangeResponseIEs[0].id = 136;
   UplinkInformationExchangeResponseIEs[0].criticality = ignore;
   UplinkInformationExchangeResponseIEs[0].ValueSize = sizeof(_UplinkInformationExchangeResponseIEs_Value);
   UplinkInformationExchangeResponseIEs[0].decodeValue = &asn1PD__UplinkInformationExchangeResponseIEs_Value;
   UplinkInformationExchangeResponseIEs[0].printValue = &asn1Print__UplinkInformationExchangeResponseIEs_Value;
   UplinkInformationExchangeResponseIEs[0].presence = mandatory;

   UplinkInformationExchangeResponseIEs[1].id = 138;
   UplinkInformationExchangeResponseIEs[1].criticality = ignore;
   UplinkInformationExchangeResponseIEs[1].ValueSize = sizeof(_UplinkInformationExchangeResponseIEs_Value_1);
   UplinkInformationExchangeResponseIEs[1].decodeValue = &asn1PD__UplinkInformationExchangeResponseIEs_Value_1;
   UplinkInformationExchangeResponseIEs[1].printValue = &asn1Print__UplinkInformationExchangeResponseIEs_Value_1;
   UplinkInformationExchangeResponseIEs[1].presence = optional;

   UplinkInformationExchangeResponseIEs[2].id = 3;
   UplinkInformationExchangeResponseIEs[2].criticality = ignore;
   UplinkInformationExchangeResponseIEs[2].ValueSize = sizeof(_UplinkInformationExchangeResponseIEs_Value_2);
   UplinkInformationExchangeResponseIEs[2].decodeValue = &asn1PD__UplinkInformationExchangeResponseIEs_Value_2;
   UplinkInformationExchangeResponseIEs[2].printValue = &asn1Print__UplinkInformationExchangeResponseIEs_Value_2;
   UplinkInformationExchangeResponseIEs[2].presence = mandatory;

   UplinkInformationExchangeResponseIEs[3].id = 96;
   UplinkInformationExchangeResponseIEs[3].criticality = ignore;
   UplinkInformationExchangeResponseIEs[3].ValueSize = sizeof(_UplinkInformationExchangeResponseIEs_Value_3);
   UplinkInformationExchangeResponseIEs[3].decodeValue = &asn1PD__UplinkInformationExchangeResponseIEs_Value_3;
   UplinkInformationExchangeResponseIEs[3].printValue = &asn1Print__UplinkInformationExchangeResponseIEs_Value_3;
   UplinkInformationExchangeResponseIEs[3].presence = optional;

   UplinkInformationExchangeResponseIEs[4].id = 9;
   UplinkInformationExchangeResponseIEs[4].criticality = ignore;
   UplinkInformationExchangeResponseIEs[4].ValueSize = sizeof(_UplinkInformationExchangeResponseIEs_Value_4);
   UplinkInformationExchangeResponseIEs[4].decodeValue = &asn1PD__UplinkInformationExchangeResponseIEs_Value_4;
   UplinkInformationExchangeResponseIEs[4].printValue = &asn1Print__UplinkInformationExchangeResponseIEs_Value_4;
   UplinkInformationExchangeResponseIEs[4].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponseExtensions               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION UplinkInformationExchangeResponseExtensions[1];
int UplinkInformationExchangeResponseExtensions_Size = 0;

void init_UplinkInformationExchangeResponseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailureIEs                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES UplinkInformationExchangeFailureIEs[5];
int UplinkInformationExchangeFailureIEs_Size = 5;

void init_UplinkInformationExchangeFailureIEs(ASN1CTXT *pctxt)
{

   UplinkInformationExchangeFailureIEs[0].id = 136;
   UplinkInformationExchangeFailureIEs[0].criticality = ignore;
   UplinkInformationExchangeFailureIEs[0].ValueSize = sizeof(_UplinkInformationExchangeFailureIEs_Value);
   UplinkInformationExchangeFailureIEs[0].decodeValue = &asn1PD__UplinkInformationExchangeFailureIEs_Value;
   UplinkInformationExchangeFailureIEs[0].printValue = &asn1Print__UplinkInformationExchangeFailureIEs_Value;
   UplinkInformationExchangeFailureIEs[0].presence = mandatory;

   UplinkInformationExchangeFailureIEs[1].id = 3;
   UplinkInformationExchangeFailureIEs[1].criticality = ignore;
   UplinkInformationExchangeFailureIEs[1].ValueSize = sizeof(_UplinkInformationExchangeFailureIEs_Value_1);
   UplinkInformationExchangeFailureIEs[1].decodeValue = &asn1PD__UplinkInformationExchangeFailureIEs_Value_1;
   UplinkInformationExchangeFailureIEs[1].printValue = &asn1Print__UplinkInformationExchangeFailureIEs_Value_1;
   UplinkInformationExchangeFailureIEs[1].presence = mandatory;

   UplinkInformationExchangeFailureIEs[2].id = 96;
   UplinkInformationExchangeFailureIEs[2].criticality = ignore;
   UplinkInformationExchangeFailureIEs[2].ValueSize = sizeof(_UplinkInformationExchangeFailureIEs_Value_2);
   UplinkInformationExchangeFailureIEs[2].decodeValue = &asn1PD__UplinkInformationExchangeFailureIEs_Value_2;
   UplinkInformationExchangeFailureIEs[2].printValue = &asn1Print__UplinkInformationExchangeFailureIEs_Value_2;
   UplinkInformationExchangeFailureIEs[2].presence = optional;

   UplinkInformationExchangeFailureIEs[3].id = 4;
   UplinkInformationExchangeFailureIEs[3].criticality = ignore;
   UplinkInformationExchangeFailureIEs[3].ValueSize = sizeof(_UplinkInformationExchangeFailureIEs_Value_3);
   UplinkInformationExchangeFailureIEs[3].decodeValue = &asn1PD__UplinkInformationExchangeFailureIEs_Value_3;
   UplinkInformationExchangeFailureIEs[3].printValue = &asn1Print__UplinkInformationExchangeFailureIEs_Value_3;
   UplinkInformationExchangeFailureIEs[3].presence = mandatory;

   UplinkInformationExchangeFailureIEs[4].id = 9;
   UplinkInformationExchangeFailureIEs[4].criticality = ignore;
   UplinkInformationExchangeFailureIEs[4].ValueSize = sizeof(_UplinkInformationExchangeFailureIEs_Value_4);
   UplinkInformationExchangeFailureIEs[4].decodeValue = &asn1PD__UplinkInformationExchangeFailureIEs_Value_4;
   UplinkInformationExchangeFailureIEs[4].printValue = &asn1Print__UplinkInformationExchangeFailureIEs_Value_4;
   UplinkInformationExchangeFailureIEs[4].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailureExtensions                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION UplinkInformationExchangeFailureExtensions[1];
int UplinkInformationExchangeFailureExtensions_Size = 0;

void init_UplinkInformationExchangeFailureExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartIEs                                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSSessionStartIEs[13];
int MBMSSessionStartIEs_Size = 13;

void init_MBMSSessionStartIEs(ASN1CTXT *pctxt)
{

   MBMSSessionStartIEs[0].id = 153;
   MBMSSessionStartIEs[0].criticality = reject;
   MBMSSessionStartIEs[0].ValueSize = sizeof(_MBMSSessionStartIEs_Value);
   MBMSSessionStartIEs[0].decodeValue = &asn1PD__MBMSSessionStartIEs_Value;
   MBMSSessionStartIEs[0].printValue = &asn1Print__MBMSSessionStartIEs_Value;
   MBMSSessionStartIEs[0].presence = mandatory;

   MBMSSessionStartIEs[1].id = 147;
   MBMSSessionStartIEs[1].criticality = ignore;
   MBMSSessionStartIEs[1].ValueSize = sizeof(_MBMSSessionStartIEs_Value_1);
   MBMSSessionStartIEs[1].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_1;
   MBMSSessionStartIEs[1].printValue = &asn1Print__MBMSSessionStartIEs_Value_1;
   MBMSSessionStartIEs[1].presence = optional;

   MBMSSessionStartIEs[2].id = 143;
   MBMSSessionStartIEs[2].criticality = reject;
   MBMSSessionStartIEs[2].ValueSize = sizeof(_MBMSSessionStartIEs_Value_2);
   MBMSSessionStartIEs[2].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_2;
   MBMSSessionStartIEs[2].printValue = &asn1Print__MBMSSessionStartIEs_Value_2;
   MBMSSessionStartIEs[2].presence = mandatory;

   MBMSSessionStartIEs[3].id = 79;
   MBMSSessionStartIEs[3].criticality = reject;
   MBMSSessionStartIEs[3].ValueSize = sizeof(_MBMSSessionStartIEs_Value_3);
   MBMSSessionStartIEs[3].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_3;
   MBMSSessionStartIEs[3].printValue = &asn1Print__MBMSSessionStartIEs_Value_3;
   MBMSSessionStartIEs[3].presence = mandatory;

   MBMSSessionStartIEs[4].id = 149;
   MBMSSessionStartIEs[4].criticality = reject;
   MBMSSessionStartIEs[4].ValueSize = sizeof(_MBMSSessionStartIEs_Value_4);
   MBMSSessionStartIEs[4].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_4;
   MBMSSessionStartIEs[4].printValue = &asn1Print__MBMSSessionStartIEs_Value_4;
   MBMSSessionStartIEs[4].presence = mandatory;

   MBMSSessionStartIEs[5].id = 148;
   MBMSSessionStartIEs[5].criticality = ignore;
   MBMSSessionStartIEs[5].ValueSize = sizeof(_MBMSSessionStartIEs_Value_5);
   MBMSSessionStartIEs[5].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_5;
   MBMSSessionStartIEs[5].printValue = &asn1Print__MBMSSessionStartIEs_Value_5;
   MBMSSessionStartIEs[5].presence = optional;

   MBMSSessionStartIEs[6].id = 146;
   MBMSSessionStartIEs[6].criticality = reject;
   MBMSSessionStartIEs[6].ValueSize = sizeof(_MBMSSessionStartIEs_Value_6);
   MBMSSessionStartIEs[6].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_6;
   MBMSSessionStartIEs[6].printValue = &asn1Print__MBMSSessionStartIEs_Value_6;
   MBMSSessionStartIEs[6].presence = mandatory;

   MBMSSessionStartIEs[7].id = 145;
   MBMSSessionStartIEs[7].criticality = reject;
   MBMSSessionStartIEs[7].ValueSize = sizeof(_MBMSSessionStartIEs_Value_7);
   MBMSSessionStartIEs[7].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_7;
   MBMSSessionStartIEs[7].printValue = &asn1Print__MBMSSessionStartIEs_Value_7;
   MBMSSessionStartIEs[7].presence = mandatory;

   MBMSSessionStartIEs[8].id = 135;
   MBMSSessionStartIEs[8].criticality = ignore;
   MBMSSessionStartIEs[8].ValueSize = sizeof(_MBMSSessionStartIEs_Value_8);
   MBMSSessionStartIEs[8].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_8;
   MBMSSessionStartIEs[8].printValue = &asn1Print__MBMSSessionStartIEs_Value_8;
   MBMSSessionStartIEs[8].presence = optional;

   MBMSSessionStartIEs[9].id = 150;
   MBMSSessionStartIEs[9].criticality = ignore;
   MBMSSessionStartIEs[9].ValueSize = sizeof(_MBMSSessionStartIEs_Value_9);
   MBMSSessionStartIEs[9].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_9;
   MBMSSessionStartIEs[9].printValue = &asn1Print__MBMSSessionStartIEs_Value_9;
   MBMSSessionStartIEs[9].presence = optional;

   MBMSSessionStartIEs[10].id = 96;
   MBMSSessionStartIEs[10].criticality = reject;
   MBMSSessionStartIEs[10].ValueSize = sizeof(_MBMSSessionStartIEs_Value_10);
   MBMSSessionStartIEs[10].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_10;
   MBMSSessionStartIEs[10].printValue = &asn1Print__MBMSSessionStartIEs_Value_10;
   MBMSSessionStartIEs[10].presence = optional;

   MBMSSessionStartIEs[11].id = 157;
   MBMSSessionStartIEs[11].criticality = ignore;
   MBMSSessionStartIEs[11].ValueSize = sizeof(_MBMSSessionStartIEs_Value_11);
   MBMSSessionStartIEs[11].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_11;
   MBMSSessionStartIEs[11].printValue = &asn1Print__MBMSSessionStartIEs_Value_11;
   MBMSSessionStartIEs[11].presence = optional;

   MBMSSessionStartIEs[12].id = 163;
   MBMSSessionStartIEs[12].criticality = reject;
   MBMSSessionStartIEs[12].ValueSize = sizeof(_MBMSSessionStartIEs_Value_12);
   MBMSSessionStartIEs[12].decodeValue = &asn1PD__MBMSSessionStartIEs_Value_12;
   MBMSSessionStartIEs[12].printValue = &asn1Print__MBMSSessionStartIEs_Value_12;
   MBMSSessionStartIEs[12].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartExtensions                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSSessionStartExtensions[1];
int MBMSSessionStartExtensions_Size = 0;

void init_MBMSSessionStartExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponseIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSSessionStartResponseIEs[3];
int MBMSSessionStartResponseIEs_Size = 3;

void init_MBMSSessionStartResponseIEs(ASN1CTXT *pctxt)
{

   MBMSSessionStartResponseIEs[0].id = 154;
   MBMSSessionStartResponseIEs[0].criticality = ignore;
   MBMSSessionStartResponseIEs[0].ValueSize = sizeof(_MBMSSessionStartResponseIEs_Value);
   MBMSSessionStartResponseIEs[0].decodeValue = &asn1PD__MBMSSessionStartResponseIEs_Value;
   MBMSSessionStartResponseIEs[0].printValue = &asn1Print__MBMSSessionStartResponseIEs_Value;
   MBMSSessionStartResponseIEs[0].presence = optional;

   MBMSSessionStartResponseIEs[1].id = 4;
   MBMSSessionStartResponseIEs[1].criticality = ignore;
   MBMSSessionStartResponseIEs[1].ValueSize = sizeof(_MBMSSessionStartResponseIEs_Value_1);
   MBMSSessionStartResponseIEs[1].decodeValue = &asn1PD__MBMSSessionStartResponseIEs_Value_1;
   MBMSSessionStartResponseIEs[1].printValue = &asn1Print__MBMSSessionStartResponseIEs_Value_1;
   MBMSSessionStartResponseIEs[1].presence = optional;

   MBMSSessionStartResponseIEs[2].id = 9;
   MBMSSessionStartResponseIEs[2].criticality = ignore;
   MBMSSessionStartResponseIEs[2].ValueSize = sizeof(_MBMSSessionStartResponseIEs_Value_2);
   MBMSSessionStartResponseIEs[2].decodeValue = &asn1PD__MBMSSessionStartResponseIEs_Value_2;
   MBMSSessionStartResponseIEs[2].printValue = &asn1Print__MBMSSessionStartResponseIEs_Value_2;
   MBMSSessionStartResponseIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponseExtensions                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSSessionStartResponseExtensions[1];
int MBMSSessionStartResponseExtensions_Size = 0;

void init_MBMSSessionStartResponseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailureIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSSessionStartFailureIEs[2];
int MBMSSessionStartFailureIEs_Size = 2;

void init_MBMSSessionStartFailureIEs(ASN1CTXT *pctxt)
{

   MBMSSessionStartFailureIEs[0].id = 4;
   MBMSSessionStartFailureIEs[0].criticality = ignore;
   MBMSSessionStartFailureIEs[0].ValueSize = sizeof(_MBMSSessionStartFailureIEs_Value);
   MBMSSessionStartFailureIEs[0].decodeValue = &asn1PD__MBMSSessionStartFailureIEs_Value;
   MBMSSessionStartFailureIEs[0].printValue = &asn1Print__MBMSSessionStartFailureIEs_Value;
   MBMSSessionStartFailureIEs[0].presence = mandatory;

   MBMSSessionStartFailureIEs[1].id = 9;
   MBMSSessionStartFailureIEs[1].criticality = ignore;
   MBMSSessionStartFailureIEs[1].ValueSize = sizeof(_MBMSSessionStartFailureIEs_Value_1);
   MBMSSessionStartFailureIEs[1].decodeValue = &asn1PD__MBMSSessionStartFailureIEs_Value_1;
   MBMSSessionStartFailureIEs[1].printValue = &asn1Print__MBMSSessionStartFailureIEs_Value_1;
   MBMSSessionStartFailureIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailureExtensions                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSSessionStartFailureExtensions[1];
int MBMSSessionStartFailureExtensions_Size = 0;

void init_MBMSSessionStartFailureExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateIEs                                      */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSSessionUpdateIEs[2];
int MBMSSessionUpdateIEs_Size = 2;

void init_MBMSSessionUpdateIEs(ASN1CTXT *pctxt)
{

   MBMSSessionUpdateIEs[0].id = 152;
   MBMSSessionUpdateIEs[0].criticality = reject;
   MBMSSessionUpdateIEs[0].ValueSize = sizeof(_MBMSSessionUpdateIEs_Value);
   MBMSSessionUpdateIEs[0].decodeValue = &asn1PD__MBMSSessionUpdateIEs_Value;
   MBMSSessionUpdateIEs[0].printValue = &asn1Print__MBMSSessionUpdateIEs_Value;
   MBMSSessionUpdateIEs[0].presence = mandatory;

   MBMSSessionUpdateIEs[1].id = 134;
   MBMSSessionUpdateIEs[1].criticality = reject;
   MBMSSessionUpdateIEs[1].ValueSize = sizeof(_MBMSSessionUpdateIEs_Value_1);
   MBMSSessionUpdateIEs[1].decodeValue = &asn1PD__MBMSSessionUpdateIEs_Value_1;
   MBMSSessionUpdateIEs[1].printValue = &asn1Print__MBMSSessionUpdateIEs_Value_1;
   MBMSSessionUpdateIEs[1].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateExtensions                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSSessionUpdateExtensions[1];
int MBMSSessionUpdateExtensions_Size = 0;

void init_MBMSSessionUpdateExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponseIEs                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSSessionUpdateResponseIEs[4];
int MBMSSessionUpdateResponseIEs_Size = 4;

void init_MBMSSessionUpdateResponseIEs(ASN1CTXT *pctxt)
{

   MBMSSessionUpdateResponseIEs[0].id = 152;
   MBMSSessionUpdateResponseIEs[0].criticality = ignore;
   MBMSSessionUpdateResponseIEs[0].ValueSize = sizeof(_MBMSSessionUpdateResponseIEs_Value);
   MBMSSessionUpdateResponseIEs[0].decodeValue = &asn1PD__MBMSSessionUpdateResponseIEs_Value;
   MBMSSessionUpdateResponseIEs[0].printValue = &asn1Print__MBMSSessionUpdateResponseIEs_Value;
   MBMSSessionUpdateResponseIEs[0].presence = mandatory;

   MBMSSessionUpdateResponseIEs[1].id = 154;
   MBMSSessionUpdateResponseIEs[1].criticality = ignore;
   MBMSSessionUpdateResponseIEs[1].ValueSize = sizeof(_MBMSSessionUpdateResponseIEs_Value_1);
   MBMSSessionUpdateResponseIEs[1].decodeValue = &asn1PD__MBMSSessionUpdateResponseIEs_Value_1;
   MBMSSessionUpdateResponseIEs[1].printValue = &asn1Print__MBMSSessionUpdateResponseIEs_Value_1;
   MBMSSessionUpdateResponseIEs[1].presence = optional;

   MBMSSessionUpdateResponseIEs[2].id = 4;
   MBMSSessionUpdateResponseIEs[2].criticality = ignore;
   MBMSSessionUpdateResponseIEs[2].ValueSize = sizeof(_MBMSSessionUpdateResponseIEs_Value_2);
   MBMSSessionUpdateResponseIEs[2].decodeValue = &asn1PD__MBMSSessionUpdateResponseIEs_Value_2;
   MBMSSessionUpdateResponseIEs[2].printValue = &asn1Print__MBMSSessionUpdateResponseIEs_Value_2;
   MBMSSessionUpdateResponseIEs[2].presence = optional;

   MBMSSessionUpdateResponseIEs[3].id = 9;
   MBMSSessionUpdateResponseIEs[3].criticality = ignore;
   MBMSSessionUpdateResponseIEs[3].ValueSize = sizeof(_MBMSSessionUpdateResponseIEs_Value_3);
   MBMSSessionUpdateResponseIEs[3].decodeValue = &asn1PD__MBMSSessionUpdateResponseIEs_Value_3;
   MBMSSessionUpdateResponseIEs[3].printValue = &asn1Print__MBMSSessionUpdateResponseIEs_Value_3;
   MBMSSessionUpdateResponseIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponseExtensions                       */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSSessionUpdateResponseExtensions[1];
int MBMSSessionUpdateResponseExtensions_Size = 0;

void init_MBMSSessionUpdateResponseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailureIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSSessionUpdateFailureIEs[3];
int MBMSSessionUpdateFailureIEs_Size = 3;

void init_MBMSSessionUpdateFailureIEs(ASN1CTXT *pctxt)
{

   MBMSSessionUpdateFailureIEs[0].id = 152;
   MBMSSessionUpdateFailureIEs[0].criticality = ignore;
   MBMSSessionUpdateFailureIEs[0].ValueSize = sizeof(_MBMSSessionUpdateFailureIEs_Value);
   MBMSSessionUpdateFailureIEs[0].decodeValue = &asn1PD__MBMSSessionUpdateFailureIEs_Value;
   MBMSSessionUpdateFailureIEs[0].printValue = &asn1Print__MBMSSessionUpdateFailureIEs_Value;
   MBMSSessionUpdateFailureIEs[0].presence = mandatory;

   MBMSSessionUpdateFailureIEs[1].id = 4;
   MBMSSessionUpdateFailureIEs[1].criticality = ignore;
   MBMSSessionUpdateFailureIEs[1].ValueSize = sizeof(_MBMSSessionUpdateFailureIEs_Value_1);
   MBMSSessionUpdateFailureIEs[1].decodeValue = &asn1PD__MBMSSessionUpdateFailureIEs_Value_1;
   MBMSSessionUpdateFailureIEs[1].printValue = &asn1Print__MBMSSessionUpdateFailureIEs_Value_1;
   MBMSSessionUpdateFailureIEs[1].presence = mandatory;

   MBMSSessionUpdateFailureIEs[2].id = 9;
   MBMSSessionUpdateFailureIEs[2].criticality = ignore;
   MBMSSessionUpdateFailureIEs[2].ValueSize = sizeof(_MBMSSessionUpdateFailureIEs_Value_2);
   MBMSSessionUpdateFailureIEs[2].decodeValue = &asn1PD__MBMSSessionUpdateFailureIEs_Value_2;
   MBMSSessionUpdateFailureIEs[2].printValue = &asn1Print__MBMSSessionUpdateFailureIEs_Value_2;
   MBMSSessionUpdateFailureIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailureExtensions                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSSessionUpdateFailureExtensions[1];
int MBMSSessionUpdateFailureExtensions_Size = 0;

void init_MBMSSessionUpdateFailureExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopIEs                                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSSessionStopIEs[1];
int MBMSSessionStopIEs_Size = 1;

void init_MBMSSessionStopIEs(ASN1CTXT *pctxt)
{

   MBMSSessionStopIEs[0].id = 144;
   MBMSSessionStopIEs[0].criticality = reject;
   MBMSSessionStopIEs[0].ValueSize = sizeof(_MBMSSessionStopIEs_Value);
   MBMSSessionStopIEs[0].decodeValue = &asn1PD__MBMSSessionStopIEs_Value;
   MBMSSessionStopIEs[0].printValue = &asn1Print__MBMSSessionStopIEs_Value;
   MBMSSessionStopIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopExtensions                                 */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSSessionStopExtensions[1];
int MBMSSessionStopExtensions_Size = 0;

void init_MBMSSessionStopExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponseIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSSessionStopResponseIEs[2];
int MBMSSessionStopResponseIEs_Size = 2;

void init_MBMSSessionStopResponseIEs(ASN1CTXT *pctxt)
{

   MBMSSessionStopResponseIEs[0].id = 4;
   MBMSSessionStopResponseIEs[0].criticality = ignore;
   MBMSSessionStopResponseIEs[0].ValueSize = sizeof(_MBMSSessionStopResponseIEs_Value);
   MBMSSessionStopResponseIEs[0].decodeValue = &asn1PD__MBMSSessionStopResponseIEs_Value;
   MBMSSessionStopResponseIEs[0].printValue = &asn1Print__MBMSSessionStopResponseIEs_Value;
   MBMSSessionStopResponseIEs[0].presence = optional;

   MBMSSessionStopResponseIEs[1].id = 9;
   MBMSSessionStopResponseIEs[1].criticality = ignore;
   MBMSSessionStopResponseIEs[1].ValueSize = sizeof(_MBMSSessionStopResponseIEs_Value_1);
   MBMSSessionStopResponseIEs[1].decodeValue = &asn1PD__MBMSSessionStopResponseIEs_Value_1;
   MBMSSessionStopResponseIEs[1].printValue = &asn1Print__MBMSSessionStopResponseIEs_Value_1;
   MBMSSessionStopResponseIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponseExtensions                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSSessionStopResponseExtensions[1];
int MBMSSessionStopResponseExtensions_Size = 0;

void init_MBMSSessionStopResponseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequestIEs                                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSUELinkingRequestIEs[2];
int MBMSUELinkingRequestIEs_Size = 2;

void init_MBMSUELinkingRequestIEs(ASN1CTXT *pctxt)
{

   MBMSUELinkingRequestIEs[0].id = 141;
   MBMSUELinkingRequestIEs[0].criticality = reject;
   MBMSUELinkingRequestIEs[0].ValueSize = sizeof(_MBMSUELinkingRequestIEs_Value);
   MBMSUELinkingRequestIEs[0].decodeValue = &asn1PD__MBMSUELinkingRequestIEs_Value;
   MBMSUELinkingRequestIEs[0].printValue = &asn1Print__MBMSUELinkingRequestIEs_Value;
   MBMSUELinkingRequestIEs[0].presence = optional;

   MBMSUELinkingRequestIEs[1].id = 142;
   MBMSUELinkingRequestIEs[1].criticality = reject;
   MBMSUELinkingRequestIEs[1].ValueSize = sizeof(_MBMSUELinkingRequestIEs_Value_1);
   MBMSUELinkingRequestIEs[1].decodeValue = &asn1PD__MBMSUELinkingRequestIEs_Value_1;
   MBMSUELinkingRequestIEs[1].printValue = &asn1Print__MBMSUELinkingRequestIEs_Value_1;
   MBMSUELinkingRequestIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_ExtIEs                              */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION LeftMBMSBearerService_ExtIEs[1];
int LeftMBMSBearerService_ExtIEs_Size = 0;

void init_LeftMBMSBearerService_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequestExtensions                            */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSUELinkingRequestExtensions[1];
int MBMSUELinkingRequestExtensions_Size = 0;

void init_MBMSUELinkingRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponseIEs                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSUELinkingResponseIEs[2];
int MBMSUELinkingResponseIEs_Size = 2;

void init_MBMSUELinkingResponseIEs(ASN1CTXT *pctxt)
{

   MBMSUELinkingResponseIEs[0].id = 155;
   MBMSUELinkingResponseIEs[0].criticality = ignore;
   MBMSUELinkingResponseIEs[0].ValueSize = sizeof(_MBMSUELinkingResponseIEs_Value);
   MBMSUELinkingResponseIEs[0].decodeValue = &asn1PD__MBMSUELinkingResponseIEs_Value;
   MBMSUELinkingResponseIEs[0].printValue = &asn1Print__MBMSUELinkingResponseIEs_Value;
   MBMSUELinkingResponseIEs[0].presence = optional;

   MBMSUELinkingResponseIEs[1].id = 9;
   MBMSUELinkingResponseIEs[1].criticality = ignore;
   MBMSUELinkingResponseIEs[1].ValueSize = sizeof(_MBMSUELinkingResponseIEs_Value_1);
   MBMSUELinkingResponseIEs[1].decodeValue = &asn1PD__MBMSUELinkingResponseIEs_Value_1;
   MBMSUELinkingResponseIEs[1].printValue = &asn1Print__MBMSUELinkingResponseIEs_Value_1;
   MBMSUELinkingResponseIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_ExtIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION UnsuccessfulLinking_ExtIEs[1];
int UnsuccessfulLinking_ExtIEs_Size = 0;

void init_UnsuccessfulLinking_ExtIEs(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponseExtensions                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSUELinkingResponseExtensions[1];
int MBMSUELinkingResponseExtensions_Size = 0;

void init_MBMSUELinkingResponseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequestIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSRegistrationRequestIEs[5];
int MBMSRegistrationRequestIEs_Size = 5;

void init_MBMSRegistrationRequestIEs(ASN1CTXT *pctxt)
{

   MBMSRegistrationRequestIEs[0].id = 151;
   MBMSRegistrationRequestIEs[0].criticality = reject;
   MBMSRegistrationRequestIEs[0].ValueSize = sizeof(_MBMSRegistrationRequestIEs_Value);
   MBMSRegistrationRequestIEs[0].decodeValue = &asn1PD__MBMSRegistrationRequestIEs_Value;
   MBMSRegistrationRequestIEs[0].printValue = &asn1Print__MBMSRegistrationRequestIEs_Value;
   MBMSRegistrationRequestIEs[0].presence = mandatory;

   MBMSRegistrationRequestIEs[1].id = 153;
   MBMSRegistrationRequestIEs[1].criticality = reject;
   MBMSRegistrationRequestIEs[1].ValueSize = sizeof(_MBMSRegistrationRequestIEs_Value_1);
   MBMSRegistrationRequestIEs[1].decodeValue = &asn1PD__MBMSRegistrationRequestIEs_Value_1;
   MBMSRegistrationRequestIEs[1].printValue = &asn1Print__MBMSRegistrationRequestIEs_Value_1;
   MBMSRegistrationRequestIEs[1].presence = mandatory;

   MBMSRegistrationRequestIEs[2].id = 140;
   MBMSRegistrationRequestIEs[2].criticality = reject;
   MBMSRegistrationRequestIEs[2].ValueSize = sizeof(_MBMSRegistrationRequestIEs_Value_2);
   MBMSRegistrationRequestIEs[2].decodeValue = &asn1PD__MBMSRegistrationRequestIEs_Value_2;
   MBMSRegistrationRequestIEs[2].printValue = &asn1Print__MBMSRegistrationRequestIEs_Value_2;
   MBMSRegistrationRequestIEs[2].presence = conditional;

   MBMSRegistrationRequestIEs[3].id = 132;
   MBMSRegistrationRequestIEs[3].criticality = reject;
   MBMSRegistrationRequestIEs[3].ValueSize = sizeof(_MBMSRegistrationRequestIEs_Value_3);
   MBMSRegistrationRequestIEs[3].decodeValue = &asn1PD__MBMSRegistrationRequestIEs_Value_3;
   MBMSRegistrationRequestIEs[3].printValue = &asn1Print__MBMSRegistrationRequestIEs_Value_3;
   MBMSRegistrationRequestIEs[3].presence = conditional;

   MBMSRegistrationRequestIEs[4].id = 86;
   MBMSRegistrationRequestIEs[4].criticality = reject;
   MBMSRegistrationRequestIEs[4].ValueSize = sizeof(_MBMSRegistrationRequestIEs_Value_4);
   MBMSRegistrationRequestIEs[4].decodeValue = &asn1PD__MBMSRegistrationRequestIEs_Value_4;
   MBMSRegistrationRequestIEs[4].printValue = &asn1Print__MBMSRegistrationRequestIEs_Value_4;
   MBMSRegistrationRequestIEs[4].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequestExtensions                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSRegistrationRequestExtensions[1];
int MBMSRegistrationRequestExtensions_Size = 0;

void init_MBMSRegistrationRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponseIEs                               */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSRegistrationResponseIEs[3];
int MBMSRegistrationResponseIEs_Size = 3;

void init_MBMSRegistrationResponseIEs(ASN1CTXT *pctxt)
{

   MBMSRegistrationResponseIEs[0].id = 153;
   MBMSRegistrationResponseIEs[0].criticality = ignore;
   MBMSRegistrationResponseIEs[0].ValueSize = sizeof(_MBMSRegistrationResponseIEs_Value);
   MBMSRegistrationResponseIEs[0].decodeValue = &asn1PD__MBMSRegistrationResponseIEs_Value;
   MBMSRegistrationResponseIEs[0].printValue = &asn1Print__MBMSRegistrationResponseIEs_Value;
   MBMSRegistrationResponseIEs[0].presence = optional;

   MBMSRegistrationResponseIEs[1].id = 96;
   MBMSRegistrationResponseIEs[1].criticality = ignore;
   MBMSRegistrationResponseIEs[1].ValueSize = sizeof(_MBMSRegistrationResponseIEs_Value_1);
   MBMSRegistrationResponseIEs[1].decodeValue = &asn1PD__MBMSRegistrationResponseIEs_Value_1;
   MBMSRegistrationResponseIEs[1].printValue = &asn1Print__MBMSRegistrationResponseIEs_Value_1;
   MBMSRegistrationResponseIEs[1].presence = optional;

   MBMSRegistrationResponseIEs[2].id = 9;
   MBMSRegistrationResponseIEs[2].criticality = ignore;
   MBMSRegistrationResponseIEs[2].ValueSize = sizeof(_MBMSRegistrationResponseIEs_Value_2);
   MBMSRegistrationResponseIEs[2].decodeValue = &asn1PD__MBMSRegistrationResponseIEs_Value_2;
   MBMSRegistrationResponseIEs[2].printValue = &asn1Print__MBMSRegistrationResponseIEs_Value_2;
   MBMSRegistrationResponseIEs[2].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponseExtensions                        */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSRegistrationResponseExtensions[1];
int MBMSRegistrationResponseExtensions_Size = 0;

void init_MBMSRegistrationResponseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailureIEs                                */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSRegistrationFailureIEs[4];
int MBMSRegistrationFailureIEs_Size = 4;

void init_MBMSRegistrationFailureIEs(ASN1CTXT *pctxt)
{

   MBMSRegistrationFailureIEs[0].id = 153;
   MBMSRegistrationFailureIEs[0].criticality = ignore;
   MBMSRegistrationFailureIEs[0].ValueSize = sizeof(_MBMSRegistrationFailureIEs_Value);
   MBMSRegistrationFailureIEs[0].decodeValue = &asn1PD__MBMSRegistrationFailureIEs_Value;
   MBMSRegistrationFailureIEs[0].printValue = &asn1Print__MBMSRegistrationFailureIEs_Value;
   MBMSRegistrationFailureIEs[0].presence = optional;

   MBMSRegistrationFailureIEs[1].id = 96;
   MBMSRegistrationFailureIEs[1].criticality = ignore;
   MBMSRegistrationFailureIEs[1].ValueSize = sizeof(_MBMSRegistrationFailureIEs_Value_1);
   MBMSRegistrationFailureIEs[1].decodeValue = &asn1PD__MBMSRegistrationFailureIEs_Value_1;
   MBMSRegistrationFailureIEs[1].printValue = &asn1Print__MBMSRegistrationFailureIEs_Value_1;
   MBMSRegistrationFailureIEs[1].presence = optional;

   MBMSRegistrationFailureIEs[2].id = 4;
   MBMSRegistrationFailureIEs[2].criticality = ignore;
   MBMSRegistrationFailureIEs[2].ValueSize = sizeof(_MBMSRegistrationFailureIEs_Value_2);
   MBMSRegistrationFailureIEs[2].decodeValue = &asn1PD__MBMSRegistrationFailureIEs_Value_2;
   MBMSRegistrationFailureIEs[2].printValue = &asn1Print__MBMSRegistrationFailureIEs_Value_2;
   MBMSRegistrationFailureIEs[2].presence = mandatory;

   MBMSRegistrationFailureIEs[3].id = 9;
   MBMSRegistrationFailureIEs[3].criticality = ignore;
   MBMSRegistrationFailureIEs[3].ValueSize = sizeof(_MBMSRegistrationFailureIEs_Value_3);
   MBMSRegistrationFailureIEs[3].decodeValue = &asn1PD__MBMSRegistrationFailureIEs_Value_3;
   MBMSRegistrationFailureIEs[3].printValue = &asn1Print__MBMSRegistrationFailureIEs_Value_3;
   MBMSRegistrationFailureIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailureExtensions                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSRegistrationFailureExtensions[1];
int MBMSRegistrationFailureExtensions_Size = 0;

void init_MBMSRegistrationFailureExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequestIEs                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSCNDe_RegistrationRequestIEs[2];
int MBMSCNDe_RegistrationRequestIEs_Size = 2;

void init_MBMSCNDe_RegistrationRequestIEs(ASN1CTXT *pctxt)
{

   MBMSCNDe_RegistrationRequestIEs[0].id = 153;
   MBMSCNDe_RegistrationRequestIEs[0].criticality = reject;
   MBMSCNDe_RegistrationRequestIEs[0].ValueSize = sizeof(_MBMSCNDe_RegistrationRequestIEs_Value);
   MBMSCNDe_RegistrationRequestIEs[0].decodeValue = &asn1PD__MBMSCNDe_RegistrationRequestIEs_Value;
   MBMSCNDe_RegistrationRequestIEs[0].printValue = &asn1Print__MBMSCNDe_RegistrationRequestIEs_Value;
   MBMSCNDe_RegistrationRequestIEs[0].presence = mandatory;

   MBMSCNDe_RegistrationRequestIEs[1].id = 96;
   MBMSCNDe_RegistrationRequestIEs[1].criticality = reject;
   MBMSCNDe_RegistrationRequestIEs[1].ValueSize = sizeof(_MBMSCNDe_RegistrationRequestIEs_Value_1);
   MBMSCNDe_RegistrationRequestIEs[1].decodeValue = &asn1PD__MBMSCNDe_RegistrationRequestIEs_Value_1;
   MBMSCNDe_RegistrationRequestIEs[1].printValue = &asn1Print__MBMSCNDe_RegistrationRequestIEs_Value_1;
   MBMSCNDe_RegistrationRequestIEs[1].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequestExtensions                    */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSCNDe_RegistrationRequestExtensions[1];
int MBMSCNDe_RegistrationRequestExtensions_Size = 0;

void init_MBMSCNDe_RegistrationRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponseIEs                          */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSCNDe_RegistrationResponseIEs[4];
int MBMSCNDe_RegistrationResponseIEs_Size = 4;

void init_MBMSCNDe_RegistrationResponseIEs(ASN1CTXT *pctxt)
{

   MBMSCNDe_RegistrationResponseIEs[0].id = 153;
   MBMSCNDe_RegistrationResponseIEs[0].criticality = ignore;
   MBMSCNDe_RegistrationResponseIEs[0].ValueSize = sizeof(_MBMSCNDe_RegistrationResponseIEs_Value);
   MBMSCNDe_RegistrationResponseIEs[0].decodeValue = &asn1PD__MBMSCNDe_RegistrationResponseIEs_Value;
   MBMSCNDe_RegistrationResponseIEs[0].printValue = &asn1Print__MBMSCNDe_RegistrationResponseIEs_Value;
   MBMSCNDe_RegistrationResponseIEs[0].presence = mandatory;

   MBMSCNDe_RegistrationResponseIEs[1].id = 86;
   MBMSCNDe_RegistrationResponseIEs[1].criticality = ignore;
   MBMSCNDe_RegistrationResponseIEs[1].ValueSize = sizeof(_MBMSCNDe_RegistrationResponseIEs_Value_1);
   MBMSCNDe_RegistrationResponseIEs[1].decodeValue = &asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_1;
   MBMSCNDe_RegistrationResponseIEs[1].printValue = &asn1Print__MBMSCNDe_RegistrationResponseIEs_Value_1;
   MBMSCNDe_RegistrationResponseIEs[1].presence = mandatory;

   MBMSCNDe_RegistrationResponseIEs[2].id = 4;
   MBMSCNDe_RegistrationResponseIEs[2].criticality = ignore;
   MBMSCNDe_RegistrationResponseIEs[2].ValueSize = sizeof(_MBMSCNDe_RegistrationResponseIEs_Value_2);
   MBMSCNDe_RegistrationResponseIEs[2].decodeValue = &asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_2;
   MBMSCNDe_RegistrationResponseIEs[2].printValue = &asn1Print__MBMSCNDe_RegistrationResponseIEs_Value_2;
   MBMSCNDe_RegistrationResponseIEs[2].presence = optional;

   MBMSCNDe_RegistrationResponseIEs[3].id = 9;
   MBMSCNDe_RegistrationResponseIEs[3].criticality = ignore;
   MBMSCNDe_RegistrationResponseIEs[3].ValueSize = sizeof(_MBMSCNDe_RegistrationResponseIEs_Value_3);
   MBMSCNDe_RegistrationResponseIEs[3].decodeValue = &asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_3;
   MBMSCNDe_RegistrationResponseIEs[3].printValue = &asn1Print__MBMSCNDe_RegistrationResponseIEs_Value_3;
   MBMSCNDe_RegistrationResponseIEs[3].presence = optional;

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponseExtensions                   */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSCNDe_RegistrationResponseExtensions[1];
int MBMSCNDe_RegistrationResponseExtensions_Size = 0;

void init_MBMSCNDe_RegistrationResponseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndicationIEs                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSRABEstablishmentIndicationIEs[1];
int MBMSRABEstablishmentIndicationIEs_Size = 1;

void init_MBMSRABEstablishmentIndicationIEs(ASN1CTXT *pctxt)
{

   MBMSRABEstablishmentIndicationIEs[0].id = 154;
   MBMSRABEstablishmentIndicationIEs[0].criticality = ignore;
   MBMSRABEstablishmentIndicationIEs[0].ValueSize = sizeof(_MBMSRABEstablishmentIndicationIEs_Value);
   MBMSRABEstablishmentIndicationIEs[0].decodeValue = &asn1PD__MBMSRABEstablishmentIndicationIEs_Value;
   MBMSRABEstablishmentIndicationIEs[0].printValue = &asn1Print__MBMSRABEstablishmentIndicationIEs_Value;
   MBMSRABEstablishmentIndicationIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndicationExtensions                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSRABEstablishmentIndicationExtensions[1];
int MBMSRABEstablishmentIndicationExtensions_Size = 0;

void init_MBMSRABEstablishmentIndicationExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequestIEs                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSRABReleaseRequestIEs[1];
int MBMSRABReleaseRequestIEs_Size = 1;

void init_MBMSRABReleaseRequestIEs(ASN1CTXT *pctxt)
{

   MBMSRABReleaseRequestIEs[0].id = 4;
   MBMSRABReleaseRequestIEs[0].criticality = ignore;
   MBMSRABReleaseRequestIEs[0].ValueSize = sizeof(_MBMSRABReleaseRequestIEs_Value);
   MBMSRABReleaseRequestIEs[0].decodeValue = &asn1PD__MBMSRABReleaseRequestIEs_Value;
   MBMSRABReleaseRequestIEs[0].printValue = &asn1Print__MBMSRABReleaseRequestIEs_Value;
   MBMSRABReleaseRequestIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequestExtensions                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSRABReleaseRequestExtensions[1];
int MBMSRABReleaseRequestExtensions_Size = 0;

void init_MBMSRABReleaseRequestExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseIEs                                         */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSRABReleaseIEs[1];
int MBMSRABReleaseIEs_Size = 1;

void init_MBMSRABReleaseIEs(ASN1CTXT *pctxt)
{

   MBMSRABReleaseIEs[0].id = 4;
   MBMSRABReleaseIEs[0].criticality = ignore;
   MBMSRABReleaseIEs[0].ValueSize = sizeof(_MBMSRABReleaseIEs_Value);
   MBMSRABReleaseIEs[0].decodeValue = &asn1PD__MBMSRABReleaseIEs_Value;
   MBMSRABReleaseIEs[0].printValue = &asn1Print__MBMSRABReleaseIEs_Value;
   MBMSRABReleaseIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseExtensions                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSRABReleaseExtensions[1];
int MBMSRABReleaseExtensions_Size = 0;

void init_MBMSRABReleaseExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailureIEs                                  */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_IES MBMSRABReleaseFailureIEs[1];
int MBMSRABReleaseFailureIEs_Size = 1;

void init_MBMSRABReleaseFailureIEs(ASN1CTXT *pctxt)
{

   MBMSRABReleaseFailureIEs[0].id = 4;
   MBMSRABReleaseFailureIEs[0].criticality = ignore;
   MBMSRABReleaseFailureIEs[0].ValueSize = sizeof(_MBMSRABReleaseFailureIEs_Value);
   MBMSRABReleaseFailureIEs[0].decodeValue = &asn1PD__MBMSRABReleaseFailureIEs_Value;
   MBMSRABReleaseFailureIEs[0].printValue = &asn1Print__MBMSRABReleaseFailureIEs_Value;
   MBMSRABReleaseFailureIEs[0].presence = mandatory;

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailureExtensions                           */
/*                                                            */
/**************************************************************/

RANAP_PROTOCOL_EXTENSION MBMSRABReleaseFailureExtensions[1];
int MBMSRABReleaseFailureExtensions_Size = 0;

void init_MBMSRABReleaseFailureExtensions(ASN1CTXT *pctxt)
{

}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCommandIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__Iu_ReleaseCommandIEs_Value
   (const char* name, void* pvalue_)
{
   _Iu_ReleaseCommandIEs_Value *pvalue = (_Iu_ReleaseCommandIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseCommand_protocolIEs_element
   (const char* name, Iu_ReleaseCommand_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Iu_ReleaseCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCommandIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      Iu_ReleaseCommandIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs                             */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseCommand_protocolIEs
   (const char* name, Iu_ReleaseCommand_protocolIEs* pvalue)
{
   Iu_ReleaseCommand_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Iu_ReleaseCommand_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Iu_ReleaseCommand_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseCommand_protocolExtensions_element
   (const char* name, Iu_ReleaseCommand_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Iu_ReleaseCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCommandExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      Iu_ReleaseCommandExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseCommand_protocolExtensions
   (const char* name, Iu_ReleaseCommand_protocolExtensions* pvalue)
{
   Iu_ReleaseCommand_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Iu_ReleaseCommand_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Iu_ReleaseCommand_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand                                         */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseCommand
   (const char* name, Iu_ReleaseCommand* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_Iu_ReleaseCommand_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_Iu_ReleaseCommand_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeList_element_iE_Extensions_element
   (const char* name, DataVolumeList_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DataVolumeList_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeList_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeList_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      DataVolumeList_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeList_element_iE_Extensions
   (const char* name, DataVolumeList_element_iE_Extensions* pvalue)
{
   DataVolumeList_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DataVolumeList_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DataVolumeList_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element                                    */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeList_element
   (const char* name, DataVolumeList_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.dataVolumeReferencePresent = %d\n", name, (int)pvalue->m.dataVolumeReferencePresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.dl_UnsuccessfullyTransmittedDataVolume", name);
   asn1Print_UnsuccessfullyTransmittedDataVolume (namebuf, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);

   if (pvalue->m.dataVolumeReferencePresent) {
      sprintf (namebuf, "%s.dataVolumeReference", name);
      asn1Print_DataVolumeReference (namebuf, &pvalue->dataVolumeReference);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_DataVolumeList_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  DataVolumeList                                            */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeList
   (const char* name, DataVolumeList* pvalue)
{
   DataVolumeList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DataVolumeList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DataVolumeList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportItem_iE_Extensions_element
   (const char* name, RAB_DataVolumeReportItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_DataVolumeReportItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportItem_iE_Extensions
   (const char* name, RAB_DataVolumeReportItem_iE_Extensions* pvalue)
{
   RAB_DataVolumeReportItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataVolumeReportItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataVolumeReportItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem                                  */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportItem
   (const char* name, RAB_DataVolumeReportItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.dl_UnsuccessfullyTransmittedDataVolumePresent = %d\n", name, (int)pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent) {
      sprintf (namebuf, "%s.dl_UnsuccessfullyTransmittedDataVolume", name);
      asn1Print_DataVolumeList (namebuf, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_DataVolumeReportItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_DataVolumeReportItemIEs_Value                        */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_DataVolumeReportItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_DataVolumeReportItemIEs_Value *pvalue = (_RAB_DataVolumeReportItemIEs_Value*) pvalue_;
   asn1Print_RAB_DataVolumeReportItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element_element                  */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportList_element_element
   (const char* name, RAB_DataVolumeReportList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_DataVolumeReportItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element                          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportList_element
   (const char* name, RAB_DataVolumeReportList_element* pvalue)
{
   RAB_DataVolumeReportList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataVolumeReportList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataVolumeReportList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList                                  */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportList
   (const char* name, RAB_DataVolumeReportList* pvalue)
{
   RAB_DataVolumeReportList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataVolumeReportList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataVolumeReportList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value                              */
/*                                                            */
/**************************************************************/

void asn1Print__Iu_ReleaseCompleteIEs_Value
   (const char* name, void* pvalue_)
{
   _Iu_ReleaseCompleteIEs_Value *pvalue = (_Iu_ReleaseCompleteIEs_Value*) pvalue_;
   asn1Print_RAB_DataVolumeReportList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedItem_IuRelComp_iE_Extensions_element
   (const char* name, RAB_ReleasedItem_IuRelComp_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_IuRelComp_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_IuRelComp_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_IuRelComp_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_ReleasedItem_IuRelComp_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions                  */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedItem_IuRelComp_iE_Extensions
   (const char* name, RAB_ReleasedItem_IuRelComp_iE_Extensions* pvalue)
{
   RAB_ReleasedItem_IuRelComp_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleasedItem_IuRelComp_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp                                */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedItem_IuRelComp
   (const char* name, RAB_ReleasedItem_IuRelComp* pvalue)
{
   char namebuf[512];

   printf ("%s.m.dL_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.dL_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.uL_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.uL_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.dL_GTP_PDU_SequenceNumber", name);
      asn1Print_DL_GTP_PDU_SequenceNumber (namebuf, &pvalue->dL_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.uL_GTP_PDU_SequenceNumber", name);
      asn1Print_UL_GTP_PDU_SequenceNumber (namebuf, &pvalue->uL_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_ReleasedItem_IuRelComp_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleasedItem_IuRelComp_IEs_Value                     */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_ReleasedItem_IuRelComp_IEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_ReleasedItem_IuRelComp_IEs_Value *pvalue = (_RAB_ReleasedItem_IuRelComp_IEs_Value*) pvalue_;
   asn1Print_RAB_ReleasedItem_IuRelComp (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element_element                */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedList_IuRelComp_element_element
   (const char* name, RAB_ReleasedList_IuRelComp_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_IuRelComp_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_IuRelComp_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_IuRelComp_IEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_ReleasedItem_IuRelComp_IEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedList_IuRelComp_element
   (const char* name, RAB_ReleasedList_IuRelComp_element* pvalue)
{
   RAB_ReleasedList_IuRelComp_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleasedList_IuRelComp_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleasedList_IuRelComp_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp                                */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedList_IuRelComp
   (const char* name, RAB_ReleasedList_IuRelComp* pvalue)
{
   RAB_ReleasedList_IuRelComp_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleasedList_IuRelComp_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleasedList_IuRelComp_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value_1                            */
/*                                                            */
/**************************************************************/

void asn1Print__Iu_ReleaseCompleteIEs_Value_1
   (const char* name, void* pvalue_)
{
   _Iu_ReleaseCompleteIEs_Value_1 *pvalue = (_Iu_ReleaseCompleteIEs_Value_1*) pvalue_;
   asn1Print_RAB_ReleasedList_IuRelComp (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value_2                            */
/*                                                            */
/**************************************************************/

void asn1Print__Iu_ReleaseCompleteIEs_Value_2
   (const char* name, void* pvalue_)
{
   _Iu_ReleaseCompleteIEs_Value_2 *pvalue = (_Iu_ReleaseCompleteIEs_Value_2*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseComplete_protocolIEs_element
   (const char* name, Iu_ReleaseComplete_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Iu_ReleaseCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCompleteIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      Iu_ReleaseCompleteIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs                            */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseComplete_protocolIEs
   (const char* name, Iu_ReleaseComplete_protocolIEs* pvalue)
{
   Iu_ReleaseComplete_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Iu_ReleaseComplete_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Iu_ReleaseComplete_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseComplete_protocolExtensions_element
   (const char* name, Iu_ReleaseComplete_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Iu_ReleaseCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCompleteExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      Iu_ReleaseCompleteExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseComplete_protocolExtensions
   (const char* name, Iu_ReleaseComplete_protocolExtensions* pvalue)
{
   Iu_ReleaseComplete_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Iu_ReleaseComplete_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Iu_ReleaseComplete_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete                                        */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseComplete
   (const char* name, Iu_ReleaseComplete* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_Iu_ReleaseComplete_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_Iu_ReleaseComplete_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value                              */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredIEs_Value
   (const char* name, void* pvalue_)
{
   _RelocationRequiredIEs_Value *pvalue = (_RelocationRequiredIEs_Value*) pvalue_;
   asn1Print_RelocationType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_1                            */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RelocationRequiredIEs_Value_1 *pvalue = (_RelocationRequiredIEs_Value_1*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_2                            */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredIEs_Value_2
   (const char* name, void* pvalue_)
{
   _RelocationRequiredIEs_Value_2 *pvalue = (_RelocationRequiredIEs_Value_2*) pvalue_;
   asn1Print_SourceID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_3                            */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredIEs_Value_3
   (const char* name, void* pvalue_)
{
   _RelocationRequiredIEs_Value_3 *pvalue = (_RelocationRequiredIEs_Value_3*) pvalue_;
   asn1Print_TargetID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_4                            */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredIEs_Value_4
   (const char* name, void* pvalue_)
{
   _RelocationRequiredIEs_Value_4 *pvalue = (_RelocationRequiredIEs_Value_4*) pvalue_;
   asn1Print_ClassmarkInformation2 (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_5                            */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredIEs_Value_5
   (const char* name, void* pvalue_)
{
   _RelocationRequiredIEs_Value_5 *pvalue = (_RelocationRequiredIEs_Value_5*) pvalue_;
   asn1Print_ClassmarkInformation3 (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_6                            */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredIEs_Value_6
   (const char* name, void* pvalue_)
{
   _RelocationRequiredIEs_Value_6 *pvalue = (_RelocationRequiredIEs_Value_6*) pvalue_;
   asn1Print_SourceRNC_ToTargetRNC_TransparentContainer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_7                            */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredIEs_Value_7
   (const char* name, void* pvalue_)
{
   _RelocationRequiredIEs_Value_7 *pvalue = (_RelocationRequiredIEs_Value_7*) pvalue_;
   asn1Print_OldBSS_ToNewBSS_Information (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequired_protocolIEs_element
   (const char* name, RelocationRequired_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationRequiredIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequiredIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequiredIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationRequiredIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs                            */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequired_protocolIEs
   (const char* name, RelocationRequired_protocolIEs* pvalue)
{
   RelocationRequired_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationRequired_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationRequired_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredExtensions_Extension                   */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredExtensions_Extension
   (const char* name, void* pvalue_)
{
   _RelocationRequiredExtensions_Extension *pvalue = (_RelocationRequiredExtensions_Extension*) pvalue_;
   asn1Print_GERAN_Classmark (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredExtensions_Extension_1                 */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequiredExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _RelocationRequiredExtensions_Extension_1 *pvalue = (_RelocationRequiredExtensions_Extension_1*) pvalue_;
   asn1Print_SourceBSS_ToTargetBSS_TransparentContainer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequired_protocolExtensions_element
   (const char* name, RelocationRequired_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationRequiredExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequiredExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequiredExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationRequiredExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequired_protocolExtensions
   (const char* name, RelocationRequired_protocolExtensions* pvalue)
{
   RelocationRequired_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationRequired_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationRequired_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired                                        */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequired
   (const char* name, RelocationRequired* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationRequired_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationRequired_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCommandIEs_Value
   (const char* name, void* pvalue_)
{
   _RelocationCommandIEs_Value *pvalue = (_RelocationCommandIEs_Value*) pvalue_;
   asn1Print_TargetRNC_ToSourceRNC_TransparentContainer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_1                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCommandIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RelocationCommandIEs_Value_1 *pvalue = (_RelocationCommandIEs_Value_1*) pvalue_;
   asn1Print_L3_Information (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_RelocationReleaseItem_iE_Extensions_element
   (const char* name, RAB_RelocationReleaseItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_RelocationReleaseItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_RelocationReleaseItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_RelocationReleaseItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_RelocationReleaseItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_RelocationReleaseItem_iE_Extensions
   (const char* name, RAB_RelocationReleaseItem_iE_Extensions* pvalue)
{
   RAB_RelocationReleaseItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_RelocationReleaseItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_RelocationReleaseItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem                                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_RelocationReleaseItem
   (const char* name, RAB_RelocationReleaseItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_RelocationReleaseItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_RelocationReleaseItemIEs_Value                       */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_RelocationReleaseItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_RelocationReleaseItemIEs_Value *pvalue = (_RAB_RelocationReleaseItemIEs_Value*) pvalue_;
   asn1Print_RAB_RelocationReleaseItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_RelocationReleaseList_element_element
   (const char* name, RAB_RelocationReleaseList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_RelocationReleaseItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_RelocationReleaseItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_RelocationReleaseItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_RelocationReleaseItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element                         */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_RelocationReleaseList_element
   (const char* name, RAB_RelocationReleaseList_element* pvalue)
{
   RAB_RelocationReleaseList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_RelocationReleaseList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_RelocationReleaseList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList                                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_RelocationReleaseList
   (const char* name, RAB_RelocationReleaseList* pvalue)
{
   RAB_RelocationReleaseList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_RelocationReleaseList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_RelocationReleaseList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_2                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCommandIEs_Value_2
   (const char* name, void* pvalue_)
{
   _RelocationCommandIEs_Value_2 *pvalue = (_RelocationCommandIEs_Value_2*) pvalue_;
   asn1Print_RAB_RelocationReleaseList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_ExtIEs_Extension                  */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_DataForwardingItem_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _RAB_DataForwardingItem_ExtIEs_Extension *pvalue = (_RAB_DataForwardingItem_ExtIEs_Extension*) pvalue_;
   asn1Print_TransportLayerAddress (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_ExtIEs_Extension_1                */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_DataForwardingItem_ExtIEs_Extension_1
   (const char* name, void* pvalue_)
{
   _RAB_DataForwardingItem_ExtIEs_Extension_1 *pvalue = (_RAB_DataForwardingItem_ExtIEs_Extension_1*) pvalue_;
   asn1Print_IuTransportAssociation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingItem_iE_Extensions_element
   (const char* name, RAB_DataForwardingItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_DataForwardingItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingItem_iE_Extensions
   (const char* name, RAB_DataForwardingItem_iE_Extensions* pvalue)
{
   RAB_DataForwardingItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataForwardingItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataForwardingItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingItem
   (const char* name, RAB_DataForwardingItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   sprintf (namebuf, "%s.transportLayerAddress", name);
   asn1Print_TransportLayerAddress (namebuf, &pvalue->transportLayerAddress);

   sprintf (namebuf, "%s.iuTransportAssociation", name);
   asn1Print_IuTransportAssociation (namebuf, &pvalue->iuTransportAssociation);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_DataForwardingItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItemIEs_Value                          */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_DataForwardingItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_DataForwardingItemIEs_Value *pvalue = (_RAB_DataForwardingItemIEs_Value*) pvalue_;
   asn1Print_RAB_DataForwardingItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingList_element_element
   (const char* name, RAB_DataForwardingList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_DataForwardingItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_DataForwardingItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingList_element
   (const char* name, RAB_DataForwardingList_element* pvalue)
{
   RAB_DataForwardingList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataForwardingList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataForwardingList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingList
   (const char* name, RAB_DataForwardingList* pvalue)
{
   RAB_DataForwardingList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataForwardingList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataForwardingList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_3                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCommandIEs_Value_3
   (const char* name, void* pvalue_)
{
   _RelocationCommandIEs_Value_3 *pvalue = (_RelocationCommandIEs_Value_3*) pvalue_;
   asn1Print_RAB_DataForwardingList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_4                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCommandIEs_Value_4
   (const char* name, void* pvalue_)
{
   _RelocationCommandIEs_Value_4 *pvalue = (_RelocationCommandIEs_Value_4*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCommand_protocolIEs_element
   (const char* name, RelocationCommand_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCommandIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationCommandIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs                             */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCommand_protocolIEs
   (const char* name, RelocationCommand_protocolIEs* pvalue)
{
   RelocationCommand_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationCommand_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationCommand_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandExtensions_Extension                    */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCommandExtensions_Extension
   (const char* name, void* pvalue_)
{
   _RelocationCommandExtensions_Extension *pvalue = (_RelocationCommandExtensions_Extension*) pvalue_;
   asn1Print_InterSystemInformation_TransparentContainer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCommandExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _RelocationCommandExtensions_Extension_1 *pvalue = (_RelocationCommandExtensions_Extension_1*) pvalue_;
   asn1Print_TargetBSS_ToSourceBSS_TransparentContainer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCommand_protocolExtensions_element
   (const char* name, RelocationCommand_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCommandExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationCommandExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCommand_protocolExtensions
   (const char* name, RelocationCommand_protocolExtensions* pvalue)
{
   RelocationCommand_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationCommand_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationCommand_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand                                         */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCommand
   (const char* name, RelocationCommand* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationCommand_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationCommand_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureIEs_Value                    */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationPreparationFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _RelocationPreparationFailureIEs_Value *pvalue = (_RelocationPreparationFailureIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureIEs_Value_1                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationPreparationFailureIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RelocationPreparationFailureIEs_Value_1 *pvalue = (_RelocationPreparationFailureIEs_Value_1*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs_element          */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationPreparationFailure_protocolIEs_element
   (const char* name, RelocationPreparationFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationPreparationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationPreparationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationPreparationFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationPreparationFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs                  */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationPreparationFailure_protocolIEs
   (const char* name, RelocationPreparationFailure_protocolIEs* pvalue)
{
   RelocationPreparationFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationPreparationFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationPreparationFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureExtensions_Extension         */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationPreparationFailureExtensions_Extension
   (const char* name, void* pvalue_)
{
   _RelocationPreparationFailureExtensions_Extension *pvalue = (_RelocationPreparationFailureExtensions_Extension*) pvalue_;
   asn1Print_InterSystemInformation_TransparentContainer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationPreparationFailure_protocolExtensions_element
   (const char* name, RelocationPreparationFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationPreparationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationPreparationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationPreparationFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationPreparationFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions           */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationPreparationFailure_protocolExtensions
   (const char* name, RelocationPreparationFailure_protocolExtensions* pvalue)
{
   RelocationPreparationFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationPreparationFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationPreparationFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure                              */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationPreparationFailure
   (const char* name, RelocationPreparationFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationPreparationFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationPreparationFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _RelocationRequestIEs_Value *pvalue = (_RelocationRequestIEs_Value*) pvalue_;
   asn1Print_PermanentNAS_UE_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_1                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RelocationRequestIEs_Value_1 *pvalue = (_RelocationRequestIEs_Value_1*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_2                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestIEs_Value_2
   (const char* name, void* pvalue_)
{
   _RelocationRequestIEs_Value_2 *pvalue = (_RelocationRequestIEs_Value_2*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_3                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestIEs_Value_3
   (const char* name, void* pvalue_)
{
   _RelocationRequestIEs_Value_3 *pvalue = (_RelocationRequestIEs_Value_3*) pvalue_;
   asn1Print_SourceRNC_ToTargetRNC_TransparentContainer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

void asn1Print_UserPlaneInformation_iE_Extensions_element
   (const char* name, UserPlaneInformation_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UserPlaneInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UserPlaneInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UserPlaneInformation_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      UserPlaneInformation_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions                        */
/*                                                            */
/**************************************************************/

void asn1Print_UserPlaneInformation_iE_Extensions
   (const char* name, UserPlaneInformation_iE_Extensions* pvalue)
{
   UserPlaneInformation_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UserPlaneInformation_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UserPlaneInformation_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation                                      */
/*                                                            */
/**************************************************************/

void asn1Print_UserPlaneInformation
   (const char* name, UserPlaneInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.userPlaneMode", name);
   asn1Print_UserPlaneMode (namebuf, &pvalue->userPlaneMode);

   sprintf (namebuf, "%s.uP_ModeVersions", name);
   asn1Print_UP_ModeVersions (namebuf, &pvalue->uP_ModeVersions);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_UserPlaneInformation_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_ExtIEs_Extension                  */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupItem_RelocReq_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _RAB_SetupItem_RelocReq_ExtIEs_Extension *pvalue = (_RAB_SetupItem_RelocReq_ExtIEs_Extension*) pvalue_;
   asn1Print_Alt_RAB_Parameters (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_ExtIEs_Extension_1                */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupItem_RelocReq_ExtIEs_Extension_1
   (const char* name, void* pvalue_)
{
   _RAB_SetupItem_RelocReq_ExtIEs_Extension_1 *pvalue = (_RAB_SetupItem_RelocReq_ExtIEs_Extension_1*) pvalue_;
   asn1Print_GERAN_BSC_Container (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupItem_RelocReq_iE_Extensions_element
   (const char* name, RAB_SetupItem_RelocReq_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReq_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReq_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReq_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_SetupItem_RelocReq_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupItem_RelocReq_iE_Extensions
   (const char* name, RAB_SetupItem_RelocReq_iE_Extensions* pvalue)
{
   RAB_SetupItem_RelocReq_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupItem_RelocReq_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupItem_RelocReq_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupItem_RelocReq
   (const char* name, RAB_SetupItem_RelocReq* pvalue)
{
   char namebuf[512];

   printf ("%s.m.nAS_SynchronisationIndicatorPresent = %d\n", name, (int)pvalue->m.nAS_SynchronisationIndicatorPresent);
   printf ("%s.m.dataVolumeReportingIndicationPresent = %d\n", name, (int)pvalue->m.dataVolumeReportingIndicationPresent);
   printf ("%s.m.pDP_TypeInformationPresent = %d\n", name, (int)pvalue->m.pDP_TypeInformationPresent);
   printf ("%s.m.service_HandoverPresent = %d\n", name, (int)pvalue->m.service_HandoverPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      sprintf (namebuf, "%s.nAS_SynchronisationIndicator", name);
      asn1Print_NAS_SynchronisationIndicator (namebuf, &pvalue->nAS_SynchronisationIndicator);
   }

   sprintf (namebuf, "%s.rAB_Parameters", name);
   asn1Print_RAB_Parameters (namebuf, &pvalue->rAB_Parameters);

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      sprintf (namebuf, "%s.dataVolumeReportingIndication", name);
      asn1Print_DataVolumeReportingIndication (namebuf, &pvalue->dataVolumeReportingIndication);
   }

   if (pvalue->m.pDP_TypeInformationPresent) {
      sprintf (namebuf, "%s.pDP_TypeInformation", name);
      asn1Print_PDP_TypeInformation (namebuf, &pvalue->pDP_TypeInformation);
   }

   sprintf (namebuf, "%s.userPlaneInformation", name);
   asn1Print_UserPlaneInformation (namebuf, &pvalue->userPlaneInformation);

   sprintf (namebuf, "%s.transportLayerAddress", name);
   asn1Print_TransportLayerAddress (namebuf, &pvalue->transportLayerAddress);

   sprintf (namebuf, "%s.iuTransportAssociation", name);
   asn1Print_IuTransportAssociation (namebuf, &pvalue->iuTransportAssociation);

   if (pvalue->m.service_HandoverPresent) {
      sprintf (namebuf, "%s.service_Handover", name);
      asn1Print_Service_Handover (namebuf, &pvalue->service_Handover);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_SetupItem_RelocReq_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_IEs_Value                         */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupItem_RelocReq_IEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_SetupItem_RelocReq_IEs_Value *pvalue = (_RAB_SetupItem_RelocReq_IEs_Value*) pvalue_;
   asn1Print_RAB_SetupItem_RelocReq (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupList_RelocReq_element_element
   (const char* name, RAB_SetupList_RelocReq_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReq_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReq_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReq_IEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_SetupItem_RelocReq_IEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupList_RelocReq_element
   (const char* name, RAB_SetupList_RelocReq_element* pvalue)
{
   RAB_SetupList_RelocReq_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupList_RelocReq_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupList_RelocReq_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupList_RelocReq
   (const char* name, RAB_SetupList_RelocReq* pvalue)
{
   RAB_SetupList_RelocReq_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupList_RelocReq_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupList_RelocReq_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_4                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestIEs_Value_4
   (const char* name, void* pvalue_)
{
   _RelocationRequestIEs_Value_4 *pvalue = (_RelocationRequestIEs_Value_4*) pvalue_;
   asn1Print_RAB_SetupList_RelocReq (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_5                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestIEs_Value_5
   (const char* name, void* pvalue_)
{
   _RelocationRequestIEs_Value_5 *pvalue = (_RelocationRequestIEs_Value_5*) pvalue_;
   asn1Print_IntegrityProtectionInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_6                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestIEs_Value_6
   (const char* name, void* pvalue_)
{
   _RelocationRequestIEs_Value_6 *pvalue = (_RelocationRequestIEs_Value_6*) pvalue_;
   asn1Print_EncryptionInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_7                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestIEs_Value_7
   (const char* name, void* pvalue_)
{
   _RelocationRequestIEs_Value_7 *pvalue = (_RelocationRequestIEs_Value_7*) pvalue_;
   asn1Print_IuSignallingConnectionIdentifier (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequest_protocolIEs_element
   (const char* name, RelocationRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequest_protocolIEs
   (const char* name, RelocationRequest_protocolIEs* pvalue)
{
   RelocationRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension                    */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestExtensions_Extension
   (const char* name, void* pvalue_)
{
   _RelocationRequestExtensions_Extension *pvalue = (_RelocationRequestExtensions_Extension*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _RelocationRequestExtensions_Extension_1 *pvalue = (_RelocationRequestExtensions_Extension_1*) pvalue_;
   asn1Print_SNA_Access_Information (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_2                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestExtensions_Extension_2
   (const char* name, void* pvalue_)
{
   _RelocationRequestExtensions_Extension_2 *pvalue = (_RelocationRequestExtensions_Extension_2*) pvalue_;
   asn1Print_UESBI_Iu (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_3                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestExtensions_Extension_3
   (const char* name, void* pvalue_)
{
   _RelocationRequestExtensions_Extension_3 *pvalue = (_RelocationRequestExtensions_Extension_3*) pvalue_;
   asn1Print_PLMNidentity (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions_elemen  */
/*                                                            */
/**************************************************************/

void asn1Print_JoinedMBMSBearerService_IEs_element_iE_Extensions_element
   (const char* name, JoinedMBMSBearerService_IEs_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < JoinedMBMSBearerService_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &JoinedMBMSBearerService_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == JoinedMBMSBearerService_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      JoinedMBMSBearerService_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions         */
/*                                                            */
/**************************************************************/

void asn1Print_JoinedMBMSBearerService_IEs_element_iE_Extensions
   (const char* name, JoinedMBMSBearerService_IEs_element_iE_Extensions* pvalue)
{
   JoinedMBMSBearerService_IEs_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (JoinedMBMSBearerService_IEs_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element                       */
/*                                                            */
/**************************************************************/

void asn1Print_JoinedMBMSBearerService_IEs_element
   (const char* name, JoinedMBMSBearerService_IEs_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.tMGI", name);
   asn1Print_TMGI (namebuf, &pvalue->tMGI);

   sprintf (namebuf, "%s.mBMS_PTP_RAB_ID", name);
   asn1Print_MBMS_PTP_RAB_ID (namebuf, &pvalue->mBMS_PTP_RAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_JoinedMBMSBearerService_IEs_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs                               */
/*                                                            */
/**************************************************************/

void asn1Print_JoinedMBMSBearerService_IEs
   (const char* name, JoinedMBMSBearerService_IEs* pvalue)
{
   JoinedMBMSBearerService_IEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (JoinedMBMSBearerService_IEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_JoinedMBMSBearerService_IEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

void asn1Print_CNMBMSLinkingInformation_iE_Extensions_element
   (const char* name, CNMBMSLinkingInformation_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CNMBMSLinkingInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CNMBMSLinkingInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CNMBMSLinkingInformation_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CNMBMSLinkingInformation_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions                    */
/*                                                            */
/**************************************************************/

void asn1Print_CNMBMSLinkingInformation_iE_Extensions
   (const char* name, CNMBMSLinkingInformation_iE_Extensions* pvalue)
{
   CNMBMSLinkingInformation_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CNMBMSLinkingInformation_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CNMBMSLinkingInformation_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation                                  */
/*                                                            */
/**************************************************************/

void asn1Print_CNMBMSLinkingInformation
   (const char* name, CNMBMSLinkingInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.joinedMBMSBearerService_IEs", name);
   asn1Print_JoinedMBMSBearerService_IEs (namebuf, &pvalue->joinedMBMSBearerService_IEs);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_CNMBMSLinkingInformation_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_4                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestExtensions_Extension_4
   (const char* name, void* pvalue_)
{
   _RelocationRequestExtensions_Extension_4 *pvalue = (_RelocationRequestExtensions_Extension_4*) pvalue_;
   asn1Print_CNMBMSLinkingInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequest_protocolExtensions_element
   (const char* name, RelocationRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequest_protocolExtensions
   (const char* name, RelocationRequest_protocolExtensions* pvalue)
{
   RelocationRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest                                         */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequest
   (const char* name, RelocationRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value                    */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestAcknowledgeIEs_Value
   (const char* name, void* pvalue_)
{
   _RelocationRequestAcknowledgeIEs_Value *pvalue = (_RelocationRequestAcknowledgeIEs_Value*) pvalue_;
   asn1Print_TargetRNC_ToSourceRNC_TransparentContainer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension               */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupItem_RelocReqAck_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension*) pvalue_;
   asn1Print_Ass_RAB_Parameters (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1             */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1
   (const char* name, void* pvalue_)
{
   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1 *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1*) pvalue_;
   asn1Print_TransportLayerAddress (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2             */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2
   (const char* name, void* pvalue_)
{
   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2 *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2*) pvalue_;
   asn1Print_IuTransportAssociation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupItem_RelocReqAck_iE_Extensions_element
   (const char* name, RAB_SetupItem_RelocReqAck_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReqAck_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReqAck_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReqAck_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_SetupItem_RelocReqAck_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupItem_RelocReqAck_iE_Extensions
   (const char* name, RAB_SetupItem_RelocReqAck_iE_Extensions* pvalue)
{
   RAB_SetupItem_RelocReqAck_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupItem_RelocReqAck_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupItem_RelocReqAck_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck                                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupItem_RelocReqAck
   (const char* name, RAB_SetupItem_RelocReqAck* pvalue)
{
   char namebuf[512];

   printf ("%s.m.transportLayerAddressPresent = %d\n", name, (int)pvalue->m.transportLayerAddressPresent);
   printf ("%s.m.iuTransportAssociationPresent = %d\n", name, (int)pvalue->m.iuTransportAssociationPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.transportLayerAddressPresent) {
      sprintf (namebuf, "%s.transportLayerAddress", name);
      asn1Print_TransportLayerAddress (namebuf, &pvalue->transportLayerAddress);
   }

   if (pvalue->m.iuTransportAssociationPresent) {
      sprintf (namebuf, "%s.iuTransportAssociation", name);
      asn1Print_IuTransportAssociation (namebuf, &pvalue->iuTransportAssociation);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_SetupItem_RelocReqAck_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_IEs_Value                      */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupItem_RelocReqAck_IEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_SetupItem_RelocReqAck_IEs_Value *pvalue = (_RAB_SetupItem_RelocReqAck_IEs_Value*) pvalue_;
   asn1Print_RAB_SetupItem_RelocReqAck (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupList_RelocReqAck_element_element
   (const char* name, RAB_SetupList_RelocReqAck_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReqAck_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReqAck_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReqAck_IEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_SetupItem_RelocReqAck_IEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element                         */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupList_RelocReqAck_element
   (const char* name, RAB_SetupList_RelocReqAck_element* pvalue)
{
   RAB_SetupList_RelocReqAck_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupList_RelocReqAck_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupList_RelocReqAck_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck                                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupList_RelocReqAck
   (const char* name, RAB_SetupList_RelocReqAck* pvalue)
{
   RAB_SetupList_RelocReqAck_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupList_RelocReqAck_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupList_RelocReqAck_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_1                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestAcknowledgeIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RelocationRequestAcknowledgeIEs_Value_1 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_1*) pvalue_;
   asn1Print_RAB_SetupList_RelocReqAck (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedItem_iE_Extensions_element
   (const char* name, RAB_FailedItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_FailedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_FailedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_FailedItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_FailedItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedItem_iE_Extensions
   (const char* name, RAB_FailedItem_iE_Extensions* pvalue)
{
   RAB_FailedItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_FailedItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_FailedItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedItem
   (const char* name, RAB_FailedItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   sprintf (namebuf, "%s.cause", name);
   asn1Print_Cause (namebuf, &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_FailedItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_FailedItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_FailedItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_FailedItemIEs_Value *pvalue = (_RAB_FailedItemIEs_Value*) pvalue_;
   asn1Print_RAB_FailedItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element_element                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedList_element_element
   (const char* name, RAB_FailedList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_FailedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_FailedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_FailedItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_FailedItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedList_element
   (const char* name, RAB_FailedList_element* pvalue)
{
   RAB_FailedList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_FailedList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_FailedList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedList
   (const char* name, RAB_FailedList* pvalue)
{
   RAB_FailedList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_FailedList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_FailedList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_2                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestAcknowledgeIEs_Value_2
   (const char* name, void* pvalue_)
{
   _RelocationRequestAcknowledgeIEs_Value_2 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_2*) pvalue_;
   asn1Print_RAB_FailedList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_3                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestAcknowledgeIEs_Value_3
   (const char* name, void* pvalue_)
{
   _RelocationRequestAcknowledgeIEs_Value_3 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_3*) pvalue_;
   asn1Print_ChosenIntegrityProtectionAlgorithm (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_4                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestAcknowledgeIEs_Value_4
   (const char* name, void* pvalue_)
{
   _RelocationRequestAcknowledgeIEs_Value_4 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_4*) pvalue_;
   asn1Print_ChosenEncryptionAlgorithm (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_5                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestAcknowledgeIEs_Value_5
   (const char* name, void* pvalue_)
{
   _RelocationRequestAcknowledgeIEs_Value_5 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_5*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs_element          */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequestAcknowledge_protocolIEs_element
   (const char* name, RelocationRequestAcknowledge_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationRequestAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestAcknowledgeIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationRequestAcknowledgeIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs                  */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequestAcknowledge_protocolIEs
   (const char* name, RelocationRequestAcknowledge_protocolIEs* pvalue)
{
   RelocationRequestAcknowledge_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationRequestAcknowledge_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationRequestAcknowledge_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeExtensions_Extension         */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationRequestAcknowledgeExtensions_Extension
   (const char* name, void* pvalue_)
{
   _RelocationRequestAcknowledgeExtensions_Extension *pvalue = (_RelocationRequestAcknowledgeExtensions_Extension*) pvalue_;
   asn1Print_NewBSS_To_OldBSS_Information (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequestAcknowledge_protocolExtensions_element
   (const char* name, RelocationRequestAcknowledge_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationRequestAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestAcknowledgeExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationRequestAcknowledgeExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions           */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequestAcknowledge_protocolExtensions
   (const char* name, RelocationRequestAcknowledge_protocolExtensions* pvalue)
{
   RelocationRequestAcknowledge_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationRequestAcknowledge_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationRequestAcknowledge_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge                              */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationRequestAcknowledge
   (const char* name, RelocationRequestAcknowledge* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationRequestAcknowledge_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationRequestAcknowledge_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _RelocationFailureIEs_Value *pvalue = (_RelocationFailureIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureIEs_Value_1                             */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationFailureIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RelocationFailureIEs_Value_1 *pvalue = (_RelocationFailureIEs_Value_1*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationFailure_protocolIEs_element
   (const char* name, RelocationFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs                             */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationFailure_protocolIEs
   (const char* name, RelocationFailure_protocolIEs* pvalue)
{
   RelocationFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureExtensions_Extension                    */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationFailureExtensions_Extension
   (const char* name, void* pvalue_)
{
   _RelocationFailureExtensions_Extension *pvalue = (_RelocationFailureExtensions_Extension*) pvalue_;
   asn1Print_NewBSS_To_OldBSS_Information (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationFailureExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _RelocationFailureExtensions_Extension_1 *pvalue = (_RelocationFailureExtensions_Extension_1*) pvalue_;
   asn1Print_GERAN_Classmark (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationFailure_protocolExtensions_element
   (const char* name, RelocationFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationFailure_protocolExtensions
   (const char* name, RelocationFailure_protocolExtensions* pvalue)
{
   RelocationFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure                                         */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationFailure
   (const char* name, RelocationFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationCancelIEs_Value                                */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCancelIEs_Value
   (const char* name, void* pvalue_)
{
   _RelocationCancelIEs_Value *pvalue = (_RelocationCancelIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancel_protocolIEs_element
   (const char* name, RelocationCancel_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationCancelIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationCancelIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs                              */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancel_protocolIEs
   (const char* name, RelocationCancel_protocolIEs* pvalue)
{
   RelocationCancel_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationCancel_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationCancel_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancel_protocolExtensions_element
   (const char* name, RelocationCancel_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationCancelExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationCancelExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions                       */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancel_protocolExtensions
   (const char* name, RelocationCancel_protocolExtensions* pvalue)
{
   RelocationCancel_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationCancel_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationCancel_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel                                          */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancel
   (const char* name, RelocationCancel* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationCancel_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationCancel_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RelocationCancelAcknowledgeIEs_Value                     */
/*                                                            */
/**************************************************************/

void asn1Print__RelocationCancelAcknowledgeIEs_Value
   (const char* name, void* pvalue_)
{
   _RelocationCancelAcknowledgeIEs_Value *pvalue = (_RelocationCancelAcknowledgeIEs_Value*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs_element           */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancelAcknowledge_protocolIEs_element
   (const char* name, RelocationCancelAcknowledge_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationCancelAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelAcknowledgeIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationCancelAcknowledgeIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs                   */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancelAcknowledge_protocolIEs
   (const char* name, RelocationCancelAcknowledge_protocolIEs* pvalue)
{
   RelocationCancelAcknowledge_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationCancelAcknowledge_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationCancelAcknowledge_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancelAcknowledge_protocolExtensions_element
   (const char* name, RelocationCancelAcknowledge_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationCancelAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelAcknowledgeExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationCancelAcknowledgeExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions            */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancelAcknowledge_protocolExtensions
   (const char* name, RelocationCancelAcknowledge_protocolExtensions* pvalue)
{
   RelocationCancelAcknowledge_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationCancelAcknowledge_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationCancelAcknowledge_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge                               */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationCancelAcknowledge
   (const char* name, RelocationCancelAcknowledge* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationCancelAcknowledge_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationCancelAcknowledge_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element  */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element
   (const char* name, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions
   (const char* name, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions* pvalue)
{
   RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq                        */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingItem_SRNS_CtxReq
   (const char* name, RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value             */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value *pvalue = (_RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value*) pvalue_;
   asn1Print_RAB_DataForwardingItem_SRNS_CtxReq (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element_element        */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingList_SRNS_CtxReq_element_element
   (const char* name, RAB_DataForwardingList_SRNS_CtxReq_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element                */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingList_SRNS_CtxReq_element
   (const char* name, RAB_DataForwardingList_SRNS_CtxReq_element* pvalue)
{
   RAB_DataForwardingList_SRNS_CtxReq_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataForwardingList_SRNS_CtxReq_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataForwardingList_SRNS_CtxReq_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq                        */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataForwardingList_SRNS_CtxReq
   (const char* name, RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   RAB_DataForwardingList_SRNS_CtxReq_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataForwardingList_SRNS_CtxReq_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataForwardingList_SRNS_CtxReq_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextRequestIEs_Value                             */
/*                                                            */
/**************************************************************/

void asn1Print__SRNS_ContextRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _SRNS_ContextRequestIEs_Value *pvalue = (_SRNS_ContextRequestIEs_Value*) pvalue_;
   asn1Print_RAB_DataForwardingList_SRNS_CtxReq (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextRequest_protocolIEs_element
   (const char* name, SRNS_ContextRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SRNS_ContextRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      SRNS_ContextRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs                           */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextRequest_protocolIEs
   (const char* name, SRNS_ContextRequest_protocolIEs* pvalue)
{
   SRNS_ContextRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SRNS_ContextRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SRNS_ContextRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextRequest_protocolExtensions_element
   (const char* name, SRNS_ContextRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SRNS_ContextRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SRNS_ContextRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions                    */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextRequest_protocolExtensions
   (const char* name, SRNS_ContextRequest_protocolExtensions* pvalue)
{
   SRNS_ContextRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SRNS_ContextRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SRNS_ContextRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest                                       */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextRequest
   (const char* name, SRNS_ContextRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_SRNS_ContextRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_SRNS_ContextRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextItem_iE_Extensions_element
   (const char* name, RAB_ContextItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ContextItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_ContextItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions                             */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextItem_iE_Extensions
   (const char* name, RAB_ContextItem_iE_Extensions* pvalue)
{
   RAB_ContextItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ContextItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ContextItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem                                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextItem
   (const char* name, RAB_ContextItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.dl_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.ul_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.dl_N_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   printf ("%s.m.ul_N_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.dl_GTP_PDU_SequenceNumber", name);
      asn1Print_DL_GTP_PDU_SequenceNumber (namebuf, &pvalue->dl_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.ul_GTP_PDU_SequenceNumber", name);
      asn1Print_UL_GTP_PDU_SequenceNumber (namebuf, &pvalue->ul_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.dl_N_PDU_SequenceNumber", name);
      asn1Print_DL_N_PDU_SequenceNumber (namebuf, &pvalue->dl_N_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.ul_N_PDU_SequenceNumber", name);
      asn1Print_UL_N_PDU_SequenceNumber (namebuf, &pvalue->ul_N_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_ContextItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_ContextItemIEs_Value                                 */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_ContextItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_ContextItemIEs_Value *pvalue = (_RAB_ContextItemIEs_Value*) pvalue_;
   asn1Print_RAB_ContextItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element_element                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextList_element_element
   (const char* name, RAB_ContextList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ContextItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_ContextItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element                                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextList_element
   (const char* name, RAB_ContextList_element* pvalue)
{
   RAB_ContextList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ContextList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ContextList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList                                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextList
   (const char* name, RAB_ContextList* pvalue)
{
   RAB_ContextList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ContextList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ContextList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value                            */
/*                                                            */
/**************************************************************/

void asn1Print__SRNS_ContextResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _SRNS_ContextResponseIEs_Value *pvalue = (_SRNS_ContextResponseIEs_Value*) pvalue_;
   asn1Print_RAB_ContextList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

void asn1Print_RABs_ContextFailedtoTransferItem_iE_Extensions_element
   (const char* name, RABs_ContextFailedtoTransferItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RABs_ContextFailedtoTransferItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_ContextFailedtoTransferItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_ContextFailedtoTransferItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RABs_ContextFailedtoTransferItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions            */
/*                                                            */
/**************************************************************/

void asn1Print_RABs_ContextFailedtoTransferItem_iE_Extensions
   (const char* name, RABs_ContextFailedtoTransferItem_iE_Extensions* pvalue)
{
   RABs_ContextFailedtoTransferItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RABs_ContextFailedtoTransferItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RABs_ContextFailedtoTransferItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem                          */
/*                                                            */
/**************************************************************/

void asn1Print_RABs_ContextFailedtoTransferItem
   (const char* name, RABs_ContextFailedtoTransferItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   sprintf (namebuf, "%s.cause", name);
   asn1Print_Cause (namebuf, &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RABs_ContextFailedtoTransferItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RABs_ContextFailedtoTransferItemIEs_Value                */
/*                                                            */
/**************************************************************/

void asn1Print__RABs_ContextFailedtoTransferItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RABs_ContextFailedtoTransferItemIEs_Value *pvalue = (_RABs_ContextFailedtoTransferItemIEs_Value*) pvalue_;
   asn1Print_RABs_ContextFailedtoTransferItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element_element           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextFailedtoTransferList_element_element
   (const char* name, RAB_ContextFailedtoTransferList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RABs_ContextFailedtoTransferItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_ContextFailedtoTransferItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_ContextFailedtoTransferItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RABs_ContextFailedtoTransferItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextFailedtoTransferList_element
   (const char* name, RAB_ContextFailedtoTransferList_element* pvalue)
{
   RAB_ContextFailedtoTransferList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ContextFailedtoTransferList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ContextFailedtoTransferList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextFailedtoTransferList
   (const char* name, RAB_ContextFailedtoTransferList* pvalue)
{
   RAB_ContextFailedtoTransferList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ContextFailedtoTransferList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ContextFailedtoTransferList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value_1                          */
/*                                                            */
/**************************************************************/

void asn1Print__SRNS_ContextResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _SRNS_ContextResponseIEs_Value_1 *pvalue = (_SRNS_ContextResponseIEs_Value_1*) pvalue_;
   asn1Print_RAB_ContextFailedtoTransferList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value_2                          */
/*                                                            */
/**************************************************************/

void asn1Print__SRNS_ContextResponseIEs_Value_2
   (const char* name, void* pvalue_)
{
   _SRNS_ContextResponseIEs_Value_2 *pvalue = (_SRNS_ContextResponseIEs_Value_2*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextResponse_protocolIEs_element
   (const char* name, SRNS_ContextResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SRNS_ContextResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      SRNS_ContextResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs                          */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextResponse_protocolIEs
   (const char* name, SRNS_ContextResponse_protocolIEs* pvalue)
{
   SRNS_ContextResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SRNS_ContextResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SRNS_ContextResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextResponse_protocolExtensions_element
   (const char* name, SRNS_ContextResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SRNS_ContextResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SRNS_ContextResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions                   */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextResponse_protocolExtensions
   (const char* name, SRNS_ContextResponse_protocolExtensions* pvalue)
{
   SRNS_ContextResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SRNS_ContextResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SRNS_ContextResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse                                      */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_ContextResponse
   (const char* name, SRNS_ContextResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_SRNS_ContextResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_SRNS_ContextResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value                             */
/*                                                            */
/**************************************************************/

void asn1Print__SecurityModeCommandIEs_Value
   (const char* name, void* pvalue_)
{
   _SecurityModeCommandIEs_Value *pvalue = (_SecurityModeCommandIEs_Value*) pvalue_;
   asn1Print_IntegrityProtectionInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value_1                           */
/*                                                            */
/**************************************************************/

void asn1Print__SecurityModeCommandIEs_Value_1
   (const char* name, void* pvalue_)
{
   _SecurityModeCommandIEs_Value_1 *pvalue = (_SecurityModeCommandIEs_Value_1*) pvalue_;
   asn1Print_EncryptionInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value_2                           */
/*                                                            */
/**************************************************************/

void asn1Print__SecurityModeCommandIEs_Value_2
   (const char* name, void* pvalue_)
{
   _SecurityModeCommandIEs_Value_2 *pvalue = (_SecurityModeCommandIEs_Value_2*) pvalue_;
   asn1Print_KeyStatus (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeCommand_protocolIEs_element
   (const char* name, SecurityModeCommand_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SecurityModeCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCommandIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      SecurityModeCommandIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs                           */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeCommand_protocolIEs
   (const char* name, SecurityModeCommand_protocolIEs* pvalue)
{
   SecurityModeCommand_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SecurityModeCommand_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SecurityModeCommand_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeCommand_protocolExtensions_element
   (const char* name, SecurityModeCommand_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SecurityModeCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCommandExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SecurityModeCommandExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions                    */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeCommand_protocolExtensions
   (const char* name, SecurityModeCommand_protocolExtensions* pvalue)
{
   SecurityModeCommand_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SecurityModeCommand_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SecurityModeCommand_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand                                       */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeCommand
   (const char* name, SecurityModeCommand* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_SecurityModeCommand_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_SecurityModeCommand_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value                            */
/*                                                            */
/**************************************************************/

void asn1Print__SecurityModeCompleteIEs_Value
   (const char* name, void* pvalue_)
{
   _SecurityModeCompleteIEs_Value *pvalue = (_SecurityModeCompleteIEs_Value*) pvalue_;
   asn1Print_ChosenIntegrityProtectionAlgorithm (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value_1                          */
/*                                                            */
/**************************************************************/

void asn1Print__SecurityModeCompleteIEs_Value_1
   (const char* name, void* pvalue_)
{
   _SecurityModeCompleteIEs_Value_1 *pvalue = (_SecurityModeCompleteIEs_Value_1*) pvalue_;
   asn1Print_ChosenEncryptionAlgorithm (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value_2                          */
/*                                                            */
/**************************************************************/

void asn1Print__SecurityModeCompleteIEs_Value_2
   (const char* name, void* pvalue_)
{
   _SecurityModeCompleteIEs_Value_2 *pvalue = (_SecurityModeCompleteIEs_Value_2*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeComplete_protocolIEs_element
   (const char* name, SecurityModeComplete_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SecurityModeCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCompleteIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      SecurityModeCompleteIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs                          */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeComplete_protocolIEs
   (const char* name, SecurityModeComplete_protocolIEs* pvalue)
{
   SecurityModeComplete_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SecurityModeComplete_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SecurityModeComplete_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeComplete_protocolExtensions_element
   (const char* name, SecurityModeComplete_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SecurityModeCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCompleteExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SecurityModeCompleteExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions                   */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeComplete_protocolExtensions
   (const char* name, SecurityModeComplete_protocolExtensions* pvalue)
{
   SecurityModeComplete_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SecurityModeComplete_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SecurityModeComplete_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete                                      */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeComplete
   (const char* name, SecurityModeComplete* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_SecurityModeComplete_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_SecurityModeComplete_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _SecurityModeRejectIEs_Value                              */
/*                                                            */
/**************************************************************/

void asn1Print__SecurityModeRejectIEs_Value
   (const char* name, void* pvalue_)
{
   _SecurityModeRejectIEs_Value *pvalue = (_SecurityModeRejectIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeRejectIEs_Value_1                            */
/*                                                            */
/**************************************************************/

void asn1Print__SecurityModeRejectIEs_Value_1
   (const char* name, void* pvalue_)
{
   _SecurityModeRejectIEs_Value_1 *pvalue = (_SecurityModeRejectIEs_Value_1*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeReject_protocolIEs_element
   (const char* name, SecurityModeReject_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SecurityModeRejectIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeRejectIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeRejectIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      SecurityModeRejectIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs                            */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeReject_protocolIEs
   (const char* name, SecurityModeReject_protocolIEs* pvalue)
{
   SecurityModeReject_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SecurityModeReject_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SecurityModeReject_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeReject_protocolExtensions_element
   (const char* name, SecurityModeReject_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SecurityModeRejectExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeRejectExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeRejectExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SecurityModeRejectExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeReject_protocolExtensions
   (const char* name, SecurityModeReject_protocolExtensions* pvalue)
{
   SecurityModeReject_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SecurityModeReject_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SecurityModeReject_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject                                        */
/*                                                            */
/**************************************************************/

void asn1Print_SecurityModeReject
   (const char* name, SecurityModeReject* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_SecurityModeReject_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_SecurityModeReject_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportRequestItem_iE_Extensions_element
   (const char* name, RAB_DataVolumeReportRequestItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportRequestItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportRequestItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportRequestItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_DataVolumeReportRequestItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions             */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportRequestItem_iE_Extensions
   (const char* name, RAB_DataVolumeReportRequestItem_iE_Extensions* pvalue)
{
   RAB_DataVolumeReportRequestItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataVolumeReportRequestItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataVolumeReportRequestItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportRequestItem
   (const char* name, RAB_DataVolumeReportRequestItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_DataVolumeReportRequestItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_DataVolumeReportRequestItemIEs_Value                 */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_DataVolumeReportRequestItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_DataVolumeReportRequestItemIEs_Value *pvalue = (_RAB_DataVolumeReportRequestItemIEs_Value*) pvalue_;
   asn1Print_RAB_DataVolumeReportRequestItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element_element           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportRequestList_element_element
   (const char* name, RAB_DataVolumeReportRequestList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportRequestItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportRequestItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportRequestItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_DataVolumeReportRequestItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportRequestList_element
   (const char* name, RAB_DataVolumeReportRequestList_element* pvalue)
{
   RAB_DataVolumeReportRequestList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataVolumeReportRequestList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataVolumeReportRequestList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_DataVolumeReportRequestList
   (const char* name, RAB_DataVolumeReportRequestList* pvalue)
{
   RAB_DataVolumeReportRequestList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_DataVolumeReportRequestList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_DataVolumeReportRequestList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportRequestIEs_Value                         */
/*                                                            */
/**************************************************************/

void asn1Print__DataVolumeReportRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _DataVolumeReportRequestIEs_Value *pvalue = (_DataVolumeReportRequestIEs_Value*) pvalue_;
   asn1Print_RAB_DataVolumeReportRequestList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReportRequest_protocolIEs_element
   (const char* name, DataVolumeReportRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DataVolumeReportRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      DataVolumeReportRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs                       */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReportRequest_protocolIEs
   (const char* name, DataVolumeReportRequest_protocolIEs* pvalue)
{
   DataVolumeReportRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DataVolumeReportRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DataVolumeReportRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReportRequest_protocolExtensions_element
   (const char* name, DataVolumeReportRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DataVolumeReportRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      DataVolumeReportRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions                */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReportRequest_protocolExtensions
   (const char* name, DataVolumeReportRequest_protocolExtensions* pvalue)
{
   DataVolumeReportRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DataVolumeReportRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DataVolumeReportRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest                                   */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReportRequest
   (const char* name, DataVolumeReportRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_DataVolumeReportRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_DataVolumeReportRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value                                */
/*                                                            */
/**************************************************************/

void asn1Print__DataVolumeReportIEs_Value
   (const char* name, void* pvalue_)
{
   _DataVolumeReportIEs_Value *pvalue = (_DataVolumeReportIEs_Value*) pvalue_;
   asn1Print_RAB_DataVolumeReportList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

void asn1Print_RABs_failed_to_reportItem_iE_Extensions_element
   (const char* name, RABs_failed_to_reportItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RABs_failed_to_reportItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_failed_to_reportItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_failed_to_reportItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RABs_failed_to_reportItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions                   */
/*                                                            */
/**************************************************************/

void asn1Print_RABs_failed_to_reportItem_iE_Extensions
   (const char* name, RABs_failed_to_reportItem_iE_Extensions* pvalue)
{
   RABs_failed_to_reportItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RABs_failed_to_reportItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RABs_failed_to_reportItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem                                 */
/*                                                            */
/**************************************************************/

void asn1Print_RABs_failed_to_reportItem
   (const char* name, RABs_failed_to_reportItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   sprintf (namebuf, "%s.cause", name);
   asn1Print_Cause (namebuf, &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RABs_failed_to_reportItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RABs_failed_to_reportItemIEs_Value                       */
/*                                                            */
/**************************************************************/

void asn1Print__RABs_failed_to_reportItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RABs_failed_to_reportItemIEs_Value *pvalue = (_RABs_failed_to_reportItemIEs_Value*) pvalue_;
   asn1Print_RABs_failed_to_reportItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedtoReportList_element_element
   (const char* name, RAB_FailedtoReportList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RABs_failed_to_reportItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_failed_to_reportItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_failed_to_reportItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RABs_failed_to_reportItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedtoReportList_element
   (const char* name, RAB_FailedtoReportList_element* pvalue)
{
   RAB_FailedtoReportList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_FailedtoReportList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_FailedtoReportList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_FailedtoReportList
   (const char* name, RAB_FailedtoReportList* pvalue)
{
   RAB_FailedtoReportList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_FailedtoReportList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_FailedtoReportList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value_1                              */
/*                                                            */
/**************************************************************/

void asn1Print__DataVolumeReportIEs_Value_1
   (const char* name, void* pvalue_)
{
   _DataVolumeReportIEs_Value_1 *pvalue = (_DataVolumeReportIEs_Value_1*) pvalue_;
   asn1Print_RAB_FailedtoReportList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value_2                              */
/*                                                            */
/**************************************************************/

void asn1Print__DataVolumeReportIEs_Value_2
   (const char* name, void* pvalue_)
{
   _DataVolumeReportIEs_Value_2 *pvalue = (_DataVolumeReportIEs_Value_2*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReport_protocolIEs_element
   (const char* name, DataVolumeReport_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DataVolumeReportIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      DataVolumeReportIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs                              */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReport_protocolIEs
   (const char* name, DataVolumeReport_protocolIEs* pvalue)
{
   DataVolumeReport_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DataVolumeReport_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DataVolumeReport_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReport_protocolExtensions_element
   (const char* name, DataVolumeReport_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DataVolumeReportExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      DataVolumeReportExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions                       */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReport_protocolExtensions
   (const char* name, DataVolumeReport_protocolExtensions* pvalue)
{
   DataVolumeReport_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DataVolumeReport_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DataVolumeReport_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport                                          */
/*                                                            */
/**************************************************************/

void asn1Print_DataVolumeReport
   (const char* name, DataVolumeReport* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_DataVolumeReport_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_DataVolumeReport_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value                                           */
/*                                                            */
/**************************************************************/

void asn1Print__ResetIEs_Value
   (const char* name, void* pvalue_)
{
   _ResetIEs_Value *pvalue = (_ResetIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value_1                                         */
/*                                                            */
/**************************************************************/

void asn1Print__ResetIEs_Value_1
   (const char* name, void* pvalue_)
{
   _ResetIEs_Value_1 *pvalue = (_ResetIEs_Value_1*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value_2                                         */
/*                                                            */
/**************************************************************/

void asn1Print__ResetIEs_Value_2
   (const char* name, void* pvalue_)
{
   _ResetIEs_Value_2 *pvalue = (_ResetIEs_Value_2*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs_element                                 */
/*                                                            */
/**************************************************************/

void asn1Print_Reset_protocolIEs_element
   (const char* name, Reset_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      ResetIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs                                         */
/*                                                            */
/**************************************************************/

void asn1Print_Reset_protocolIEs
   (const char* name, Reset_protocolIEs* pvalue)
{
   Reset_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Reset_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Reset_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _ResetExtensions_Extension                                */
/*                                                            */
/**************************************************************/

void asn1Print__ResetExtensions_Extension
   (const char* name, void* pvalue_)
{
   _ResetExtensions_Extension *pvalue = (_ResetExtensions_Extension*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions_element                          */
/*                                                            */
/**************************************************************/

void asn1Print_Reset_protocolExtensions_element
   (const char* name, Reset_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ResetExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions                                  */
/*                                                            */
/**************************************************************/

void asn1Print_Reset_protocolExtensions
   (const char* name, Reset_protocolExtensions* pvalue)
{
   Reset_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Reset_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Reset_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Reset                                                     */
/*                                                            */
/**************************************************************/

void asn1Print_Reset
   (const char* name, Reset* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_Reset_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_Reset_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value                                */
/*                                                            */
/**************************************************************/

void asn1Print__ResetAcknowledgeIEs_Value
   (const char* name, void* pvalue_)
{
   _ResetAcknowledgeIEs_Value *pvalue = (_ResetAcknowledgeIEs_Value*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value_1                              */
/*                                                            */
/**************************************************************/

void asn1Print__ResetAcknowledgeIEs_Value_1
   (const char* name, void* pvalue_)
{
   _ResetAcknowledgeIEs_Value_1 *pvalue = (_ResetAcknowledgeIEs_Value_1*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value_2                              */
/*                                                            */
/**************************************************************/

void asn1Print__ResetAcknowledgeIEs_Value_2
   (const char* name, void* pvalue_)
{
   _ResetAcknowledgeIEs_Value_2 *pvalue = (_ResetAcknowledgeIEs_Value_2*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_ResetAcknowledge_protocolIEs_element
   (const char* name, ResetAcknowledge_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetAcknowledgeIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      ResetAcknowledgeIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs                              */
/*                                                            */
/**************************************************************/

void asn1Print_ResetAcknowledge_protocolIEs
   (const char* name, ResetAcknowledge_protocolIEs* pvalue)
{
   ResetAcknowledge_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetAcknowledge_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetAcknowledge_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeExtensions_Extension                     */
/*                                                            */
/**************************************************************/

void asn1Print__ResetAcknowledgeExtensions_Extension
   (const char* name, void* pvalue_)
{
   _ResetAcknowledgeExtensions_Extension *pvalue = (_ResetAcknowledgeExtensions_Extension*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

void asn1Print_ResetAcknowledge_protocolExtensions_element
   (const char* name, ResetAcknowledge_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetAcknowledgeExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ResetAcknowledgeExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions                       */
/*                                                            */
/**************************************************************/

void asn1Print_ResetAcknowledge_protocolExtensions
   (const char* name, ResetAcknowledge_protocolExtensions* pvalue)
{
   ResetAcknowledge_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetAcknowledge_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetAcknowledge_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge                                          */
/*                                                            */
/**************************************************************/

void asn1Print_ResetAcknowledge
   (const char* name, ResetAcknowledge* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_ResetAcknowledge_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_ResetAcknowledge_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseItem_iE_Extensions_element
   (const char* name, RAB_ReleaseItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ReleaseItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_ReleaseItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions                             */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseItem_iE_Extensions
   (const char* name, RAB_ReleaseItem_iE_Extensions* pvalue)
{
   RAB_ReleaseItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleaseItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleaseItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem                                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseItem
   (const char* name, RAB_ReleaseItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   sprintf (namebuf, "%s.cause", name);
   asn1Print_Cause (namebuf, &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_ReleaseItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleaseItemIEs_Value                                 */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_ReleaseItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_ReleaseItemIEs_Value *pvalue = (_RAB_ReleaseItemIEs_Value*) pvalue_;
   asn1Print_RAB_ReleaseItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element_element                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseList_element_element
   (const char* name, RAB_ReleaseList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ReleaseItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_ReleaseItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element                                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseList_element
   (const char* name, RAB_ReleaseList_element* pvalue)
{
   RAB_ReleaseList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleaseList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleaseList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList                                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseList
   (const char* name, RAB_ReleaseList* pvalue)
{
   RAB_ReleaseList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleaseList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleaseList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleaseRequestIEs_Value                              */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_ReleaseRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_ReleaseRequestIEs_Value *pvalue = (_RAB_ReleaseRequestIEs_Value*) pvalue_;
   asn1Print_RAB_ReleaseList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseRequest_protocolIEs_element
   (const char* name, RAB_ReleaseRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_ReleaseRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseRequest_protocolIEs
   (const char* name, RAB_ReleaseRequest_protocolIEs* pvalue)
{
   RAB_ReleaseRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleaseRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleaseRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseRequest_protocolExtensions_element
   (const char* name, RAB_ReleaseRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_ReleaseRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseRequest_protocolExtensions
   (const char* name, RAB_ReleaseRequest_protocolExtensions* pvalue)
{
   RAB_ReleaseRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleaseRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleaseRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest                                        */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseRequest
   (const char* name, RAB_ReleaseRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RAB_ReleaseRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RAB_ReleaseRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__Iu_ReleaseRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _Iu_ReleaseRequestIEs_Value *pvalue = (_Iu_ReleaseRequestIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseRequest_protocolIEs_element
   (const char* name, Iu_ReleaseRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Iu_ReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      Iu_ReleaseRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseRequest_protocolIEs
   (const char* name, Iu_ReleaseRequest_protocolIEs* pvalue)
{
   Iu_ReleaseRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Iu_ReleaseRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Iu_ReleaseRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseRequest_protocolExtensions_element
   (const char* name, Iu_ReleaseRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < Iu_ReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      Iu_ReleaseRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseRequest_protocolExtensions
   (const char* name, Iu_ReleaseRequest_protocolExtensions* pvalue)
{
   Iu_ReleaseRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Iu_ReleaseRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Iu_ReleaseRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest                                         */
/*                                                            */
/**************************************************************/

void asn1Print_Iu_ReleaseRequest
   (const char* name, Iu_ReleaseRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_Iu_ReleaseRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_Iu_ReleaseRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationDetect_protocolIEs_element
   (const char* name, RelocationDetect_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationDetectIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationDetectIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationDetectIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationDetectIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs                              */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationDetect_protocolIEs
   (const char* name, RelocationDetect_protocolIEs* pvalue)
{
   RelocationDetect_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationDetect_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationDetect_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationDetect_protocolExtensions_element
   (const char* name, RelocationDetect_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationDetectExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationDetectExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationDetectExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationDetectExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions                       */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationDetect_protocolExtensions
   (const char* name, RelocationDetect_protocolExtensions* pvalue)
{
   RelocationDetect_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationDetect_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationDetect_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect                                          */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationDetect
   (const char* name, RelocationDetect* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationDetect_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationDetect_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationComplete_protocolIEs_element
   (const char* name, RelocationComplete_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCompleteIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RelocationCompleteIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs                            */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationComplete_protocolIEs
   (const char* name, RelocationComplete_protocolIEs* pvalue)
{
   RelocationComplete_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationComplete_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationComplete_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationComplete_protocolExtensions_element
   (const char* name, RelocationComplete_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RelocationCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCompleteExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RelocationCompleteExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationComplete_protocolExtensions
   (const char* name, RelocationComplete_protocolExtensions* pvalue)
{
   RelocationComplete_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RelocationComplete_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RelocationComplete_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete                                        */
/*                                                            */
/**************************************************************/

void asn1Print_RelocationComplete
   (const char* name, RelocationComplete* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RelocationComplete_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RelocationComplete_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value                                          */
/*                                                            */
/**************************************************************/

void asn1Print__PagingIEs_Value
   (const char* name, void* pvalue_)
{
   _PagingIEs_Value *pvalue = (_PagingIEs_Value*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_1                                        */
/*                                                            */
/**************************************************************/

void asn1Print__PagingIEs_Value_1
   (const char* name, void* pvalue_)
{
   _PagingIEs_Value_1 *pvalue = (_PagingIEs_Value_1*) pvalue_;
   asn1Print_PermanentNAS_UE_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_2                                        */
/*                                                            */
/**************************************************************/

void asn1Print__PagingIEs_Value_2
   (const char* name, void* pvalue_)
{
   _PagingIEs_Value_2 *pvalue = (_PagingIEs_Value_2*) pvalue_;
   asn1Print_TemporaryUE_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_3                                        */
/*                                                            */
/**************************************************************/

void asn1Print__PagingIEs_Value_3
   (const char* name, void* pvalue_)
{
   _PagingIEs_Value_3 *pvalue = (_PagingIEs_Value_3*) pvalue_;
   asn1Print_PagingAreaID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_4                                        */
/*                                                            */
/**************************************************************/

void asn1Print__PagingIEs_Value_4
   (const char* name, void* pvalue_)
{
   _PagingIEs_Value_4 *pvalue = (_PagingIEs_Value_4*) pvalue_;
   asn1Print_PagingCause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_5                                        */
/*                                                            */
/**************************************************************/

void asn1Print__PagingIEs_Value_5
   (const char* name, void* pvalue_)
{
   _PagingIEs_Value_5 *pvalue = (_PagingIEs_Value_5*) pvalue_;
   asn1Print_NonSearchingIndication (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_6                                        */
/*                                                            */
/**************************************************************/

void asn1Print__PagingIEs_Value_6
   (const char* name, void* pvalue_)
{
   _PagingIEs_Value_6 *pvalue = (_PagingIEs_Value_6*) pvalue_;
   asn1Print_DRX_CycleLengthCoefficient (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs_element                                */
/*                                                            */
/**************************************************************/

void asn1Print_Paging_protocolIEs_element
   (const char* name, Paging_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < PagingIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PagingIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PagingIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      PagingIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs                                        */
/*                                                            */
/**************************************************************/

void asn1Print_Paging_protocolIEs
   (const char* name, Paging_protocolIEs* pvalue)
{
   Paging_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Paging_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Paging_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _PagingExtensions_Extension                               */
/*                                                            */
/**************************************************************/

void asn1Print__PagingExtensions_Extension
   (const char* name, void* pvalue_)
{
   _PagingExtensions_Extension *pvalue = (_PagingExtensions_Extension*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions_element                         */
/*                                                            */
/**************************************************************/

void asn1Print_Paging_protocolExtensions_element
   (const char* name, Paging_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < PagingExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PagingExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == PagingExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      PagingExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions                                 */
/*                                                            */
/**************************************************************/

void asn1Print_Paging_protocolExtensions
   (const char* name, Paging_protocolExtensions* pvalue)
{
   Paging_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Paging_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Paging_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Paging                                                    */
/*                                                            */
/**************************************************************/

void asn1Print_Paging
   (const char* name, Paging* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_Paging_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_Paging_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _CommonID_IEs_Value                                       */
/*                                                            */
/**************************************************************/

void asn1Print__CommonID_IEs_Value
   (const char* name, void* pvalue_)
{
   _CommonID_IEs_Value *pvalue = (_CommonID_IEs_Value*) pvalue_;
   asn1Print_PermanentNAS_UE_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

void asn1Print_CommonID_protocolIEs_element
   (const char* name, CommonID_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CommonID_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CommonID_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == CommonID_IEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      CommonID_IEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs                                      */
/*                                                            */
/**************************************************************/

void asn1Print_CommonID_protocolIEs
   (const char* name, CommonID_protocolIEs* pvalue)
{
   CommonID_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CommonID_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CommonID_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension                             */
/*                                                            */
/**************************************************************/

void asn1Print__CommonIDExtensions_Extension
   (const char* name, void* pvalue_)
{
   _CommonIDExtensions_Extension *pvalue = (_CommonIDExtensions_Extension*) pvalue_;
   asn1Print_SNA_Access_Information (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension_1                           */
/*                                                            */
/**************************************************************/

void asn1Print__CommonIDExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _CommonIDExtensions_Extension_1 *pvalue = (_CommonIDExtensions_Extension_1*) pvalue_;
   asn1Print_UESBI_Iu (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension_2                           */
/*                                                            */
/**************************************************************/

void asn1Print__CommonIDExtensions_Extension_2
   (const char* name, void* pvalue_)
{
   _CommonIDExtensions_Extension_2 *pvalue = (_CommonIDExtensions_Extension_2*) pvalue_;
   asn1Print_PLMNidentity (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

void asn1Print_CommonID_protocolExtensions_element
   (const char* name, CommonID_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CommonIDExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CommonIDExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CommonIDExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CommonIDExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions                               */
/*                                                            */
/**************************************************************/

void asn1Print_CommonID_protocolExtensions
   (const char* name, CommonID_protocolExtensions* pvalue)
{
   CommonID_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CommonID_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CommonID_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CommonID                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_CommonID
   (const char* name, CommonID* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_CommonID_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_CommonID_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value                                  */
/*                                                            */
/**************************************************************/

void asn1Print__CN_InvokeTraceIEs_Value
   (const char* name, void* pvalue_)
{
   _CN_InvokeTraceIEs_Value *pvalue = (_CN_InvokeTraceIEs_Value*) pvalue_;
   asn1Print_TraceType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_1                                */
/*                                                            */
/**************************************************************/

void asn1Print__CN_InvokeTraceIEs_Value_1
   (const char* name, void* pvalue_)
{
   _CN_InvokeTraceIEs_Value_1 *pvalue = (_CN_InvokeTraceIEs_Value_1*) pvalue_;
   asn1Print_TraceReference (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_2                                */
/*                                                            */
/**************************************************************/

void asn1Print__CN_InvokeTraceIEs_Value_2
   (const char* name, void* pvalue_)
{
   _CN_InvokeTraceIEs_Value_2 *pvalue = (_CN_InvokeTraceIEs_Value_2*) pvalue_;
   asn1Print_TriggerID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_3                                */
/*                                                            */
/**************************************************************/

void asn1Print__CN_InvokeTraceIEs_Value_3
   (const char* name, void* pvalue_)
{
   _CN_InvokeTraceIEs_Value_3 *pvalue = (_CN_InvokeTraceIEs_Value_3*) pvalue_;
   asn1Print_UE_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_4                                */
/*                                                            */
/**************************************************************/

void asn1Print__CN_InvokeTraceIEs_Value_4
   (const char* name, void* pvalue_)
{
   _CN_InvokeTraceIEs_Value_4 *pvalue = (_CN_InvokeTraceIEs_Value_4*) pvalue_;
   asn1Print_OMC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_CN_InvokeTrace_protocolIEs_element
   (const char* name, CN_InvokeTrace_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CN_InvokeTraceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_InvokeTraceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CN_InvokeTraceIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      CN_InvokeTraceIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs                                */
/*                                                            */
/**************************************************************/

void asn1Print_CN_InvokeTrace_protocolIEs
   (const char* name, CN_InvokeTrace_protocolIEs* pvalue)
{
   CN_InvokeTrace_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CN_InvokeTrace_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CN_InvokeTrace_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceExtensions_Extension                       */
/*                                                            */
/**************************************************************/

void asn1Print__CN_InvokeTraceExtensions_Extension
   (const char* name, void* pvalue_)
{
   _CN_InvokeTraceExtensions_Extension *pvalue = (_CN_InvokeTraceExtensions_Extension*) pvalue_;
   asn1Print_TracePropagationParameters (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_CN_InvokeTrace_protocolExtensions_element
   (const char* name, CN_InvokeTrace_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CN_InvokeTraceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_InvokeTraceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CN_InvokeTraceExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CN_InvokeTraceExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions                         */
/*                                                            */
/**************************************************************/

void asn1Print_CN_InvokeTrace_protocolExtensions
   (const char* name, CN_InvokeTrace_protocolExtensions* pvalue)
{
   CN_InvokeTrace_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CN_InvokeTrace_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CN_InvokeTrace_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace                                            */
/*                                                            */
/**************************************************************/

void asn1Print_CN_InvokeTrace
   (const char* name, CN_InvokeTrace* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_CN_InvokeTrace_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_CN_InvokeTrace_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _CN_DeactivateTraceIEs_Value                              */
/*                                                            */
/**************************************************************/

void asn1Print__CN_DeactivateTraceIEs_Value
   (const char* name, void* pvalue_)
{
   _CN_DeactivateTraceIEs_Value *pvalue = (_CN_DeactivateTraceIEs_Value*) pvalue_;
   asn1Print_TraceReference (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _CN_DeactivateTraceIEs_Value_1                            */
/*                                                            */
/**************************************************************/

void asn1Print__CN_DeactivateTraceIEs_Value_1
   (const char* name, void* pvalue_)
{
   _CN_DeactivateTraceIEs_Value_1 *pvalue = (_CN_DeactivateTraceIEs_Value_1*) pvalue_;
   asn1Print_TriggerID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_CN_DeactivateTrace_protocolIEs_element
   (const char* name, CN_DeactivateTrace_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CN_DeactivateTraceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_DeactivateTraceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CN_DeactivateTraceIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      CN_DeactivateTraceIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs                            */
/*                                                            */
/**************************************************************/

void asn1Print_CN_DeactivateTrace_protocolIEs
   (const char* name, CN_DeactivateTrace_protocolIEs* pvalue)
{
   CN_DeactivateTrace_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CN_DeactivateTrace_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CN_DeactivateTrace_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_CN_DeactivateTrace_protocolExtensions_element
   (const char* name, CN_DeactivateTrace_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < CN_DeactivateTraceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_DeactivateTraceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CN_DeactivateTraceExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      CN_DeactivateTraceExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_CN_DeactivateTrace_protocolExtensions
   (const char* name, CN_DeactivateTrace_protocolExtensions* pvalue)
{
   CN_DeactivateTrace_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (CN_DeactivateTrace_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_CN_DeactivateTrace_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace                                        */
/*                                                            */
/**************************************************************/

void asn1Print_CN_DeactivateTrace
   (const char* name, CN_DeactivateTrace* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_CN_DeactivateTrace_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_CN_DeactivateTrace_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlIEs_Value                        */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportingControlIEs_Value
   (const char* name, void* pvalue_)
{
   _LocationReportingControlIEs_Value *pvalue = (_LocationReportingControlIEs_Value*) pvalue_;
   asn1Print_RequestType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs_element              */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReportingControl_protocolIEs_element
   (const char* name, LocationReportingControl_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationReportingControlIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportingControlIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportingControlIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      LocationReportingControlIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs                      */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReportingControl_protocolIEs
   (const char* name, LocationReportingControl_protocolIEs* pvalue)
{
   LocationReportingControl_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationReportingControl_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationReportingControl_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension             */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportingControlExtensions_Extension
   (const char* name, void* pvalue_)
{
   _LocationReportingControlExtensions_Extension *pvalue = (_LocationReportingControlExtensions_Extension*) pvalue_;
   asn1Print_VerticalAccuracyCode (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_1           */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportingControlExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _LocationReportingControlExtensions_Extension_1 *pvalue = (_LocationReportingControlExtensions_Extension_1*) pvalue_;
   asn1Print_ResponseTime (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_2           */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportingControlExtensions_Extension_2
   (const char* name, void* pvalue_)
{
   _LocationReportingControlExtensions_Extension_2 *pvalue = (_LocationReportingControlExtensions_Extension_2*) pvalue_;
   asn1Print_PositioningPriority (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_3           */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportingControlExtensions_Extension_3
   (const char* name, void* pvalue_)
{
   _LocationReportingControlExtensions_Extension_3 *pvalue = (_LocationReportingControlExtensions_Extension_3*) pvalue_;
   asn1Print_ClientType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReportingControl_protocolExtensions_element
   (const char* name, LocationReportingControl_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationReportingControlExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportingControlExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportingControlExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LocationReportingControlExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions               */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReportingControl_protocolExtensions
   (const char* name, LocationReportingControl_protocolExtensions* pvalue)
{
   LocationReportingControl_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationReportingControl_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationReportingControl_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl                                  */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReportingControl
   (const char* name, LocationReportingControl* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_LocationReportingControl_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_LocationReportingControl_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value                                  */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportIEs_Value
   (const char* name, void* pvalue_)
{
   _LocationReportIEs_Value *pvalue = (_LocationReportIEs_Value*) pvalue_;
   asn1Print_AreaIdentity (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value_1                                */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportIEs_Value_1
   (const char* name, void* pvalue_)
{
   _LocationReportIEs_Value_1 *pvalue = (_LocationReportIEs_Value_1*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value_2                                */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportIEs_Value_2
   (const char* name, void* pvalue_)
{
   _LocationReportIEs_Value_2 *pvalue = (_LocationReportIEs_Value_2*) pvalue_;
   asn1Print_RequestType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReport_protocolIEs_element
   (const char* name, LocationReport_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationReportIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      LocationReportIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs                                */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReport_protocolIEs
   (const char* name, LocationReport_protocolIEs* pvalue)
{
   LocationReport_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationReport_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationReport_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension                       */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportExtensions_Extension
   (const char* name, void* pvalue_)
{
   _LocationReportExtensions_Extension *pvalue = (_LocationReportExtensions_Extension*) pvalue_;
   asn1Print_LastKnownServiceArea (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_1                     */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _LocationReportExtensions_Extension_1 *pvalue = (_LocationReportExtensions_Extension_1*) pvalue_;
   asn1Print_PositionData (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_2                     */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportExtensions_Extension_2
   (const char* name, void* pvalue_)
{
   _LocationReportExtensions_Extension_2 *pvalue = (_LocationReportExtensions_Extension_2*) pvalue_;
   asn1Print_PositionDataSpecificToGERANIuMode (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_3                     */
/*                                                            */
/**************************************************************/

void asn1Print__LocationReportExtensions_Extension_3
   (const char* name, void* pvalue_)
{
   _LocationReportExtensions_Extension_3 *pvalue = (_LocationReportExtensions_Extension_3*) pvalue_;
   asn1Print_AccuracyFulfilmentIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReport_protocolExtensions_element
   (const char* name, LocationReport_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationReportExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LocationReportExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions                         */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReport_protocolExtensions
   (const char* name, LocationReport_protocolExtensions* pvalue)
{
   LocationReport_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationReport_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationReport_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LocationReport                                            */
/*                                                            */
/**************************************************************/

void asn1Print_LocationReport
   (const char* name, LocationReport* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_LocationReport_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_LocationReport_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageIEs_Value
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageIEs_Value *pvalue = (_InitialUE_MessageIEs_Value*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_1                             */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageIEs_Value_1
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageIEs_Value_1 *pvalue = (_InitialUE_MessageIEs_Value_1*) pvalue_;
   asn1Print_LAI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_2                             */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageIEs_Value_2
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageIEs_Value_2 *pvalue = (_InitialUE_MessageIEs_Value_2*) pvalue_;
   asn1Print_RAC (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_3                             */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageIEs_Value_3
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageIEs_Value_3 *pvalue = (_InitialUE_MessageIEs_Value_3*) pvalue_;
   asn1Print_SAI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_4                             */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageIEs_Value_4
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageIEs_Value_4 *pvalue = (_InitialUE_MessageIEs_Value_4*) pvalue_;
   asn1Print_NAS_PDU (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_5                             */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageIEs_Value_5
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageIEs_Value_5 *pvalue = (_InitialUE_MessageIEs_Value_5*) pvalue_;
   asn1Print_IuSignallingConnectionIdentifier (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_6                             */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageIEs_Value_6
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageIEs_Value_6 *pvalue = (_InitialUE_MessageIEs_Value_6*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_InitialUE_Message_protocolIEs_element
   (const char* name, InitialUE_Message_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InitialUE_MessageIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InitialUE_MessageIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InitialUE_MessageIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      InitialUE_MessageIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs                             */
/*                                                            */
/**************************************************************/

void asn1Print_InitialUE_Message_protocolIEs
   (const char* name, InitialUE_Message_protocolIEs* pvalue)
{
   InitialUE_Message_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InitialUE_Message_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InitialUE_Message_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension                    */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageExtensions_Extension
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageExtensions_Extension *pvalue = (_InitialUE_MessageExtensions_Extension*) pvalue_;
   asn1Print_GERAN_Classmark (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageExtensions_Extension_1 *pvalue = (_InitialUE_MessageExtensions_Extension_1*) pvalue_;
   asn1Print_PLMNidentity (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_2                  */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageExtensions_Extension_2
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageExtensions_Extension_2 *pvalue = (_InitialUE_MessageExtensions_Extension_2*) pvalue_;
   asn1Print_PermanentNAS_UE_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_3                  */
/*                                                            */
/**************************************************************/

void asn1Print__InitialUE_MessageExtensions_Extension_3
   (const char* name, void* pvalue_)
{
   _InitialUE_MessageExtensions_Extension_3 *pvalue = (_InitialUE_MessageExtensions_Extension_3*) pvalue_;
   asn1Print_NAS_SequenceNumber (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_InitialUE_Message_protocolExtensions_element
   (const char* name, InitialUE_Message_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InitialUE_MessageExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InitialUE_MessageExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InitialUE_MessageExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      InitialUE_MessageExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_InitialUE_Message_protocolExtensions
   (const char* name, InitialUE_Message_protocolExtensions* pvalue)
{
   InitialUE_Message_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InitialUE_Message_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InitialUE_Message_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message                                         */
/*                                                            */
/**************************************************************/

void asn1Print_InitialUE_Message
   (const char* name, InitialUE_Message* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_InitialUE_Message_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_InitialUE_Message_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value                                  */
/*                                                            */
/**************************************************************/

void asn1Print__DirectTransferIEs_Value
   (const char* name, void* pvalue_)
{
   _DirectTransferIEs_Value *pvalue = (_DirectTransferIEs_Value*) pvalue_;
   asn1Print_NAS_PDU (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_1                                */
/*                                                            */
/**************************************************************/

void asn1Print__DirectTransferIEs_Value_1
   (const char* name, void* pvalue_)
{
   _DirectTransferIEs_Value_1 *pvalue = (_DirectTransferIEs_Value_1*) pvalue_;
   asn1Print_LAI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_2                                */
/*                                                            */
/**************************************************************/

void asn1Print__DirectTransferIEs_Value_2
   (const char* name, void* pvalue_)
{
   _DirectTransferIEs_Value_2 *pvalue = (_DirectTransferIEs_Value_2*) pvalue_;
   asn1Print_RAC (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_3                                */
/*                                                            */
/**************************************************************/

void asn1Print__DirectTransferIEs_Value_3
   (const char* name, void* pvalue_)
{
   _DirectTransferIEs_Value_3 *pvalue = (_DirectTransferIEs_Value_3*) pvalue_;
   asn1Print_SAI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_4                                */
/*                                                            */
/**************************************************************/

void asn1Print__DirectTransferIEs_Value_4
   (const char* name, void* pvalue_)
{
   _DirectTransferIEs_Value_4 *pvalue = (_DirectTransferIEs_Value_4*) pvalue_;
   asn1Print_SAPI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransfer_protocolIEs_element
   (const char* name, DirectTransfer_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DirectTransferIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      DirectTransferIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs                                */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransfer_protocolIEs
   (const char* name, DirectTransfer_protocolIEs* pvalue)
{
   DirectTransfer_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DirectTransfer_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DirectTransfer_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value                          */
/*                                                            */
/**************************************************************/

void asn1Print__RedirectionIndication_IEs_Value
   (const char* name, void* pvalue_)
{
   _RedirectionIndication_IEs_Value *pvalue = (_RedirectionIndication_IEs_Value*) pvalue_;
   asn1Print_NAS_PDU (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_1                        */
/*                                                            */
/**************************************************************/

void asn1Print__RedirectionIndication_IEs_Value_1
   (const char* name, void* pvalue_)
{
   _RedirectionIndication_IEs_Value_1 *pvalue = (_RedirectionIndication_IEs_Value_1*) pvalue_;
   asn1Print_RejectCauseValue (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_2                        */
/*                                                            */
/**************************************************************/

void asn1Print__RedirectionIndication_IEs_Value_2
   (const char* name, void* pvalue_)
{
   _RedirectionIndication_IEs_Value_2 *pvalue = (_RedirectionIndication_IEs_Value_2*) pvalue_;
   asn1Print_NAS_SequenceNumber (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_3                        */
/*                                                            */
/**************************************************************/

void asn1Print__RedirectionIndication_IEs_Value_3
   (const char* name, void* pvalue_)
{
   _RedirectionIndication_IEs_Value_3 *pvalue = (_RedirectionIndication_IEs_Value_3*) pvalue_;
   asn1Print_PermanentNAS_UE_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication_element                             */
/*                                                            */
/**************************************************************/

void asn1Print_RedirectionIndication_element
   (const char* name, RedirectionIndication_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RedirectionIndication_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RedirectionIndication_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RedirectionIndication_IEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RedirectionIndication_IEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication                                     */
/*                                                            */
/**************************************************************/

void asn1Print_RedirectionIndication
   (const char* name, RedirectionIndication* pvalue)
{
   RedirectionIndication_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RedirectionIndication_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RedirectionIndication_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferExtensions_Extension                       */
/*                                                            */
/**************************************************************/

void asn1Print__DirectTransferExtensions_Extension
   (const char* name, void* pvalue_)
{
   _DirectTransferExtensions_Extension *pvalue = (_DirectTransferExtensions_Extension*) pvalue_;
   asn1Print_RedirectionIndication (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferExtensions_Extension_1                     */
/*                                                            */
/**************************************************************/

void asn1Print__DirectTransferExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _DirectTransferExtensions_Extension_1 *pvalue = (_DirectTransferExtensions_Extension_1*) pvalue_;
   asn1Print_RedirectionCompleted (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransfer_protocolExtensions_element
   (const char* name, DirectTransfer_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DirectTransferExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      DirectTransferExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions                         */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransfer_protocolExtensions
   (const char* name, DirectTransfer_protocolExtensions* pvalue)
{
   DirectTransfer_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DirectTransfer_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DirectTransfer_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer                                            */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransfer
   (const char* name, DirectTransfer* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_DirectTransfer_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_DirectTransfer_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _OverloadIEs_Value                                        */
/*                                                            */
/**************************************************************/

void asn1Print__OverloadIEs_Value
   (const char* name, void* pvalue_)
{
   _OverloadIEs_Value *pvalue = (_OverloadIEs_Value*) pvalue_;
   asn1Print_NumberOfSteps (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _OverloadIEs_Value_1                                      */
/*                                                            */
/**************************************************************/

void asn1Print__OverloadIEs_Value_1
   (const char* name, void* pvalue_)
{
   _OverloadIEs_Value_1 *pvalue = (_OverloadIEs_Value_1*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

void asn1Print_Overload_protocolIEs_element
   (const char* name, Overload_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < OverloadIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &OverloadIEs[index].id) == 0) {
         break;
      }
   }
   if(index == OverloadIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      OverloadIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs                                      */
/*                                                            */
/**************************************************************/

void asn1Print_Overload_protocolIEs
   (const char* name, Overload_protocolIEs* pvalue)
{
   Overload_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Overload_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Overload_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _OverloadExtensions_Extension                             */
/*                                                            */
/**************************************************************/

void asn1Print__OverloadExtensions_Extension
   (const char* name, void* pvalue_)
{
   _OverloadExtensions_Extension *pvalue = (_OverloadExtensions_Extension*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _OverloadExtensions_Extension_1                           */
/*                                                            */
/**************************************************************/

void asn1Print__OverloadExtensions_Extension_1
   (const char* name, void* pvalue_)
{
   _OverloadExtensions_Extension_1 *pvalue = (_OverloadExtensions_Extension_1*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

void asn1Print_Overload_protocolExtensions_element
   (const char* name, Overload_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < OverloadExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &OverloadExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == OverloadExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      OverloadExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions                               */
/*                                                            */
/**************************************************************/

void asn1Print_Overload_protocolExtensions
   (const char* name, Overload_protocolExtensions* pvalue)
{
   Overload_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (Overload_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_Overload_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  Overload                                                  */
/*                                                            */
/**************************************************************/

void asn1Print_Overload
   (const char* name, Overload* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_Overload_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_Overload_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value                                 */
/*                                                            */
/**************************************************************/

void asn1Print__ErrorIndicationIEs_Value
   (const char* name, void* pvalue_)
{
   _ErrorIndicationIEs_Value *pvalue = (_ErrorIndicationIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_1                               */
/*                                                            */
/**************************************************************/

void asn1Print__ErrorIndicationIEs_Value_1
   (const char* name, void* pvalue_)
{
   _ErrorIndicationIEs_Value_1 *pvalue = (_ErrorIndicationIEs_Value_1*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_2                               */
/*                                                            */
/**************************************************************/

void asn1Print__ErrorIndicationIEs_Value_2
   (const char* name, void* pvalue_)
{
   _ErrorIndicationIEs_Value_2 *pvalue = (_ErrorIndicationIEs_Value_2*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_3                               */
/*                                                            */
/**************************************************************/

void asn1Print__ErrorIndicationIEs_Value_3
   (const char* name, void* pvalue_)
{
   _ErrorIndicationIEs_Value_3 *pvalue = (_ErrorIndicationIEs_Value_3*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

void asn1Print_ErrorIndication_protocolIEs_element
   (const char* name, ErrorIndication_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ErrorIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ErrorIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ErrorIndicationIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      ErrorIndicationIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs                               */
/*                                                            */
/**************************************************************/

void asn1Print_ErrorIndication_protocolIEs
   (const char* name, ErrorIndication_protocolIEs* pvalue)
{
   ErrorIndication_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ErrorIndication_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ErrorIndication_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationExtensions_Extension                      */
/*                                                            */
/**************************************************************/

void asn1Print__ErrorIndicationExtensions_Extension
   (const char* name, void* pvalue_)
{
   _ErrorIndicationExtensions_Extension *pvalue = (_ErrorIndicationExtensions_Extension*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

void asn1Print_ErrorIndication_protocolExtensions_element
   (const char* name, ErrorIndication_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ErrorIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ErrorIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ErrorIndicationExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ErrorIndicationExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions                        */
/*                                                            */
/**************************************************************/

void asn1Print_ErrorIndication_protocolExtensions
   (const char* name, ErrorIndication_protocolExtensions* pvalue)
{
   ErrorIndication_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ErrorIndication_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ErrorIndication_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication                                           */
/*                                                            */
/**************************************************************/

void asn1Print_ErrorIndication
   (const char* name, ErrorIndication* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_ErrorIndication_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_ErrorIndication_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _SRNS_DataForwardCommandIEs_Value                         */
/*                                                            */
/**************************************************************/

void asn1Print__SRNS_DataForwardCommandIEs_Value
   (const char* name, void* pvalue_)
{
   _SRNS_DataForwardCommandIEs_Value *pvalue = (_SRNS_DataForwardCommandIEs_Value*) pvalue_;
   asn1Print_RAB_DataForwardingList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs_element               */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_DataForwardCommand_protocolIEs_element
   (const char* name, SRNS_DataForwardCommand_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SRNS_DataForwardCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_DataForwardCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_DataForwardCommandIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      SRNS_DataForwardCommandIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs                       */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_DataForwardCommand_protocolIEs
   (const char* name, SRNS_DataForwardCommand_protocolIEs* pvalue)
{
   SRNS_DataForwardCommand_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SRNS_DataForwardCommand_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SRNS_DataForwardCommand_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_DataForwardCommand_protocolExtensions_element
   (const char* name, SRNS_DataForwardCommand_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < SRNS_DataForwardCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_DataForwardCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_DataForwardCommandExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      SRNS_DataForwardCommandExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions                */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_DataForwardCommand_protocolExtensions
   (const char* name, SRNS_DataForwardCommand_protocolExtensions* pvalue)
{
   SRNS_DataForwardCommand_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (SRNS_DataForwardCommand_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_SRNS_DataForwardCommand_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand                                   */
/*                                                            */
/**************************************************************/

void asn1Print_SRNS_DataForwardCommand
   (const char* name, SRNS_DataForwardCommand* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_SRNS_DataForwardCommand_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_SRNS_DataForwardCommand_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _ForwardSRNS_ContextIEs_Value                             */
/*                                                            */
/**************************************************************/

void asn1Print__ForwardSRNS_ContextIEs_Value
   (const char* name, void* pvalue_)
{
   _ForwardSRNS_ContextIEs_Value *pvalue = (_ForwardSRNS_ContextIEs_Value*) pvalue_;
   asn1Print_RAB_ContextList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_ForwardSRNS_Context_protocolIEs_element
   (const char* name, ForwardSRNS_Context_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ForwardSRNS_ContextIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ForwardSRNS_ContextIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ForwardSRNS_ContextIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      ForwardSRNS_ContextIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs                           */
/*                                                            */
/**************************************************************/

void asn1Print_ForwardSRNS_Context_protocolIEs
   (const char* name, ForwardSRNS_Context_protocolIEs* pvalue)
{
   ForwardSRNS_Context_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ForwardSRNS_Context_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ForwardSRNS_Context_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _ForwardSRNS_ContextExtensions_Extension                  */
/*                                                            */
/**************************************************************/

void asn1Print__ForwardSRNS_ContextExtensions_Extension
   (const char* name, void* pvalue_)
{
   _ForwardSRNS_ContextExtensions_Extension *pvalue = (_ForwardSRNS_ContextExtensions_Extension*) pvalue_;
   asn1Print_RRC_Container (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

void asn1Print_ForwardSRNS_Context_protocolExtensions_element
   (const char* name, ForwardSRNS_Context_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ForwardSRNS_ContextExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ForwardSRNS_ContextExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ForwardSRNS_ContextExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ForwardSRNS_ContextExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions                    */
/*                                                            */
/**************************************************************/

void asn1Print_ForwardSRNS_Context_protocolExtensions
   (const char* name, ForwardSRNS_Context_protocolExtensions* pvalue)
{
   ForwardSRNS_Context_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ForwardSRNS_Context_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ForwardSRNS_Context_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context                                       */
/*                                                            */
/**************************************************************/

void asn1Print_ForwardSRNS_Context
   (const char* name, ForwardSRNS_Context* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_ForwardSRNS_Context_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_ForwardSRNS_Context_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

void asn1Print_TransportLayerInformation_iE_Extensions_element
   (const char* name, TransportLayerInformation_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < TransportLayerInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TransportLayerInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TransportLayerInformation_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      TransportLayerInformation_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions                   */
/*                                                            */
/**************************************************************/

void asn1Print_TransportLayerInformation_iE_Extensions
   (const char* name, TransportLayerInformation_iE_Extensions* pvalue)
{
   TransportLayerInformation_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (TransportLayerInformation_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_TransportLayerInformation_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation                                 */
/*                                                            */
/**************************************************************/

void asn1Print_TransportLayerInformation
   (const char* name, TransportLayerInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.transportLayerAddress", name);
   asn1Print_TransportLayerAddress (namebuf, &pvalue->transportLayerAddress);

   sprintf (namebuf, "%s.iuTransportAssociation", name);
   asn1Print_IuTransportAssociation (namebuf, &pvalue->iuTransportAssociation);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_TransportLayerInformation_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyItemFirst_iE_Extensions_element
   (const char* name, RAB_SetupOrModifyItemFirst_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItemFirst_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItemFirst_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItemFirst_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_SetupOrModifyItemFirst_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions                  */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyItemFirst_iE_Extensions
   (const char* name, RAB_SetupOrModifyItemFirst_iE_Extensions* pvalue)
{
   RAB_SetupOrModifyItemFirst_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupOrModifyItemFirst_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupOrModifyItemFirst_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst                                */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyItemFirst
   (const char* name, RAB_SetupOrModifyItemFirst* pvalue)
{
   char namebuf[512];

   printf ("%s.m.nAS_SynchronisationIndicatorPresent = %d\n", name, (int)pvalue->m.nAS_SynchronisationIndicatorPresent);
   printf ("%s.m.rAB_ParametersPresent = %d\n", name, (int)pvalue->m.rAB_ParametersPresent);
   printf ("%s.m.userPlaneInformationPresent = %d\n", name, (int)pvalue->m.userPlaneInformationPresent);
   printf ("%s.m.transportLayerInformationPresent = %d\n", name, (int)pvalue->m.transportLayerInformationPresent);
   printf ("%s.m.service_HandoverPresent = %d\n", name, (int)pvalue->m.service_HandoverPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      sprintf (namebuf, "%s.nAS_SynchronisationIndicator", name);
      asn1Print_NAS_SynchronisationIndicator (namebuf, &pvalue->nAS_SynchronisationIndicator);
   }

   if (pvalue->m.rAB_ParametersPresent) {
      sprintf (namebuf, "%s.rAB_Parameters", name);
      asn1Print_RAB_Parameters (namebuf, &pvalue->rAB_Parameters);
   }

   if (pvalue->m.userPlaneInformationPresent) {
      sprintf (namebuf, "%s.userPlaneInformation", name);
      asn1Print_UserPlaneInformation (namebuf, &pvalue->userPlaneInformation);
   }

   if (pvalue->m.transportLayerInformationPresent) {
      sprintf (namebuf, "%s.transportLayerInformation", name);
      asn1Print_TransportLayerInformation (namebuf, &pvalue->transportLayerInformation);
   }

   if (pvalue->m.service_HandoverPresent) {
      sprintf (namebuf, "%s.service_Handover", name);
      asn1Print_Service_Handover (namebuf, &pvalue->service_Handover);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_SetupOrModifyItemFirst_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItem_IEs_FirstValue                     */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupOrModifyItem_IEs_FirstValue
   (const char* name, void* pvalue_)
{
   _RAB_SetupOrModifyItem_IEs_FirstValue *pvalue = (_RAB_SetupOrModifyItem_IEs_FirstValue*) pvalue_;
   asn1Print_RAB_SetupOrModifyItemFirst (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItemSecond_ExtIEs_Extension             */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupOrModifyItemSecond_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _RAB_SetupOrModifyItemSecond_ExtIEs_Extension *pvalue = (_RAB_SetupOrModifyItemSecond_ExtIEs_Extension*) pvalue_;
   asn1Print_Alt_RAB_Parameters (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1           */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1
   (const char* name, void* pvalue_)
{
   _RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1 *pvalue = (_RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1*) pvalue_;
   asn1Print_GERAN_BSC_Container (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyItemSecond_iE_Extensions_element
   (const char* name, RAB_SetupOrModifyItemSecond_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItemSecond_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItemSecond_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItemSecond_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_SetupOrModifyItemSecond_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyItemSecond_iE_Extensions
   (const char* name, RAB_SetupOrModifyItemSecond_iE_Extensions* pvalue)
{
   RAB_SetupOrModifyItemSecond_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupOrModifyItemSecond_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupOrModifyItemSecond_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond                               */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyItemSecond
   (const char* name, RAB_SetupOrModifyItemSecond* pvalue)
{
   char namebuf[512];

   printf ("%s.m.pDP_TypeInformationPresent = %d\n", name, (int)pvalue->m.pDP_TypeInformationPresent);
   printf ("%s.m.dataVolumeReportingIndicationPresent = %d\n", name, (int)pvalue->m.dataVolumeReportingIndicationPresent);
   printf ("%s.m.dl_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.ul_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.dl_N_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   printf ("%s.m.ul_N_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   if (pvalue->m.pDP_TypeInformationPresent) {
      sprintf (namebuf, "%s.pDP_TypeInformation", name);
      asn1Print_PDP_TypeInformation (namebuf, &pvalue->pDP_TypeInformation);
   }

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      sprintf (namebuf, "%s.dataVolumeReportingIndication", name);
      asn1Print_DataVolumeReportingIndication (namebuf, &pvalue->dataVolumeReportingIndication);
   }

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.dl_GTP_PDU_SequenceNumber", name);
      asn1Print_DL_GTP_PDU_SequenceNumber (namebuf, &pvalue->dl_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.ul_GTP_PDU_SequenceNumber", name);
      asn1Print_UL_GTP_PDU_SequenceNumber (namebuf, &pvalue->ul_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.dl_N_PDU_SequenceNumber", name);
      asn1Print_DL_N_PDU_SequenceNumber (namebuf, &pvalue->dl_N_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.ul_N_PDU_SequenceNumber", name);
      asn1Print_UL_N_PDU_SequenceNumber (namebuf, &pvalue->ul_N_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_SetupOrModifyItemSecond_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItem_IEs_SecondValue                    */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupOrModifyItem_IEs_SecondValue
   (const char* name, void* pvalue_)
{
   _RAB_SetupOrModifyItem_IEs_SecondValue *pvalue = (_RAB_SetupOrModifyItem_IEs_SecondValue*) pvalue_;
   asn1Print_RAB_SetupOrModifyItemSecond (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyList_element_element
   (const char* name, RAB_SetupOrModifyList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItem_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItem_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItem_IEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.firstCriticality", name);
   asn1Print_Criticality (namebuf, &pvalue->firstCriticality);

   sprintf (namebuf, "%s.firstValue", name);
   if (index != -1){
      RAB_SetupOrModifyItem_IEs[index].printFirstValue(namebuf, pvalue->firstValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->firstValue.encoded.numocts,
         pvalue->firstValue.encoded.data, ".");
   }

   sprintf (namebuf, "%s.secondCriticality", name);
   asn1Print_Criticality (namebuf, &pvalue->secondCriticality);

   sprintf (namebuf, "%s.secondValue", name);
   if (index != -1){
      RAB_SetupOrModifyItem_IEs[index].printSecondValue(namebuf, pvalue->secondValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->secondValue.encoded.numocts,
         pvalue->secondValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element                             */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyList_element
   (const char* name, RAB_SetupOrModifyList_element* pvalue)
{
   RAB_SetupOrModifyList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupOrModifyList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupOrModifyList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList                                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifyList
   (const char* name, RAB_SetupOrModifyList* pvalue)
{
   RAB_SetupOrModifyList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupOrModifyList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupOrModifyList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentRequestIEs_Value                           */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentRequestIEs_Value *pvalue = (_RAB_AssignmentRequestIEs_Value*) pvalue_;
   asn1Print_RAB_SetupOrModifyList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentRequestIEs_Value_1                         */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentRequestIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentRequestIEs_Value_1 *pvalue = (_RAB_AssignmentRequestIEs_Value_1*) pvalue_;
   asn1Print_RAB_ReleaseList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentRequest_protocolIEs_element
   (const char* name, RAB_AssignmentRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_AssignmentRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_AssignmentRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs                         */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentRequest_protocolIEs
   (const char* name, RAB_AssignmentRequest_protocolIEs* pvalue)
{
   RAB_AssignmentRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_AssignmentRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_AssignmentRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentRequest_protocolExtensions_element
   (const char* name, RAB_AssignmentRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_AssignmentRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_AssignmentRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions                  */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentRequest_protocolExtensions
   (const char* name, RAB_AssignmentRequest_protocolExtensions* pvalue)
{
   RAB_AssignmentRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_AssignmentRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_AssignmentRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest                                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentRequest
   (const char* name, RAB_AssignmentRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RAB_AssignmentRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RAB_AssignmentRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifiedItem_ExtIEs_Extension                 */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupOrModifiedItem_ExtIEs_Extension
   (const char* name, void* pvalue_)
{
   _RAB_SetupOrModifiedItem_ExtIEs_Extension *pvalue = (_RAB_SetupOrModifiedItem_ExtIEs_Extension*) pvalue_;
   asn1Print_Ass_RAB_Parameters (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifiedItem_iE_Extensions_element
   (const char* name, RAB_SetupOrModifiedItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupOrModifiedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifiedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifiedItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_SetupOrModifiedItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifiedItem_iE_Extensions
   (const char* name, RAB_SetupOrModifiedItem_iE_Extensions* pvalue)
{
   RAB_SetupOrModifiedItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupOrModifiedItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupOrModifiedItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem                                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifiedItem
   (const char* name, RAB_SetupOrModifiedItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.transportLayerAddressPresent = %d\n", name, (int)pvalue->m.transportLayerAddressPresent);
   printf ("%s.m.iuTransportAssociationPresent = %d\n", name, (int)pvalue->m.iuTransportAssociationPresent);
   printf ("%s.m.dl_dataVolumesPresent = %d\n", name, (int)pvalue->m.dl_dataVolumesPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.transportLayerAddressPresent) {
      sprintf (namebuf, "%s.transportLayerAddress", name);
      asn1Print_TransportLayerAddress (namebuf, &pvalue->transportLayerAddress);
   }

   if (pvalue->m.iuTransportAssociationPresent) {
      sprintf (namebuf, "%s.iuTransportAssociation", name);
      asn1Print_IuTransportAssociation (namebuf, &pvalue->iuTransportAssociation);
   }

   if (pvalue->m.dl_dataVolumesPresent) {
      sprintf (namebuf, "%s.dl_dataVolumes", name);
      asn1Print_DataVolumeList (namebuf, &pvalue->dl_dataVolumes);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_SetupOrModifiedItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifiedItemIEs_Value                         */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_SetupOrModifiedItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_SetupOrModifiedItemIEs_Value *pvalue = (_RAB_SetupOrModifiedItemIEs_Value*) pvalue_;
   asn1Print_RAB_SetupOrModifiedItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifiedList_element_element
   (const char* name, RAB_SetupOrModifiedList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_SetupOrModifiedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifiedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifiedItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_SetupOrModifiedItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element                           */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifiedList_element
   (const char* name, RAB_SetupOrModifiedList_element* pvalue)
{
   RAB_SetupOrModifiedList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupOrModifiedList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupOrModifiedList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList                                   */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_SetupOrModifiedList
   (const char* name, RAB_SetupOrModifiedList* pvalue)
{
   RAB_SetupOrModifiedList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_SetupOrModifiedList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_SetupOrModifiedList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value                          */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentResponseIEs_Value *pvalue = (_RAB_AssignmentResponseIEs_Value*) pvalue_;
   asn1Print_RAB_SetupOrModifiedList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedItem_iE_Extensions_element
   (const char* name, RAB_ReleasedItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_ReleasedItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedItem_iE_Extensions
   (const char* name, RAB_ReleasedItem_iE_Extensions* pvalue)
{
   RAB_ReleasedItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleasedItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleasedItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem                                          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedItem
   (const char* name, RAB_ReleasedItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.dl_dataVolumesPresent = %d\n", name, (int)pvalue->m.dl_dataVolumesPresent);
   printf ("%s.m.dL_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.dL_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.uL_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.uL_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.dl_dataVolumesPresent) {
      sprintf (namebuf, "%s.dl_dataVolumes", name);
      asn1Print_DataVolumeList (namebuf, &pvalue->dl_dataVolumes);
   }

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.dL_GTP_PDU_SequenceNumber", name);
      asn1Print_DL_GTP_PDU_SequenceNumber (namebuf, &pvalue->dL_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.uL_GTP_PDU_SequenceNumber", name);
      asn1Print_UL_GTP_PDU_SequenceNumber (namebuf, &pvalue->uL_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_ReleasedItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleasedItemIEs_Value                                */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_ReleasedItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_ReleasedItemIEs_Value *pvalue = (_RAB_ReleasedItemIEs_Value*) pvalue_;
   asn1Print_RAB_ReleasedItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element_element                          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedList_element_element
   (const char* name, RAB_ReleasedList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ReleasedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_ReleasedItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element                                  */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedList_element
   (const char* name, RAB_ReleasedList_element* pvalue)
{
   RAB_ReleasedList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleasedList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleasedList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList                                          */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleasedList
   (const char* name, RAB_ReleasedList* pvalue)
{
   RAB_ReleasedList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ReleasedList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ReleasedList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_1                        */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentResponseIEs_Value_1 *pvalue = (_RAB_AssignmentResponseIEs_Value_1*) pvalue_;
   asn1Print_RAB_ReleasedList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_QueuedItem_iE_Extensions_element
   (const char* name, RAB_QueuedItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_QueuedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_QueuedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_QueuedItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_QueuedItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_QueuedItem_iE_Extensions
   (const char* name, RAB_QueuedItem_iE_Extensions* pvalue)
{
   RAB_QueuedItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_QueuedItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_QueuedItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_QueuedItem
   (const char* name, RAB_QueuedItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_QueuedItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_QueuedItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_QueuedItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_QueuedItemIEs_Value *pvalue = (_RAB_QueuedItemIEs_Value*) pvalue_;
   asn1Print_RAB_QueuedItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element_element                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_QueuedList_element_element
   (const char* name, RAB_QueuedList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_QueuedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_QueuedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_QueuedItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_QueuedItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_QueuedList_element
   (const char* name, RAB_QueuedList_element* pvalue)
{
   RAB_QueuedList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_QueuedList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_QueuedList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_QueuedList
   (const char* name, RAB_QueuedList* pvalue)
{
   RAB_QueuedList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_QueuedList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_QueuedList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_2                        */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentResponseIEs_Value_2
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentResponseIEs_Value_2 *pvalue = (_RAB_AssignmentResponseIEs_Value_2*) pvalue_;
   asn1Print_RAB_QueuedList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_3                        */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentResponseIEs_Value_3
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentResponseIEs_Value_3 *pvalue = (_RAB_AssignmentResponseIEs_Value_3*) pvalue_;
   asn1Print_RAB_FailedList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseFailedList                                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ReleaseFailedList
   (const char* name, RAB_ReleaseFailedList* pvalue)
{
   asn1Print_RAB_FailedList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_4                        */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentResponseIEs_Value_4
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentResponseIEs_Value_4 *pvalue = (_RAB_AssignmentResponseIEs_Value_4*) pvalue_;
   asn1Print_RAB_ReleaseFailedList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_5                        */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentResponseIEs_Value_5
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentResponseIEs_Value_5 *pvalue = (_RAB_AssignmentResponseIEs_Value_5*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs_element                */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentResponse_protocolIEs_element
   (const char* name, RAB_AssignmentResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_AssignmentResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_AssignmentResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs                        */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentResponse_protocolIEs
   (const char* name, RAB_AssignmentResponse_protocolIEs* pvalue)
{
   RAB_AssignmentResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_AssignmentResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_AssignmentResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element
   (const char* name, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions
   (const char* name, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions* pvalue)
{
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item            */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item
   (const char* name, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   char namebuf[512];

   printf ("%s.m.gERAN_ClassmarkPresent = %d\n", name, (int)pvalue->m.gERAN_ClassmarkPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   sprintf (namebuf, "%s.cause", name);
   asn1Print_Cause (namebuf, &pvalue->cause);

   if (pvalue->m.gERAN_ClassmarkPresent) {
      sprintf (namebuf, "%s.gERAN_Classmark", name);
      asn1Print_GERAN_Classmark (namebuf, &pvalue->gERAN_Classmark);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value  */
/*                                                            */
/**************************************************************/

void asn1Print__GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value
   (const char* name, void* pvalue_)
{
   _GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value *pvalue = (_GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value*) pvalue_;
   asn1Print_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_el  */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element
   (const char* name, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element     */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element
   (const char* name, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element* pvalue)
{
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse             */
/*                                                            */
/**************************************************************/

void asn1Print_GERAN_Iumode_RAB_FailedList_RABAssgntResponse
   (const char* name, GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseExtensions_Extension               */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_AssignmentResponseExtensions_Extension
   (const char* name, void* pvalue_)
{
   _RAB_AssignmentResponseExtensions_Extension *pvalue = (_RAB_AssignmentResponseExtensions_Extension*) pvalue_;
   asn1Print_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions_element         */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentResponse_protocolExtensions_element
   (const char* name, RAB_AssignmentResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_AssignmentResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_AssignmentResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions                 */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentResponse_protocolExtensions
   (const char* name, RAB_AssignmentResponse_protocolExtensions* pvalue)
{
   RAB_AssignmentResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_AssignmentResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_AssignmentResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_AssignmentResponse
   (const char* name, RAB_AssignmentResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RAB_AssignmentResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RAB_AssignmentResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs_element                         */
/*                                                            */
/**************************************************************/

void asn1Print_PrivateMessage_privateIEs_element
   (const char* name, PrivateMessage_privateIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < PrivateMessage_IEs_Size; index++) {
      if(asn1CmpTC_PrivateIE_ID(&pvalue->id, &PrivateMessage_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == PrivateMessage_IEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_PrivateIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      PrivateMessage_IEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs                                 */
/*                                                            */
/**************************************************************/

void asn1Print_PrivateMessage_privateIEs
   (const char* name, PrivateMessage_privateIEs* pvalue)
{
   PrivateMessage_privateIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (PrivateMessage_privateIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_PrivateMessage_privateIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage                                            */
/*                                                            */
/**************************************************************/

void asn1Print_PrivateMessage
   (const char* name, PrivateMessage* pvalue)
{
   char namebuf[512];

   sprintf (namebuf, "%s.privateIEs", name);
   asn1Print_PrivateMessage_privateIEs (namebuf, &pvalue->privateIEs);

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value                                   */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceIEs_Value
   (const char* name, void* pvalue_)
{
   _ResetResourceIEs_Value *pvalue = (_ResetResourceIEs_Value*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_1                                 */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceIEs_Value_1
   (const char* name, void* pvalue_)
{
   _ResetResourceIEs_Value_1 *pvalue = (_ResetResourceIEs_Value_1*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceItem_iE_Extensions_element
   (const char* name, ResetResourceItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetResourceItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ResetResourceItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions                           */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceItem_iE_Extensions
   (const char* name, ResetResourceItem_iE_Extensions* pvalue)
{
   ResetResourceItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResourceItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResourceItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem                                         */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceItem
   (const char* name, ResetResourceItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.iuSigConId", name);
   asn1Print_IuSignallingConnectionIdentifier (namebuf, &pvalue->iuSigConId);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_ResetResourceItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _ResetResourceItemIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceItemIEs_Value
   (const char* name, void* pvalue_)
{
   _ResetResourceItemIEs_Value *pvalue = (_ResetResourceItemIEs_Value*) pvalue_;
   asn1Print_ResetResourceItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element_element                         */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceList_element_element
   (const char* name, ResetResourceList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetResourceItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      ResetResourceItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element                                 */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceList_element
   (const char* name, ResetResourceList_element* pvalue)
{
   ResetResourceList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResourceList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResourceList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList                                         */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceList
   (const char* name, ResetResourceList* pvalue)
{
   ResetResourceList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResourceList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResourceList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_2                                 */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceIEs_Value_2
   (const char* name, void* pvalue_)
{
   _ResetResourceIEs_Value_2 *pvalue = (_ResetResourceIEs_Value_2*) pvalue_;
   asn1Print_ResetResourceList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_3                                 */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceIEs_Value_3
   (const char* name, void* pvalue_)
{
   _ResetResourceIEs_Value_3 *pvalue = (_ResetResourceIEs_Value_3*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs_element                         */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResource_protocolIEs_element
   (const char* name, ResetResource_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetResourceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      ResetResourceIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs                                 */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResource_protocolIEs
   (const char* name, ResetResource_protocolIEs* pvalue)
{
   ResetResource_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResource_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResource_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceExtensions_Extension                        */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceExtensions_Extension
   (const char* name, void* pvalue_)
{
   _ResetResourceExtensions_Extension *pvalue = (_ResetResourceExtensions_Extension*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions_element                  */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResource_protocolExtensions_element
   (const char* name, ResetResource_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetResourceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ResetResourceExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions                          */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResource_protocolExtensions
   (const char* name, ResetResource_protocolExtensions* pvalue)
{
   ResetResource_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResource_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResource_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ResetResource                                             */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResource
   (const char* name, ResetResource* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_ResetResource_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_ResetResource_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value                        */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceAcknowledgeIEs_Value
   (const char* name, void* pvalue_)
{
   _ResetResourceAcknowledgeIEs_Value *pvalue = (_ResetResourceAcknowledgeIEs_Value*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAckItem_iE_Extensions_element
   (const char* name, ResetResourceAckItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetResourceAckItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAckItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAckItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ResetResourceAckItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAckItem_iE_Extensions
   (const char* name, ResetResourceAckItem_iE_Extensions* pvalue)
{
   ResetResourceAckItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResourceAckItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResourceAckItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem                                      */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAckItem
   (const char* name, ResetResourceAckItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.iuSigConId", name);
   asn1Print_IuSignallingConnectionIdentifier (namebuf, &pvalue->iuSigConId);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_ResetResourceAckItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAckItemIEs_Value                            */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceAckItemIEs_Value
   (const char* name, void* pvalue_)
{
   _ResetResourceAckItemIEs_Value *pvalue = (_ResetResourceAckItemIEs_Value*) pvalue_;
   asn1Print_ResetResourceAckItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAckList_element_element
   (const char* name, ResetResourceAckList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetResourceAckItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAckItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAckItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      ResetResourceAckItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element                              */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAckList_element
   (const char* name, ResetResourceAckList_element* pvalue)
{
   ResetResourceAckList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResourceAckList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResourceAckList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList                                      */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAckList
   (const char* name, ResetResourceAckList* pvalue)
{
   ResetResourceAckList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResourceAckList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResourceAckList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_1                      */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceAcknowledgeIEs_Value_1
   (const char* name, void* pvalue_)
{
   _ResetResourceAcknowledgeIEs_Value_1 *pvalue = (_ResetResourceAcknowledgeIEs_Value_1*) pvalue_;
   asn1Print_ResetResourceAckList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_2                      */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceAcknowledgeIEs_Value_2
   (const char* name, void* pvalue_)
{
   _ResetResourceAcknowledgeIEs_Value_2 *pvalue = (_ResetResourceAcknowledgeIEs_Value_2*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_3                      */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceAcknowledgeIEs_Value_3
   (const char* name, void* pvalue_)
{
   _ResetResourceAcknowledgeIEs_Value_3 *pvalue = (_ResetResourceAcknowledgeIEs_Value_3*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs_element              */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAcknowledge_protocolIEs_element
   (const char* name, ResetResourceAcknowledge_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetResourceAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAcknowledgeIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      ResetResourceAcknowledgeIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs                      */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAcknowledge_protocolIEs
   (const char* name, ResetResourceAcknowledge_protocolIEs* pvalue)
{
   ResetResourceAcknowledge_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResourceAcknowledge_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResourceAcknowledge_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeExtensions_Extension             */
/*                                                            */
/**************************************************************/

void asn1Print__ResetResourceAcknowledgeExtensions_Extension
   (const char* name, void* pvalue_)
{
   _ResetResourceAcknowledgeExtensions_Extension *pvalue = (_ResetResourceAcknowledgeExtensions_Extension*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAcknowledge_protocolExtensions_element
   (const char* name, ResetResourceAcknowledge_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < ResetResourceAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAcknowledgeExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      ResetResourceAcknowledgeExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions               */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAcknowledge_protocolExtensions
   (const char* name, ResetResourceAcknowledge_protocolExtensions* pvalue)
{
   ResetResourceAcknowledge_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (ResetResourceAcknowledge_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_ResetResourceAcknowledge_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge                                  */
/*                                                            */
/**************************************************************/

void asn1Print_ResetResourceAcknowledge
   (const char* name, ResetResourceAcknowledge* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_ResetResourceAcknowledge_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_ResetResourceAcknowledge_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element
   (const char* name, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions
   (const char* name, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions* pvalue)
{
   DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf              */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransferInformationItem_RANAP_RelocInf
   (const char* name, DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.nAS_PDU", name);
   asn1Print_NAS_PDU (namebuf, &pvalue->nAS_PDU);

   sprintf (namebuf, "%s.sAPI", name);
   asn1Print_SAPI (namebuf, &pvalue->sAPI);

   sprintf (namebuf, "%s.cN_DomainIndicator", name);
   asn1Print_CN_DomainIndicator (namebuf, &pvalue->cN_DomainIndicator);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _DirectTransferInformationItemIEs_RANAP_RelocInf_Value    */
/*                                                            */
/**************************************************************/

void asn1Print__DirectTransferInformationItemIEs_RANAP_RelocInf_Value
   (const char* name, void* pvalue_)
{
   _DirectTransferInformationItemIEs_RANAP_RelocInf_Value *pvalue = (_DirectTransferInformationItemIEs_RANAP_RelocInf_Value*) pvalue_;
   asn1Print_DirectTransferInformationItem_RANAP_RelocInf (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element_ele  */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransferInformationList_RANAP_RelocInf_element_element
   (const char* name, DirectTransferInformationList_RANAP_RelocInf_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DirectTransferInformationItemIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferInformationItemIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferInformationItemIEs_RANAP_RelocInf_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      DirectTransferInformationItemIEs_RANAP_RelocInf[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element      */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransferInformationList_RANAP_RelocInf_element
   (const char* name, DirectTransferInformationList_RANAP_RelocInf_element* pvalue)
{
   DirectTransferInformationList_RANAP_RelocInf_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DirectTransferInformationList_RANAP_RelocInf_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DirectTransferInformationList_RANAP_RelocInf_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf              */
/*                                                            */
/**************************************************************/

void asn1Print_DirectTransferInformationList_RANAP_RelocInf
   (const char* name, DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   DirectTransferInformationList_RANAP_RelocInf_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DirectTransferInformationList_RANAP_RelocInf_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DirectTransferInformationList_RANAP_RelocInf_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationIEs_Value                     */
/*                                                            */
/**************************************************************/

void asn1Print__RANAP_RelocationInformationIEs_Value
   (const char* name, void* pvalue_)
{
   _RANAP_RelocationInformationIEs_Value *pvalue = (_RANAP_RelocationInformationIEs_Value*) pvalue_;
   asn1Print_DirectTransferInformationList_RANAP_RelocInf (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element
   (const char* name, RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextItem_RANAP_RelocInf_iE_Extensions
   (const char* name, RAB_ContextItem_RANAP_RelocInf_iE_Extensions* pvalue)
{
   RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextItem_RANAP_RelocInf
   (const char* name, RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   char namebuf[512];

   printf ("%s.m.dl_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.ul_GTP_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   printf ("%s.m.dl_N_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   printf ("%s.m.ul_N_PDU_SequenceNumberPresent = %d\n", name, (int)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.dl_GTP_PDU_SequenceNumber", name);
      asn1Print_DL_GTP_PDU_SequenceNumber (namebuf, &pvalue->dl_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.ul_GTP_PDU_SequenceNumber", name);
      asn1Print_UL_GTP_PDU_SequenceNumber (namebuf, &pvalue->ul_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.dl_N_PDU_SequenceNumber", name);
      asn1Print_DL_N_PDU_SequenceNumber (namebuf, &pvalue->dl_N_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      sprintf (namebuf, "%s.ul_N_PDU_SequenceNumber", name);
      asn1Print_UL_N_PDU_SequenceNumber (namebuf, &pvalue->ul_N_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_ContextItem_RANAP_RelocInf_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_ContextItemIEs_RANAP_RelocInf_Value                  */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_ContextItemIEs_RANAP_RelocInf_Value
   (const char* name, void* pvalue_)
{
   _RAB_ContextItemIEs_RANAP_RelocInf_Value *pvalue = (_RAB_ContextItemIEs_RANAP_RelocInf_Value*) pvalue_;
   asn1Print_RAB_ContextItem_RANAP_RelocInf (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element_element            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextList_RANAP_RelocInf_element_element
   (const char* name, RAB_ContextList_RANAP_RelocInf_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ContextItemIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItemIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItemIEs_RANAP_RelocInf_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_ContextItemIEs_RANAP_RelocInf[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextList_RANAP_RelocInf_element
   (const char* name, RAB_ContextList_RANAP_RelocInf_element* pvalue)
{
   RAB_ContextList_RANAP_RelocInf_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ContextList_RANAP_RelocInf_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ContextList_RANAP_RelocInf_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ContextList_RANAP_RelocInf
   (const char* name, RAB_ContextList_RANAP_RelocInf* pvalue)
{
   RAB_ContextList_RANAP_RelocInf_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ContextList_RANAP_RelocInf_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ContextList_RANAP_RelocInf_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationIEs_Value_1                   */
/*                                                            */
/**************************************************************/

void asn1Print__RANAP_RelocationInformationIEs_Value_1
   (const char* name, void* pvalue_)
{
   _RANAP_RelocationInformationIEs_Value_1 *pvalue = (_RANAP_RelocationInformationIEs_Value_1*) pvalue_;
   asn1Print_RAB_ContextList_RANAP_RelocInf (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs_element           */
/*                                                            */
/**************************************************************/

void asn1Print_RANAP_RelocationInformation_protocolIEs_element
   (const char* name, RANAP_RelocationInformation_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RANAP_RelocationInformationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_RelocationInformationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_RelocationInformationIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RANAP_RelocationInformationIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs                   */
/*                                                            */
/**************************************************************/

void asn1Print_RANAP_RelocationInformation_protocolIEs
   (const char* name, RANAP_RelocationInformation_protocolIEs* pvalue)
{
   RANAP_RelocationInformation_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RANAP_RelocationInformation_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RANAP_RelocationInformation_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationExtensions_Extension          */
/*                                                            */
/**************************************************************/

void asn1Print__RANAP_RelocationInformationExtensions_Extension
   (const char* name, void* pvalue_)
{
   _RANAP_RelocationInformationExtensions_Extension *pvalue = (_RANAP_RelocationInformationExtensions_Extension*) pvalue_;
   asn1Print_RRC_Container (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

void asn1Print_RANAP_RelocationInformation_protocolExtensions_element
   (const char* name, RANAP_RelocationInformation_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RANAP_RelocationInformationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_RelocationInformationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_RelocationInformationExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RANAP_RelocationInformationExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions            */
/*                                                            */
/**************************************************************/

void asn1Print_RANAP_RelocationInformation_protocolExtensions
   (const char* name, RANAP_RelocationInformation_protocolExtensions* pvalue)
{
   RANAP_RelocationInformation_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RANAP_RelocationInformation_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RANAP_RelocationInformation_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation                               */
/*                                                            */
/**************************************************************/

void asn1Print_RANAP_RelocationInformation
   (const char* name, RANAP_RelocationInformation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RANAP_RelocationInformation_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RANAP_RelocationInformation_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyItem_iE_Extensions_element
   (const char* name, RAB_ModifyItem_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ModifyItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyItem_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_ModifyItem_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyItem_iE_Extensions
   (const char* name, RAB_ModifyItem_iE_Extensions* pvalue)
{
   RAB_ModifyItem_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ModifyItem_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ModifyItem_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyItem
   (const char* name, RAB_ModifyItem* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.rAB_ID", name);
   asn1Print_RAB_ID (namebuf, &pvalue->rAB_ID);

   sprintf (namebuf, "%s.requested_RAB_Parameter_Values", name);
   asn1Print_Requested_RAB_Parameter_Values (namebuf, &pvalue->requested_RAB_Parameter_Values);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_RAB_ModifyItem_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _RAB_ModifyItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_ModifyItemIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_ModifyItemIEs_Value *pvalue = (_RAB_ModifyItemIEs_Value*) pvalue_;
   asn1Print_RAB_ModifyItem (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element_element                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyList_element_element
   (const char* name, RAB_ModifyList_element_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ModifyItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyItemIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_ModifyItemIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element                                    */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyList_element
   (const char* name, RAB_ModifyList_element* pvalue)
{
   RAB_ModifyList_element_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ModifyList_element_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ModifyList_element_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList                                            */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyList
   (const char* name, RAB_ModifyList* pvalue)
{
   RAB_ModifyList_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ModifyList_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ModifyList_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _RAB_ModifyRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__RAB_ModifyRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _RAB_ModifyRequestIEs_Value *pvalue = (_RAB_ModifyRequestIEs_Value*) pvalue_;
   asn1Print_RAB_ModifyList (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyRequest_protocolIEs_element
   (const char* name, RAB_ModifyRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ModifyRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RAB_ModifyRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyRequest_protocolIEs
   (const char* name, RAB_ModifyRequest_protocolIEs* pvalue)
{
   RAB_ModifyRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ModifyRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ModifyRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyRequest_protocolExtensions_element
   (const char* name, RAB_ModifyRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < RAB_ModifyRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      RAB_ModifyRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyRequest_protocolExtensions
   (const char* name, RAB_ModifyRequest_protocolExtensions* pvalue)
{
   RAB_ModifyRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (RAB_ModifyRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_RAB_ModifyRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest                                         */
/*                                                            */
/**************************************************************/

void asn1Print_RAB_ModifyRequest
   (const char* name, RAB_ModifyRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_RAB_ModifyRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_RAB_ModifyRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataRequestIEs_Value                      */
/*                                                            */
/**************************************************************/

void asn1Print__LocationRelatedDataRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _LocationRelatedDataRequestIEs_Value *pvalue = (_LocationRelatedDataRequestIEs_Value*) pvalue_;
   asn1Print_LocationRelatedDataRequestType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs_element            */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataRequest_protocolIEs_element
   (const char* name, LocationRelatedDataRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationRelatedDataRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      LocationRelatedDataRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs                    */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataRequest_protocolIEs
   (const char* name, LocationRelatedDataRequest_protocolIEs* pvalue)
{
   LocationRelatedDataRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationRelatedDataRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationRelatedDataRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataRequestExtensions_Extension           */
/*                                                            */
/**************************************************************/

void asn1Print__LocationRelatedDataRequestExtensions_Extension
   (const char* name, void* pvalue_)
{
   _LocationRelatedDataRequestExtensions_Extension *pvalue = (_LocationRelatedDataRequestExtensions_Extension*) pvalue_;
   asn1Print_LocationRelatedDataRequestTypeSpecificToGERANIuMode (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataRequest_protocolExtensions_element
   (const char* name, LocationRelatedDataRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationRelatedDataRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LocationRelatedDataRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions             */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataRequest_protocolExtensions
   (const char* name, LocationRelatedDataRequest_protocolExtensions* pvalue)
{
   LocationRelatedDataRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationRelatedDataRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationRelatedDataRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest                                */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataRequest
   (const char* name, LocationRelatedDataRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_LocationRelatedDataRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_LocationRelatedDataRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataResponseIEs_Value                     */
/*                                                            */
/**************************************************************/

void asn1Print__LocationRelatedDataResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _LocationRelatedDataResponseIEs_Value *pvalue = (_LocationRelatedDataResponseIEs_Value*) pvalue_;
   asn1Print_BroadcastAssistanceDataDecipheringKeys (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs_element           */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataResponse_protocolIEs_element
   (const char* name, LocationRelatedDataResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationRelatedDataResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      LocationRelatedDataResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs                   */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataResponse_protocolIEs
   (const char* name, LocationRelatedDataResponse_protocolIEs* pvalue)
{
   LocationRelatedDataResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationRelatedDataResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationRelatedDataResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataResponseExtensions_Extension          */
/*                                                            */
/**************************************************************/

void asn1Print__LocationRelatedDataResponseExtensions_Extension
   (const char* name, void* pvalue_)
{
   _LocationRelatedDataResponseExtensions_Extension *pvalue = (_LocationRelatedDataResponseExtensions_Extension*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataResponse_protocolExtensions_element
   (const char* name, LocationRelatedDataResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationRelatedDataResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LocationRelatedDataResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions            */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataResponse_protocolExtensions
   (const char* name, LocationRelatedDataResponse_protocolExtensions* pvalue)
{
   LocationRelatedDataResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationRelatedDataResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationRelatedDataResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse                               */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataResponse
   (const char* name, LocationRelatedDataResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_LocationRelatedDataResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_LocationRelatedDataResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataFailureIEs_Value                      */
/*                                                            */
/**************************************************************/

void asn1Print__LocationRelatedDataFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _LocationRelatedDataFailureIEs_Value *pvalue = (_LocationRelatedDataFailureIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataFailure_protocolIEs_element
   (const char* name, LocationRelatedDataFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationRelatedDataFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      LocationRelatedDataFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs                    */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataFailure_protocolIEs
   (const char* name, LocationRelatedDataFailure_protocolIEs* pvalue)
{
   LocationRelatedDataFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationRelatedDataFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationRelatedDataFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataFailureExtensions_Extension           */
/*                                                            */
/**************************************************************/

void asn1Print__LocationRelatedDataFailureExtensions_Extension
   (const char* name, void* pvalue_)
{
   _LocationRelatedDataFailureExtensions_Extension *pvalue = (_LocationRelatedDataFailureExtensions_Extension*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataFailure_protocolExtensions_element
   (const char* name, LocationRelatedDataFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LocationRelatedDataFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LocationRelatedDataFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions             */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataFailure_protocolExtensions
   (const char* name, LocationRelatedDataFailure_protocolExtensions* pvalue)
{
   LocationRelatedDataFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LocationRelatedDataFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LocationRelatedDataFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure                                */
/*                                                            */
/**************************************************************/

void asn1Print_LocationRelatedDataFailure
   (const char* name, LocationRelatedDataFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_LocationRelatedDataFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_LocationRelatedDataFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value                   */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferIndicationIEs_Value
   (const char* name, void* pvalue_)
{
   _InformationTransferIndicationIEs_Value *pvalue = (_InformationTransferIndicationIEs_Value*) pvalue_;
   asn1Print_InformationTransferID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_1                 */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferIndicationIEs_Value_1
   (const char* name, void* pvalue_)
{
   _InformationTransferIndicationIEs_Value_1 *pvalue = (_InformationTransferIndicationIEs_Value_1*) pvalue_;
   asn1Print_ProvidedData (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_2                 */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferIndicationIEs_Value_2
   (const char* name, void* pvalue_)
{
   _InformationTransferIndicationIEs_Value_2 *pvalue = (_InformationTransferIndicationIEs_Value_2*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_3                 */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferIndicationIEs_Value_3
   (const char* name, void* pvalue_)
{
   _InformationTransferIndicationIEs_Value_3 *pvalue = (_InformationTransferIndicationIEs_Value_3*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs_element         */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferIndication_protocolIEs_element
   (const char* name, InformationTransferIndication_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InformationTransferIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferIndicationIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      InformationTransferIndicationIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs                 */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferIndication_protocolIEs
   (const char* name, InformationTransferIndication_protocolIEs* pvalue)
{
   InformationTransferIndication_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InformationTransferIndication_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InformationTransferIndication_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferIndication_protocolExtensions_element
   (const char* name, InformationTransferIndication_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InformationTransferIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferIndicationExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      InformationTransferIndicationExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions          */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferIndication_protocolExtensions
   (const char* name, InformationTransferIndication_protocolExtensions* pvalue)
{
   InformationTransferIndication_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InformationTransferIndication_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InformationTransferIndication_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication                             */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferIndication
   (const char* name, InformationTransferIndication* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_InformationTransferIndication_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_InformationTransferIndication_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value                 */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferConfirmationIEs_Value
   (const char* name, void* pvalue_)
{
   _InformationTransferConfirmationIEs_Value *pvalue = (_InformationTransferConfirmationIEs_Value*) pvalue_;
   asn1Print_InformationTransferID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_1               */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferConfirmationIEs_Value_1
   (const char* name, void* pvalue_)
{
   _InformationTransferConfirmationIEs_Value_1 *pvalue = (_InformationTransferConfirmationIEs_Value_1*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_2               */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferConfirmationIEs_Value_2
   (const char* name, void* pvalue_)
{
   _InformationTransferConfirmationIEs_Value_2 *pvalue = (_InformationTransferConfirmationIEs_Value_2*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_3               */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferConfirmationIEs_Value_3
   (const char* name, void* pvalue_)
{
   _InformationTransferConfirmationIEs_Value_3 *pvalue = (_InformationTransferConfirmationIEs_Value_3*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs_element       */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferConfirmation_protocolIEs_element
   (const char* name, InformationTransferConfirmation_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InformationTransferConfirmationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferConfirmationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferConfirmationIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      InformationTransferConfirmationIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs               */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferConfirmation_protocolIEs
   (const char* name, InformationTransferConfirmation_protocolIEs* pvalue)
{
   InformationTransferConfirmation_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InformationTransferConfirmation_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InformationTransferConfirmation_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferConfirmation_protocolExtensions_element
   (const char* name, InformationTransferConfirmation_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InformationTransferConfirmationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferConfirmationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferConfirmationExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      InformationTransferConfirmationExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions        */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferConfirmation_protocolExtensions
   (const char* name, InformationTransferConfirmation_protocolExtensions* pvalue)
{
   InformationTransferConfirmation_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InformationTransferConfirmation_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InformationTransferConfirmation_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation                           */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferConfirmation
   (const char* name, InformationTransferConfirmation* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_InformationTransferConfirmation_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_InformationTransferConfirmation_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value                      */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _InformationTransferFailureIEs_Value *pvalue = (_InformationTransferFailureIEs_Value*) pvalue_;
   asn1Print_InformationTransferID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_1                    */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferFailureIEs_Value_1
   (const char* name, void* pvalue_)
{
   _InformationTransferFailureIEs_Value_1 *pvalue = (_InformationTransferFailureIEs_Value_1*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_2                    */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferFailureIEs_Value_2
   (const char* name, void* pvalue_)
{
   _InformationTransferFailureIEs_Value_2 *pvalue = (_InformationTransferFailureIEs_Value_2*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_3                    */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferFailureIEs_Value_3
   (const char* name, void* pvalue_)
{
   _InformationTransferFailureIEs_Value_3 *pvalue = (_InformationTransferFailureIEs_Value_3*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_4                    */
/*                                                            */
/**************************************************************/

void asn1Print__InformationTransferFailureIEs_Value_4
   (const char* name, void* pvalue_)
{
   _InformationTransferFailureIEs_Value_4 *pvalue = (_InformationTransferFailureIEs_Value_4*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferFailure_protocolIEs_element
   (const char* name, InformationTransferFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InformationTransferFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      InformationTransferFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs                    */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferFailure_protocolIEs
   (const char* name, InformationTransferFailure_protocolIEs* pvalue)
{
   InformationTransferFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InformationTransferFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InformationTransferFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferFailure_protocolExtensions_element
   (const char* name, InformationTransferFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < InformationTransferFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      InformationTransferFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions             */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferFailure_protocolExtensions
   (const char* name, InformationTransferFailure_protocolExtensions* pvalue)
{
   InformationTransferFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (InformationTransferFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_InformationTransferFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure                                */
/*                                                            */
/**************************************************************/

void asn1Print_InformationTransferFailure
   (const char* name, InformationTransferFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_InformationTransferFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_InformationTransferFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _UESpecificInformationIndicationIEs_Value                 */
/*                                                            */
/**************************************************************/

void asn1Print__UESpecificInformationIndicationIEs_Value
   (const char* name, void* pvalue_)
{
   _UESpecificInformationIndicationIEs_Value *pvalue = (_UESpecificInformationIndicationIEs_Value*) pvalue_;
   asn1Print_UESBI_Iu (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs_element       */
/*                                                            */
/**************************************************************/

void asn1Print_UESpecificInformationIndication_protocolIEs_element
   (const char* name, UESpecificInformationIndication_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UESpecificInformationIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESpecificInformationIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UESpecificInformationIndicationIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      UESpecificInformationIndicationIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs               */
/*                                                            */
/**************************************************************/

void asn1Print_UESpecificInformationIndication_protocolIEs
   (const char* name, UESpecificInformationIndication_protocolIEs* pvalue)
{
   UESpecificInformationIndication_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UESpecificInformationIndication_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UESpecificInformationIndication_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

void asn1Print_UESpecificInformationIndication_protocolExtensions_element
   (const char* name, UESpecificInformationIndication_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UESpecificInformationIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESpecificInformationIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UESpecificInformationIndicationExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      UESpecificInformationIndicationExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions        */
/*                                                            */
/**************************************************************/

void asn1Print_UESpecificInformationIndication_protocolExtensions
   (const char* name, UESpecificInformationIndication_protocolExtensions* pvalue)
{
   UESpecificInformationIndication_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UESpecificInformationIndication_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UESpecificInformationIndication_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication                           */
/*                                                            */
/**************************************************************/

void asn1Print_UESpecificInformationIndication
   (const char* name, UESpecificInformationIndication* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_UESpecificInformationIndication_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_UESpecificInformationIndication_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value                       */
/*                                                            */
/**************************************************************/

void asn1Print__DirectInformationTransferIEs_Value
   (const char* name, void* pvalue_)
{
   _DirectInformationTransferIEs_Value *pvalue = (_DirectInformationTransferIEs_Value*) pvalue_;
   asn1Print_InterSystemInformationTransferType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_1                     */
/*                                                            */
/**************************************************************/

void asn1Print__DirectInformationTransferIEs_Value_1
   (const char* name, void* pvalue_)
{
   _DirectInformationTransferIEs_Value_1 *pvalue = (_DirectInformationTransferIEs_Value_1*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_2                     */
/*                                                            */
/**************************************************************/

void asn1Print__DirectInformationTransferIEs_Value_2
   (const char* name, void* pvalue_)
{
   _DirectInformationTransferIEs_Value_2 *pvalue = (_DirectInformationTransferIEs_Value_2*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_3                     */
/*                                                            */
/**************************************************************/

void asn1Print__DirectInformationTransferIEs_Value_3
   (const char* name, void* pvalue_)
{
   _DirectInformationTransferIEs_Value_3 *pvalue = (_DirectInformationTransferIEs_Value_3*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs_element             */
/*                                                            */
/**************************************************************/

void asn1Print_DirectInformationTransfer_protocolIEs_element
   (const char* name, DirectInformationTransfer_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DirectInformationTransferIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectInformationTransferIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DirectInformationTransferIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      DirectInformationTransferIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs                     */
/*                                                            */
/**************************************************************/

void asn1Print_DirectInformationTransfer_protocolIEs
   (const char* name, DirectInformationTransfer_protocolIEs* pvalue)
{
   DirectInformationTransfer_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DirectInformationTransfer_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DirectInformationTransfer_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

void asn1Print_DirectInformationTransfer_protocolExtensions_element
   (const char* name, DirectInformationTransfer_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < DirectInformationTransferExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectInformationTransferExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DirectInformationTransferExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      DirectInformationTransferExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions              */
/*                                                            */
/**************************************************************/

void asn1Print_DirectInformationTransfer_protocolExtensions
   (const char* name, DirectInformationTransfer_protocolExtensions* pvalue)
{
   DirectInformationTransfer_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (DirectInformationTransfer_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_DirectInformationTransfer_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer                                 */
/*                                                            */
/**************************************************************/

void asn1Print_DirectInformationTransfer
   (const char* name, DirectInformationTransfer* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_DirectInformationTransfer_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_DirectInformationTransfer_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value                */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeRequestIEs_Value *pvalue = (_UplinkInformationExchangeRequestIEs_Value*) pvalue_;
   asn1Print_InformationExchangeID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_1              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeRequestIEs_Value_1
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeRequestIEs_Value_1 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_1*) pvalue_;
   asn1Print_InformationExchangeType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_2              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeRequestIEs_Value_2
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeRequestIEs_Value_2 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_2*) pvalue_;
   asn1Print_InformationTransferType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_3              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeRequestIEs_Value_3
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeRequestIEs_Value_3 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_3*) pvalue_;
   asn1Print_InformationRequestType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_4              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeRequestIEs_Value_4
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeRequestIEs_Value_4 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_4*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_5              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeRequestIEs_Value_5
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeRequestIEs_Value_5 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_5*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs_element      */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeRequest_protocolIEs_element
   (const char* name, UplinkInformationExchangeRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UplinkInformationExchangeRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      UplinkInformationExchangeRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs              */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeRequest_protocolIEs
   (const char* name, UplinkInformationExchangeRequest_protocolIEs* pvalue)
{
   UplinkInformationExchangeRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UplinkInformationExchangeRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UplinkInformationExchangeRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeRequest_protocolExtensions_element
   (const char* name, UplinkInformationExchangeRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UplinkInformationExchangeRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      UplinkInformationExchangeRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions       */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeRequest_protocolExtensions
   (const char* name, UplinkInformationExchangeRequest_protocolExtensions* pvalue)
{
   UplinkInformationExchangeRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UplinkInformationExchangeRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UplinkInformationExchangeRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest                          */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeRequest
   (const char* name, UplinkInformationExchangeRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_UplinkInformationExchangeRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_UplinkInformationExchangeRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value               */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeResponseIEs_Value *pvalue = (_UplinkInformationExchangeResponseIEs_Value*) pvalue_;
   asn1Print_InformationExchangeID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_1             */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeResponseIEs_Value_1 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_1*) pvalue_;
   asn1Print_InformationRequested (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_2             */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeResponseIEs_Value_2
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeResponseIEs_Value_2 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_2*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_3             */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeResponseIEs_Value_3
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeResponseIEs_Value_3 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_3*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_4             */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeResponseIEs_Value_4
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeResponseIEs_Value_4 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_4*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs_element     */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeResponse_protocolIEs_element
   (const char* name, UplinkInformationExchangeResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UplinkInformationExchangeResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      UplinkInformationExchangeResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs             */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeResponse_protocolIEs
   (const char* name, UplinkInformationExchangeResponse_protocolIEs* pvalue)
{
   UplinkInformationExchangeResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UplinkInformationExchangeResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UplinkInformationExchangeResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions_ele  */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeResponse_protocolExtensions_element
   (const char* name, UplinkInformationExchangeResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UplinkInformationExchangeResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      UplinkInformationExchangeResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions      */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeResponse_protocolExtensions
   (const char* name, UplinkInformationExchangeResponse_protocolExtensions* pvalue)
{
   UplinkInformationExchangeResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UplinkInformationExchangeResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UplinkInformationExchangeResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse                         */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeResponse
   (const char* name, UplinkInformationExchangeResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_UplinkInformationExchangeResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_UplinkInformationExchangeResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value                */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeFailureIEs_Value *pvalue = (_UplinkInformationExchangeFailureIEs_Value*) pvalue_;
   asn1Print_InformationExchangeID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_1              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeFailureIEs_Value_1
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeFailureIEs_Value_1 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_1*) pvalue_;
   asn1Print_CN_DomainIndicator (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_2              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeFailureIEs_Value_2
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeFailureIEs_Value_2 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_2*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_3              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeFailureIEs_Value_3
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeFailureIEs_Value_3 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_3*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_4              */
/*                                                            */
/**************************************************************/

void asn1Print__UplinkInformationExchangeFailureIEs_Value_4
   (const char* name, void* pvalue_)
{
   _UplinkInformationExchangeFailureIEs_Value_4 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_4*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs_element      */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeFailure_protocolIEs_element
   (const char* name, UplinkInformationExchangeFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UplinkInformationExchangeFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      UplinkInformationExchangeFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs              */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeFailure_protocolIEs
   (const char* name, UplinkInformationExchangeFailure_protocolIEs* pvalue)
{
   UplinkInformationExchangeFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UplinkInformationExchangeFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UplinkInformationExchangeFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeFailure_protocolExtensions_element
   (const char* name, UplinkInformationExchangeFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UplinkInformationExchangeFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      UplinkInformationExchangeFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions       */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeFailure_protocolExtensions
   (const char* name, UplinkInformationExchangeFailure_protocolExtensions* pvalue)
{
   UplinkInformationExchangeFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UplinkInformationExchangeFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UplinkInformationExchangeFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure                          */
/*                                                            */
/**************************************************************/

void asn1Print_UplinkInformationExchangeFailure
   (const char* name, UplinkInformationExchangeFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_UplinkInformationExchangeFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_UplinkInformationExchangeFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value                                */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value *pvalue = (_MBMSSessionStartIEs_Value*) pvalue_;
   asn1Print_TMGI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_1                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_1 *pvalue = (_MBMSSessionStartIEs_Value_1*) pvalue_;
   asn1Print_MBMSSessionIdentity (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_2                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_2
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_2 *pvalue = (_MBMSSessionStartIEs_Value_2*) pvalue_;
   asn1Print_MBMSBearerServiceType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_3                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_3
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_3 *pvalue = (_MBMSSessionStartIEs_Value_3*) pvalue_;
   asn1Print_IuSignallingConnectionIdentifier (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_4                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_4
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_4 *pvalue = (_MBMSSessionStartIEs_Value_4*) pvalue_;
   asn1Print_RAB_Parameters (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_5                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_5
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_5 *pvalue = (_MBMSSessionStartIEs_Value_5*) pvalue_;
   asn1Print_PDP_TypeInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_6                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_6
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_6 *pvalue = (_MBMSSessionStartIEs_Value_6*) pvalue_;
   asn1Print_MBMSSessionDuration (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_7                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_7
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_7 *pvalue = (_MBMSSessionStartIEs_Value_7*) pvalue_;
   asn1Print_MBMSServiceArea (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_8                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_8
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_8 *pvalue = (_MBMSSessionStartIEs_Value_8*) pvalue_;
   asn1Print_FrequenceLayerConvergenceFlag (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_9                              */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_9
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_9 *pvalue = (_MBMSSessionStartIEs_Value_9*) pvalue_;
   asn1Print_RAListofIdleModeUEs (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_10                             */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_10
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_10 *pvalue = (_MBMSSessionStartIEs_Value_10*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_11                             */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_11
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_11 *pvalue = (_MBMSSessionStartIEs_Value_11*) pvalue_;
   asn1Print_MBMSSessionRepetitionNumber (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_12                             */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartIEs_Value_12
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartIEs_Value_12 *pvalue = (_MBMSSessionStartIEs_Value_12*) pvalue_;
   asn1Print_TimeToMBMSDataTransfer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStart_protocolIEs_element
   (const char* name, MBMSSessionStart_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStartIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSSessionStartIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs                              */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStart_protocolIEs
   (const char* name, MBMSSessionStart_protocolIEs* pvalue)
{
   MBMSSessionStart_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStart_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStart_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStart_protocolExtensions_element
   (const char* name, MBMSSessionStart_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStartExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSSessionStartExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStart_protocolExtensions
   (const char* name, MBMSSessionStart_protocolExtensions* pvalue)
{
   MBMSSessionStart_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStart_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStart_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart                                          */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStart
   (const char* name, MBMSSessionStart* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSSessionStart_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSSessionStart_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value                        */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartResponseIEs_Value *pvalue = (_MBMSSessionStartResponseIEs_Value*) pvalue_;
   asn1Print_TransportLayerInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value_1                      */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartResponseIEs_Value_1 *pvalue = (_MBMSSessionStartResponseIEs_Value_1*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value_2                      */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartResponseIEs_Value_2
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartResponseIEs_Value_2 *pvalue = (_MBMSSessionStartResponseIEs_Value_2*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartResponse_protocolIEs_element
   (const char* name, MBMSSessionStartResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStartResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSSessionStartResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs                      */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartResponse_protocolIEs
   (const char* name, MBMSSessionStartResponse_protocolIEs* pvalue)
{
   MBMSSessionStartResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStartResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStartResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartResponse_protocolExtensions_element
   (const char* name, MBMSSessionStartResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStartResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSSessionStartResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartResponse_protocolExtensions
   (const char* name, MBMSSessionStartResponse_protocolExtensions* pvalue)
{
   MBMSSessionStartResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStartResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStartResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse                                  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartResponse
   (const char* name, MBMSSessionStartResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSSessionStartResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSSessionStartResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartFailureIEs_Value                         */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartFailureIEs_Value *pvalue = (_MBMSSessionStartFailureIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartFailureIEs_Value_1                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStartFailureIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSSessionStartFailureIEs_Value_1 *pvalue = (_MBMSSessionStartFailureIEs_Value_1*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartFailure_protocolIEs_element
   (const char* name, MBMSSessionStartFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStartFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSSessionStartFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartFailure_protocolIEs
   (const char* name, MBMSSessionStartFailure_protocolIEs* pvalue)
{
   MBMSSessionStartFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStartFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStartFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartFailure_protocolExtensions_element
   (const char* name, MBMSSessionStartFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStartFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSSessionStartFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions                */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartFailure_protocolExtensions
   (const char* name, MBMSSessionStartFailure_protocolExtensions* pvalue)
{
   MBMSSessionStartFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStartFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStartFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure                                   */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStartFailure
   (const char* name, MBMSSessionStartFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSSessionStartFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSSessionStartFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateIEs_Value                               */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateIEs_Value *pvalue = (_MBMSSessionUpdateIEs_Value*) pvalue_;
   asn1Print_SessionUpdateID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateIEs_Value_1                             */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateIEs_Value_1 *pvalue = (_MBMSSessionUpdateIEs_Value_1*) pvalue_;
   asn1Print_DeltaRAListofIdleModeUEs (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdate_protocolIEs_element
   (const char* name, MBMSSessionUpdate_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionUpdateIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSSessionUpdateIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs                             */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdate_protocolIEs
   (const char* name, MBMSSessionUpdate_protocolIEs* pvalue)
{
   MBMSSessionUpdate_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionUpdate_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionUpdate_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdate_protocolExtensions_element
   (const char* name, MBMSSessionUpdate_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionUpdateExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSSessionUpdateExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions                      */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdate_protocolExtensions
   (const char* name, MBMSSessionUpdate_protocolExtensions* pvalue)
{
   MBMSSessionUpdate_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionUpdate_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionUpdate_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate                                         */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdate
   (const char* name, MBMSSessionUpdate* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSSessionUpdate_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSSessionUpdate_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateResponseIEs_Value *pvalue = (_MBMSSessionUpdateResponseIEs_Value*) pvalue_;
   asn1Print_SessionUpdateID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_1                     */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateResponseIEs_Value_1 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_1*) pvalue_;
   asn1Print_TransportLayerInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_2                     */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateResponseIEs_Value_2
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateResponseIEs_Value_2 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_2*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_3                     */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateResponseIEs_Value_3
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateResponseIEs_Value_3 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_3*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs_element             */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateResponse_protocolIEs_element
   (const char* name, MBMSSessionUpdateResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionUpdateResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSSessionUpdateResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs                     */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateResponse_protocolIEs
   (const char* name, MBMSSessionUpdateResponse_protocolIEs* pvalue)
{
   MBMSSessionUpdateResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionUpdateResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionUpdateResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateResponse_protocolExtensions_element
   (const char* name, MBMSSessionUpdateResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionUpdateResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSSessionUpdateResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions              */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateResponse_protocolExtensions
   (const char* name, MBMSSessionUpdateResponse_protocolExtensions* pvalue)
{
   MBMSSessionUpdateResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionUpdateResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionUpdateResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse                                 */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateResponse
   (const char* name, MBMSSessionUpdateResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSSessionUpdateResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSSessionUpdateResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value                        */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateFailureIEs_Value *pvalue = (_MBMSSessionUpdateFailureIEs_Value*) pvalue_;
   asn1Print_SessionUpdateID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value_1                      */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateFailureIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateFailureIEs_Value_1 *pvalue = (_MBMSSessionUpdateFailureIEs_Value_1*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value_2                      */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionUpdateFailureIEs_Value_2
   (const char* name, void* pvalue_)
{
   _MBMSSessionUpdateFailureIEs_Value_2 *pvalue = (_MBMSSessionUpdateFailureIEs_Value_2*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs_element              */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateFailure_protocolIEs_element
   (const char* name, MBMSSessionUpdateFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionUpdateFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSSessionUpdateFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs                      */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateFailure_protocolIEs
   (const char* name, MBMSSessionUpdateFailure_protocolIEs* pvalue)
{
   MBMSSessionUpdateFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionUpdateFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionUpdateFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateFailure_protocolExtensions_element
   (const char* name, MBMSSessionUpdateFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionUpdateFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSSessionUpdateFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateFailure_protocolExtensions
   (const char* name, MBMSSessionUpdateFailure_protocolExtensions* pvalue)
{
   MBMSSessionUpdateFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionUpdateFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionUpdateFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure                                  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionUpdateFailure
   (const char* name, MBMSSessionUpdateFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSSessionUpdateFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSSessionUpdateFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopIEs_Value                                 */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStopIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSSessionStopIEs_Value *pvalue = (_MBMSSessionStopIEs_Value*) pvalue_;
   asn1Print_MBMSCNDe_Registration (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStop_protocolIEs_element
   (const char* name, MBMSSessionStop_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStopIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSSessionStopIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs                               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStop_protocolIEs
   (const char* name, MBMSSessionStop_protocolIEs* pvalue)
{
   MBMSSessionStop_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStop_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStop_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStop_protocolExtensions_element
   (const char* name, MBMSSessionStop_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStopExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSSessionStopExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions                        */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStop_protocolExtensions
   (const char* name, MBMSSessionStop_protocolExtensions* pvalue)
{
   MBMSSessionStop_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStop_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStop_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop                                           */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStop
   (const char* name, MBMSSessionStop* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSSessionStop_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSSessionStop_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopResponseIEs_Value                         */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStopResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSSessionStopResponseIEs_Value *pvalue = (_MBMSSessionStopResponseIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopResponseIEs_Value_1                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSSessionStopResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSSessionStopResponseIEs_Value_1 *pvalue = (_MBMSSessionStopResponseIEs_Value_1*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs_element               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStopResponse_protocolIEs_element
   (const char* name, MBMSSessionStopResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStopResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSSessionStopResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStopResponse_protocolIEs
   (const char* name, MBMSSessionStopResponse_protocolIEs* pvalue)
{
   MBMSSessionStopResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStopResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStopResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStopResponse_protocolExtensions_element
   (const char* name, MBMSSessionStopResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSSessionStopResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSSessionStopResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions                */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStopResponse_protocolExtensions
   (const char* name, MBMSSessionStopResponse_protocolExtensions* pvalue)
{
   MBMSSessionStopResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSSessionStopResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSSessionStopResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse                                   */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSSessionStopResponse
   (const char* name, MBMSSessionStopResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSSessionStopResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSSessionStopResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingRequestIEs_Value                            */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSUELinkingRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSUELinkingRequestIEs_Value *pvalue = (_MBMSUELinkingRequestIEs_Value*) pvalue_;
   asn1Print_JoinedMBMSBearerService_IEs (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions_element   */
/*                                                            */
/**************************************************************/

void asn1Print_LeftMBMSBearerService_IEs_element_iE_Extensions_element
   (const char* name, LeftMBMSBearerService_IEs_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < LeftMBMSBearerService_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LeftMBMSBearerService_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LeftMBMSBearerService_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      LeftMBMSBearerService_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions           */
/*                                                            */
/**************************************************************/

void asn1Print_LeftMBMSBearerService_IEs_element_iE_Extensions
   (const char* name, LeftMBMSBearerService_IEs_element_iE_Extensions* pvalue)
{
   LeftMBMSBearerService_IEs_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LeftMBMSBearerService_IEs_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LeftMBMSBearerService_IEs_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element                         */
/*                                                            */
/**************************************************************/

void asn1Print_LeftMBMSBearerService_IEs_element
   (const char* name, LeftMBMSBearerService_IEs_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.tMGI", name);
   asn1Print_TMGI (namebuf, &pvalue->tMGI);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_LeftMBMSBearerService_IEs_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs                                 */
/*                                                            */
/**************************************************************/

void asn1Print_LeftMBMSBearerService_IEs
   (const char* name, LeftMBMSBearerService_IEs* pvalue)
{
   LeftMBMSBearerService_IEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (LeftMBMSBearerService_IEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_LeftMBMSBearerService_IEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingRequestIEs_Value_1                          */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSUELinkingRequestIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSUELinkingRequestIEs_Value_1 *pvalue = (_MBMSUELinkingRequestIEs_Value_1*) pvalue_;
   asn1Print_LeftMBMSBearerService_IEs (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingRequest_protocolIEs_element
   (const char* name, MBMSUELinkingRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSUELinkingRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSUELinkingRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs                          */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingRequest_protocolIEs
   (const char* name, MBMSUELinkingRequest_protocolIEs* pvalue)
{
   MBMSUELinkingRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSUELinkingRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSUELinkingRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingRequest_protocolExtensions_element
   (const char* name, MBMSUELinkingRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSUELinkingRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSUELinkingRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions                   */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingRequest_protocolExtensions
   (const char* name, MBMSUELinkingRequest_protocolExtensions* pvalue)
{
   MBMSUELinkingRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSUELinkingRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSUELinkingRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest                                      */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingRequest
   (const char* name, MBMSUELinkingRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSUELinkingRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSUELinkingRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

void asn1Print_UnsuccessfulLinking_IEs_element_iE_Extensions_element
   (const char* name, UnsuccessfulLinking_IEs_element_iE_Extensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < UnsuccessfulLinking_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UnsuccessfulLinking_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UnsuccessfulLinking_ExtIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      UnsuccessfulLinking_ExtIEs[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions             */
/*                                                            */
/**************************************************************/

void asn1Print_UnsuccessfulLinking_IEs_element_iE_Extensions
   (const char* name, UnsuccessfulLinking_IEs_element_iE_Extensions* pvalue)
{
   UnsuccessfulLinking_IEs_element_iE_Extensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UnsuccessfulLinking_IEs_element_iE_Extensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UnsuccessfulLinking_IEs_element_iE_Extensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element                           */
/*                                                            */
/**************************************************************/

void asn1Print_UnsuccessfulLinking_IEs_element
   (const char* name, UnsuccessfulLinking_IEs_element* pvalue)
{
   char namebuf[512];

   printf ("%s.m.iE_ExtensionsPresent = %d\n", name, (int)pvalue->m.iE_ExtensionsPresent);
   sprintf (namebuf, "%s.tMGI", name);
   asn1Print_TMGI (namebuf, &pvalue->tMGI);

   sprintf (namebuf, "%s.cause", name);
   asn1Print_Cause (namebuf, &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      sprintf (namebuf, "%s.iE_Extensions", name);
      asn1Print_UnsuccessfulLinking_IEs_element_iE_Extensions (namebuf, &pvalue->iE_Extensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs                                   */
/*                                                            */
/**************************************************************/

void asn1Print_UnsuccessfulLinking_IEs
   (const char* name, UnsuccessfulLinking_IEs* pvalue)
{
   UnsuccessfulLinking_IEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (UnsuccessfulLinking_IEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_UnsuccessfulLinking_IEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingResponseIEs_Value                           */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSUELinkingResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSUELinkingResponseIEs_Value *pvalue = (_MBMSUELinkingResponseIEs_Value*) pvalue_;
   asn1Print_UnsuccessfulLinking_IEs (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingResponseIEs_Value_1                         */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSUELinkingResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSUELinkingResponseIEs_Value_1 *pvalue = (_MBMSUELinkingResponseIEs_Value_1*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingResponse_protocolIEs_element
   (const char* name, MBMSUELinkingResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSUELinkingResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSUELinkingResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs                         */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingResponse_protocolIEs
   (const char* name, MBMSUELinkingResponse_protocolIEs* pvalue)
{
   MBMSUELinkingResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSUELinkingResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSUELinkingResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingResponse_protocolExtensions_element
   (const char* name, MBMSUELinkingResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSUELinkingResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSUELinkingResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions                  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingResponse_protocolExtensions
   (const char* name, MBMSUELinkingResponse_protocolExtensions* pvalue)
{
   MBMSUELinkingResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSUELinkingResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSUELinkingResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse                                     */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSUELinkingResponse
   (const char* name, MBMSUELinkingResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSUELinkingResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSUELinkingResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value                         */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationRequestIEs_Value *pvalue = (_MBMSRegistrationRequestIEs_Value*) pvalue_;
   asn1Print_MBMSRegistrationRequestType (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_1                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationRequestIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationRequestIEs_Value_1 *pvalue = (_MBMSRegistrationRequestIEs_Value_1*) pvalue_;
   asn1Print_TMGI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_2                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationRequestIEs_Value_2
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationRequestIEs_Value_2 *pvalue = (_MBMSRegistrationRequestIEs_Value_2*) pvalue_;
   asn1Print_IPMulticastAddress (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_3                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationRequestIEs_Value_3
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationRequestIEs_Value_3 *pvalue = (_MBMSRegistrationRequestIEs_Value_3*) pvalue_;
   asn1Print_APN (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_4                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationRequestIEs_Value_4
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationRequestIEs_Value_4 *pvalue = (_MBMSRegistrationRequestIEs_Value_4*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationRequest_protocolIEs_element
   (const char* name, MBMSRegistrationRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRegistrationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSRegistrationRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationRequest_protocolIEs
   (const char* name, MBMSRegistrationRequest_protocolIEs* pvalue)
{
   MBMSRegistrationRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRegistrationRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRegistrationRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationRequest_protocolExtensions_element
   (const char* name, MBMSRegistrationRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRegistrationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSRegistrationRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions                */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationRequest_protocolExtensions
   (const char* name, MBMSRegistrationRequest_protocolExtensions* pvalue)
{
   MBMSRegistrationRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRegistrationRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRegistrationRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest                                   */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationRequest
   (const char* name, MBMSRegistrationRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSRegistrationRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSRegistrationRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value                        */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationResponseIEs_Value *pvalue = (_MBMSRegistrationResponseIEs_Value*) pvalue_;
   asn1Print_TMGI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value_1                      */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationResponseIEs_Value_1 *pvalue = (_MBMSRegistrationResponseIEs_Value_1*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value_2                      */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationResponseIEs_Value_2
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationResponseIEs_Value_2 *pvalue = (_MBMSRegistrationResponseIEs_Value_2*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationResponse_protocolIEs_element
   (const char* name, MBMSRegistrationResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRegistrationResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSRegistrationResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs                      */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationResponse_protocolIEs
   (const char* name, MBMSRegistrationResponse_protocolIEs* pvalue)
{
   MBMSRegistrationResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRegistrationResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRegistrationResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationResponse_protocolExtensions_element
   (const char* name, MBMSRegistrationResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRegistrationResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSRegistrationResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationResponse_protocolExtensions
   (const char* name, MBMSRegistrationResponse_protocolExtensions* pvalue)
{
   MBMSRegistrationResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRegistrationResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRegistrationResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse                                  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationResponse
   (const char* name, MBMSRegistrationResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSRegistrationResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSRegistrationResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value                         */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationFailureIEs_Value *pvalue = (_MBMSRegistrationFailureIEs_Value*) pvalue_;
   asn1Print_TMGI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_1                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationFailureIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationFailureIEs_Value_1 *pvalue = (_MBMSRegistrationFailureIEs_Value_1*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_2                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationFailureIEs_Value_2
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationFailureIEs_Value_2 *pvalue = (_MBMSRegistrationFailureIEs_Value_2*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_3                       */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRegistrationFailureIEs_Value_3
   (const char* name, void* pvalue_)
{
   _MBMSRegistrationFailureIEs_Value_3 *pvalue = (_MBMSRegistrationFailureIEs_Value_3*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationFailure_protocolIEs_element
   (const char* name, MBMSRegistrationFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRegistrationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSRegistrationFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs                       */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationFailure_protocolIEs
   (const char* name, MBMSRegistrationFailure_protocolIEs* pvalue)
{
   MBMSRegistrationFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRegistrationFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRegistrationFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationFailure_protocolExtensions_element
   (const char* name, MBMSRegistrationFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRegistrationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSRegistrationFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions                */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationFailure_protocolExtensions
   (const char* name, MBMSRegistrationFailure_protocolExtensions* pvalue)
{
   MBMSRegistrationFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRegistrationFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRegistrationFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure                                   */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRegistrationFailure
   (const char* name, MBMSRegistrationFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSRegistrationFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSRegistrationFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationRequestIEs_Value                    */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSCNDe_RegistrationRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSCNDe_RegistrationRequestIEs_Value *pvalue = (_MBMSCNDe_RegistrationRequestIEs_Value*) pvalue_;
   asn1Print_TMGI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationRequestIEs_Value_1                  */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSCNDe_RegistrationRequestIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSCNDe_RegistrationRequestIEs_Value_1 *pvalue = (_MBMSCNDe_RegistrationRequestIEs_Value_1*) pvalue_;
   asn1Print_GlobalCN_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs_element          */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationRequest_protocolIEs_element
   (const char* name, MBMSCNDe_RegistrationRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSCNDe_RegistrationRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs                  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationRequest_protocolIEs
   (const char* name, MBMSCNDe_RegistrationRequest_protocolIEs* pvalue)
{
   MBMSCNDe_RegistrationRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSCNDe_RegistrationRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSCNDe_RegistrationRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationRequest_protocolExtensions_element
   (const char* name, MBMSCNDe_RegistrationRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSCNDe_RegistrationRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions           */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationRequest_protocolExtensions
   (const char* name, MBMSCNDe_RegistrationRequest_protocolExtensions* pvalue)
{
   MBMSCNDe_RegistrationRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSCNDe_RegistrationRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSCNDe_RegistrationRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest                              */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationRequest
   (const char* name, MBMSCNDe_RegistrationRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSCNDe_RegistrationRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSCNDe_RegistrationRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value                   */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSCNDe_RegistrationResponseIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSCNDe_RegistrationResponseIEs_Value *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value*) pvalue_;
   asn1Print_TMGI (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_1                 */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSCNDe_RegistrationResponseIEs_Value_1
   (const char* name, void* pvalue_)
{
   _MBMSCNDe_RegistrationResponseIEs_Value_1 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_1*) pvalue_;
   asn1Print_GlobalRNC_ID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_2                 */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSCNDe_RegistrationResponseIEs_Value_2
   (const char* name, void* pvalue_)
{
   _MBMSCNDe_RegistrationResponseIEs_Value_2 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_2*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_3                 */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSCNDe_RegistrationResponseIEs_Value_3
   (const char* name, void* pvalue_)
{
   _MBMSCNDe_RegistrationResponseIEs_Value_3 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_3*) pvalue_;
   asn1Print_CriticalityDiagnostics (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs_element         */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationResponse_protocolIEs_element
   (const char* name, MBMSCNDe_RegistrationResponse_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationResponseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSCNDe_RegistrationResponseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs                 */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationResponse_protocolIEs
   (const char* name, MBMSCNDe_RegistrationResponse_protocolIEs* pvalue)
{
   MBMSCNDe_RegistrationResponse_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSCNDe_RegistrationResponse_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSCNDe_RegistrationResponse_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationResponse_protocolExtensions_element
   (const char* name, MBMSCNDe_RegistrationResponse_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationResponseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSCNDe_RegistrationResponseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions          */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationResponse_protocolExtensions
   (const char* name, MBMSCNDe_RegistrationResponse_protocolExtensions* pvalue)
{
   MBMSCNDe_RegistrationResponse_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSCNDe_RegistrationResponse_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSCNDe_RegistrationResponse_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse                             */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSCNDe_RegistrationResponse
   (const char* name, MBMSCNDe_RegistrationResponse* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSCNDe_RegistrationResponse_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSCNDe_RegistrationResponse_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSRABEstablishmentIndicationIEs_Value                  */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRABEstablishmentIndicationIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSRABEstablishmentIndicationIEs_Value *pvalue = (_MBMSRABEstablishmentIndicationIEs_Value*) pvalue_;
   asn1Print_TransportLayerInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs_element        */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABEstablishmentIndication_protocolIEs_element
   (const char* name, MBMSRABEstablishmentIndication_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRABEstablishmentIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABEstablishmentIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABEstablishmentIndicationIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSRABEstablishmentIndicationIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs                */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABEstablishmentIndication_protocolIEs
   (const char* name, MBMSRABEstablishmentIndication_protocolIEs* pvalue)
{
   MBMSRABEstablishmentIndication_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRABEstablishmentIndication_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRABEstablishmentIndication_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions_elemen  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABEstablishmentIndication_protocolExtensions_element
   (const char* name, MBMSRABEstablishmentIndication_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRABEstablishmentIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABEstablishmentIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABEstablishmentIndicationExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSRABEstablishmentIndicationExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions         */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABEstablishmentIndication_protocolExtensions
   (const char* name, MBMSRABEstablishmentIndication_protocolExtensions* pvalue)
{
   MBMSRABEstablishmentIndication_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRABEstablishmentIndication_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRABEstablishmentIndication_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication                            */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABEstablishmentIndication
   (const char* name, MBMSRABEstablishmentIndication* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSRABEstablishmentIndication_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSRABEstablishmentIndication_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseRequestIEs_Value                           */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRABReleaseRequestIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSRABReleaseRequestIEs_Value *pvalue = (_MBMSRABReleaseRequestIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseRequest_protocolIEs_element
   (const char* name, MBMSRABReleaseRequest_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRABReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseRequestIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSRABReleaseRequestIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs                         */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseRequest_protocolIEs
   (const char* name, MBMSRABReleaseRequest_protocolIEs* pvalue)
{
   MBMSRABReleaseRequest_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRABReleaseRequest_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRABReleaseRequest_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseRequest_protocolExtensions_element
   (const char* name, MBMSRABReleaseRequest_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRABReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseRequestExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSRABReleaseRequestExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions                  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseRequest_protocolExtensions
   (const char* name, MBMSRABReleaseRequest_protocolExtensions* pvalue)
{
   MBMSRABReleaseRequest_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRABReleaseRequest_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRABReleaseRequest_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest                                     */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseRequest
   (const char* name, MBMSRABReleaseRequest* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSRABReleaseRequest_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSRABReleaseRequest_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseIEs_Value                                  */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRABReleaseIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSRABReleaseIEs_Value *pvalue = (_MBMSRABReleaseIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABRelease_protocolIEs_element
   (const char* name, MBMSRABRelease_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRABReleaseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSRABReleaseIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs                                */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABRelease_protocolIEs
   (const char* name, MBMSRABRelease_protocolIEs* pvalue)
{
   MBMSRABRelease_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRABRelease_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRABRelease_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABRelease_protocolExtensions_element
   (const char* name, MBMSRABRelease_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRABReleaseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSRABReleaseExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions                         */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABRelease_protocolExtensions
   (const char* name, MBMSRABRelease_protocolExtensions* pvalue)
{
   MBMSRABRelease_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRABRelease_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRABRelease_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease                                            */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABRelease
   (const char* name, MBMSRABRelease* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSRABRelease_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSRABRelease_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseFailureIEs_Value                           */
/*                                                            */
/**************************************************************/

void asn1Print__MBMSRABReleaseFailureIEs_Value
   (const char* name, void* pvalue_)
{
   _MBMSRABReleaseFailureIEs_Value *pvalue = (_MBMSRABReleaseFailureIEs_Value*) pvalue_;
   asn1Print_Cause (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseFailure_protocolIEs_element
   (const char* name, MBMSRABReleaseFailure_protocolIEs_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRABReleaseFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseFailureIEs_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolIE_ID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      MBMSRABReleaseFailureIEs[index].printValue(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs                         */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseFailure_protocolIEs
   (const char* name, MBMSRABReleaseFailure_protocolIEs* pvalue)
{
   MBMSRABReleaseFailure_protocolIEs_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRABReleaseFailure_protocolIEs_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRABReleaseFailure_protocolIEs_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseFailure_protocolExtensions_element
   (const char* name, MBMSRABReleaseFailure_protocolExtensions_element* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check id */
   for(index = 0; index < MBMSRABReleaseFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseFailureExtensions_Size) index = -1;

   sprintf (namebuf, "%s.id", name);
   asn1Print_ProtocolExtensionID (namebuf, &pvalue->id);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.extensionValue", name);
   if (index != -1){
      MBMSRABReleaseFailureExtensions[index].printExtension(namebuf, pvalue->extensionValue.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->extensionValue.encoded.numocts,
         pvalue->extensionValue.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions                  */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseFailure_protocolExtensions
   (const char* name, MBMSRABReleaseFailure_protocolExtensions* pvalue)
{
   MBMSRABReleaseFailure_protocolExtensions_element* pdata;
   Asn1RTDListNode* pnode;
   char namebuf[512];

   printf ("%s.count = %d\n", name, pvalue->count);
   {
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata = (MBMSRABReleaseFailure_protocolExtensions_element*) pnode->data;
      sprintf (namebuf, "%s.elem[%d]", name, xx1);
      asn1Print_MBMSRABReleaseFailure_protocolExtensions_element (namebuf, pdata);
      pnode = pnode->next;
   }
   }
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure                                     */
/*                                                            */
/**************************************************************/

void asn1Print_MBMSRABReleaseFailure
   (const char* name, MBMSRABReleaseFailure* pvalue)
{
   char namebuf[512];

   printf ("%s.m.protocolExtensionsPresent = %d\n", name, (int)pvalue->m.protocolExtensionsPresent);
   sprintf (namebuf, "%s.protocolIEs", name);
   asn1Print_MBMSRABReleaseFailure_protocolIEs (namebuf, &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      sprintf (namebuf, "%s.protocolExtensions", name);
      asn1Print_MBMSRABReleaseFailure_protocolExtensions (namebuf, &pvalue->protocolExtensions);
   }

   sprintf (namebuf, "%s.extElem1", name);
   rtPrintOpenTypeExt (namebuf, &pvalue->extElem1);

}

/**************************************************************/
/*                                                            */
/*  _iu_Release_InitiatingMessage                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__iu_Release_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _iu_Release_InitiatingMessage *pvalue = (_iu_Release_InitiatingMessage*) pvalue_;

   stat = asn1PD_Iu_ReleaseCommand (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _iu_Release_SuccessfulOutcome                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__iu_Release_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _iu_Release_SuccessfulOutcome *pvalue = (_iu_Release_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_Iu_ReleaseComplete (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationPreparation_InitiatingMessage                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationPreparation_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationPreparation_InitiatingMessage *pvalue = (_relocationPreparation_InitiatingMessage*) pvalue_;

   stat = asn1PD_RelocationRequired (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationPreparation_SuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationPreparation_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationPreparation_SuccessfulOutcome *pvalue = (_relocationPreparation_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_RelocationCommand (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationPreparation_UnsuccessfulOutcome                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationPreparation_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationPreparation_UnsuccessfulOutcome *pvalue = (_relocationPreparation_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_RelocationPreparationFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationResourceAllocation_InitiatingMessage           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationResourceAllocation_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationResourceAllocation_InitiatingMessage *pvalue = (_relocationResourceAllocation_InitiatingMessage*) pvalue_;

   stat = asn1PD_RelocationRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationResourceAllocation_SuccessfulOutcome           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationResourceAllocation_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationResourceAllocation_SuccessfulOutcome *pvalue = (_relocationResourceAllocation_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_RelocationRequestAcknowledge (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationResourceAllocation_UnsuccessfulOutcome         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationResourceAllocation_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationResourceAllocation_UnsuccessfulOutcome *pvalue = (_relocationResourceAllocation_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_RelocationFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationCancel_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationCancel_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationCancel_InitiatingMessage *pvalue = (_relocationCancel_InitiatingMessage*) pvalue_;

   stat = asn1PD_RelocationCancel (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationCancel_SuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationCancel_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationCancel_SuccessfulOutcome *pvalue = (_relocationCancel_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_RelocationCancelAcknowledge (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _sRNS_ContextTransfer_InitiatingMessage                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__sRNS_ContextTransfer_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _sRNS_ContextTransfer_InitiatingMessage *pvalue = (_sRNS_ContextTransfer_InitiatingMessage*) pvalue_;

   stat = asn1PD_SRNS_ContextRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _sRNS_ContextTransfer_SuccessfulOutcome                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__sRNS_ContextTransfer_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _sRNS_ContextTransfer_SuccessfulOutcome *pvalue = (_sRNS_ContextTransfer_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_SRNS_ContextResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _securityModeControl_InitiatingMessage                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__securityModeControl_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _securityModeControl_InitiatingMessage *pvalue = (_securityModeControl_InitiatingMessage*) pvalue_;

   stat = asn1PD_SecurityModeCommand (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _securityModeControl_SuccessfulOutcome                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__securityModeControl_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _securityModeControl_SuccessfulOutcome *pvalue = (_securityModeControl_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_SecurityModeComplete (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _securityModeControl_UnsuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__securityModeControl_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _securityModeControl_UnsuccessfulOutcome *pvalue = (_securityModeControl_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_SecurityModeReject (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _dataVolumeReport_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__dataVolumeReport_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _dataVolumeReport_InitiatingMessage *pvalue = (_dataVolumeReport_InitiatingMessage*) pvalue_;

   stat = asn1PD_DataVolumeReportRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _dataVolumeReport_SuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__dataVolumeReport_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _dataVolumeReport_SuccessfulOutcome *pvalue = (_dataVolumeReport_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_DataVolumeReport (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _reset_InitiatingMessage                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__reset_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _reset_InitiatingMessage *pvalue = (_reset_InitiatingMessage*) pvalue_;

   stat = asn1PD_Reset (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _reset_SuccessfulOutcome                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__reset_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _reset_SuccessfulOutcome *pvalue = (_reset_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_ResetAcknowledge (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _rAB_ReleaseRequest_InitiatingMessage                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__rAB_ReleaseRequest_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _rAB_ReleaseRequest_InitiatingMessage *pvalue = (_rAB_ReleaseRequest_InitiatingMessage*) pvalue_;

   stat = asn1PD_RAB_ReleaseRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _iu_ReleaseRequest_InitiatingMessage                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__iu_ReleaseRequest_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _iu_ReleaseRequest_InitiatingMessage *pvalue = (_iu_ReleaseRequest_InitiatingMessage*) pvalue_;

   stat = asn1PD_Iu_ReleaseRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationDetect_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationDetect_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationDetect_InitiatingMessage *pvalue = (_relocationDetect_InitiatingMessage*) pvalue_;

   stat = asn1PD_RelocationDetect (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _relocationComplete_InitiatingMessage                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__relocationComplete_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _relocationComplete_InitiatingMessage *pvalue = (_relocationComplete_InitiatingMessage*) pvalue_;

   stat = asn1PD_RelocationComplete (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _paging_InitiatingMessage                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__paging_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _paging_InitiatingMessage *pvalue = (_paging_InitiatingMessage*) pvalue_;

   stat = asn1PD_Paging (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _commonID_InitiatingMessage                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__commonID_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _commonID_InitiatingMessage *pvalue = (_commonID_InitiatingMessage*) pvalue_;

   stat = asn1PD_CommonID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _cN_InvokeTrace_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__cN_InvokeTrace_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _cN_InvokeTrace_InitiatingMessage *pvalue = (_cN_InvokeTrace_InitiatingMessage*) pvalue_;

   stat = asn1PD_CN_InvokeTrace (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _cN_DeactivateTrace_InitiatingMessage                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__cN_DeactivateTrace_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _cN_DeactivateTrace_InitiatingMessage *pvalue = (_cN_DeactivateTrace_InitiatingMessage*) pvalue_;

   stat = asn1PD_CN_DeactivateTrace (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _locationReportingControl_InitiatingMessage               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__locationReportingControl_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _locationReportingControl_InitiatingMessage *pvalue = (_locationReportingControl_InitiatingMessage*) pvalue_;

   stat = asn1PD_LocationReportingControl (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _locationReport_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__locationReport_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _locationReport_InitiatingMessage *pvalue = (_locationReport_InitiatingMessage*) pvalue_;

   stat = asn1PD_LocationReport (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _initialUE_Message_InitiatingMessage                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__initialUE_Message_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _initialUE_Message_InitiatingMessage *pvalue = (_initialUE_Message_InitiatingMessage*) pvalue_;

   stat = asn1PD_InitialUE_Message (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _directTransfer_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__directTransfer_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _directTransfer_InitiatingMessage *pvalue = (_directTransfer_InitiatingMessage*) pvalue_;

   stat = asn1PD_DirectTransfer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _overloadControl_InitiatingMessage                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__overloadControl_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _overloadControl_InitiatingMessage *pvalue = (_overloadControl_InitiatingMessage*) pvalue_;

   stat = asn1PD_Overload (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _errorIndication_InitiatingMessage                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__errorIndication_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _errorIndication_InitiatingMessage *pvalue = (_errorIndication_InitiatingMessage*) pvalue_;

   stat = asn1PD_ErrorIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _sRNS_DataForward_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__sRNS_DataForward_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _sRNS_DataForward_InitiatingMessage *pvalue = (_sRNS_DataForward_InitiatingMessage*) pvalue_;

   stat = asn1PD_SRNS_DataForwardCommand (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _forwardSRNS_Context_InitiatingMessage                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__forwardSRNS_Context_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _forwardSRNS_Context_InitiatingMessage *pvalue = (_forwardSRNS_Context_InitiatingMessage*) pvalue_;

   stat = asn1PD_ForwardSRNS_Context (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _rAB_Assignment_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__rAB_Assignment_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _rAB_Assignment_InitiatingMessage *pvalue = (_rAB_Assignment_InitiatingMessage*) pvalue_;

   stat = asn1PD_RAB_AssignmentRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _rAB_Assignment_Outcome                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__rAB_Assignment_Outcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _rAB_Assignment_Outcome *pvalue = (_rAB_Assignment_Outcome*) pvalue_;

   stat = asn1PD_RAB_AssignmentResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _privateMessage_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__privateMessage_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _privateMessage_InitiatingMessage *pvalue = (_privateMessage_InitiatingMessage*) pvalue_;

   stat = asn1PD_PrivateMessage (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _resetResource_InitiatingMessage                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__resetResource_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _resetResource_InitiatingMessage *pvalue = (_resetResource_InitiatingMessage*) pvalue_;

   stat = asn1PD_ResetResource (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _resetResource_SuccessfulOutcome                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__resetResource_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _resetResource_SuccessfulOutcome *pvalue = (_resetResource_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_ResetResourceAcknowledge (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _rANAP_Relocation_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__rANAP_Relocation_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _rANAP_Relocation_InitiatingMessage *pvalue = (_rANAP_Relocation_InitiatingMessage*) pvalue_;

   stat = asn1PD_RANAP_RelocationInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _rAB_ModifyRequest_InitiatingMessage                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__rAB_ModifyRequest_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _rAB_ModifyRequest_InitiatingMessage *pvalue = (_rAB_ModifyRequest_InitiatingMessage*) pvalue_;

   stat = asn1PD_RAB_ModifyRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _locationRelatedData_InitiatingMessage                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__locationRelatedData_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _locationRelatedData_InitiatingMessage *pvalue = (_locationRelatedData_InitiatingMessage*) pvalue_;

   stat = asn1PD_LocationRelatedDataRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _locationRelatedData_SuccessfulOutcome                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__locationRelatedData_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _locationRelatedData_SuccessfulOutcome *pvalue = (_locationRelatedData_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_LocationRelatedDataResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _locationRelatedData_UnsuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__locationRelatedData_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _locationRelatedData_UnsuccessfulOutcome *pvalue = (_locationRelatedData_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_LocationRelatedDataFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _informationTransfer_InitiatingMessage                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__informationTransfer_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _informationTransfer_InitiatingMessage *pvalue = (_informationTransfer_InitiatingMessage*) pvalue_;

   stat = asn1PD_InformationTransferIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _informationTransfer_SuccessfulOutcome                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__informationTransfer_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _informationTransfer_SuccessfulOutcome *pvalue = (_informationTransfer_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_InformationTransferConfirmation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _informationTransfer_UnsuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__informationTransfer_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _informationTransfer_UnsuccessfulOutcome *pvalue = (_informationTransfer_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_InformationTransferFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _uESpecificInformation_InitiatingMessage                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__uESpecificInformation_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _uESpecificInformation_InitiatingMessage *pvalue = (_uESpecificInformation_InitiatingMessage*) pvalue_;

   stat = asn1PD_UESpecificInformationIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _directInformationTransfer_InitiatingMessage              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__directInformationTransfer_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _directInformationTransfer_InitiatingMessage *pvalue = (_directInformationTransfer_InitiatingMessage*) pvalue_;

   stat = asn1PD_DirectInformationTransfer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _uplinkInformationExchange_InitiatingMessage              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__uplinkInformationExchange_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _uplinkInformationExchange_InitiatingMessage *pvalue = (_uplinkInformationExchange_InitiatingMessage*) pvalue_;

   stat = asn1PD_UplinkInformationExchangeRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _uplinkInformationExchange_SuccessfulOutcome              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__uplinkInformationExchange_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _uplinkInformationExchange_SuccessfulOutcome *pvalue = (_uplinkInformationExchange_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_UplinkInformationExchangeResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _uplinkInformationExchange_UnsuccessfulOutcome            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__uplinkInformationExchange_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _uplinkInformationExchange_UnsuccessfulOutcome *pvalue = (_uplinkInformationExchange_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_UplinkInformationExchangeFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStart_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSSessionStart_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSSessionStart_InitiatingMessage *pvalue = (_mBMSSessionStart_InitiatingMessage*) pvalue_;

   stat = asn1PD_MBMSSessionStart (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStart_SuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSSessionStart_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSSessionStart_SuccessfulOutcome *pvalue = (_mBMSSessionStart_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSSessionStartResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStart_UnsuccessfulOutcome                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSSessionStart_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSSessionStart_UnsuccessfulOutcome *pvalue = (_mBMSSessionStart_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSSessionStartFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionUpdate_InitiatingMessage                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSSessionUpdate_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSSessionUpdate_InitiatingMessage *pvalue = (_mBMSSessionUpdate_InitiatingMessage*) pvalue_;

   stat = asn1PD_MBMSSessionUpdate (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionUpdate_SuccessfulOutcome                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSSessionUpdate_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSSessionUpdate_SuccessfulOutcome *pvalue = (_mBMSSessionUpdate_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSSessionUpdateResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionUpdate_UnsuccessfulOutcome                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSSessionUpdate_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSSessionUpdate_UnsuccessfulOutcome *pvalue = (_mBMSSessionUpdate_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSSessionUpdateFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStop_InitiatingMessage                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSSessionStop_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSSessionStop_InitiatingMessage *pvalue = (_mBMSSessionStop_InitiatingMessage*) pvalue_;

   stat = asn1PD_MBMSSessionStop (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStop_SuccessfulOutcome                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSSessionStop_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSSessionStop_SuccessfulOutcome *pvalue = (_mBMSSessionStop_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSSessionStopResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSUELinking_InitiatingMessage                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSUELinking_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSUELinking_InitiatingMessage *pvalue = (_mBMSUELinking_InitiatingMessage*) pvalue_;

   stat = asn1PD_MBMSUELinkingRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSUELinking_Outcome                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSUELinking_Outcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSUELinking_Outcome *pvalue = (_mBMSUELinking_Outcome*) pvalue_;

   stat = asn1PD_MBMSUELinkingResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRegistration_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSRegistration_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSRegistration_InitiatingMessage *pvalue = (_mBMSRegistration_InitiatingMessage*) pvalue_;

   stat = asn1PD_MBMSRegistrationRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRegistration_SuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSRegistration_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSRegistration_SuccessfulOutcome *pvalue = (_mBMSRegistration_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSRegistrationResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRegistration_UnsuccessfulOutcome                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSRegistration_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSRegistration_UnsuccessfulOutcome *pvalue = (_mBMSRegistration_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSRegistrationFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSCNDe_Registration_InitiatingMessage                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSCNDe_Registration_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSCNDe_Registration_InitiatingMessage *pvalue = (_mBMSCNDe_Registration_InitiatingMessage*) pvalue_;

   stat = asn1PD_MBMSCNDe_RegistrationRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSCNDe_Registration_SuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSCNDe_Registration_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSCNDe_Registration_SuccessfulOutcome *pvalue = (_mBMSCNDe_Registration_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSCNDe_RegistrationResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRABEstablishmentIndication_InitiatingMessage         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSRABEstablishmentIndication_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSRABEstablishmentIndication_InitiatingMessage *pvalue = (_mBMSRABEstablishmentIndication_InitiatingMessage*) pvalue_;

   stat = asn1PD_MBMSRABEstablishmentIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRABRelease_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSRABRelease_InitiatingMessage (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSRABRelease_InitiatingMessage *pvalue = (_mBMSRABRelease_InitiatingMessage*) pvalue_;

   stat = asn1PD_MBMSRABReleaseRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRABRelease_SuccessfulOutcome                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSRABRelease_SuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSRABRelease_SuccessfulOutcome *pvalue = (_mBMSRABRelease_SuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSRABRelease (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRABRelease_UnsuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__mBMSRABRelease_UnsuccessfulOutcome (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _mBMSRABRelease_UnsuccessfulOutcome *pvalue = (_mBMSRABRelease_UnsuccessfulOutcome*) pvalue_;

   stat = asn1PD_MBMSRABReleaseFailure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitiatingMessage                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitiatingMessage (ASN1CTXT* pctxt, InitiatingMessage* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode procedureCode */

   stat = asn1PD_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InitiatingMessage (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitiatingMessage                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InitiatingMessage (ASN1CTXT* pctxt,
   InitiatingMessage *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check procedureCode */
   for(index = 0; index < RANAP_ELEMENTARY_PROCEDURES_Size; index++) {
      if(rtCmpTCUINT8(&pvalue->procedureCode, &RANAP_ELEMENTARY_PROCEDURES[index].procedureCode) == 0) {
         break;
      }
   }
   if(index == RANAP_ELEMENTARY_PROCEDURES_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RANAP_ELEMENTARY_PROCEDURES[index].InitiatingMessageSize);
   stat = RANAP_ELEMENTARY_PROCEDURES[index].decodeInitiatingMessage(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SuccessfulOutcome                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SuccessfulOutcome (ASN1CTXT* pctxt, SuccessfulOutcome* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode procedureCode */

   stat = asn1PD_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SuccessfulOutcome (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SuccessfulOutcome                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SuccessfulOutcome (ASN1CTXT* pctxt,
   SuccessfulOutcome *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check procedureCode */
   for(index = 0; index < RANAP_ELEMENTARY_PROCEDURES_Size; index++) {
      if(rtCmpTCUINT8(&pvalue->procedureCode, &RANAP_ELEMENTARY_PROCEDURES[index].procedureCode) == 0) {
         break;
      }
   }
   if(index == RANAP_ELEMENTARY_PROCEDURES_Size) return 0;

   /* check value */
   if(RANAP_ELEMENTARY_PROCEDURES[index].m.SuccessfulOutcomePresent)
   {
      stat = pd_setp (pctxt,
            (OSOCTET*)pvalue->value.encoded.data,
            pvalue->value.encoded.numocts,
            pctxt->buffer.aligned);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pvalue->value.decoded = rtMemAlloc (pctxt, RANAP_ELEMENTARY_PROCEDURES[index].SuccessfulOutcomeSize);
      stat = RANAP_ELEMENTARY_PROCEDURES[index].decodeSuccessfulOutcome(pctxt, pvalue->value.decoded );
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulOutcome                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulOutcome (ASN1CTXT* pctxt, UnsuccessfulOutcome* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode procedureCode */

   stat = asn1PD_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UnsuccessfulOutcome (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulOutcome                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UnsuccessfulOutcome (ASN1CTXT* pctxt,
   UnsuccessfulOutcome *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check procedureCode */
   for(index = 0; index < RANAP_ELEMENTARY_PROCEDURES_Size; index++) {
      if(rtCmpTCUINT8(&pvalue->procedureCode, &RANAP_ELEMENTARY_PROCEDURES[index].procedureCode) == 0) {
         break;
      }
   }
   if(index == RANAP_ELEMENTARY_PROCEDURES_Size) return 0;

   /* check value */
   if(RANAP_ELEMENTARY_PROCEDURES[index].m.UnsuccessfulOutcomePresent)
   {
      stat = pd_setp (pctxt,
            (OSOCTET*)pvalue->value.encoded.data,
            pvalue->value.encoded.numocts,
            pctxt->buffer.aligned);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pvalue->value.decoded = rtMemAlloc (pctxt, RANAP_ELEMENTARY_PROCEDURES[index].UnsuccessfulOutcomeSize);
      stat = RANAP_ELEMENTARY_PROCEDURES[index].decodeUnsuccessfulOutcome(pctxt, pvalue->value.decoded );
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Outcome                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Outcome (ASN1CTXT* pctxt, Outcome* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode procedureCode */

   stat = asn1PD_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Outcome (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Outcome                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Outcome (ASN1CTXT* pctxt,
   Outcome *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check procedureCode */
   for(index = 0; index < RANAP_ELEMENTARY_PROCEDURES_Size; index++) {
      if(rtCmpTCUINT8(&pvalue->procedureCode, &RANAP_ELEMENTARY_PROCEDURES[index].procedureCode) == 0) {
         break;
      }
   }
   if(index == RANAP_ELEMENTARY_PROCEDURES_Size) return 0;

   /* check value */
   if(RANAP_ELEMENTARY_PROCEDURES[index].m.OutcomePresent)
   {
      stat = pd_setp (pctxt,
            (OSOCTET*)pvalue->value.encoded.data,
            pvalue->value.encoded.numocts,
            pctxt->buffer.aligned);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pvalue->value.decoded = rtMemAlloc (pctxt, RANAP_ELEMENTARY_PROCEDURES[index].OutcomeSize);
      stat = RANAP_ELEMENTARY_PROCEDURES[index].decodeOutcome(pctxt, pvalue->value.decoded );
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RANAP_PDU                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_PDU (ASN1CTXT* pctxt, RANAP_PDU* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* initiatingMessage */
         case 0:
            pvalue->u.initiatingMessage = rtMemAllocTypeZ (pctxt, InitiatingMessage);
            if (pvalue->u.initiatingMessage == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_InitiatingMessage (pctxt, pvalue->u.initiatingMessage);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* successfulOutcome */
         case 1:
            pvalue->u.successfulOutcome = rtMemAllocTypeZ (pctxt, SuccessfulOutcome);
            if (pvalue->u.successfulOutcome == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SuccessfulOutcome (pctxt, pvalue->u.successfulOutcome);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* unsuccessfulOutcome */
         case 2:
            pvalue->u.unsuccessfulOutcome = rtMemAllocTypeZ (pctxt, UnsuccessfulOutcome);
            if (pvalue->u.unsuccessfulOutcome == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_UnsuccessfulOutcome (pctxt, pvalue->u.unsuccessfulOutcome);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* outcome */
         case 3:
            pvalue->u.outcome = rtMemAllocTypeZ (pctxt, Outcome);
            if (pvalue->u.outcome == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Outcome (pctxt, pvalue->u.outcome);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/* Object assignments */
RANAP_ELEMENTARY_PROCEDURE iu_Release;
RANAP_ELEMENTARY_PROCEDURE relocationPreparation;
RANAP_ELEMENTARY_PROCEDURE relocationResourceAllocation;
RANAP_ELEMENTARY_PROCEDURE relocationCancel;
RANAP_ELEMENTARY_PROCEDURE sRNS_ContextTransfer;
RANAP_ELEMENTARY_PROCEDURE securityModeControl;
RANAP_ELEMENTARY_PROCEDURE dataVolumeReport;
RANAP_ELEMENTARY_PROCEDURE reset;
RANAP_ELEMENTARY_PROCEDURE rAB_ReleaseRequest;
RANAP_ELEMENTARY_PROCEDURE iu_ReleaseRequest;
RANAP_ELEMENTARY_PROCEDURE relocationDetect;
RANAP_ELEMENTARY_PROCEDURE relocationComplete;
RANAP_ELEMENTARY_PROCEDURE paging;
RANAP_ELEMENTARY_PROCEDURE commonID;
RANAP_ELEMENTARY_PROCEDURE cN_InvokeTrace;
RANAP_ELEMENTARY_PROCEDURE cN_DeactivateTrace;
RANAP_ELEMENTARY_PROCEDURE locationReportingControl;
RANAP_ELEMENTARY_PROCEDURE locationReport;
RANAP_ELEMENTARY_PROCEDURE initialUE_Message;
RANAP_ELEMENTARY_PROCEDURE directTransfer;
RANAP_ELEMENTARY_PROCEDURE overloadControl;
RANAP_ELEMENTARY_PROCEDURE errorIndication;
RANAP_ELEMENTARY_PROCEDURE sRNS_DataForward;
RANAP_ELEMENTARY_PROCEDURE forwardSRNS_Context;
RANAP_ELEMENTARY_PROCEDURE rAB_Assignment;
RANAP_ELEMENTARY_PROCEDURE privateMessage;
RANAP_ELEMENTARY_PROCEDURE resetResource;
RANAP_ELEMENTARY_PROCEDURE rANAP_Relocation;
RANAP_ELEMENTARY_PROCEDURE rAB_ModifyRequest;
RANAP_ELEMENTARY_PROCEDURE locationRelatedData;
RANAP_ELEMENTARY_PROCEDURE informationTransfer;
RANAP_ELEMENTARY_PROCEDURE uESpecificInformation;
RANAP_ELEMENTARY_PROCEDURE directInformationTransfer;
RANAP_ELEMENTARY_PROCEDURE uplinkInformationExchange;
RANAP_ELEMENTARY_PROCEDURE mBMSSessionStart;
RANAP_ELEMENTARY_PROCEDURE mBMSSessionUpdate;
RANAP_ELEMENTARY_PROCEDURE mBMSSessionStop;
RANAP_ELEMENTARY_PROCEDURE mBMSUELinking;
RANAP_ELEMENTARY_PROCEDURE mBMSRegistration;
RANAP_ELEMENTARY_PROCEDURE mBMSCNDe_Registration;
RANAP_ELEMENTARY_PROCEDURE mBMSRABEstablishmentIndication;
RANAP_ELEMENTARY_PROCEDURE mBMSRABRelease;

void init_RANAP_PDU_DescriptionsObject(ASN1CTXT *pctxt) {

   iu_Release.InitiatingMessageSize = sizeof(_iu_Release_InitiatingMessage);
   iu_Release.decodeInitiatingMessage = &asn1PD__iu_Release_InitiatingMessage;
   iu_Release.printInitiatingMessage = &asn1Print__iu_Release_InitiatingMessage;
   iu_Release.m.SuccessfulOutcomePresent = 1;
   iu_Release.SuccessfulOutcomeSize = sizeof(_iu_Release_SuccessfulOutcome);
   iu_Release.decodeSuccessfulOutcome = &asn1PD__iu_Release_SuccessfulOutcome;
   iu_Release.printSuccessfulOutcome = &asn1Print__iu_Release_SuccessfulOutcome;
   iu_Release.m.UnsuccessfulOutcomePresent = 0;
   iu_Release.m.OutcomePresent = 0;
   iu_Release.procedureCode = 1;
   iu_Release.m.criticalityPresent = 1;
   iu_Release.criticality = reject;

   relocationPreparation.InitiatingMessageSize = sizeof(_relocationPreparation_InitiatingMessage);
   relocationPreparation.decodeInitiatingMessage = &asn1PD__relocationPreparation_InitiatingMessage;
   relocationPreparation.printInitiatingMessage = &asn1Print__relocationPreparation_InitiatingMessage;
   relocationPreparation.m.SuccessfulOutcomePresent = 1;
   relocationPreparation.SuccessfulOutcomeSize = sizeof(_relocationPreparation_SuccessfulOutcome);
   relocationPreparation.decodeSuccessfulOutcome = &asn1PD__relocationPreparation_SuccessfulOutcome;
   relocationPreparation.printSuccessfulOutcome = &asn1Print__relocationPreparation_SuccessfulOutcome;
   relocationPreparation.m.UnsuccessfulOutcomePresent = 1;
   relocationPreparation.UnsuccessfulOutcomeSize = sizeof(_relocationPreparation_UnsuccessfulOutcome);
   relocationPreparation.decodeUnsuccessfulOutcome = &asn1PD__relocationPreparation_UnsuccessfulOutcome;
   relocationPreparation.printUnsuccessfulOutcome = &asn1Print__relocationPreparation_UnsuccessfulOutcome;
   relocationPreparation.m.OutcomePresent = 0;
   relocationPreparation.procedureCode = 2;
   relocationPreparation.m.criticalityPresent = 1;
   relocationPreparation.criticality = reject;

   relocationResourceAllocation.InitiatingMessageSize = sizeof(_relocationResourceAllocation_InitiatingMessage);
   relocationResourceAllocation.decodeInitiatingMessage = &asn1PD__relocationResourceAllocation_InitiatingMessage;
   relocationResourceAllocation.printInitiatingMessage = &asn1Print__relocationResourceAllocation_InitiatingMessage;
   relocationResourceAllocation.m.SuccessfulOutcomePresent = 1;
   relocationResourceAllocation.SuccessfulOutcomeSize = sizeof(_relocationResourceAllocation_SuccessfulOutcome);
   relocationResourceAllocation.decodeSuccessfulOutcome = &asn1PD__relocationResourceAllocation_SuccessfulOutcome;
   relocationResourceAllocation.printSuccessfulOutcome = &asn1Print__relocationResourceAllocation_SuccessfulOutcome;
   relocationResourceAllocation.m.UnsuccessfulOutcomePresent = 1;
   relocationResourceAllocation.UnsuccessfulOutcomeSize = sizeof(_relocationResourceAllocation_UnsuccessfulOutcome);
   relocationResourceAllocation.decodeUnsuccessfulOutcome = &asn1PD__relocationResourceAllocation_UnsuccessfulOutcome;
   relocationResourceAllocation.printUnsuccessfulOutcome = &asn1Print__relocationResourceAllocation_UnsuccessfulOutcome;
   relocationResourceAllocation.m.OutcomePresent = 0;
   relocationResourceAllocation.procedureCode = 3;
   relocationResourceAllocation.m.criticalityPresent = 1;
   relocationResourceAllocation.criticality = reject;

   relocationCancel.InitiatingMessageSize = sizeof(_relocationCancel_InitiatingMessage);
   relocationCancel.decodeInitiatingMessage = &asn1PD__relocationCancel_InitiatingMessage;
   relocationCancel.printInitiatingMessage = &asn1Print__relocationCancel_InitiatingMessage;
   relocationCancel.m.SuccessfulOutcomePresent = 1;
   relocationCancel.SuccessfulOutcomeSize = sizeof(_relocationCancel_SuccessfulOutcome);
   relocationCancel.decodeSuccessfulOutcome = &asn1PD__relocationCancel_SuccessfulOutcome;
   relocationCancel.printSuccessfulOutcome = &asn1Print__relocationCancel_SuccessfulOutcome;
   relocationCancel.m.UnsuccessfulOutcomePresent = 0;
   relocationCancel.m.OutcomePresent = 0;
   relocationCancel.procedureCode = 4;
   relocationCancel.m.criticalityPresent = 1;
   relocationCancel.criticality = reject;

   sRNS_ContextTransfer.InitiatingMessageSize = sizeof(_sRNS_ContextTransfer_InitiatingMessage);
   sRNS_ContextTransfer.decodeInitiatingMessage = &asn1PD__sRNS_ContextTransfer_InitiatingMessage;
   sRNS_ContextTransfer.printInitiatingMessage = &asn1Print__sRNS_ContextTransfer_InitiatingMessage;
   sRNS_ContextTransfer.m.SuccessfulOutcomePresent = 1;
   sRNS_ContextTransfer.SuccessfulOutcomeSize = sizeof(_sRNS_ContextTransfer_SuccessfulOutcome);
   sRNS_ContextTransfer.decodeSuccessfulOutcome = &asn1PD__sRNS_ContextTransfer_SuccessfulOutcome;
   sRNS_ContextTransfer.printSuccessfulOutcome = &asn1Print__sRNS_ContextTransfer_SuccessfulOutcome;
   sRNS_ContextTransfer.m.UnsuccessfulOutcomePresent = 0;
   sRNS_ContextTransfer.m.OutcomePresent = 0;
   sRNS_ContextTransfer.procedureCode = 5;
   sRNS_ContextTransfer.m.criticalityPresent = 1;
   sRNS_ContextTransfer.criticality = reject;

   securityModeControl.InitiatingMessageSize = sizeof(_securityModeControl_InitiatingMessage);
   securityModeControl.decodeInitiatingMessage = &asn1PD__securityModeControl_InitiatingMessage;
   securityModeControl.printInitiatingMessage = &asn1Print__securityModeControl_InitiatingMessage;
   securityModeControl.m.SuccessfulOutcomePresent = 1;
   securityModeControl.SuccessfulOutcomeSize = sizeof(_securityModeControl_SuccessfulOutcome);
   securityModeControl.decodeSuccessfulOutcome = &asn1PD__securityModeControl_SuccessfulOutcome;
   securityModeControl.printSuccessfulOutcome = &asn1Print__securityModeControl_SuccessfulOutcome;
   securityModeControl.m.UnsuccessfulOutcomePresent = 1;
   securityModeControl.UnsuccessfulOutcomeSize = sizeof(_securityModeControl_UnsuccessfulOutcome);
   securityModeControl.decodeUnsuccessfulOutcome = &asn1PD__securityModeControl_UnsuccessfulOutcome;
   securityModeControl.printUnsuccessfulOutcome = &asn1Print__securityModeControl_UnsuccessfulOutcome;
   securityModeControl.m.OutcomePresent = 0;
   securityModeControl.procedureCode = 6;
   securityModeControl.m.criticalityPresent = 1;
   securityModeControl.criticality = reject;

   dataVolumeReport.InitiatingMessageSize = sizeof(_dataVolumeReport_InitiatingMessage);
   dataVolumeReport.decodeInitiatingMessage = &asn1PD__dataVolumeReport_InitiatingMessage;
   dataVolumeReport.printInitiatingMessage = &asn1Print__dataVolumeReport_InitiatingMessage;
   dataVolumeReport.m.SuccessfulOutcomePresent = 1;
   dataVolumeReport.SuccessfulOutcomeSize = sizeof(_dataVolumeReport_SuccessfulOutcome);
   dataVolumeReport.decodeSuccessfulOutcome = &asn1PD__dataVolumeReport_SuccessfulOutcome;
   dataVolumeReport.printSuccessfulOutcome = &asn1Print__dataVolumeReport_SuccessfulOutcome;
   dataVolumeReport.m.UnsuccessfulOutcomePresent = 0;
   dataVolumeReport.m.OutcomePresent = 0;
   dataVolumeReport.procedureCode = 7;
   dataVolumeReport.m.criticalityPresent = 1;
   dataVolumeReport.criticality = reject;

   reset.InitiatingMessageSize = sizeof(_reset_InitiatingMessage);
   reset.decodeInitiatingMessage = &asn1PD__reset_InitiatingMessage;
   reset.printInitiatingMessage = &asn1Print__reset_InitiatingMessage;
   reset.m.SuccessfulOutcomePresent = 1;
   reset.SuccessfulOutcomeSize = sizeof(_reset_SuccessfulOutcome);
   reset.decodeSuccessfulOutcome = &asn1PD__reset_SuccessfulOutcome;
   reset.printSuccessfulOutcome = &asn1Print__reset_SuccessfulOutcome;
   reset.m.UnsuccessfulOutcomePresent = 0;
   reset.m.OutcomePresent = 0;
   reset.procedureCode = 9;
   reset.m.criticalityPresent = 1;
   reset.criticality = reject;

   rAB_ReleaseRequest.InitiatingMessageSize = sizeof(_rAB_ReleaseRequest_InitiatingMessage);
   rAB_ReleaseRequest.decodeInitiatingMessage = &asn1PD__rAB_ReleaseRequest_InitiatingMessage;
   rAB_ReleaseRequest.printInitiatingMessage = &asn1Print__rAB_ReleaseRequest_InitiatingMessage;
   rAB_ReleaseRequest.m.SuccessfulOutcomePresent = 0;
   rAB_ReleaseRequest.m.UnsuccessfulOutcomePresent = 0;
   rAB_ReleaseRequest.m.OutcomePresent = 0;
   rAB_ReleaseRequest.procedureCode = 10;
   rAB_ReleaseRequest.m.criticalityPresent = 1;
   rAB_ReleaseRequest.criticality = ignore;

   iu_ReleaseRequest.InitiatingMessageSize = sizeof(_iu_ReleaseRequest_InitiatingMessage);
   iu_ReleaseRequest.decodeInitiatingMessage = &asn1PD__iu_ReleaseRequest_InitiatingMessage;
   iu_ReleaseRequest.printInitiatingMessage = &asn1Print__iu_ReleaseRequest_InitiatingMessage;
   iu_ReleaseRequest.m.SuccessfulOutcomePresent = 0;
   iu_ReleaseRequest.m.UnsuccessfulOutcomePresent = 0;
   iu_ReleaseRequest.m.OutcomePresent = 0;
   iu_ReleaseRequest.procedureCode = 11;
   iu_ReleaseRequest.m.criticalityPresent = 1;
   iu_ReleaseRequest.criticality = ignore;

   relocationDetect.InitiatingMessageSize = sizeof(_relocationDetect_InitiatingMessage);
   relocationDetect.decodeInitiatingMessage = &asn1PD__relocationDetect_InitiatingMessage;
   relocationDetect.printInitiatingMessage = &asn1Print__relocationDetect_InitiatingMessage;
   relocationDetect.m.SuccessfulOutcomePresent = 0;
   relocationDetect.m.UnsuccessfulOutcomePresent = 0;
   relocationDetect.m.OutcomePresent = 0;
   relocationDetect.procedureCode = 12;
   relocationDetect.m.criticalityPresent = 1;
   relocationDetect.criticality = ignore;

   relocationComplete.InitiatingMessageSize = sizeof(_relocationComplete_InitiatingMessage);
   relocationComplete.decodeInitiatingMessage = &asn1PD__relocationComplete_InitiatingMessage;
   relocationComplete.printInitiatingMessage = &asn1Print__relocationComplete_InitiatingMessage;
   relocationComplete.m.SuccessfulOutcomePresent = 0;
   relocationComplete.m.UnsuccessfulOutcomePresent = 0;
   relocationComplete.m.OutcomePresent = 0;
   relocationComplete.procedureCode = 13;
   relocationComplete.m.criticalityPresent = 1;
   relocationComplete.criticality = ignore;

   paging.InitiatingMessageSize = sizeof(_paging_InitiatingMessage);
   paging.decodeInitiatingMessage = &asn1PD__paging_InitiatingMessage;
   paging.printInitiatingMessage = &asn1Print__paging_InitiatingMessage;
   paging.m.SuccessfulOutcomePresent = 0;
   paging.m.UnsuccessfulOutcomePresent = 0;
   paging.m.OutcomePresent = 0;
   paging.procedureCode = 14;
   paging.m.criticalityPresent = 1;
   paging.criticality = ignore;

   commonID.InitiatingMessageSize = sizeof(_commonID_InitiatingMessage);
   commonID.decodeInitiatingMessage = &asn1PD__commonID_InitiatingMessage;
   commonID.printInitiatingMessage = &asn1Print__commonID_InitiatingMessage;
   commonID.m.SuccessfulOutcomePresent = 0;
   commonID.m.UnsuccessfulOutcomePresent = 0;
   commonID.m.OutcomePresent = 0;
   commonID.procedureCode = 15;
   commonID.m.criticalityPresent = 1;
   commonID.criticality = ignore;

   cN_InvokeTrace.InitiatingMessageSize = sizeof(_cN_InvokeTrace_InitiatingMessage);
   cN_InvokeTrace.decodeInitiatingMessage = &asn1PD__cN_InvokeTrace_InitiatingMessage;
   cN_InvokeTrace.printInitiatingMessage = &asn1Print__cN_InvokeTrace_InitiatingMessage;
   cN_InvokeTrace.m.SuccessfulOutcomePresent = 0;
   cN_InvokeTrace.m.UnsuccessfulOutcomePresent = 0;
   cN_InvokeTrace.m.OutcomePresent = 0;
   cN_InvokeTrace.procedureCode = 16;
   cN_InvokeTrace.m.criticalityPresent = 1;
   cN_InvokeTrace.criticality = ignore;

   cN_DeactivateTrace.InitiatingMessageSize = sizeof(_cN_DeactivateTrace_InitiatingMessage);
   cN_DeactivateTrace.decodeInitiatingMessage = &asn1PD__cN_DeactivateTrace_InitiatingMessage;
   cN_DeactivateTrace.printInitiatingMessage = &asn1Print__cN_DeactivateTrace_InitiatingMessage;
   cN_DeactivateTrace.m.SuccessfulOutcomePresent = 0;
   cN_DeactivateTrace.m.UnsuccessfulOutcomePresent = 0;
   cN_DeactivateTrace.m.OutcomePresent = 0;
   cN_DeactivateTrace.procedureCode = 26;
   cN_DeactivateTrace.m.criticalityPresent = 1;
   cN_DeactivateTrace.criticality = ignore;

   locationReportingControl.InitiatingMessageSize = sizeof(_locationReportingControl_InitiatingMessage);
   locationReportingControl.decodeInitiatingMessage = &asn1PD__locationReportingControl_InitiatingMessage;
   locationReportingControl.printInitiatingMessage = &asn1Print__locationReportingControl_InitiatingMessage;
   locationReportingControl.m.SuccessfulOutcomePresent = 0;
   locationReportingControl.m.UnsuccessfulOutcomePresent = 0;
   locationReportingControl.m.OutcomePresent = 0;
   locationReportingControl.procedureCode = 17;
   locationReportingControl.m.criticalityPresent = 1;
   locationReportingControl.criticality = ignore;

   locationReport.InitiatingMessageSize = sizeof(_locationReport_InitiatingMessage);
   locationReport.decodeInitiatingMessage = &asn1PD__locationReport_InitiatingMessage;
   locationReport.printInitiatingMessage = &asn1Print__locationReport_InitiatingMessage;
   locationReport.m.SuccessfulOutcomePresent = 0;
   locationReport.m.UnsuccessfulOutcomePresent = 0;
   locationReport.m.OutcomePresent = 0;
   locationReport.procedureCode = 18;
   locationReport.m.criticalityPresent = 1;
   locationReport.criticality = ignore;

   initialUE_Message.InitiatingMessageSize = sizeof(_initialUE_Message_InitiatingMessage);
   initialUE_Message.decodeInitiatingMessage = &asn1PD__initialUE_Message_InitiatingMessage;
   initialUE_Message.printInitiatingMessage = &asn1Print__initialUE_Message_InitiatingMessage;
   initialUE_Message.m.SuccessfulOutcomePresent = 0;
   initialUE_Message.m.UnsuccessfulOutcomePresent = 0;
   initialUE_Message.m.OutcomePresent = 0;
   initialUE_Message.procedureCode = 19;
   initialUE_Message.m.criticalityPresent = 1;
   initialUE_Message.criticality = ignore;

   directTransfer.InitiatingMessageSize = sizeof(_directTransfer_InitiatingMessage);
   directTransfer.decodeInitiatingMessage = &asn1PD__directTransfer_InitiatingMessage;
   directTransfer.printInitiatingMessage = &asn1Print__directTransfer_InitiatingMessage;
   directTransfer.m.SuccessfulOutcomePresent = 0;
   directTransfer.m.UnsuccessfulOutcomePresent = 0;
   directTransfer.m.OutcomePresent = 0;
   directTransfer.procedureCode = 20;
   directTransfer.m.criticalityPresent = 1;
   directTransfer.criticality = ignore;

   overloadControl.InitiatingMessageSize = sizeof(_overloadControl_InitiatingMessage);
   overloadControl.decodeInitiatingMessage = &asn1PD__overloadControl_InitiatingMessage;
   overloadControl.printInitiatingMessage = &asn1Print__overloadControl_InitiatingMessage;
   overloadControl.m.SuccessfulOutcomePresent = 0;
   overloadControl.m.UnsuccessfulOutcomePresent = 0;
   overloadControl.m.OutcomePresent = 0;
   overloadControl.procedureCode = 21;
   overloadControl.m.criticalityPresent = 1;
   overloadControl.criticality = ignore;

   errorIndication.InitiatingMessageSize = sizeof(_errorIndication_InitiatingMessage);
   errorIndication.decodeInitiatingMessage = &asn1PD__errorIndication_InitiatingMessage;
   errorIndication.printInitiatingMessage = &asn1Print__errorIndication_InitiatingMessage;
   errorIndication.m.SuccessfulOutcomePresent = 0;
   errorIndication.m.UnsuccessfulOutcomePresent = 0;
   errorIndication.m.OutcomePresent = 0;
   errorIndication.procedureCode = 22;
   errorIndication.m.criticalityPresent = 1;
   errorIndication.criticality = ignore;

   sRNS_DataForward.InitiatingMessageSize = sizeof(_sRNS_DataForward_InitiatingMessage);
   sRNS_DataForward.decodeInitiatingMessage = &asn1PD__sRNS_DataForward_InitiatingMessage;
   sRNS_DataForward.printInitiatingMessage = &asn1Print__sRNS_DataForward_InitiatingMessage;
   sRNS_DataForward.m.SuccessfulOutcomePresent = 0;
   sRNS_DataForward.m.UnsuccessfulOutcomePresent = 0;
   sRNS_DataForward.m.OutcomePresent = 0;
   sRNS_DataForward.procedureCode = 23;
   sRNS_DataForward.m.criticalityPresent = 1;
   sRNS_DataForward.criticality = ignore;

   forwardSRNS_Context.InitiatingMessageSize = sizeof(_forwardSRNS_Context_InitiatingMessage);
   forwardSRNS_Context.decodeInitiatingMessage = &asn1PD__forwardSRNS_Context_InitiatingMessage;
   forwardSRNS_Context.printInitiatingMessage = &asn1Print__forwardSRNS_Context_InitiatingMessage;
   forwardSRNS_Context.m.SuccessfulOutcomePresent = 0;
   forwardSRNS_Context.m.UnsuccessfulOutcomePresent = 0;
   forwardSRNS_Context.m.OutcomePresent = 0;
   forwardSRNS_Context.procedureCode = 24;
   forwardSRNS_Context.m.criticalityPresent = 1;
   forwardSRNS_Context.criticality = ignore;

   rAB_Assignment.InitiatingMessageSize = sizeof(_rAB_Assignment_InitiatingMessage);
   rAB_Assignment.decodeInitiatingMessage = &asn1PD__rAB_Assignment_InitiatingMessage;
   rAB_Assignment.printInitiatingMessage = &asn1Print__rAB_Assignment_InitiatingMessage;
   rAB_Assignment.m.SuccessfulOutcomePresent = 0;
   rAB_Assignment.m.UnsuccessfulOutcomePresent = 0;
   rAB_Assignment.m.OutcomePresent = 1;
   rAB_Assignment.OutcomeSize = sizeof(_rAB_Assignment_Outcome);
   rAB_Assignment.decodeOutcome = &asn1PD__rAB_Assignment_Outcome;
   rAB_Assignment.printOutcome = &asn1Print__rAB_Assignment_Outcome;
   rAB_Assignment.procedureCode = 0;
   rAB_Assignment.m.criticalityPresent = 1;
   rAB_Assignment.criticality = reject;

   privateMessage.InitiatingMessageSize = sizeof(_privateMessage_InitiatingMessage);
   privateMessage.decodeInitiatingMessage = &asn1PD__privateMessage_InitiatingMessage;
   privateMessage.printInitiatingMessage = &asn1Print__privateMessage_InitiatingMessage;
   privateMessage.m.SuccessfulOutcomePresent = 0;
   privateMessage.m.UnsuccessfulOutcomePresent = 0;
   privateMessage.m.OutcomePresent = 0;
   privateMessage.procedureCode = 25;
   privateMessage.m.criticalityPresent = 1;
   privateMessage.criticality = ignore;

   resetResource.InitiatingMessageSize = sizeof(_resetResource_InitiatingMessage);
   resetResource.decodeInitiatingMessage = &asn1PD__resetResource_InitiatingMessage;
   resetResource.printInitiatingMessage = &asn1Print__resetResource_InitiatingMessage;
   resetResource.m.SuccessfulOutcomePresent = 1;
   resetResource.SuccessfulOutcomeSize = sizeof(_resetResource_SuccessfulOutcome);
   resetResource.decodeSuccessfulOutcome = &asn1PD__resetResource_SuccessfulOutcome;
   resetResource.printSuccessfulOutcome = &asn1Print__resetResource_SuccessfulOutcome;
   resetResource.m.UnsuccessfulOutcomePresent = 0;
   resetResource.m.OutcomePresent = 0;
   resetResource.procedureCode = 27;
   resetResource.m.criticalityPresent = 1;
   resetResource.criticality = reject;

   rANAP_Relocation.InitiatingMessageSize = sizeof(_rANAP_Relocation_InitiatingMessage);
   rANAP_Relocation.decodeInitiatingMessage = &asn1PD__rANAP_Relocation_InitiatingMessage;
   rANAP_Relocation.printInitiatingMessage = &asn1Print__rANAP_Relocation_InitiatingMessage;
   rANAP_Relocation.m.SuccessfulOutcomePresent = 0;
   rANAP_Relocation.m.UnsuccessfulOutcomePresent = 0;
   rANAP_Relocation.m.OutcomePresent = 0;
   rANAP_Relocation.procedureCode = 28;
   rANAP_Relocation.m.criticalityPresent = 1;
   rANAP_Relocation.criticality = ignore;

   rAB_ModifyRequest.InitiatingMessageSize = sizeof(_rAB_ModifyRequest_InitiatingMessage);
   rAB_ModifyRequest.decodeInitiatingMessage = &asn1PD__rAB_ModifyRequest_InitiatingMessage;
   rAB_ModifyRequest.printInitiatingMessage = &asn1Print__rAB_ModifyRequest_InitiatingMessage;
   rAB_ModifyRequest.m.SuccessfulOutcomePresent = 0;
   rAB_ModifyRequest.m.UnsuccessfulOutcomePresent = 0;
   rAB_ModifyRequest.m.OutcomePresent = 0;
   rAB_ModifyRequest.procedureCode = 29;
   rAB_ModifyRequest.m.criticalityPresent = 1;
   rAB_ModifyRequest.criticality = ignore;

   locationRelatedData.InitiatingMessageSize = sizeof(_locationRelatedData_InitiatingMessage);
   locationRelatedData.decodeInitiatingMessage = &asn1PD__locationRelatedData_InitiatingMessage;
   locationRelatedData.printInitiatingMessage = &asn1Print__locationRelatedData_InitiatingMessage;
   locationRelatedData.m.SuccessfulOutcomePresent = 1;
   locationRelatedData.SuccessfulOutcomeSize = sizeof(_locationRelatedData_SuccessfulOutcome);
   locationRelatedData.decodeSuccessfulOutcome = &asn1PD__locationRelatedData_SuccessfulOutcome;
   locationRelatedData.printSuccessfulOutcome = &asn1Print__locationRelatedData_SuccessfulOutcome;
   locationRelatedData.m.UnsuccessfulOutcomePresent = 1;
   locationRelatedData.UnsuccessfulOutcomeSize = sizeof(_locationRelatedData_UnsuccessfulOutcome);
   locationRelatedData.decodeUnsuccessfulOutcome = &asn1PD__locationRelatedData_UnsuccessfulOutcome;
   locationRelatedData.printUnsuccessfulOutcome = &asn1Print__locationRelatedData_UnsuccessfulOutcome;
   locationRelatedData.m.OutcomePresent = 0;
   locationRelatedData.procedureCode = 30;
   locationRelatedData.m.criticalityPresent = 1;
   locationRelatedData.criticality = reject;

   informationTransfer.InitiatingMessageSize = sizeof(_informationTransfer_InitiatingMessage);
   informationTransfer.decodeInitiatingMessage = &asn1PD__informationTransfer_InitiatingMessage;
   informationTransfer.printInitiatingMessage = &asn1Print__informationTransfer_InitiatingMessage;
   informationTransfer.m.SuccessfulOutcomePresent = 1;
   informationTransfer.SuccessfulOutcomeSize = sizeof(_informationTransfer_SuccessfulOutcome);
   informationTransfer.decodeSuccessfulOutcome = &asn1PD__informationTransfer_SuccessfulOutcome;
   informationTransfer.printSuccessfulOutcome = &asn1Print__informationTransfer_SuccessfulOutcome;
   informationTransfer.m.UnsuccessfulOutcomePresent = 1;
   informationTransfer.UnsuccessfulOutcomeSize = sizeof(_informationTransfer_UnsuccessfulOutcome);
   informationTransfer.decodeUnsuccessfulOutcome = &asn1PD__informationTransfer_UnsuccessfulOutcome;
   informationTransfer.printUnsuccessfulOutcome = &asn1Print__informationTransfer_UnsuccessfulOutcome;
   informationTransfer.m.OutcomePresent = 0;
   informationTransfer.procedureCode = 31;
   informationTransfer.m.criticalityPresent = 1;
   informationTransfer.criticality = reject;

   uESpecificInformation.InitiatingMessageSize = sizeof(_uESpecificInformation_InitiatingMessage);
   uESpecificInformation.decodeInitiatingMessage = &asn1PD__uESpecificInformation_InitiatingMessage;
   uESpecificInformation.printInitiatingMessage = &asn1Print__uESpecificInformation_InitiatingMessage;
   uESpecificInformation.m.SuccessfulOutcomePresent = 0;
   uESpecificInformation.m.UnsuccessfulOutcomePresent = 0;
   uESpecificInformation.m.OutcomePresent = 0;
   uESpecificInformation.procedureCode = 32;
   uESpecificInformation.m.criticalityPresent = 1;
   uESpecificInformation.criticality = ignore;

   directInformationTransfer.InitiatingMessageSize = sizeof(_directInformationTransfer_InitiatingMessage);
   directInformationTransfer.decodeInitiatingMessage = &asn1PD__directInformationTransfer_InitiatingMessage;
   directInformationTransfer.printInitiatingMessage = &asn1Print__directInformationTransfer_InitiatingMessage;
   directInformationTransfer.m.SuccessfulOutcomePresent = 0;
   directInformationTransfer.m.UnsuccessfulOutcomePresent = 0;
   directInformationTransfer.m.OutcomePresent = 0;
   directInformationTransfer.procedureCode = 34;
   directInformationTransfer.m.criticalityPresent = 1;
   directInformationTransfer.criticality = ignore;

   uplinkInformationExchange.InitiatingMessageSize = sizeof(_uplinkInformationExchange_InitiatingMessage);
   uplinkInformationExchange.decodeInitiatingMessage = &asn1PD__uplinkInformationExchange_InitiatingMessage;
   uplinkInformationExchange.printInitiatingMessage = &asn1Print__uplinkInformationExchange_InitiatingMessage;
   uplinkInformationExchange.m.SuccessfulOutcomePresent = 1;
   uplinkInformationExchange.SuccessfulOutcomeSize = sizeof(_uplinkInformationExchange_SuccessfulOutcome);
   uplinkInformationExchange.decodeSuccessfulOutcome = &asn1PD__uplinkInformationExchange_SuccessfulOutcome;
   uplinkInformationExchange.printSuccessfulOutcome = &asn1Print__uplinkInformationExchange_SuccessfulOutcome;
   uplinkInformationExchange.m.UnsuccessfulOutcomePresent = 1;
   uplinkInformationExchange.UnsuccessfulOutcomeSize = sizeof(_uplinkInformationExchange_UnsuccessfulOutcome);
   uplinkInformationExchange.decodeUnsuccessfulOutcome = &asn1PD__uplinkInformationExchange_UnsuccessfulOutcome;
   uplinkInformationExchange.printUnsuccessfulOutcome = &asn1Print__uplinkInformationExchange_UnsuccessfulOutcome;
   uplinkInformationExchange.m.OutcomePresent = 0;
   uplinkInformationExchange.procedureCode = 33;
   uplinkInformationExchange.m.criticalityPresent = 1;
   uplinkInformationExchange.criticality = reject;

   mBMSSessionStart.InitiatingMessageSize = sizeof(_mBMSSessionStart_InitiatingMessage);
   mBMSSessionStart.decodeInitiatingMessage = &asn1PD__mBMSSessionStart_InitiatingMessage;
   mBMSSessionStart.printInitiatingMessage = &asn1Print__mBMSSessionStart_InitiatingMessage;
   mBMSSessionStart.m.SuccessfulOutcomePresent = 1;
   mBMSSessionStart.SuccessfulOutcomeSize = sizeof(_mBMSSessionStart_SuccessfulOutcome);
   mBMSSessionStart.decodeSuccessfulOutcome = &asn1PD__mBMSSessionStart_SuccessfulOutcome;
   mBMSSessionStart.printSuccessfulOutcome = &asn1Print__mBMSSessionStart_SuccessfulOutcome;
   mBMSSessionStart.m.UnsuccessfulOutcomePresent = 1;
   mBMSSessionStart.UnsuccessfulOutcomeSize = sizeof(_mBMSSessionStart_UnsuccessfulOutcome);
   mBMSSessionStart.decodeUnsuccessfulOutcome = &asn1PD__mBMSSessionStart_UnsuccessfulOutcome;
   mBMSSessionStart.printUnsuccessfulOutcome = &asn1Print__mBMSSessionStart_UnsuccessfulOutcome;
   mBMSSessionStart.m.OutcomePresent = 0;
   mBMSSessionStart.procedureCode = 35;
   mBMSSessionStart.m.criticalityPresent = 1;
   mBMSSessionStart.criticality = reject;

   mBMSSessionUpdate.InitiatingMessageSize = sizeof(_mBMSSessionUpdate_InitiatingMessage);
   mBMSSessionUpdate.decodeInitiatingMessage = &asn1PD__mBMSSessionUpdate_InitiatingMessage;
   mBMSSessionUpdate.printInitiatingMessage = &asn1Print__mBMSSessionUpdate_InitiatingMessage;
   mBMSSessionUpdate.m.SuccessfulOutcomePresent = 1;
   mBMSSessionUpdate.SuccessfulOutcomeSize = sizeof(_mBMSSessionUpdate_SuccessfulOutcome);
   mBMSSessionUpdate.decodeSuccessfulOutcome = &asn1PD__mBMSSessionUpdate_SuccessfulOutcome;
   mBMSSessionUpdate.printSuccessfulOutcome = &asn1Print__mBMSSessionUpdate_SuccessfulOutcome;
   mBMSSessionUpdate.m.UnsuccessfulOutcomePresent = 1;
   mBMSSessionUpdate.UnsuccessfulOutcomeSize = sizeof(_mBMSSessionUpdate_UnsuccessfulOutcome);
   mBMSSessionUpdate.decodeUnsuccessfulOutcome = &asn1PD__mBMSSessionUpdate_UnsuccessfulOutcome;
   mBMSSessionUpdate.printUnsuccessfulOutcome = &asn1Print__mBMSSessionUpdate_UnsuccessfulOutcome;
   mBMSSessionUpdate.m.OutcomePresent = 0;
   mBMSSessionUpdate.procedureCode = 36;
   mBMSSessionUpdate.m.criticalityPresent = 1;
   mBMSSessionUpdate.criticality = reject;

   mBMSSessionStop.InitiatingMessageSize = sizeof(_mBMSSessionStop_InitiatingMessage);
   mBMSSessionStop.decodeInitiatingMessage = &asn1PD__mBMSSessionStop_InitiatingMessage;
   mBMSSessionStop.printInitiatingMessage = &asn1Print__mBMSSessionStop_InitiatingMessage;
   mBMSSessionStop.m.SuccessfulOutcomePresent = 1;
   mBMSSessionStop.SuccessfulOutcomeSize = sizeof(_mBMSSessionStop_SuccessfulOutcome);
   mBMSSessionStop.decodeSuccessfulOutcome = &asn1PD__mBMSSessionStop_SuccessfulOutcome;
   mBMSSessionStop.printSuccessfulOutcome = &asn1Print__mBMSSessionStop_SuccessfulOutcome;
   mBMSSessionStop.m.UnsuccessfulOutcomePresent = 0;
   mBMSSessionStop.m.OutcomePresent = 0;
   mBMSSessionStop.procedureCode = 37;
   mBMSSessionStop.m.criticalityPresent = 1;
   mBMSSessionStop.criticality = reject;

   mBMSUELinking.InitiatingMessageSize = sizeof(_mBMSUELinking_InitiatingMessage);
   mBMSUELinking.decodeInitiatingMessage = &asn1PD__mBMSUELinking_InitiatingMessage;
   mBMSUELinking.printInitiatingMessage = &asn1Print__mBMSUELinking_InitiatingMessage;
   mBMSUELinking.m.SuccessfulOutcomePresent = 0;
   mBMSUELinking.m.UnsuccessfulOutcomePresent = 0;
   mBMSUELinking.m.OutcomePresent = 1;
   mBMSUELinking.OutcomeSize = sizeof(_mBMSUELinking_Outcome);
   mBMSUELinking.decodeOutcome = &asn1PD__mBMSUELinking_Outcome;
   mBMSUELinking.printOutcome = &asn1Print__mBMSUELinking_Outcome;
   mBMSUELinking.procedureCode = 38;
   mBMSUELinking.m.criticalityPresent = 1;
   mBMSUELinking.criticality = reject;

   mBMSRegistration.InitiatingMessageSize = sizeof(_mBMSRegistration_InitiatingMessage);
   mBMSRegistration.decodeInitiatingMessage = &asn1PD__mBMSRegistration_InitiatingMessage;
   mBMSRegistration.printInitiatingMessage = &asn1Print__mBMSRegistration_InitiatingMessage;
   mBMSRegistration.m.SuccessfulOutcomePresent = 1;
   mBMSRegistration.SuccessfulOutcomeSize = sizeof(_mBMSRegistration_SuccessfulOutcome);
   mBMSRegistration.decodeSuccessfulOutcome = &asn1PD__mBMSRegistration_SuccessfulOutcome;
   mBMSRegistration.printSuccessfulOutcome = &asn1Print__mBMSRegistration_SuccessfulOutcome;
   mBMSRegistration.m.UnsuccessfulOutcomePresent = 1;
   mBMSRegistration.UnsuccessfulOutcomeSize = sizeof(_mBMSRegistration_UnsuccessfulOutcome);
   mBMSRegistration.decodeUnsuccessfulOutcome = &asn1PD__mBMSRegistration_UnsuccessfulOutcome;
   mBMSRegistration.printUnsuccessfulOutcome = &asn1Print__mBMSRegistration_UnsuccessfulOutcome;
   mBMSRegistration.m.OutcomePresent = 0;
   mBMSRegistration.procedureCode = 39;
   mBMSRegistration.m.criticalityPresent = 1;
   mBMSRegistration.criticality = reject;

   mBMSCNDe_Registration.InitiatingMessageSize = sizeof(_mBMSCNDe_Registration_InitiatingMessage);
   mBMSCNDe_Registration.decodeInitiatingMessage = &asn1PD__mBMSCNDe_Registration_InitiatingMessage;
   mBMSCNDe_Registration.printInitiatingMessage = &asn1Print__mBMSCNDe_Registration_InitiatingMessage;
   mBMSCNDe_Registration.m.SuccessfulOutcomePresent = 1;
   mBMSCNDe_Registration.SuccessfulOutcomeSize = sizeof(_mBMSCNDe_Registration_SuccessfulOutcome);
   mBMSCNDe_Registration.decodeSuccessfulOutcome = &asn1PD__mBMSCNDe_Registration_SuccessfulOutcome;
   mBMSCNDe_Registration.printSuccessfulOutcome = &asn1Print__mBMSCNDe_Registration_SuccessfulOutcome;
   mBMSCNDe_Registration.m.UnsuccessfulOutcomePresent = 0;
   mBMSCNDe_Registration.m.OutcomePresent = 0;
   mBMSCNDe_Registration.procedureCode = 40;
   mBMSCNDe_Registration.m.criticalityPresent = 1;
   mBMSCNDe_Registration.criticality = reject;

   mBMSRABEstablishmentIndication.InitiatingMessageSize = sizeof(_mBMSRABEstablishmentIndication_InitiatingMessage);
   mBMSRABEstablishmentIndication.decodeInitiatingMessage = &asn1PD__mBMSRABEstablishmentIndication_InitiatingMessage;
   mBMSRABEstablishmentIndication.printInitiatingMessage = &asn1Print__mBMSRABEstablishmentIndication_InitiatingMessage;
   mBMSRABEstablishmentIndication.m.SuccessfulOutcomePresent = 0;
   mBMSRABEstablishmentIndication.m.UnsuccessfulOutcomePresent = 0;
   mBMSRABEstablishmentIndication.m.OutcomePresent = 0;
   mBMSRABEstablishmentIndication.procedureCode = 41;
   mBMSRABEstablishmentIndication.m.criticalityPresent = 1;
   mBMSRABEstablishmentIndication.criticality = ignore;

   mBMSRABRelease.InitiatingMessageSize = sizeof(_mBMSRABRelease_InitiatingMessage);
   mBMSRABRelease.decodeInitiatingMessage = &asn1PD__mBMSRABRelease_InitiatingMessage;
   mBMSRABRelease.printInitiatingMessage = &asn1Print__mBMSRABRelease_InitiatingMessage;
   mBMSRABRelease.m.SuccessfulOutcomePresent = 1;
   mBMSRABRelease.SuccessfulOutcomeSize = sizeof(_mBMSRABRelease_SuccessfulOutcome);
   mBMSRABRelease.decodeSuccessfulOutcome = &asn1PD__mBMSRABRelease_SuccessfulOutcome;
   mBMSRABRelease.printSuccessfulOutcome = &asn1Print__mBMSRABRelease_SuccessfulOutcome;
   mBMSRABRelease.m.UnsuccessfulOutcomePresent = 1;
   mBMSRABRelease.UnsuccessfulOutcomeSize = sizeof(_mBMSRABRelease_UnsuccessfulOutcome);
   mBMSRABRelease.decodeUnsuccessfulOutcome = &asn1PD__mBMSRABRelease_UnsuccessfulOutcome;
   mBMSRABRelease.printUnsuccessfulOutcome = &asn1Print__mBMSRABRelease_UnsuccessfulOutcome;
   mBMSRABRelease.m.OutcomePresent = 0;
   mBMSRABRelease.procedureCode = 42;
   mBMSRABRelease.m.criticalityPresent = 1;
   mBMSRABRelease.criticality = reject;

}

extern void init_RANAP_ELEMENTARY_PROCEDURES(ASN1CTXT *pctxt);
extern void init_RANAP_ELEMENTARY_PROCEDURES_CLASS_1(ASN1CTXT *pctxt);
extern void init_RANAP_ELEMENTARY_PROCEDURES_CLASS_2(ASN1CTXT *pctxt);
extern void init_RANAP_ELEMENTARY_PROCEDURES_CLASS_3(ASN1CTXT *pctxt);

void RANAP_PDU_Descriptions_init(ASN1CTXT *pctxt)
{
   init_RANAP_PDU_DescriptionsObject(pctxt);
   init_RANAP_ELEMENTARY_PROCEDURES(pctxt);
   init_RANAP_ELEMENTARY_PROCEDURES_CLASS_1(pctxt);
   init_RANAP_ELEMENTARY_PROCEDURES_CLASS_2(pctxt);
   init_RANAP_ELEMENTARY_PROCEDURES_CLASS_3(pctxt);
}

/**************************************************************/
/*                                                            */
/*  RANAP_ELEMENTARY_PROCEDURES                               */
/*                                                            */
/**************************************************************/

RANAP_ELEMENTARY_PROCEDURE RANAP_ELEMENTARY_PROCEDURES[42];
int RANAP_ELEMENTARY_PROCEDURES_Size = 42;

void init_RANAP_ELEMENTARY_PROCEDURES(ASN1CTXT *pctxt)
{

   RANAP_ELEMENTARY_PROCEDURES[0].InitiatingMessageSize = sizeof(_iu_Release_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[0].decodeInitiatingMessage = &asn1PD__iu_Release_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[0].printInitiatingMessage = &asn1Print__iu_Release_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[0].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[0].SuccessfulOutcomeSize = sizeof(_iu_Release_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[0].decodeSuccessfulOutcome = &asn1PD__iu_Release_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[0].printSuccessfulOutcome = &asn1Print__iu_Release_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[0].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[0].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[0].procedureCode = 1;
   RANAP_ELEMENTARY_PROCEDURES[0].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[0].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[1].InitiatingMessageSize = sizeof(_relocationPreparation_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[1].decodeInitiatingMessage = &asn1PD__relocationPreparation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[1].printInitiatingMessage = &asn1Print__relocationPreparation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[1].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[1].SuccessfulOutcomeSize = sizeof(_relocationPreparation_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[1].decodeSuccessfulOutcome = &asn1PD__relocationPreparation_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[1].printSuccessfulOutcome = &asn1Print__relocationPreparation_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[1].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[1].UnsuccessfulOutcomeSize = sizeof(_relocationPreparation_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[1].decodeUnsuccessfulOutcome = &asn1PD__relocationPreparation_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[1].printUnsuccessfulOutcome = &asn1Print__relocationPreparation_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[1].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[1].procedureCode = 2;
   RANAP_ELEMENTARY_PROCEDURES[1].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[1].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[2].InitiatingMessageSize = sizeof(_relocationResourceAllocation_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[2].decodeInitiatingMessage = &asn1PD__relocationResourceAllocation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[2].printInitiatingMessage = &asn1Print__relocationResourceAllocation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[2].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[2].SuccessfulOutcomeSize = sizeof(_relocationResourceAllocation_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[2].decodeSuccessfulOutcome = &asn1PD__relocationResourceAllocation_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[2].printSuccessfulOutcome = &asn1Print__relocationResourceAllocation_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[2].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[2].UnsuccessfulOutcomeSize = sizeof(_relocationResourceAllocation_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[2].decodeUnsuccessfulOutcome = &asn1PD__relocationResourceAllocation_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[2].printUnsuccessfulOutcome = &asn1Print__relocationResourceAllocation_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[2].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[2].procedureCode = 3;
   RANAP_ELEMENTARY_PROCEDURES[2].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[2].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[3].InitiatingMessageSize = sizeof(_relocationCancel_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[3].decodeInitiatingMessage = &asn1PD__relocationCancel_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[3].printInitiatingMessage = &asn1Print__relocationCancel_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[3].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[3].SuccessfulOutcomeSize = sizeof(_relocationCancel_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[3].decodeSuccessfulOutcome = &asn1PD__relocationCancel_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[3].printSuccessfulOutcome = &asn1Print__relocationCancel_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[3].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[3].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[3].procedureCode = 4;
   RANAP_ELEMENTARY_PROCEDURES[3].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[3].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[4].InitiatingMessageSize = sizeof(_sRNS_ContextTransfer_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[4].decodeInitiatingMessage = &asn1PD__sRNS_ContextTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[4].printInitiatingMessage = &asn1Print__sRNS_ContextTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[4].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[4].SuccessfulOutcomeSize = sizeof(_sRNS_ContextTransfer_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[4].decodeSuccessfulOutcome = &asn1PD__sRNS_ContextTransfer_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[4].printSuccessfulOutcome = &asn1Print__sRNS_ContextTransfer_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[4].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[4].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[4].procedureCode = 5;
   RANAP_ELEMENTARY_PROCEDURES[4].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[4].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[5].InitiatingMessageSize = sizeof(_securityModeControl_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[5].decodeInitiatingMessage = &asn1PD__securityModeControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[5].printInitiatingMessage = &asn1Print__securityModeControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[5].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[5].SuccessfulOutcomeSize = sizeof(_securityModeControl_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[5].decodeSuccessfulOutcome = &asn1PD__securityModeControl_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[5].printSuccessfulOutcome = &asn1Print__securityModeControl_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[5].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[5].UnsuccessfulOutcomeSize = sizeof(_securityModeControl_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[5].decodeUnsuccessfulOutcome = &asn1PD__securityModeControl_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[5].printUnsuccessfulOutcome = &asn1Print__securityModeControl_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[5].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[5].procedureCode = 6;
   RANAP_ELEMENTARY_PROCEDURES[5].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[5].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[6].InitiatingMessageSize = sizeof(_dataVolumeReport_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[6].decodeInitiatingMessage = &asn1PD__dataVolumeReport_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[6].printInitiatingMessage = &asn1Print__dataVolumeReport_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[6].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[6].SuccessfulOutcomeSize = sizeof(_dataVolumeReport_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[6].decodeSuccessfulOutcome = &asn1PD__dataVolumeReport_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[6].printSuccessfulOutcome = &asn1Print__dataVolumeReport_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[6].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[6].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[6].procedureCode = 7;
   RANAP_ELEMENTARY_PROCEDURES[6].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[6].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[7].InitiatingMessageSize = sizeof(_reset_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[7].decodeInitiatingMessage = &asn1PD__reset_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[7].printInitiatingMessage = &asn1Print__reset_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[7].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[7].SuccessfulOutcomeSize = sizeof(_reset_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[7].decodeSuccessfulOutcome = &asn1PD__reset_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[7].printSuccessfulOutcome = &asn1Print__reset_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[7].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[7].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[7].procedureCode = 9;
   RANAP_ELEMENTARY_PROCEDURES[7].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[7].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[8].InitiatingMessageSize = sizeof(_resetResource_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[8].decodeInitiatingMessage = &asn1PD__resetResource_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[8].printInitiatingMessage = &asn1Print__resetResource_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[8].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[8].SuccessfulOutcomeSize = sizeof(_resetResource_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[8].decodeSuccessfulOutcome = &asn1PD__resetResource_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[8].printSuccessfulOutcome = &asn1Print__resetResource_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[8].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[8].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[8].procedureCode = 27;
   RANAP_ELEMENTARY_PROCEDURES[8].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[8].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[9].InitiatingMessageSize = sizeof(_locationRelatedData_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[9].decodeInitiatingMessage = &asn1PD__locationRelatedData_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[9].printInitiatingMessage = &asn1Print__locationRelatedData_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[9].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[9].SuccessfulOutcomeSize = sizeof(_locationRelatedData_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[9].decodeSuccessfulOutcome = &asn1PD__locationRelatedData_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[9].printSuccessfulOutcome = &asn1Print__locationRelatedData_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[9].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[9].UnsuccessfulOutcomeSize = sizeof(_locationRelatedData_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[9].decodeUnsuccessfulOutcome = &asn1PD__locationRelatedData_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[9].printUnsuccessfulOutcome = &asn1Print__locationRelatedData_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[9].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[9].procedureCode = 30;
   RANAP_ELEMENTARY_PROCEDURES[9].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[9].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[10].InitiatingMessageSize = sizeof(_informationTransfer_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[10].decodeInitiatingMessage = &asn1PD__informationTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[10].printInitiatingMessage = &asn1Print__informationTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[10].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[10].SuccessfulOutcomeSize = sizeof(_informationTransfer_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[10].decodeSuccessfulOutcome = &asn1PD__informationTransfer_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[10].printSuccessfulOutcome = &asn1Print__informationTransfer_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[10].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[10].UnsuccessfulOutcomeSize = sizeof(_informationTransfer_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[10].decodeUnsuccessfulOutcome = &asn1PD__informationTransfer_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[10].printUnsuccessfulOutcome = &asn1Print__informationTransfer_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[10].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[10].procedureCode = 31;
   RANAP_ELEMENTARY_PROCEDURES[10].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[10].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[11].InitiatingMessageSize = sizeof(_uplinkInformationExchange_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[11].decodeInitiatingMessage = &asn1PD__uplinkInformationExchange_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[11].printInitiatingMessage = &asn1Print__uplinkInformationExchange_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[11].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[11].SuccessfulOutcomeSize = sizeof(_uplinkInformationExchange_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[11].decodeSuccessfulOutcome = &asn1PD__uplinkInformationExchange_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[11].printSuccessfulOutcome = &asn1Print__uplinkInformationExchange_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[11].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[11].UnsuccessfulOutcomeSize = sizeof(_uplinkInformationExchange_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[11].decodeUnsuccessfulOutcome = &asn1PD__uplinkInformationExchange_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[11].printUnsuccessfulOutcome = &asn1Print__uplinkInformationExchange_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[11].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[11].procedureCode = 33;
   RANAP_ELEMENTARY_PROCEDURES[11].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[11].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[12].InitiatingMessageSize = sizeof(_mBMSSessionStart_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[12].decodeInitiatingMessage = &asn1PD__mBMSSessionStart_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[12].printInitiatingMessage = &asn1Print__mBMSSessionStart_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[12].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[12].SuccessfulOutcomeSize = sizeof(_mBMSSessionStart_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[12].decodeSuccessfulOutcome = &asn1PD__mBMSSessionStart_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[12].printSuccessfulOutcome = &asn1Print__mBMSSessionStart_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[12].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[12].UnsuccessfulOutcomeSize = sizeof(_mBMSSessionStart_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[12].decodeUnsuccessfulOutcome = &asn1PD__mBMSSessionStart_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[12].printUnsuccessfulOutcome = &asn1Print__mBMSSessionStart_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[12].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[12].procedureCode = 35;
   RANAP_ELEMENTARY_PROCEDURES[12].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[12].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[13].InitiatingMessageSize = sizeof(_mBMSSessionUpdate_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[13].decodeInitiatingMessage = &asn1PD__mBMSSessionUpdate_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[13].printInitiatingMessage = &asn1Print__mBMSSessionUpdate_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[13].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[13].SuccessfulOutcomeSize = sizeof(_mBMSSessionUpdate_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[13].decodeSuccessfulOutcome = &asn1PD__mBMSSessionUpdate_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[13].printSuccessfulOutcome = &asn1Print__mBMSSessionUpdate_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[13].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[13].UnsuccessfulOutcomeSize = sizeof(_mBMSSessionUpdate_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[13].decodeUnsuccessfulOutcome = &asn1PD__mBMSSessionUpdate_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[13].printUnsuccessfulOutcome = &asn1Print__mBMSSessionUpdate_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[13].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[13].procedureCode = 36;
   RANAP_ELEMENTARY_PROCEDURES[13].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[13].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[14].InitiatingMessageSize = sizeof(_mBMSSessionStop_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[14].decodeInitiatingMessage = &asn1PD__mBMSSessionStop_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[14].printInitiatingMessage = &asn1Print__mBMSSessionStop_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[14].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[14].SuccessfulOutcomeSize = sizeof(_mBMSSessionStop_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[14].decodeSuccessfulOutcome = &asn1PD__mBMSSessionStop_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[14].printSuccessfulOutcome = &asn1Print__mBMSSessionStop_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[14].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[14].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[14].procedureCode = 37;
   RANAP_ELEMENTARY_PROCEDURES[14].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[14].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[15].InitiatingMessageSize = sizeof(_mBMSUELinking_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[15].decodeInitiatingMessage = &asn1PD__mBMSUELinking_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[15].printInitiatingMessage = &asn1Print__mBMSUELinking_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[15].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[15].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[15].m.OutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[15].OutcomeSize = sizeof(_mBMSUELinking_Outcome);
   RANAP_ELEMENTARY_PROCEDURES[15].decodeOutcome = &asn1PD__mBMSUELinking_Outcome;
   RANAP_ELEMENTARY_PROCEDURES[15].printOutcome = &asn1Print__mBMSUELinking_Outcome;
   RANAP_ELEMENTARY_PROCEDURES[15].procedureCode = 38;
   RANAP_ELEMENTARY_PROCEDURES[15].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[15].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[16].InitiatingMessageSize = sizeof(_mBMSRegistration_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[16].decodeInitiatingMessage = &asn1PD__mBMSRegistration_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[16].printInitiatingMessage = &asn1Print__mBMSRegistration_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[16].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[16].SuccessfulOutcomeSize = sizeof(_mBMSRegistration_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[16].decodeSuccessfulOutcome = &asn1PD__mBMSRegistration_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[16].printSuccessfulOutcome = &asn1Print__mBMSRegistration_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[16].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[16].UnsuccessfulOutcomeSize = sizeof(_mBMSRegistration_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[16].decodeUnsuccessfulOutcome = &asn1PD__mBMSRegistration_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[16].printUnsuccessfulOutcome = &asn1Print__mBMSRegistration_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[16].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[16].procedureCode = 39;
   RANAP_ELEMENTARY_PROCEDURES[16].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[16].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[17].InitiatingMessageSize = sizeof(_mBMSCNDe_Registration_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[17].decodeInitiatingMessage = &asn1PD__mBMSCNDe_Registration_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[17].printInitiatingMessage = &asn1Print__mBMSCNDe_Registration_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[17].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[17].SuccessfulOutcomeSize = sizeof(_mBMSCNDe_Registration_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[17].decodeSuccessfulOutcome = &asn1PD__mBMSCNDe_Registration_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[17].printSuccessfulOutcome = &asn1Print__mBMSCNDe_Registration_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[17].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[17].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[17].procedureCode = 40;
   RANAP_ELEMENTARY_PROCEDURES[17].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[17].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[18].InitiatingMessageSize = sizeof(_mBMSRABRelease_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[18].decodeInitiatingMessage = &asn1PD__mBMSRABRelease_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[18].printInitiatingMessage = &asn1Print__mBMSRABRelease_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[18].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[18].SuccessfulOutcomeSize = sizeof(_mBMSRABRelease_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[18].decodeSuccessfulOutcome = &asn1PD__mBMSRABRelease_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[18].printSuccessfulOutcome = &asn1Print__mBMSRABRelease_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[18].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[18].UnsuccessfulOutcomeSize = sizeof(_mBMSRABRelease_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES[18].decodeUnsuccessfulOutcome = &asn1PD__mBMSRABRelease_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[18].printUnsuccessfulOutcome = &asn1Print__mBMSRABRelease_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES[18].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[18].procedureCode = 42;
   RANAP_ELEMENTARY_PROCEDURES[18].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[18].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES[19].InitiatingMessageSize = sizeof(_rAB_ReleaseRequest_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[19].decodeInitiatingMessage = &asn1PD__rAB_ReleaseRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[19].printInitiatingMessage = &asn1Print__rAB_ReleaseRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[19].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[19].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[19].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[19].procedureCode = 10;
   RANAP_ELEMENTARY_PROCEDURES[19].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[19].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[20].InitiatingMessageSize = sizeof(_iu_ReleaseRequest_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[20].decodeInitiatingMessage = &asn1PD__iu_ReleaseRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[20].printInitiatingMessage = &asn1Print__iu_ReleaseRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[20].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[20].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[20].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[20].procedureCode = 11;
   RANAP_ELEMENTARY_PROCEDURES[20].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[20].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[21].InitiatingMessageSize = sizeof(_relocationDetect_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[21].decodeInitiatingMessage = &asn1PD__relocationDetect_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[21].printInitiatingMessage = &asn1Print__relocationDetect_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[21].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[21].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[21].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[21].procedureCode = 12;
   RANAP_ELEMENTARY_PROCEDURES[21].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[21].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[22].InitiatingMessageSize = sizeof(_relocationComplete_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[22].decodeInitiatingMessage = &asn1PD__relocationComplete_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[22].printInitiatingMessage = &asn1Print__relocationComplete_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[22].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[22].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[22].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[22].procedureCode = 13;
   RANAP_ELEMENTARY_PROCEDURES[22].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[22].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[23].InitiatingMessageSize = sizeof(_paging_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[23].decodeInitiatingMessage = &asn1PD__paging_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[23].printInitiatingMessage = &asn1Print__paging_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[23].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[23].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[23].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[23].procedureCode = 14;
   RANAP_ELEMENTARY_PROCEDURES[23].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[23].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[24].InitiatingMessageSize = sizeof(_commonID_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[24].decodeInitiatingMessage = &asn1PD__commonID_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[24].printInitiatingMessage = &asn1Print__commonID_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[24].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[24].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[24].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[24].procedureCode = 15;
   RANAP_ELEMENTARY_PROCEDURES[24].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[24].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[25].InitiatingMessageSize = sizeof(_cN_InvokeTrace_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[25].decodeInitiatingMessage = &asn1PD__cN_InvokeTrace_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[25].printInitiatingMessage = &asn1Print__cN_InvokeTrace_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[25].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[25].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[25].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[25].procedureCode = 16;
   RANAP_ELEMENTARY_PROCEDURES[25].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[25].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[26].InitiatingMessageSize = sizeof(_cN_DeactivateTrace_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[26].decodeInitiatingMessage = &asn1PD__cN_DeactivateTrace_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[26].printInitiatingMessage = &asn1Print__cN_DeactivateTrace_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[26].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[26].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[26].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[26].procedureCode = 26;
   RANAP_ELEMENTARY_PROCEDURES[26].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[26].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[27].InitiatingMessageSize = sizeof(_locationReportingControl_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[27].decodeInitiatingMessage = &asn1PD__locationReportingControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[27].printInitiatingMessage = &asn1Print__locationReportingControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[27].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[27].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[27].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[27].procedureCode = 17;
   RANAP_ELEMENTARY_PROCEDURES[27].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[27].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[28].InitiatingMessageSize = sizeof(_locationReport_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[28].decodeInitiatingMessage = &asn1PD__locationReport_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[28].printInitiatingMessage = &asn1Print__locationReport_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[28].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[28].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[28].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[28].procedureCode = 18;
   RANAP_ELEMENTARY_PROCEDURES[28].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[28].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[29].InitiatingMessageSize = sizeof(_initialUE_Message_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[29].decodeInitiatingMessage = &asn1PD__initialUE_Message_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[29].printInitiatingMessage = &asn1Print__initialUE_Message_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[29].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[29].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[29].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[29].procedureCode = 19;
   RANAP_ELEMENTARY_PROCEDURES[29].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[29].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[30].InitiatingMessageSize = sizeof(_directTransfer_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[30].decodeInitiatingMessage = &asn1PD__directTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[30].printInitiatingMessage = &asn1Print__directTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[30].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[30].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[30].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[30].procedureCode = 20;
   RANAP_ELEMENTARY_PROCEDURES[30].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[30].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[31].InitiatingMessageSize = sizeof(_overloadControl_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[31].decodeInitiatingMessage = &asn1PD__overloadControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[31].printInitiatingMessage = &asn1Print__overloadControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[31].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[31].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[31].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[31].procedureCode = 21;
   RANAP_ELEMENTARY_PROCEDURES[31].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[31].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[32].InitiatingMessageSize = sizeof(_errorIndication_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[32].decodeInitiatingMessage = &asn1PD__errorIndication_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[32].printInitiatingMessage = &asn1Print__errorIndication_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[32].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[32].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[32].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[32].procedureCode = 22;
   RANAP_ELEMENTARY_PROCEDURES[32].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[32].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[33].InitiatingMessageSize = sizeof(_sRNS_DataForward_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[33].decodeInitiatingMessage = &asn1PD__sRNS_DataForward_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[33].printInitiatingMessage = &asn1Print__sRNS_DataForward_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[33].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[33].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[33].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[33].procedureCode = 23;
   RANAP_ELEMENTARY_PROCEDURES[33].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[33].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[34].InitiatingMessageSize = sizeof(_forwardSRNS_Context_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[34].decodeInitiatingMessage = &asn1PD__forwardSRNS_Context_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[34].printInitiatingMessage = &asn1Print__forwardSRNS_Context_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[34].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[34].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[34].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[34].procedureCode = 24;
   RANAP_ELEMENTARY_PROCEDURES[34].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[34].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[35].InitiatingMessageSize = sizeof(_privateMessage_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[35].decodeInitiatingMessage = &asn1PD__privateMessage_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[35].printInitiatingMessage = &asn1Print__privateMessage_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[35].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[35].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[35].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[35].procedureCode = 25;
   RANAP_ELEMENTARY_PROCEDURES[35].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[35].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[36].InitiatingMessageSize = sizeof(_rANAP_Relocation_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[36].decodeInitiatingMessage = &asn1PD__rANAP_Relocation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[36].printInitiatingMessage = &asn1Print__rANAP_Relocation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[36].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[36].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[36].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[36].procedureCode = 28;
   RANAP_ELEMENTARY_PROCEDURES[36].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[36].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[37].InitiatingMessageSize = sizeof(_rAB_ModifyRequest_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[37].decodeInitiatingMessage = &asn1PD__rAB_ModifyRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[37].printInitiatingMessage = &asn1Print__rAB_ModifyRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[37].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[37].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[37].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[37].procedureCode = 29;
   RANAP_ELEMENTARY_PROCEDURES[37].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[37].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[38].InitiatingMessageSize = sizeof(_uESpecificInformation_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[38].decodeInitiatingMessage = &asn1PD__uESpecificInformation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[38].printInitiatingMessage = &asn1Print__uESpecificInformation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[38].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[38].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[38].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[38].procedureCode = 32;
   RANAP_ELEMENTARY_PROCEDURES[38].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[38].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[39].InitiatingMessageSize = sizeof(_directInformationTransfer_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[39].decodeInitiatingMessage = &asn1PD__directInformationTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[39].printInitiatingMessage = &asn1Print__directInformationTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[39].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[39].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[39].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[39].procedureCode = 34;
   RANAP_ELEMENTARY_PROCEDURES[39].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[39].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[40].InitiatingMessageSize = sizeof(_mBMSRABEstablishmentIndication_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[40].decodeInitiatingMessage = &asn1PD__mBMSRABEstablishmentIndication_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[40].printInitiatingMessage = &asn1Print__mBMSRABEstablishmentIndication_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[40].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[40].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[40].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[40].procedureCode = 41;
   RANAP_ELEMENTARY_PROCEDURES[40].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[40].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES[41].InitiatingMessageSize = sizeof(_rAB_Assignment_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES[41].decodeInitiatingMessage = &asn1PD__rAB_Assignment_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[41].printInitiatingMessage = &asn1Print__rAB_Assignment_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES[41].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[41].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES[41].m.OutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[41].OutcomeSize = sizeof(_rAB_Assignment_Outcome);
   RANAP_ELEMENTARY_PROCEDURES[41].decodeOutcome = &asn1PD__rAB_Assignment_Outcome;
   RANAP_ELEMENTARY_PROCEDURES[41].printOutcome = &asn1Print__rAB_Assignment_Outcome;
   RANAP_ELEMENTARY_PROCEDURES[41].procedureCode = 0;
   RANAP_ELEMENTARY_PROCEDURES[41].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES[41].criticality = reject;

}

/**************************************************************/
/*                                                            */
/*  RANAP_ELEMENTARY_PROCEDURES_CLASS_1                       */
/*                                                            */
/**************************************************************/

RANAP_ELEMENTARY_PROCEDURE RANAP_ELEMENTARY_PROCEDURES_CLASS_1[19];
int RANAP_ELEMENTARY_PROCEDURES_CLASS_1_Size = 19;

void init_RANAP_ELEMENTARY_PROCEDURES_CLASS_1(ASN1CTXT *pctxt)
{

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].InitiatingMessageSize = sizeof(_iu_Release_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].decodeInitiatingMessage = &asn1PD__iu_Release_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].printInitiatingMessage = &asn1Print__iu_Release_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].SuccessfulOutcomeSize = sizeof(_iu_Release_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].decodeSuccessfulOutcome = &asn1PD__iu_Release_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].printSuccessfulOutcome = &asn1Print__iu_Release_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].procedureCode = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[0].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].InitiatingMessageSize = sizeof(_relocationPreparation_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].decodeInitiatingMessage = &asn1PD__relocationPreparation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].printInitiatingMessage = &asn1Print__relocationPreparation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].SuccessfulOutcomeSize = sizeof(_relocationPreparation_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].decodeSuccessfulOutcome = &asn1PD__relocationPreparation_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].printSuccessfulOutcome = &asn1Print__relocationPreparation_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].UnsuccessfulOutcomeSize = sizeof(_relocationPreparation_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].decodeUnsuccessfulOutcome = &asn1PD__relocationPreparation_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].printUnsuccessfulOutcome = &asn1Print__relocationPreparation_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].procedureCode = 2;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[1].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].InitiatingMessageSize = sizeof(_relocationResourceAllocation_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].decodeInitiatingMessage = &asn1PD__relocationResourceAllocation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].printInitiatingMessage = &asn1Print__relocationResourceAllocation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].SuccessfulOutcomeSize = sizeof(_relocationResourceAllocation_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].decodeSuccessfulOutcome = &asn1PD__relocationResourceAllocation_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].printSuccessfulOutcome = &asn1Print__relocationResourceAllocation_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].UnsuccessfulOutcomeSize = sizeof(_relocationResourceAllocation_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].decodeUnsuccessfulOutcome = &asn1PD__relocationResourceAllocation_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].printUnsuccessfulOutcome = &asn1Print__relocationResourceAllocation_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].procedureCode = 3;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[2].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].InitiatingMessageSize = sizeof(_relocationCancel_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].decodeInitiatingMessage = &asn1PD__relocationCancel_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].printInitiatingMessage = &asn1Print__relocationCancel_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].SuccessfulOutcomeSize = sizeof(_relocationCancel_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].decodeSuccessfulOutcome = &asn1PD__relocationCancel_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].printSuccessfulOutcome = &asn1Print__relocationCancel_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].procedureCode = 4;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[3].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].InitiatingMessageSize = sizeof(_sRNS_ContextTransfer_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].decodeInitiatingMessage = &asn1PD__sRNS_ContextTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].printInitiatingMessage = &asn1Print__sRNS_ContextTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].SuccessfulOutcomeSize = sizeof(_sRNS_ContextTransfer_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].decodeSuccessfulOutcome = &asn1PD__sRNS_ContextTransfer_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].printSuccessfulOutcome = &asn1Print__sRNS_ContextTransfer_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].procedureCode = 5;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[4].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].InitiatingMessageSize = sizeof(_securityModeControl_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].decodeInitiatingMessage = &asn1PD__securityModeControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].printInitiatingMessage = &asn1Print__securityModeControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].SuccessfulOutcomeSize = sizeof(_securityModeControl_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].decodeSuccessfulOutcome = &asn1PD__securityModeControl_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].printSuccessfulOutcome = &asn1Print__securityModeControl_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].UnsuccessfulOutcomeSize = sizeof(_securityModeControl_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].decodeUnsuccessfulOutcome = &asn1PD__securityModeControl_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].printUnsuccessfulOutcome = &asn1Print__securityModeControl_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].procedureCode = 6;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[5].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].InitiatingMessageSize = sizeof(_dataVolumeReport_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].decodeInitiatingMessage = &asn1PD__dataVolumeReport_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].printInitiatingMessage = &asn1Print__dataVolumeReport_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].SuccessfulOutcomeSize = sizeof(_dataVolumeReport_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].decodeSuccessfulOutcome = &asn1PD__dataVolumeReport_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].printSuccessfulOutcome = &asn1Print__dataVolumeReport_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].procedureCode = 7;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[6].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].InitiatingMessageSize = sizeof(_reset_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].decodeInitiatingMessage = &asn1PD__reset_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].printInitiatingMessage = &asn1Print__reset_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].SuccessfulOutcomeSize = sizeof(_reset_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].decodeSuccessfulOutcome = &asn1PD__reset_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].printSuccessfulOutcome = &asn1Print__reset_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].procedureCode = 9;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[7].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].InitiatingMessageSize = sizeof(_resetResource_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].decodeInitiatingMessage = &asn1PD__resetResource_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].printInitiatingMessage = &asn1Print__resetResource_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].SuccessfulOutcomeSize = sizeof(_resetResource_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].decodeSuccessfulOutcome = &asn1PD__resetResource_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].printSuccessfulOutcome = &asn1Print__resetResource_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].procedureCode = 27;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[8].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].InitiatingMessageSize = sizeof(_locationRelatedData_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].decodeInitiatingMessage = &asn1PD__locationRelatedData_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].printInitiatingMessage = &asn1Print__locationRelatedData_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].SuccessfulOutcomeSize = sizeof(_locationRelatedData_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].decodeSuccessfulOutcome = &asn1PD__locationRelatedData_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].printSuccessfulOutcome = &asn1Print__locationRelatedData_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].UnsuccessfulOutcomeSize = sizeof(_locationRelatedData_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].decodeUnsuccessfulOutcome = &asn1PD__locationRelatedData_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].printUnsuccessfulOutcome = &asn1Print__locationRelatedData_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].procedureCode = 30;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[9].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].InitiatingMessageSize = sizeof(_informationTransfer_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].decodeInitiatingMessage = &asn1PD__informationTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].printInitiatingMessage = &asn1Print__informationTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].SuccessfulOutcomeSize = sizeof(_informationTransfer_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].decodeSuccessfulOutcome = &asn1PD__informationTransfer_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].printSuccessfulOutcome = &asn1Print__informationTransfer_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].UnsuccessfulOutcomeSize = sizeof(_informationTransfer_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].decodeUnsuccessfulOutcome = &asn1PD__informationTransfer_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].printUnsuccessfulOutcome = &asn1Print__informationTransfer_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].procedureCode = 31;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[10].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].InitiatingMessageSize = sizeof(_uplinkInformationExchange_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].decodeInitiatingMessage = &asn1PD__uplinkInformationExchange_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].printInitiatingMessage = &asn1Print__uplinkInformationExchange_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].SuccessfulOutcomeSize = sizeof(_uplinkInformationExchange_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].decodeSuccessfulOutcome = &asn1PD__uplinkInformationExchange_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].printSuccessfulOutcome = &asn1Print__uplinkInformationExchange_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].UnsuccessfulOutcomeSize = sizeof(_uplinkInformationExchange_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].decodeUnsuccessfulOutcome = &asn1PD__uplinkInformationExchange_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].printUnsuccessfulOutcome = &asn1Print__uplinkInformationExchange_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].procedureCode = 33;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[11].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].InitiatingMessageSize = sizeof(_mBMSSessionStart_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].decodeInitiatingMessage = &asn1PD__mBMSSessionStart_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].printInitiatingMessage = &asn1Print__mBMSSessionStart_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].SuccessfulOutcomeSize = sizeof(_mBMSSessionStart_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].decodeSuccessfulOutcome = &asn1PD__mBMSSessionStart_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].printSuccessfulOutcome = &asn1Print__mBMSSessionStart_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].UnsuccessfulOutcomeSize = sizeof(_mBMSSessionStart_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].decodeUnsuccessfulOutcome = &asn1PD__mBMSSessionStart_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].printUnsuccessfulOutcome = &asn1Print__mBMSSessionStart_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].procedureCode = 35;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[12].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].InitiatingMessageSize = sizeof(_mBMSSessionUpdate_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].decodeInitiatingMessage = &asn1PD__mBMSSessionUpdate_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].printInitiatingMessage = &asn1Print__mBMSSessionUpdate_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].SuccessfulOutcomeSize = sizeof(_mBMSSessionUpdate_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].decodeSuccessfulOutcome = &asn1PD__mBMSSessionUpdate_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].printSuccessfulOutcome = &asn1Print__mBMSSessionUpdate_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].UnsuccessfulOutcomeSize = sizeof(_mBMSSessionUpdate_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].decodeUnsuccessfulOutcome = &asn1PD__mBMSSessionUpdate_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].printUnsuccessfulOutcome = &asn1Print__mBMSSessionUpdate_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].procedureCode = 36;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[13].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].InitiatingMessageSize = sizeof(_mBMSSessionStop_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].decodeInitiatingMessage = &asn1PD__mBMSSessionStop_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].printInitiatingMessage = &asn1Print__mBMSSessionStop_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].SuccessfulOutcomeSize = sizeof(_mBMSSessionStop_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].decodeSuccessfulOutcome = &asn1PD__mBMSSessionStop_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].printSuccessfulOutcome = &asn1Print__mBMSSessionStop_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].procedureCode = 37;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[14].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].InitiatingMessageSize = sizeof(_mBMSUELinking_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].decodeInitiatingMessage = &asn1PD__mBMSUELinking_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].printInitiatingMessage = &asn1Print__mBMSUELinking_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].m.OutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].OutcomeSize = sizeof(_mBMSUELinking_Outcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].decodeOutcome = &asn1PD__mBMSUELinking_Outcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].printOutcome = &asn1Print__mBMSUELinking_Outcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].procedureCode = 38;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[15].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].InitiatingMessageSize = sizeof(_mBMSRegistration_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].decodeInitiatingMessage = &asn1PD__mBMSRegistration_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].printInitiatingMessage = &asn1Print__mBMSRegistration_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].SuccessfulOutcomeSize = sizeof(_mBMSRegistration_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].decodeSuccessfulOutcome = &asn1PD__mBMSRegistration_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].printSuccessfulOutcome = &asn1Print__mBMSRegistration_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].UnsuccessfulOutcomeSize = sizeof(_mBMSRegistration_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].decodeUnsuccessfulOutcome = &asn1PD__mBMSRegistration_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].printUnsuccessfulOutcome = &asn1Print__mBMSRegistration_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].procedureCode = 39;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[16].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].InitiatingMessageSize = sizeof(_mBMSCNDe_Registration_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].decodeInitiatingMessage = &asn1PD__mBMSCNDe_Registration_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].printInitiatingMessage = &asn1Print__mBMSCNDe_Registration_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].SuccessfulOutcomeSize = sizeof(_mBMSCNDe_Registration_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].decodeSuccessfulOutcome = &asn1PD__mBMSCNDe_Registration_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].printSuccessfulOutcome = &asn1Print__mBMSCNDe_Registration_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].procedureCode = 40;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[17].criticality = reject;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].InitiatingMessageSize = sizeof(_mBMSRABRelease_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].decodeInitiatingMessage = &asn1PD__mBMSRABRelease_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].printInitiatingMessage = &asn1Print__mBMSRABRelease_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].m.SuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].SuccessfulOutcomeSize = sizeof(_mBMSRABRelease_SuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].decodeSuccessfulOutcome = &asn1PD__mBMSRABRelease_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].printSuccessfulOutcome = &asn1Print__mBMSRABRelease_SuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].m.UnsuccessfulOutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].UnsuccessfulOutcomeSize = sizeof(_mBMSRABRelease_UnsuccessfulOutcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].decodeUnsuccessfulOutcome = &asn1PD__mBMSRABRelease_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].printUnsuccessfulOutcome = &asn1Print__mBMSRABRelease_UnsuccessfulOutcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].procedureCode = 42;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_1[18].criticality = reject;

}

/**************************************************************/
/*                                                            */
/*  RANAP_ELEMENTARY_PROCEDURES_CLASS_2                       */
/*                                                            */
/**************************************************************/

RANAP_ELEMENTARY_PROCEDURE RANAP_ELEMENTARY_PROCEDURES_CLASS_2[22];
int RANAP_ELEMENTARY_PROCEDURES_CLASS_2_Size = 22;

void init_RANAP_ELEMENTARY_PROCEDURES_CLASS_2(ASN1CTXT *pctxt)
{

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].InitiatingMessageSize = sizeof(_rAB_ReleaseRequest_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].decodeInitiatingMessage = &asn1PD__rAB_ReleaseRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].printInitiatingMessage = &asn1Print__rAB_ReleaseRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].procedureCode = 10;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[0].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].InitiatingMessageSize = sizeof(_iu_ReleaseRequest_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].decodeInitiatingMessage = &asn1PD__iu_ReleaseRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].printInitiatingMessage = &asn1Print__iu_ReleaseRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].procedureCode = 11;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[1].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].InitiatingMessageSize = sizeof(_relocationDetect_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].decodeInitiatingMessage = &asn1PD__relocationDetect_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].printInitiatingMessage = &asn1Print__relocationDetect_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].procedureCode = 12;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[2].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].InitiatingMessageSize = sizeof(_relocationComplete_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].decodeInitiatingMessage = &asn1PD__relocationComplete_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].printInitiatingMessage = &asn1Print__relocationComplete_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].procedureCode = 13;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[3].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].InitiatingMessageSize = sizeof(_paging_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].decodeInitiatingMessage = &asn1PD__paging_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].printInitiatingMessage = &asn1Print__paging_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].procedureCode = 14;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[4].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].InitiatingMessageSize = sizeof(_commonID_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].decodeInitiatingMessage = &asn1PD__commonID_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].printInitiatingMessage = &asn1Print__commonID_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].procedureCode = 15;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[5].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].InitiatingMessageSize = sizeof(_cN_InvokeTrace_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].decodeInitiatingMessage = &asn1PD__cN_InvokeTrace_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].printInitiatingMessage = &asn1Print__cN_InvokeTrace_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].procedureCode = 16;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[6].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].InitiatingMessageSize = sizeof(_cN_DeactivateTrace_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].decodeInitiatingMessage = &asn1PD__cN_DeactivateTrace_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].printInitiatingMessage = &asn1Print__cN_DeactivateTrace_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].procedureCode = 26;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[7].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].InitiatingMessageSize = sizeof(_locationReportingControl_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].decodeInitiatingMessage = &asn1PD__locationReportingControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].printInitiatingMessage = &asn1Print__locationReportingControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].procedureCode = 17;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[8].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].InitiatingMessageSize = sizeof(_locationReport_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].decodeInitiatingMessage = &asn1PD__locationReport_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].printInitiatingMessage = &asn1Print__locationReport_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].procedureCode = 18;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[9].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].InitiatingMessageSize = sizeof(_initialUE_Message_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].decodeInitiatingMessage = &asn1PD__initialUE_Message_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].printInitiatingMessage = &asn1Print__initialUE_Message_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].procedureCode = 19;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[10].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].InitiatingMessageSize = sizeof(_directTransfer_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].decodeInitiatingMessage = &asn1PD__directTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].printInitiatingMessage = &asn1Print__directTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].procedureCode = 20;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[11].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].InitiatingMessageSize = sizeof(_overloadControl_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].decodeInitiatingMessage = &asn1PD__overloadControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].printInitiatingMessage = &asn1Print__overloadControl_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].procedureCode = 21;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[12].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].InitiatingMessageSize = sizeof(_errorIndication_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].decodeInitiatingMessage = &asn1PD__errorIndication_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].printInitiatingMessage = &asn1Print__errorIndication_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].procedureCode = 22;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[13].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].InitiatingMessageSize = sizeof(_sRNS_DataForward_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].decodeInitiatingMessage = &asn1PD__sRNS_DataForward_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].printInitiatingMessage = &asn1Print__sRNS_DataForward_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].procedureCode = 23;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[14].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].InitiatingMessageSize = sizeof(_forwardSRNS_Context_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].decodeInitiatingMessage = &asn1PD__forwardSRNS_Context_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].printInitiatingMessage = &asn1Print__forwardSRNS_Context_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].procedureCode = 24;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[15].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].InitiatingMessageSize = sizeof(_privateMessage_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].decodeInitiatingMessage = &asn1PD__privateMessage_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].printInitiatingMessage = &asn1Print__privateMessage_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].procedureCode = 25;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[16].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].InitiatingMessageSize = sizeof(_rANAP_Relocation_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].decodeInitiatingMessage = &asn1PD__rANAP_Relocation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].printInitiatingMessage = &asn1Print__rANAP_Relocation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].procedureCode = 28;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[17].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].InitiatingMessageSize = sizeof(_rAB_ModifyRequest_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].decodeInitiatingMessage = &asn1PD__rAB_ModifyRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].printInitiatingMessage = &asn1Print__rAB_ModifyRequest_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].procedureCode = 29;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[18].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].InitiatingMessageSize = sizeof(_uESpecificInformation_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].decodeInitiatingMessage = &asn1PD__uESpecificInformation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].printInitiatingMessage = &asn1Print__uESpecificInformation_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].procedureCode = 32;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[19].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].InitiatingMessageSize = sizeof(_directInformationTransfer_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].decodeInitiatingMessage = &asn1PD__directInformationTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].printInitiatingMessage = &asn1Print__directInformationTransfer_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].procedureCode = 34;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[20].criticality = ignore;

   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].InitiatingMessageSize = sizeof(_mBMSRABEstablishmentIndication_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].decodeInitiatingMessage = &asn1PD__mBMSRABEstablishmentIndication_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].printInitiatingMessage = &asn1Print__mBMSRABEstablishmentIndication_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].m.OutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].procedureCode = 41;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_2[21].criticality = ignore;

}

/**************************************************************/
/*                                                            */
/*  RANAP_ELEMENTARY_PROCEDURES_CLASS_3                       */
/*                                                            */
/**************************************************************/

RANAP_ELEMENTARY_PROCEDURE RANAP_ELEMENTARY_PROCEDURES_CLASS_3[1];
int RANAP_ELEMENTARY_PROCEDURES_CLASS_3_Size = 1;

void init_RANAP_ELEMENTARY_PROCEDURES_CLASS_3(ASN1CTXT *pctxt)
{

   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].InitiatingMessageSize = sizeof(_rAB_Assignment_InitiatingMessage);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].decodeInitiatingMessage = &asn1PD__rAB_Assignment_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].printInitiatingMessage = &asn1Print__rAB_Assignment_InitiatingMessage;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].m.SuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].m.UnsuccessfulOutcomePresent = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].m.OutcomePresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].OutcomeSize = sizeof(_rAB_Assignment_Outcome);
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].decodeOutcome = &asn1PD__rAB_Assignment_Outcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].printOutcome = &asn1Print__rAB_Assignment_Outcome;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].procedureCode = 0;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].m.criticalityPresent = 1;
   RANAP_ELEMENTARY_PROCEDURES_CLASS_3[0].criticality = reject;

}

/**************************************************************/
/*                                                            */
/*  _iu_Release_InitiatingMessage                             */
/*                                                            */
/**************************************************************/

void asn1Print__iu_Release_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _iu_Release_InitiatingMessage *pvalue = (_iu_Release_InitiatingMessage*) pvalue_;
   asn1Print_Iu_ReleaseCommand (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _iu_Release_SuccessfulOutcome                             */
/*                                                            */
/**************************************************************/

void asn1Print__iu_Release_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _iu_Release_SuccessfulOutcome *pvalue = (_iu_Release_SuccessfulOutcome*) pvalue_;
   asn1Print_Iu_ReleaseComplete (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationPreparation_InitiatingMessage                  */
/*                                                            */
/**************************************************************/

void asn1Print__relocationPreparation_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _relocationPreparation_InitiatingMessage *pvalue = (_relocationPreparation_InitiatingMessage*) pvalue_;
   asn1Print_RelocationRequired (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationPreparation_SuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

void asn1Print__relocationPreparation_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _relocationPreparation_SuccessfulOutcome *pvalue = (_relocationPreparation_SuccessfulOutcome*) pvalue_;
   asn1Print_RelocationCommand (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationPreparation_UnsuccessfulOutcome                */
/*                                                            */
/**************************************************************/

void asn1Print__relocationPreparation_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _relocationPreparation_UnsuccessfulOutcome *pvalue = (_relocationPreparation_UnsuccessfulOutcome*) pvalue_;
   asn1Print_RelocationPreparationFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationResourceAllocation_InitiatingMessage           */
/*                                                            */
/**************************************************************/

void asn1Print__relocationResourceAllocation_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _relocationResourceAllocation_InitiatingMessage *pvalue = (_relocationResourceAllocation_InitiatingMessage*) pvalue_;
   asn1Print_RelocationRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationResourceAllocation_SuccessfulOutcome           */
/*                                                            */
/**************************************************************/

void asn1Print__relocationResourceAllocation_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _relocationResourceAllocation_SuccessfulOutcome *pvalue = (_relocationResourceAllocation_SuccessfulOutcome*) pvalue_;
   asn1Print_RelocationRequestAcknowledge (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationResourceAllocation_UnsuccessfulOutcome         */
/*                                                            */
/**************************************************************/

void asn1Print__relocationResourceAllocation_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _relocationResourceAllocation_UnsuccessfulOutcome *pvalue = (_relocationResourceAllocation_UnsuccessfulOutcome*) pvalue_;
   asn1Print_RelocationFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationCancel_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

void asn1Print__relocationCancel_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _relocationCancel_InitiatingMessage *pvalue = (_relocationCancel_InitiatingMessage*) pvalue_;
   asn1Print_RelocationCancel (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationCancel_SuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

void asn1Print__relocationCancel_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _relocationCancel_SuccessfulOutcome *pvalue = (_relocationCancel_SuccessfulOutcome*) pvalue_;
   asn1Print_RelocationCancelAcknowledge (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _sRNS_ContextTransfer_InitiatingMessage                   */
/*                                                            */
/**************************************************************/

void asn1Print__sRNS_ContextTransfer_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _sRNS_ContextTransfer_InitiatingMessage *pvalue = (_sRNS_ContextTransfer_InitiatingMessage*) pvalue_;
   asn1Print_SRNS_ContextRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _sRNS_ContextTransfer_SuccessfulOutcome                   */
/*                                                            */
/**************************************************************/

void asn1Print__sRNS_ContextTransfer_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _sRNS_ContextTransfer_SuccessfulOutcome *pvalue = (_sRNS_ContextTransfer_SuccessfulOutcome*) pvalue_;
   asn1Print_SRNS_ContextResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _securityModeControl_InitiatingMessage                    */
/*                                                            */
/**************************************************************/

void asn1Print__securityModeControl_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _securityModeControl_InitiatingMessage *pvalue = (_securityModeControl_InitiatingMessage*) pvalue_;
   asn1Print_SecurityModeCommand (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _securityModeControl_SuccessfulOutcome                    */
/*                                                            */
/**************************************************************/

void asn1Print__securityModeControl_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _securityModeControl_SuccessfulOutcome *pvalue = (_securityModeControl_SuccessfulOutcome*) pvalue_;
   asn1Print_SecurityModeComplete (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _securityModeControl_UnsuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

void asn1Print__securityModeControl_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _securityModeControl_UnsuccessfulOutcome *pvalue = (_securityModeControl_UnsuccessfulOutcome*) pvalue_;
   asn1Print_SecurityModeReject (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _dataVolumeReport_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

void asn1Print__dataVolumeReport_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _dataVolumeReport_InitiatingMessage *pvalue = (_dataVolumeReport_InitiatingMessage*) pvalue_;
   asn1Print_DataVolumeReportRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _dataVolumeReport_SuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

void asn1Print__dataVolumeReport_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _dataVolumeReport_SuccessfulOutcome *pvalue = (_dataVolumeReport_SuccessfulOutcome*) pvalue_;
   asn1Print_DataVolumeReport (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _reset_InitiatingMessage                                  */
/*                                                            */
/**************************************************************/

void asn1Print__reset_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _reset_InitiatingMessage *pvalue = (_reset_InitiatingMessage*) pvalue_;
   asn1Print_Reset (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _reset_SuccessfulOutcome                                  */
/*                                                            */
/**************************************************************/

void asn1Print__reset_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _reset_SuccessfulOutcome *pvalue = (_reset_SuccessfulOutcome*) pvalue_;
   asn1Print_ResetAcknowledge (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _rAB_ReleaseRequest_InitiatingMessage                     */
/*                                                            */
/**************************************************************/

void asn1Print__rAB_ReleaseRequest_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _rAB_ReleaseRequest_InitiatingMessage *pvalue = (_rAB_ReleaseRequest_InitiatingMessage*) pvalue_;
   asn1Print_RAB_ReleaseRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _iu_ReleaseRequest_InitiatingMessage                      */
/*                                                            */
/**************************************************************/

void asn1Print__iu_ReleaseRequest_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _iu_ReleaseRequest_InitiatingMessage *pvalue = (_iu_ReleaseRequest_InitiatingMessage*) pvalue_;
   asn1Print_Iu_ReleaseRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationDetect_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

void asn1Print__relocationDetect_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _relocationDetect_InitiatingMessage *pvalue = (_relocationDetect_InitiatingMessage*) pvalue_;
   asn1Print_RelocationDetect (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _relocationComplete_InitiatingMessage                     */
/*                                                            */
/**************************************************************/

void asn1Print__relocationComplete_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _relocationComplete_InitiatingMessage *pvalue = (_relocationComplete_InitiatingMessage*) pvalue_;
   asn1Print_RelocationComplete (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _paging_InitiatingMessage                                 */
/*                                                            */
/**************************************************************/

void asn1Print__paging_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _paging_InitiatingMessage *pvalue = (_paging_InitiatingMessage*) pvalue_;
   asn1Print_Paging (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _commonID_InitiatingMessage                               */
/*                                                            */
/**************************************************************/

void asn1Print__commonID_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _commonID_InitiatingMessage *pvalue = (_commonID_InitiatingMessage*) pvalue_;
   asn1Print_CommonID (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _cN_InvokeTrace_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

void asn1Print__cN_InvokeTrace_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _cN_InvokeTrace_InitiatingMessage *pvalue = (_cN_InvokeTrace_InitiatingMessage*) pvalue_;
   asn1Print_CN_InvokeTrace (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _cN_DeactivateTrace_InitiatingMessage                     */
/*                                                            */
/**************************************************************/

void asn1Print__cN_DeactivateTrace_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _cN_DeactivateTrace_InitiatingMessage *pvalue = (_cN_DeactivateTrace_InitiatingMessage*) pvalue_;
   asn1Print_CN_DeactivateTrace (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _locationReportingControl_InitiatingMessage               */
/*                                                            */
/**************************************************************/

void asn1Print__locationReportingControl_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _locationReportingControl_InitiatingMessage *pvalue = (_locationReportingControl_InitiatingMessage*) pvalue_;
   asn1Print_LocationReportingControl (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _locationReport_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

void asn1Print__locationReport_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _locationReport_InitiatingMessage *pvalue = (_locationReport_InitiatingMessage*) pvalue_;
   asn1Print_LocationReport (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _initialUE_Message_InitiatingMessage                      */
/*                                                            */
/**************************************************************/

void asn1Print__initialUE_Message_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _initialUE_Message_InitiatingMessage *pvalue = (_initialUE_Message_InitiatingMessage*) pvalue_;
   asn1Print_InitialUE_Message (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _directTransfer_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

void asn1Print__directTransfer_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _directTransfer_InitiatingMessage *pvalue = (_directTransfer_InitiatingMessage*) pvalue_;
   asn1Print_DirectTransfer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _overloadControl_InitiatingMessage                        */
/*                                                            */
/**************************************************************/

void asn1Print__overloadControl_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _overloadControl_InitiatingMessage *pvalue = (_overloadControl_InitiatingMessage*) pvalue_;
   asn1Print_Overload (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _errorIndication_InitiatingMessage                        */
/*                                                            */
/**************************************************************/

void asn1Print__errorIndication_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _errorIndication_InitiatingMessage *pvalue = (_errorIndication_InitiatingMessage*) pvalue_;
   asn1Print_ErrorIndication (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _sRNS_DataForward_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

void asn1Print__sRNS_DataForward_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _sRNS_DataForward_InitiatingMessage *pvalue = (_sRNS_DataForward_InitiatingMessage*) pvalue_;
   asn1Print_SRNS_DataForwardCommand (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _forwardSRNS_Context_InitiatingMessage                    */
/*                                                            */
/**************************************************************/

void asn1Print__forwardSRNS_Context_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _forwardSRNS_Context_InitiatingMessage *pvalue = (_forwardSRNS_Context_InitiatingMessage*) pvalue_;
   asn1Print_ForwardSRNS_Context (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _rAB_Assignment_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

void asn1Print__rAB_Assignment_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _rAB_Assignment_InitiatingMessage *pvalue = (_rAB_Assignment_InitiatingMessage*) pvalue_;
   asn1Print_RAB_AssignmentRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _rAB_Assignment_Outcome                                   */
/*                                                            */
/**************************************************************/

void asn1Print__rAB_Assignment_Outcome
   (const char* name, void* pvalue_)
{
   _rAB_Assignment_Outcome *pvalue = (_rAB_Assignment_Outcome*) pvalue_;
   asn1Print_RAB_AssignmentResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _privateMessage_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

void asn1Print__privateMessage_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _privateMessage_InitiatingMessage *pvalue = (_privateMessage_InitiatingMessage*) pvalue_;
   asn1Print_PrivateMessage (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _resetResource_InitiatingMessage                          */
/*                                                            */
/**************************************************************/

void asn1Print__resetResource_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _resetResource_InitiatingMessage *pvalue = (_resetResource_InitiatingMessage*) pvalue_;
   asn1Print_ResetResource (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _resetResource_SuccessfulOutcome                          */
/*                                                            */
/**************************************************************/

void asn1Print__resetResource_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _resetResource_SuccessfulOutcome *pvalue = (_resetResource_SuccessfulOutcome*) pvalue_;
   asn1Print_ResetResourceAcknowledge (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _rANAP_Relocation_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

void asn1Print__rANAP_Relocation_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _rANAP_Relocation_InitiatingMessage *pvalue = (_rANAP_Relocation_InitiatingMessage*) pvalue_;
   asn1Print_RANAP_RelocationInformation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _rAB_ModifyRequest_InitiatingMessage                      */
/*                                                            */
/**************************************************************/

void asn1Print__rAB_ModifyRequest_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _rAB_ModifyRequest_InitiatingMessage *pvalue = (_rAB_ModifyRequest_InitiatingMessage*) pvalue_;
   asn1Print_RAB_ModifyRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _locationRelatedData_InitiatingMessage                    */
/*                                                            */
/**************************************************************/

void asn1Print__locationRelatedData_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _locationRelatedData_InitiatingMessage *pvalue = (_locationRelatedData_InitiatingMessage*) pvalue_;
   asn1Print_LocationRelatedDataRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _locationRelatedData_SuccessfulOutcome                    */
/*                                                            */
/**************************************************************/

void asn1Print__locationRelatedData_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _locationRelatedData_SuccessfulOutcome *pvalue = (_locationRelatedData_SuccessfulOutcome*) pvalue_;
   asn1Print_LocationRelatedDataResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _locationRelatedData_UnsuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

void asn1Print__locationRelatedData_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _locationRelatedData_UnsuccessfulOutcome *pvalue = (_locationRelatedData_UnsuccessfulOutcome*) pvalue_;
   asn1Print_LocationRelatedDataFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _informationTransfer_InitiatingMessage                    */
/*                                                            */
/**************************************************************/

void asn1Print__informationTransfer_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _informationTransfer_InitiatingMessage *pvalue = (_informationTransfer_InitiatingMessage*) pvalue_;
   asn1Print_InformationTransferIndication (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _informationTransfer_SuccessfulOutcome                    */
/*                                                            */
/**************************************************************/

void asn1Print__informationTransfer_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _informationTransfer_SuccessfulOutcome *pvalue = (_informationTransfer_SuccessfulOutcome*) pvalue_;
   asn1Print_InformationTransferConfirmation (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _informationTransfer_UnsuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

void asn1Print__informationTransfer_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _informationTransfer_UnsuccessfulOutcome *pvalue = (_informationTransfer_UnsuccessfulOutcome*) pvalue_;
   asn1Print_InformationTransferFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _uESpecificInformation_InitiatingMessage                  */
/*                                                            */
/**************************************************************/

void asn1Print__uESpecificInformation_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _uESpecificInformation_InitiatingMessage *pvalue = (_uESpecificInformation_InitiatingMessage*) pvalue_;
   asn1Print_UESpecificInformationIndication (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _directInformationTransfer_InitiatingMessage              */
/*                                                            */
/**************************************************************/

void asn1Print__directInformationTransfer_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _directInformationTransfer_InitiatingMessage *pvalue = (_directInformationTransfer_InitiatingMessage*) pvalue_;
   asn1Print_DirectInformationTransfer (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _uplinkInformationExchange_InitiatingMessage              */
/*                                                            */
/**************************************************************/

void asn1Print__uplinkInformationExchange_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _uplinkInformationExchange_InitiatingMessage *pvalue = (_uplinkInformationExchange_InitiatingMessage*) pvalue_;
   asn1Print_UplinkInformationExchangeRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _uplinkInformationExchange_SuccessfulOutcome              */
/*                                                            */
/**************************************************************/

void asn1Print__uplinkInformationExchange_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _uplinkInformationExchange_SuccessfulOutcome *pvalue = (_uplinkInformationExchange_SuccessfulOutcome*) pvalue_;
   asn1Print_UplinkInformationExchangeResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _uplinkInformationExchange_UnsuccessfulOutcome            */
/*                                                            */
/**************************************************************/

void asn1Print__uplinkInformationExchange_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _uplinkInformationExchange_UnsuccessfulOutcome *pvalue = (_uplinkInformationExchange_UnsuccessfulOutcome*) pvalue_;
   asn1Print_UplinkInformationExchangeFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStart_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSSessionStart_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _mBMSSessionStart_InitiatingMessage *pvalue = (_mBMSSessionStart_InitiatingMessage*) pvalue_;
   asn1Print_MBMSSessionStart (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStart_SuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSSessionStart_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSSessionStart_SuccessfulOutcome *pvalue = (_mBMSSessionStart_SuccessfulOutcome*) pvalue_;
   asn1Print_MBMSSessionStartResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStart_UnsuccessfulOutcome                     */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSSessionStart_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSSessionStart_UnsuccessfulOutcome *pvalue = (_mBMSSessionStart_UnsuccessfulOutcome*) pvalue_;
   asn1Print_MBMSSessionStartFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionUpdate_InitiatingMessage                      */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSSessionUpdate_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _mBMSSessionUpdate_InitiatingMessage *pvalue = (_mBMSSessionUpdate_InitiatingMessage*) pvalue_;
   asn1Print_MBMSSessionUpdate (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionUpdate_SuccessfulOutcome                      */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSSessionUpdate_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSSessionUpdate_SuccessfulOutcome *pvalue = (_mBMSSessionUpdate_SuccessfulOutcome*) pvalue_;
   asn1Print_MBMSSessionUpdateResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionUpdate_UnsuccessfulOutcome                    */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSSessionUpdate_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSSessionUpdate_UnsuccessfulOutcome *pvalue = (_mBMSSessionUpdate_UnsuccessfulOutcome*) pvalue_;
   asn1Print_MBMSSessionUpdateFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStop_InitiatingMessage                        */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSSessionStop_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _mBMSSessionStop_InitiatingMessage *pvalue = (_mBMSSessionStop_InitiatingMessage*) pvalue_;
   asn1Print_MBMSSessionStop (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSSessionStop_SuccessfulOutcome                        */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSSessionStop_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSSessionStop_SuccessfulOutcome *pvalue = (_mBMSSessionStop_SuccessfulOutcome*) pvalue_;
   asn1Print_MBMSSessionStopResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSUELinking_InitiatingMessage                          */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSUELinking_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _mBMSUELinking_InitiatingMessage *pvalue = (_mBMSUELinking_InitiatingMessage*) pvalue_;
   asn1Print_MBMSUELinkingRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSUELinking_Outcome                                    */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSUELinking_Outcome
   (const char* name, void* pvalue_)
{
   _mBMSUELinking_Outcome *pvalue = (_mBMSUELinking_Outcome*) pvalue_;
   asn1Print_MBMSUELinkingResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRegistration_InitiatingMessage                       */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSRegistration_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _mBMSRegistration_InitiatingMessage *pvalue = (_mBMSRegistration_InitiatingMessage*) pvalue_;
   asn1Print_MBMSRegistrationRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRegistration_SuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSRegistration_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSRegistration_SuccessfulOutcome *pvalue = (_mBMSRegistration_SuccessfulOutcome*) pvalue_;
   asn1Print_MBMSRegistrationResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRegistration_UnsuccessfulOutcome                     */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSRegistration_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSRegistration_UnsuccessfulOutcome *pvalue = (_mBMSRegistration_UnsuccessfulOutcome*) pvalue_;
   asn1Print_MBMSRegistrationFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSCNDe_Registration_InitiatingMessage                  */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSCNDe_Registration_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _mBMSCNDe_Registration_InitiatingMessage *pvalue = (_mBMSCNDe_Registration_InitiatingMessage*) pvalue_;
   asn1Print_MBMSCNDe_RegistrationRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSCNDe_Registration_SuccessfulOutcome                  */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSCNDe_Registration_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSCNDe_Registration_SuccessfulOutcome *pvalue = (_mBMSCNDe_Registration_SuccessfulOutcome*) pvalue_;
   asn1Print_MBMSCNDe_RegistrationResponse (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRABEstablishmentIndication_InitiatingMessage         */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSRABEstablishmentIndication_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _mBMSRABEstablishmentIndication_InitiatingMessage *pvalue = (_mBMSRABEstablishmentIndication_InitiatingMessage*) pvalue_;
   asn1Print_MBMSRABEstablishmentIndication (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRABRelease_InitiatingMessage                         */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSRABRelease_InitiatingMessage
   (const char* name, void* pvalue_)
{
   _mBMSRABRelease_InitiatingMessage *pvalue = (_mBMSRABRelease_InitiatingMessage*) pvalue_;
   asn1Print_MBMSRABReleaseRequest (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRABRelease_SuccessfulOutcome                         */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSRABRelease_SuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSRABRelease_SuccessfulOutcome *pvalue = (_mBMSRABRelease_SuccessfulOutcome*) pvalue_;
   asn1Print_MBMSRABRelease (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  _mBMSRABRelease_UnsuccessfulOutcome                       */
/*                                                            */
/**************************************************************/

void asn1Print__mBMSRABRelease_UnsuccessfulOutcome
   (const char* name, void* pvalue_)
{
   _mBMSRABRelease_UnsuccessfulOutcome *pvalue = (_mBMSRABRelease_UnsuccessfulOutcome*) pvalue_;
   asn1Print_MBMSRABReleaseFailure (name, pvalue);
}

/**************************************************************/
/*                                                            */
/*  InitiatingMessage                                         */
/*                                                            */
/**************************************************************/

void asn1Print_InitiatingMessage
   (const char* name, InitiatingMessage* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check procedureCode */
   for(index = 0; index < RANAP_ELEMENTARY_PROCEDURES_Size; index++) {
      if(rtCmpTCUINT8(&pvalue->procedureCode, &RANAP_ELEMENTARY_PROCEDURES[index].procedureCode) == 0) {
         break;
      }
   }
   if(index == RANAP_ELEMENTARY_PROCEDURES_Size) index = -1;

   sprintf (namebuf, "%s.procedureCode", name);
   asn1Print_ProcedureCode (namebuf, &pvalue->procedureCode);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1){
      RANAP_ELEMENTARY_PROCEDURES[index].printInitiatingMessage(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  SuccessfulOutcome                                         */
/*                                                            */
/**************************************************************/

void asn1Print_SuccessfulOutcome
   (const char* name, SuccessfulOutcome* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check procedureCode */
   for(index = 0; index < RANAP_ELEMENTARY_PROCEDURES_Size; index++) {
      if(rtCmpTCUINT8(&pvalue->procedureCode, &RANAP_ELEMENTARY_PROCEDURES[index].procedureCode) == 0) {
         break;
      }
   }
   if(index == RANAP_ELEMENTARY_PROCEDURES_Size) index = -1;

   sprintf (namebuf, "%s.procedureCode", name);
   asn1Print_ProcedureCode (namebuf, &pvalue->procedureCode);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1 && RANAP_ELEMENTARY_PROCEDURES[index].m.SuccessfulOutcomePresent){
      RANAP_ELEMENTARY_PROCEDURES[index].printSuccessfulOutcome(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulOutcome                                       */
/*                                                            */
/**************************************************************/

void asn1Print_UnsuccessfulOutcome
   (const char* name, UnsuccessfulOutcome* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check procedureCode */
   for(index = 0; index < RANAP_ELEMENTARY_PROCEDURES_Size; index++) {
      if(rtCmpTCUINT8(&pvalue->procedureCode, &RANAP_ELEMENTARY_PROCEDURES[index].procedureCode) == 0) {
         break;
      }
   }
   if(index == RANAP_ELEMENTARY_PROCEDURES_Size) index = -1;

   sprintf (namebuf, "%s.procedureCode", name);
   asn1Print_ProcedureCode (namebuf, &pvalue->procedureCode);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1 && RANAP_ELEMENTARY_PROCEDURES[index].m.UnsuccessfulOutcomePresent){
      RANAP_ELEMENTARY_PROCEDURES[index].printUnsuccessfulOutcome(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  Outcome                                                   */
/*                                                            */
/**************************************************************/

void asn1Print_Outcome
   (const char* name, Outcome* pvalue)
{
   int  index = -1;
   char namebuf[512];

   /* check procedureCode */
   for(index = 0; index < RANAP_ELEMENTARY_PROCEDURES_Size; index++) {
      if(rtCmpTCUINT8(&pvalue->procedureCode, &RANAP_ELEMENTARY_PROCEDURES[index].procedureCode) == 0) {
         break;
      }
   }
   if(index == RANAP_ELEMENTARY_PROCEDURES_Size) index = -1;

   sprintf (namebuf, "%s.procedureCode", name);
   asn1Print_ProcedureCode (namebuf, &pvalue->procedureCode);

   sprintf (namebuf, "%s.criticality", name);
   asn1Print_Criticality (namebuf, &pvalue->criticality);

   sprintf (namebuf, "%s.value", name);
   if (index != -1 && RANAP_ELEMENTARY_PROCEDURES[index].m.OutcomePresent){
      RANAP_ELEMENTARY_PROCEDURES[index].printOutcome(namebuf, pvalue->value.decoded);
   }
   else{
      rtPrintOpenType (namebuf,
         pvalue->value.encoded.numocts,
         pvalue->value.encoded.data, ".");
   }

}

/**************************************************************/
/*                                                            */
/*  RANAP_PDU                                                 */
/*                                                            */
/**************************************************************/

void asn1Print_RANAP_PDU
   (const char* name, RANAP_PDU* pvalue)
{
   char namebuf[512];

   printf ("%s.t = %d\n", name, pvalue->t);
   switch (pvalue->t) {
      case 1:
         sprintf (namebuf, "%s.u.initiatingMessage", name);
         asn1Print_InitiatingMessage (namebuf, pvalue->u.initiatingMessage);
         break;

      case 2:
         sprintf (namebuf, "%s.u.successfulOutcome", name);
         asn1Print_SuccessfulOutcome (namebuf, pvalue->u.successfulOutcome);
         break;

      case 3:
         sprintf (namebuf, "%s.u.unsuccessfulOutcome", name);
         asn1Print_UnsuccessfulOutcome (namebuf, pvalue->u.unsuccessfulOutcome);
         break;

      case 4:
         sprintf (namebuf, "%s.u.outcome", name);
         asn1Print_Outcome (namebuf, pvalue->u.outcome);
         break;

      case 5:
         sprintf (namebuf, "%s.u.extElem1", name);
         rtPrintOpenType (namebuf,
            pvalue->u.extElem1->numocts,
            pvalue->u.extElem1->data, ".");
         break;

      default:;
   }
}

