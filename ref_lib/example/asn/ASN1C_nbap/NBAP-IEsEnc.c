/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 19-Mar-2007.
 */
#include "asn1intl.h"
#include "NBAP-IEs.h"
#include "NBAP-Constants.h"

/**************************************************************/
/*                                                            */
/*  CommonPhysicalChannelID                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonPhysicalChannelID (ASN1CTXT* pctxt, CommonPhysicalChannelID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonPhysicalChannelID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonPhysicalChannelID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_S_CCPCH_Offset                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FDD_S_CCPCH_Offset (ASN1CTXT* pctxt, FDD_S_CCPCH_Offset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_S_CCPCH_Offset: start\n");

   if ( (value <= 149) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(149));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_S_CCPCH_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_ScramblingCode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_ScramblingCode (ASN1CTXT* pctxt, DL_ScramblingCode value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_ScramblingCode: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_ScramblingCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DL_ChannelisationCodeNumber                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FDD_DL_ChannelisationCodeNumber (ASN1CTXT* pctxt, FDD_DL_ChannelisationCodeNumber value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DL_ChannelisationCodeNumber: start\n");

   if ( (value <= 511) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(511));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DL_ChannelisationCodeNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS_CTFC                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCS_CTFC (ASN1CTXT* pctxt, TFCS_CTFC* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS_CTFC: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 6);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* ctfc2bit */
      case 1:
         PU_PUSHNAME (pctxt, "u.ctfc2bit");

         if ( (pvalue->u.ctfc2bit <= 3) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.ctfc2bit, OSUINTCONST(0), OSUINTCONST(3));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else
            return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

         PU_POPNAME (pctxt);

         break;

      /* ctfc4bit */
      case 2:
         PU_PUSHNAME (pctxt, "u.ctfc4bit");

         if ( (pvalue->u.ctfc4bit <= 15) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.ctfc4bit, OSUINTCONST(0), OSUINTCONST(15));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else
            return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

         PU_POPNAME (pctxt);

         break;

      /* ctfc6bit */
      case 3:
         PU_PUSHNAME (pctxt, "u.ctfc6bit");

         if ( (pvalue->u.ctfc6bit <= 63) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.ctfc6bit, OSUINTCONST(0), OSUINTCONST(63));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else
            return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

         PU_POPNAME (pctxt);

         break;

      /* ctfc8bit */
      case 4:
         PU_PUSHNAME (pctxt, "u.ctfc8bit");

         stat = pe_ConsUnsigned (pctxt, pvalue->u.ctfc8bit, OSUINTCONST(0), OSUINTCONST(255));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* ctfc12bit */
      case 5:
         PU_PUSHNAME (pctxt, "u.ctfc12bit");

         if ( (pvalue->u.ctfc12bit <= 4095) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.ctfc12bit, OSUINTCONST(0), OSUINTCONST(4095));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else
            return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

         PU_POPNAME (pctxt);

         break;

      /* ctfc16bit */
      case 6:
         PU_PUSHNAME (pctxt, "u.ctfc16bit");

         stat = pe_ConsUnsigned (pctxt, pvalue->u.ctfc16bit, OSUINTCONST(0), OSUINTCONST(65535));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* ctfcmaxbit */
      case 7:
         PU_PUSHNAME (pctxt, "u.ctfcmaxbit");

         if ( (pvalue->u.ctfcmaxbit <= 16777215) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.ctfcmaxbit, OSUINTCONST(0), OSUINTCONST(16777215));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else
            return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS_CTFC: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BetaCD                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BetaCD (ASN1CTXT* pctxt, BetaCD value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BetaCD: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_BetaCD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatCombination_Beta_signalledGainFactors_gai  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd (ASN1CTXT* pctxt, TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode betaC */

   PU_PUSHNAME (pctxt, "betaC");

   stat = asn1PE_BetaCD (pctxt, pvalue->betaC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode betaD */

   PU_PUSHNAME (pctxt, "betaD");

   stat = asn1PE_BetaCD (pctxt, pvalue->betaD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatCombination_Beta_signalledGainFactors_gai  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatCombination_Beta_signalledGainFactors_gainFactor (ASN1CTXT* pctxt, TransportFormatCombination_Beta_signalledGainFactors_gainFactor* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatCombination_Beta_signalledGainFactors_gainFactor: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* fdd */
         case 1:
            PU_PUSHNAME (pctxt, "u.fdd");

            stat = asn1PE_TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd (pctxt, pvalue->u.fdd);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* tdd */
         case 2:
            PU_PUSHNAME (pctxt, "u.tdd");

            stat = asn1PE_BetaCD (pctxt, pvalue->u.tdd);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatCombination_Beta_signalledGainFactors_gainFactor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RefTFCNumber                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RefTFCNumber (ASN1CTXT* pctxt, RefTFCNumber value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RefTFCNumber: start\n");

   if ( (value <= 3) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_RefTFCNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatCombination_Beta_signalledGainFactors      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatCombination_Beta_signalledGainFactors (ASN1CTXT* pctxt, TransportFormatCombination_Beta_signalledGainFactors* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatCombination_Beta_signalledGainFactors: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "refTFCNumberPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.refTFCNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode gainFactor */

   PU_PUSHNAME (pctxt, "gainFactor");

   stat = asn1PE_TransportFormatCombination_Beta_signalledGainFactors_gainFactor (pctxt, &pvalue->gainFactor);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode refTFCNumber */

   if (pvalue->m.refTFCNumberPresent) {
      PU_PUSHNAME (pctxt, "refTFCNumber");

      stat = asn1PE_RefTFCNumber (pctxt, pvalue->refTFCNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatCombination_Beta_signalledGainFactors: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatCombination_Beta                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatCombination_Beta (ASN1CTXT* pctxt, TransportFormatCombination_Beta* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatCombination_Beta: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* signalledGainFactors */
         case 1:
            PU_PUSHNAME (pctxt, "u.signalledGainFactors");

            stat = asn1PE_TransportFormatCombination_Beta_signalledGainFactors (pctxt, pvalue->u.signalledGainFactors);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* computedGainFactors */
         case 2:
            PU_PUSHNAME (pctxt, "u.computedGainFactors");

            stat = asn1PE_RefTFCNumber (pctxt, pvalue->u.computedGainFactors);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatCombination_Beta: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS_TFCSList_element                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCS_TFCSList_element (ASN1CTXT* pctxt, TFCS_TFCSList_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS_TFCSList_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFC_BetaPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tFC_BetaPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cTFC */

   PU_PUSHNAME (pctxt, "cTFC");

   stat = asn1PE_TFCS_CTFC (pctxt, &pvalue->cTFC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tFC_Beta */

   if (pvalue->m.tFC_BetaPresent) {
      PU_PUSHNAME (pctxt, "tFC_Beta");

      stat = asn1PE_TransportFormatCombination_Beta (pctxt, &pvalue->tFC_Beta);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS_TFCSList_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS_TFCSList                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCS_TFCSList (ASN1CTXT* pctxt, TFCS_TFCSList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1024), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS_TFCSList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_TFCS_TFCSList_element (pctxt, ((TFCS_TFCSList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS_TFCSList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS_tFCSvalues                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCS_tFCSvalues (ASN1CTXT* pctxt, TFCS_tFCSvalues* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS_tFCSvalues: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* no_Split_in_TFCI */
         case 1:
            PU_PUSHNAME (pctxt, "u.no_Split_in_TFCI");

            stat = asn1PE_TFCS_TFCSList (pctxt, pvalue->u.no_Split_in_TFCI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* not_Used_split_in_TFCI */
         case 2:
            PU_PUSHNAME (pctxt, "u.not_Used_split_in_TFCI");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS_tFCSvalues: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCS (ASN1CTXT* pctxt, TFCS* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode tFCSvalues */

   PU_PUSHNAME (pctxt, "tFCSvalues");

   stat = asn1PE_TFCS_tFCSvalues (pctxt, &pvalue->tFCSvalues);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondaryCCPCH_SlotFormat                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecondaryCCPCH_SlotFormat (ASN1CTXT* pctxt, SecondaryCCPCH_SlotFormat value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondaryCCPCH_SlotFormat: start\n");

   if ( (value >= 0 && value <= 17) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(17));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondaryCCPCH_SlotFormat: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCI_Presence                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCI_Presence (ASN1CTXT* pctxt, TFCI_Presence value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCI_Presence: start\n");

   switch (value) {
      case present: ui = 0; break;
      case not_present: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCI_Presence: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexingPosition                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MultiplexingPosition (ASN1CTXT* pctxt, MultiplexingPosition value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_MultiplexingPosition: start\n");

   switch (value) {
      case fixed: ui = 0; break;
      case flexible: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_MultiplexingPosition: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerOffset                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PowerOffset (ASN1CTXT* pctxt, PowerOffset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PowerOffset: start\n");

   if ( (value <= 24) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PowerOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  STTD_Indicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_STTD_Indicator (ASN1CTXT* pctxt, STTD_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_STTD_Indicator: start\n");

   extbit = 0;

   switch (value) {
      case active_3: ui = 0; break;
      case inactive_3: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_STTD_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScramblingCodeNumber                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ScramblingCodeNumber (ASN1CTXT* pctxt, ScramblingCodeNumber value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ScramblingCodeNumber: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_ScramblingCodeNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreambleSignatures                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PreambleSignatures (ASN1CTXT* pctxt, PreambleSignatures* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PreambleSignatures: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_PreambleSignatures: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_SlotFormat                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RACH_SlotFormat (ASN1CTXT* pctxt, RACH_SlotFormat value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_RACH_SlotFormat: start\n");

   extbit = 0;

   switch (value) {
      case v0_2: ui = 0; break;
      case v1_3: ui = 1; break;
      case v2_6: ui = 2; break;
      case v3_1: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RACH_SlotFormat: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_SubChannelNumbers                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RACH_SubChannelNumbers (ASN1CTXT* pctxt, RACH_SubChannelNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(12), OSUINTCONST(12), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RACH_SubChannelNumbers: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_RACH_SubChannelNumbers: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PunctureLimit                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PunctureLimit (ASN1CTXT* pctxt, PunctureLimit value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PunctureLimit: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PunctureLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreambleThreshold                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PreambleThreshold (ASN1CTXT* pctxt, PreambleThreshold value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PreambleThreshold: start\n");

   if ( (value <= 72) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(72));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PreambleThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_TransmissionTiming                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AICH_TransmissionTiming (ASN1CTXT* pctxt, AICH_TransmissionTiming value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_AICH_TransmissionTiming: start\n");

   switch (value) {
      case v0: ui = 0; break;
      case v1: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_AICH_TransmissionTiming: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_Power                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AICH_Power (ASN1CTXT* pctxt, AICH_Power value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AICH_Power: start\n");

   if ( (value >= -22 && value <= 5) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-22), OSINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_AICH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelID                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonTransportChannelID (ASN1CTXT* pctxt, CommonTransportChannelID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonTransportChannelID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonTransportChannelID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_NrOfTransportBlocks                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_NrOfTransportBlocks (ASN1CTXT* pctxt, TransportFormatSet_NrOfTransportBlocks value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_NrOfTransportBlocks: start\n");

   if ( (value <= 512) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(512));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_NrOfTransportBlocks: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_TransportBlockSize                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_TransportBlockSize (ASN1CTXT* pctxt, TransportFormatSet_TransportBlockSize value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_TransportBlockSize: start\n");

   if ( (value <= 5000) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(5000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_TransportBlockSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_TransmissionTimeIntervalDynamic        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_TransmissionTimeIntervalDynamic (ASN1CTXT* pctxt, TransportFormatSet_TransmissionTimeIntervalDynamic value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_TransmissionTimeIntervalDynamic: start\n");

   extbit = 0;

   switch (value) {
      case msec_10: ui = 0; break;
      case msec_20: ui = 1; break;
      case msec_40: ui = 2; break;
      case msec_80: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_TransmissionTimeIntervalDynamic: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmissionTimeIntervalInformation_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransmissionTimeIntervalInformation_element (ASN1CTXT* pctxt, TransmissionTimeIntervalInformation_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionTimeIntervalInformation_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode transmissionTimeInterval */

   PU_PUSHNAME (pctxt, "transmissionTimeInterval");

   stat = asn1PE_TransportFormatSet_TransmissionTimeIntervalDynamic (pctxt, pvalue->transmissionTimeInterval);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionTimeIntervalInformation_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmissionTimeIntervalInformation                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransmissionTimeIntervalInformation (ASN1CTXT* pctxt, TransmissionTimeIntervalInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionTimeIntervalInformation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_TransmissionTimeIntervalInformation_element (pctxt, ((TransmissionTimeIntervalInformation_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionTimeIntervalInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_TransportFormatSet_ModeDP                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_TransportFormatSet_ModeDP (ASN1CTXT* pctxt, TDD_TransportFormatSet_ModeDP* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_TransportFormatSet_ModeDP: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transmissionTimeIntervalInformationPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transmissionTimeIntervalInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode transmissionTimeIntervalInformation */

   if (pvalue->m.transmissionTimeIntervalInformationPresent) {
      PU_PUSHNAME (pctxt, "transmissionTimeIntervalInformation");

      stat = asn1PE_TransmissionTimeIntervalInformation (pctxt, &pvalue->transmissionTimeIntervalInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_TransportFormatSet_ModeDP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_ModeDP                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_ModeDP (ASN1CTXT* pctxt, TransportFormatSet_ModeDP* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_ModeDP: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* tdd */
         case 1:
            PU_PUSHNAME (pctxt, "u.tdd");

            stat = asn1PE_TDD_TransportFormatSet_ModeDP (pctxt, pvalue->u.tdd);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* notApplicable */
         case 2:
            PU_PUSHNAME (pctxt, "u.notApplicable");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_ModeDP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_DynamicPartList_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_DynamicPartList_element (ASN1CTXT* pctxt, TransportFormatSet_DynamicPartList_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_DynamicPartList_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportBlockSizePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportBlockSizePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode nrOfTransportBlocks */

   PU_PUSHNAME (pctxt, "nrOfTransportBlocks");

   stat = asn1PE_TransportFormatSet_NrOfTransportBlocks (pctxt, pvalue->nrOfTransportBlocks);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode transportBlockSize */

   if (pvalue->m.transportBlockSizePresent) {
      PU_PUSHNAME (pctxt, "transportBlockSize");

      stat = asn1PE_TransportFormatSet_TransportBlockSize (pctxt, pvalue->transportBlockSize);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode mode */

   PU_PUSHNAME (pctxt, "mode");

   stat = asn1PE_TransportFormatSet_ModeDP (pctxt, &pvalue->mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_DynamicPartList_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_DynamicPartList                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_DynamicPartList (ASN1CTXT* pctxt, TransportFormatSet_DynamicPartList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_DynamicPartList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_TransportFormatSet_DynamicPartList_element (pctxt, ((TransportFormatSet_DynamicPartList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_DynamicPartList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_TransmissionTimeIntervalSemiStatic     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_TransmissionTimeIntervalSemiStatic (ASN1CTXT* pctxt, TransportFormatSet_TransmissionTimeIntervalSemiStatic value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_TransmissionTimeIntervalSemiStatic: start\n");

   extbit = 0;

   switch (value) {
      case msec_10_1: ui = 0; break;
      case msec_20_1: ui = 1; break;
      case msec_40_1: ui = 2; break;
      case msec_80_1: ui = 3; break;
      case dynamic: ui = 4; break;
      case msec_5: ui = 0; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_TransmissionTimeIntervalSemiStatic: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_ChannelCodingType                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_ChannelCodingType (ASN1CTXT* pctxt, TransportFormatSet_ChannelCodingType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_ChannelCodingType: start\n");

   extbit = 0;

   switch (value) {
      case no_codingTDD: ui = 0; break;
      case convolutional_coding: ui = 1; break;
      case turbo_coding: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_ChannelCodingType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_CodingRate                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_CodingRate (ASN1CTXT* pctxt, TransportFormatSet_CodingRate value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_CodingRate: start\n");

   extbit = 0;

   switch (value) {
      case half: ui = 0; break;
      case third: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_CodingRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_RateMatchingAttribute                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_RateMatchingAttribute (ASN1CTXT* pctxt, TransportFormatSet_RateMatchingAttribute value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_RateMatchingAttribute: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_RateMatchingAttribute: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_CRC_Size                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_CRC_Size (ASN1CTXT* pctxt, TransportFormatSet_CRC_Size value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_CRC_Size: start\n");

   extbit = 0;

   switch (value) {
      case v0_4: ui = 0; break;
      case v8_12: ui = 1; break;
      case v12_2: ui = 2; break;
      case v16_8: ui = 3; break;
      case v24_1: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_CRC_Size: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_SecondInterleavingMode                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_SecondInterleavingMode (ASN1CTXT* pctxt, TransportFormatSet_SecondInterleavingMode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_SecondInterleavingMode: start\n");

   extbit = 0;

   switch (value) {
      case frame_related: ui = 0; break;
      case timeSlot_related: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_SecondInterleavingMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_ModeSSP                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_ModeSSP (ASN1CTXT* pctxt, TransportFormatSet_ModeSSP* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_ModeSSP: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* tdd */
         case 1:
            PU_PUSHNAME (pctxt, "u.tdd");

            stat = asn1PE_TransportFormatSet_SecondInterleavingMode (pctxt, pvalue->u.tdd);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* notApplicable */
         case 2:
            PU_PUSHNAME (pctxt, "u.notApplicable");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_ModeSSP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_Semi_staticPart                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet_Semi_staticPart (ASN1CTXT* pctxt, TransportFormatSet_Semi_staticPart* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_Semi_staticPart: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "codingRatePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.codingRatePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode transmissionTimeInterval */

   PU_PUSHNAME (pctxt, "transmissionTimeInterval");

   stat = asn1PE_TransportFormatSet_TransmissionTimeIntervalSemiStatic (pctxt, pvalue->transmissionTimeInterval);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode channelCoding */

   PU_PUSHNAME (pctxt, "channelCoding");

   stat = asn1PE_TransportFormatSet_ChannelCodingType (pctxt, pvalue->channelCoding);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode codingRate */

   if (pvalue->m.codingRatePresent) {
      PU_PUSHNAME (pctxt, "codingRate");

      stat = asn1PE_TransportFormatSet_CodingRate (pctxt, pvalue->codingRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode rateMatchingAttribute */

   PU_PUSHNAME (pctxt, "rateMatchingAttribute");

   stat = asn1PE_TransportFormatSet_RateMatchingAttribute (pctxt, pvalue->rateMatchingAttribute);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cRC_Size */

   PU_PUSHNAME (pctxt, "cRC_Size");

   stat = asn1PE_TransportFormatSet_CRC_Size (pctxt, pvalue->cRC_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode mode */

   PU_PUSHNAME (pctxt, "mode");

   stat = asn1PE_TransportFormatSet_ModeSSP (pctxt, &pvalue->mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet_Semi_staticPart: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportFormatSet (ASN1CTXT* pctxt, TransportFormatSet* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dynamicParts */

   PU_PUSHNAME (pctxt, "dynamicParts");

   stat = asn1PE_TransportFormatSet_DynamicPartList (pctxt, &pvalue->dynamicParts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode semi_staticPart */

   PU_PUSHNAME (pctxt, "semi_staticPart");

   stat = asn1PE_TransportFormatSet_Semi_staticPart (pctxt, &pvalue->semi_staticPart);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportFormatSet: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ToAWS                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ToAWS (ASN1CTXT* pctxt, ToAWS value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ToAWS: start\n");

   if ( (value <= 1279) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1279));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_ToAWS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ToAWE                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ToAWE (ASN1CTXT* pctxt, ToAWE value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ToAWE: start\n");

   if ( (value <= 2559) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(2559));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_ToAWE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Power                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_Power (ASN1CTXT* pctxt, DL_Power value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_Power: start\n");

   if ( (value >= -350 && value <= 150) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-350), OSINTCONST(150));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Power                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PICH_Power (ASN1CTXT* pctxt, PICH_Power value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PICH_Power: start\n");

   if ( (value >= -10 && value <= 5) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-10), OSINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PICH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Mode                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PICH_Mode (ASN1CTXT* pctxt, PICH_Mode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PICH_Mode: start\n");

   extbit = 0;

   switch (value) {
      case v18_1: ui = 0; break;
      case v36_1: ui = 1; break;
      case v72_1: ui = 2; break;
      case v144_1: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PICH_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_Mode                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MICH_Mode (ASN1CTXT* pctxt, MICH_Mode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MICH_Mode: start\n");

   extbit = 0;

   switch (value) {
      case v18: ui = 0; break;
      case v36: ui = 1; break;
      case v72: ui = 2; break;
      case v144: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MICH_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_ID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CCTrCH_ID (ASN1CTXT* pctxt, CCTrCH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CCTrCH_ID: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_CCTrCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCI_Coding                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCI_Coding (ASN1CTXT* pctxt, TFCI_Coding value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCI_Coding: start\n");

   extbit = 0;

   switch (value) {
      case v4_12: ui = 0; break;
      case v8_11: ui = 1; break;
      case v16_7: ui = 2; break;
      case v32_5: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCI_Coding: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_ChannelisationCode                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_ChannelisationCode (ASN1CTXT* pctxt, TDD_ChannelisationCode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_ChannelisationCode: start\n");

   extbit = 0;

   switch (value) {
      case chCode1div1: ui = 0; break;
      case chCode2div1: ui = 1; break;
      case chCode2div2: ui = 2; break;
      case chCode4div1: ui = 3; break;
      case chCode4div2: ui = 4; break;
      case chCode4div3: ui = 5; break;
      case chCode4div4: ui = 6; break;
      case chCode8div1: ui = 7; break;
      case chCode8div2: ui = 8; break;
      case chCode8div3: ui = 9; break;
      case chCode8div4: ui = 10; break;
      case chCode8div5: ui = 11; break;
      case chCode8div6: ui = 12; break;
      case chCode8div7: ui = 13; break;
      case chCode8div8: ui = 14; break;
      case chCode16div1: ui = 15; break;
      case chCode16div2: ui = 16; break;
      case chCode16div3: ui = 17; break;
      case chCode16div4: ui = 18; break;
      case chCode16div5: ui = 19; break;
      case chCode16div6: ui = 20; break;
      case chCode16div7: ui = 21; break;
      case chCode16div8: ui = 22; break;
      case chCode16div9: ui = 23; break;
      case chCode16div10: ui = 24; break;
      case chCode16div11: ui = 25; break;
      case chCode16div12: ui = 26; break;
      case chCode16div13: ui = 27; break;
      case chCode16div14: ui = 28; break;
      case chCode16div15: ui = 29; break;
      case chCode16div16: ui = 30; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(30));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_ChannelisationCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlot                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TimeSlot (ASN1CTXT* pctxt, TimeSlot value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeSlot: start\n");

   if ( (value <= 14) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(14));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeSlot: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleConfigurationBurstType1And3                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleConfigurationBurstType1And3 (ASN1CTXT* pctxt, MidambleConfigurationBurstType1And3 value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleConfigurationBurstType1And3: start\n");

   switch (value) {
      case v4_4: ui = 0; break;
      case v8_3: ui = 1; break;
      case v16_2: ui = 2; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleConfigurationBurstType1And3: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftLong                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftLong (ASN1CTXT* pctxt, MidambleShiftLong value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftLong: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftLong: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type1_midambleAllocationMode    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftAndBurstType_type1_midambleAllocationMode (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type1_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type1_midambleAllocationMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* defaultMidamble */
         case 1:
            PU_PUSHNAME (pctxt, "u.defaultMidamble");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* commonMidamble */
         case 2:
            PU_PUSHNAME (pctxt, "u.commonMidamble");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* ueSpecificMidamble */
         case 3:
            PU_PUSHNAME (pctxt, "u.ueSpecificMidamble");

            stat = asn1PE_MidambleShiftLong (pctxt, pvalue->u.ueSpecificMidamble);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type1_midambleAllocationMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftAndBurstType_type1 (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type1* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type1: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode midambleConfigurationBurstType1And3 */

   PU_PUSHNAME (pctxt, "midambleConfigurationBurstType1And3");

   stat = asn1PE_MidambleConfigurationBurstType1And3 (pctxt, pvalue->midambleConfigurationBurstType1And3);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleAllocationMode */

   PU_PUSHNAME (pctxt, "midambleAllocationMode");

   stat = asn1PE_MidambleShiftAndBurstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type1: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleConfigurationBurstType2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleConfigurationBurstType2 (ASN1CTXT* pctxt, MidambleConfigurationBurstType2 value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleConfigurationBurstType2: start\n");

   switch (value) {
      case v3: ui = 0; break;
      case v6_2: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleConfigurationBurstType2: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftShort                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftShort (ASN1CTXT* pctxt, MidambleShiftShort value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftShort: start\n");

   if ( (value <= 5) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftShort: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type2_midambleAllocationMode    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftAndBurstType_type2_midambleAllocationMode (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type2_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type2_midambleAllocationMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* defaultMidamble */
         case 1:
            PU_PUSHNAME (pctxt, "u.defaultMidamble");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* commonMidamble */
         case 2:
            PU_PUSHNAME (pctxt, "u.commonMidamble");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* ueSpecificMidamble */
         case 3:
            PU_PUSHNAME (pctxt, "u.ueSpecificMidamble");

            stat = asn1PE_MidambleShiftShort (pctxt, pvalue->u.ueSpecificMidamble);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type2_midambleAllocationMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftAndBurstType_type2 (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type2* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type2: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode midambleConfigurationBurstType2 */

   PU_PUSHNAME (pctxt, "midambleConfigurationBurstType2");

   stat = asn1PE_MidambleConfigurationBurstType2 (pctxt, pvalue->midambleConfigurationBurstType2);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleAllocationMode */

   PU_PUSHNAME (pctxt, "midambleAllocationMode");

   stat = asn1PE_MidambleShiftAndBurstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type2: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type3_midambleAllocationMode    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftAndBurstType_type3_midambleAllocationMode (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type3_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type3_midambleAllocationMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* defaultMidamble */
         case 1:
            PU_PUSHNAME (pctxt, "u.defaultMidamble");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* ueSpecificMidamble */
         case 2:
            PU_PUSHNAME (pctxt, "u.ueSpecificMidamble");

            stat = asn1PE_MidambleShiftLong (pctxt, pvalue->u.ueSpecificMidamble);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type3_midambleAllocationMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type3                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftAndBurstType_type3 (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type3* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type3: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode midambleConfigurationBurstType1And3 */

   PU_PUSHNAME (pctxt, "midambleConfigurationBurstType1And3");

   stat = asn1PE_MidambleConfigurationBurstType1And3 (pctxt, pvalue->midambleConfigurationBurstType1And3);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleAllocationMode */

   PU_PUSHNAME (pctxt, "midambleAllocationMode");

   stat = asn1PE_MidambleShiftAndBurstType_type3_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType_type3: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftAndBurstType (ASN1CTXT* pctxt, MidambleShiftAndBurstType* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* type1 */
         case 1:
            PU_PUSHNAME (pctxt, "u.type1");

            stat = asn1PE_MidambleShiftAndBurstType_type1 (pctxt, pvalue->u.type1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* type2 */
         case 2:
            PU_PUSHNAME (pctxt, "u.type2");

            stat = asn1PE_MidambleShiftAndBurstType_type2 (pctxt, pvalue->u.type2);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* type3 */
         case 3:
            PU_PUSHNAME (pctxt, "u.type3");

            stat = asn1PE_MidambleShiftAndBurstType_type3 (pctxt, pvalue->u.type3);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftAndBurstType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_PhysicalChannelOffset                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_PhysicalChannelOffset (ASN1CTXT* pctxt, TDD_PhysicalChannelOffset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_PhysicalChannelOffset: start\n");

   if ( (value <= 63) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_PhysicalChannelOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionPeriod                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RepetitionPeriod (ASN1CTXT* pctxt, RepetitionPeriod value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_RepetitionPeriod: start\n");

   extbit = 0;

   switch (value) {
      case v1_4: ui = 0; break;
      case v2_7: ui = 1; break;
      case v4_10: ui = 2; break;
      case v8_9: ui = 3; break;
      case v16_6: ui = 4; break;
      case v32_4: ui = 5; break;
      case v64_3: ui = 6; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RepetitionPeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionLength                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RepetitionLength (ASN1CTXT* pctxt, RepetitionLength value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RepetitionLength: start\n");

   if ( (value >= 1 && value <= 63) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(63));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_RepetitionLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PagingIndicatorLength                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PagingIndicatorLength (ASN1CTXT* pctxt, PagingIndicatorLength value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PagingIndicatorLength: start\n");

   extbit = 0;

   switch (value) {
      case v2_5: ui = 0; break;
      case v4_9: ui = 1; break;
      case v8_8: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PagingIndicatorLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modulation                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Modulation (ASN1CTXT* pctxt, Modulation value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Modulation: start\n");

   extbit = 0;

   switch (value) {
      case qPSK: ui = 0; break;
      case eightPSK: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Modulation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_ChannelisationCodeLCR                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_ChannelisationCodeLCR (ASN1CTXT* pctxt, TDD_ChannelisationCodeLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_ChannelisationCodeLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode tDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tDD_ChannelisationCode");

   stat = asn1PE_TDD_ChannelisationCode (pctxt, pvalue->tDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode modulation */

   PU_PUSHNAME (pctxt, "modulation");

   stat = asn1PE_Modulation (pctxt, pvalue->modulation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_ChannelisationCodeLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotLCR                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TimeSlotLCR (ASN1CTXT* pctxt, TimeSlotLCR value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeSlotLCR: start\n");

   if ( (value <= 6) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeSlotLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleAllocationMode                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleAllocationMode (ASN1CTXT* pctxt, MidambleAllocationMode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleAllocationMode: start\n");

   extbit = 0;

   switch (value) {
      case defaultMidamble: ui = 0; break;
      case commonMidamble: ui = 1; break;
      case uESpecificMidamble: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleAllocationMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleConfigurationLCR                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleConfigurationLCR (ASN1CTXT* pctxt, MidambleConfigurationLCR value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleConfigurationLCR: start\n");

   extbit = 0;

   switch (value) {
      case v2_2: ui = 0; break;
      case v4_3: ui = 1; break;
      case v6_1: ui = 2; break;
      case v8_2: ui = 3; break;
      case v10_1: ui = 4; break;
      case v12_1: ui = 5; break;
      case v14: ui = 6; break;
      case v16_1: ui = 7; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleConfigurationLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftLCR                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MidambleShiftLCR (ASN1CTXT* pctxt, MidambleShiftLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.midambleShiftPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode midambleAllocationMode */

   PU_PUSHNAME (pctxt, "midambleAllocationMode");

   stat = asn1PE_MidambleAllocationMode (pctxt, pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShift */

   if (pvalue->m.midambleShiftPresent) {
      PU_PUSHNAME (pctxt, "midambleShift");

      stat = asn1PE_MidambleShiftLong (pctxt, pvalue->midambleShift);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode midambleConfigurationLCR */

   PU_PUSHNAME (pctxt, "midambleConfigurationLCR");

   stat = asn1PE_MidambleConfigurationLCR (pctxt, pvalue->midambleConfigurationLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MidambleShiftLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QPSK_DL_DPCH_TimeSlotFormatTDD_LCR                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_QPSK_DL_DPCH_TimeSlotFormatTDD_LCR (ASN1CTXT* pctxt, QPSK_DL_DPCH_TimeSlotFormatTDD_LCR value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_QPSK_DL_DPCH_TimeSlotFormatTDD_LCR: start\n");

   if ( (value >= 0 && value <= 24) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_QPSK_DL_DPCH_TimeSlotFormatTDD_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR (ASN1CTXT* pctxt, EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR: start\n");

   if ( (value >= 0 && value <= 24) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_DPCH_TimeSlotFormat_LCR                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_DL_DPCH_TimeSlotFormat_LCR (ASN1CTXT* pctxt, TDD_DL_DPCH_TimeSlotFormat_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_DPCH_TimeSlotFormat_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* qPSK */
         case 1:
            PU_PUSHNAME (pctxt, "u.qPSK");

            stat = asn1PE_QPSK_DL_DPCH_TimeSlotFormatTDD_LCR (pctxt, pvalue->u.qPSK);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* eightPSK */
         case 2:
            PU_PUSHNAME (pctxt, "u.eightPSK");

            stat = asn1PE_EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR (pctxt, pvalue->u.eightPSK);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_DPCH_TimeSlotFormat_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotificationIndicatorLength                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NotificationIndicatorLength (ASN1CTXT* pctxt, NotificationIndicatorLength value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_NotificationIndicatorLength: start\n");

   extbit = 0;

   switch (value) {
      case v2_4: ui = 0; break;
      case v4_8: ui = 1; break;
      case v8_7: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NotificationIndicatorLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TSTD_Indicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TSTD_Indicator (ASN1CTXT* pctxt, TSTD_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_TSTD_Indicator: start\n");

   switch (value) {
      case active_6: ui = 0; break;
      case inactive_5: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_TSTD_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxPRACH_MidambleShifts                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MaxPRACH_MidambleShifts (ASN1CTXT* pctxt, MaxPRACH_MidambleShifts value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MaxPRACH_MidambleShifts: start\n");

   extbit = 0;

   switch (value) {
      case shift4: ui = 0; break;
      case shift8: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MaxPRACH_MidambleShifts: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_Midamble                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PRACH_Midamble (ASN1CTXT* pctxt, PRACH_Midamble value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PRACH_Midamble: start\n");

   extbit = 0;

   switch (value) {
      case inverted: ui = 0; break;
      case direct: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PRACH_Midamble: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FPACH_Power                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FPACH_Power (ASN1CTXT* pctxt, FPACH_Power value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_FPACH_Power: start\n");

   if ( (value >= -150 && value <= 400) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-150), OSINTCONST(400));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FPACH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BindingID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BindingID (ASN1CTXT* pctxt, BindingID value)
{
   static Asn1SizeCnst lsize2 = { 1, OSUINTCONST(0), OSUINT32_MAX, 0 };
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BindingID: start\n");

   lsize1.next = &lsize2;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_BindingID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerAddress                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportLayerAddress (ASN1CTXT* pctxt, TransportLayerAddress value)
{
   static Asn1SizeCnst lsize2 = { 1, OSUINTCONST(0), OSUINT32_MAX, 0 };
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(160), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportLayerAddress: start\n");

   lsize1.next = &lsize2;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, value.numbits, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportLayerAddress: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannel_InformationResponse                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonTransportChannel_InformationResponse (ASN1CTXT* pctxt, CommonTransportChannel_InformationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonTransportChannel_InformationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PE_CommonTransportChannelID (pctxt, pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonTransportChannel_InformationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  C_ID                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_C_ID (ASN1CTXT* pctxt, C_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_C_ID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_C_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfigurationGenerationID                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ConfigurationGenerationID (ASN1CTXT* pctxt, ConfigurationGenerationID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ConfigurationGenerationID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_ConfigurationGenerationID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResourceOperationalState                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResourceOperationalState (ASN1CTXT* pctxt, ResourceOperationalState value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_ResourceOperationalState: start\n");

   switch (value) {
      case enabled: ui = 0; break;
      case disabled: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_ResourceOperationalState: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvailabilityStatus                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AvailabilityStatus (ASN1CTXT* pctxt, AvailabilityStatus value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_AvailabilityStatus: start\n");

   extbit = 0;

   switch (value) {
      case empty: ui = 0; break;
      case in_test: ui = 1; break;
      case failed: ui = 2; break;
      case power_off: ui = 3; break;
      case off_line: ui = 4; break;
      case off_duty: ui = 5; break;
      case dependency: ui = 6; break;
      case degraded: ui = 7; break;
      case not_installed: ui = 8; break;
      case log_full: ui = 9; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(9));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AvailabilityStatus: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_ID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Local_Cell_ID (ASN1CTXT* pctxt, Local_Cell_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Local_Cell_ID: start\n");

   if ( (value <= 268435455) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(268435455));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Local_Cell_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationControlPortID                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommunicationControlPortID (ASN1CTXT* pctxt, CommunicationControlPortID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommunicationControlPortID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_CommunicationControlPortID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_or_Global_CapacityCredit                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_or_Global_CapacityCredit (ASN1CTXT* pctxt, DL_or_Global_CapacityCredit value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_or_Global_CapacityCredit: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_or_Global_CapacityCredit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CapacityCredit                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_CapacityCredit (ASN1CTXT* pctxt, UL_CapacityCredit value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_CapacityCredit: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_CapacityCredit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonChannelsCapacityConsumptionLaw_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonChannelsCapacityConsumptionLaw_element (ASN1CTXT* pctxt, CommonChannelsCapacityConsumptionLaw_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonChannelsCapacityConsumptionLaw_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dl_Cost */

   PU_PUSHNAME (pctxt, "dl_Cost");

   stat = pe_ConsUnsigned (pctxt, pvalue->dl_Cost, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode ul_Cost */

   PU_PUSHNAME (pctxt, "ul_Cost");

   stat = pe_ConsUnsigned (pctxt, pvalue->ul_Cost, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonChannelsCapacityConsumptionLaw_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonChannelsCapacityConsumptionLaw                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonChannelsCapacityConsumptionLaw (ASN1CTXT* pctxt, CommonChannelsCapacityConsumptionLaw* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonChannelsCapacityConsumptionLaw: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_CommonChannelsCapacityConsumptionLaw_element (pctxt, ((CommonChannelsCapacityConsumptionLaw_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonChannelsCapacityConsumptionLaw: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedChannelsCapacityConsumptionLaw_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DedicatedChannelsCapacityConsumptionLaw_element (ASN1CTXT* pctxt, DedicatedChannelsCapacityConsumptionLaw_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedChannelsCapacityConsumptionLaw_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dl_Cost_1 */

   PU_PUSHNAME (pctxt, "dl_Cost_1");

   stat = pe_ConsUnsigned (pctxt, pvalue->dl_Cost_1, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode dl_Cost_2 */

   PU_PUSHNAME (pctxt, "dl_Cost_2");

   stat = pe_ConsUnsigned (pctxt, pvalue->dl_Cost_2, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode ul_Cost_1 */

   PU_PUSHNAME (pctxt, "ul_Cost_1");

   stat = pe_ConsUnsigned (pctxt, pvalue->ul_Cost_1, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode ul_Cost_2 */

   PU_PUSHNAME (pctxt, "ul_Cost_2");

   stat = pe_ConsUnsigned (pctxt, pvalue->ul_Cost_2, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedChannelsCapacityConsumptionLaw_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedChannelsCapacityConsumptionLaw                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DedicatedChannelsCapacityConsumptionLaw (ASN1CTXT* pctxt, DedicatedChannelsCapacityConsumptionLaw* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedChannelsCapacityConsumptionLaw: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DedicatedChannelsCapacityConsumptionLaw_element (pctxt, ((DedicatedChannelsCapacityConsumptionLaw_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedChannelsCapacityConsumptionLaw: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaximumDL_PowerCapability                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MaximumDL_PowerCapability (ASN1CTXT* pctxt, MaximumDL_PowerCapability value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MaximumDL_PowerCapability: start\n");

   if ( (value <= 500) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(500));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MaximumDL_PowerCapability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MinSpreadingFactor                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MinSpreadingFactor (ASN1CTXT* pctxt, MinSpreadingFactor value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_MinSpreadingFactor: start\n");

   switch (value) {
      case v4_5: ui = 0; break;
      case v8_4: ui = 1; break;
      case v16_3: ui = 2; break;
      case v32_1: ui = 3; break;
      case v64: ui = 4; break;
      case v128: ui = 5; break;
      case v256: ui = 6; break;
      case v512: ui = 7; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_MinSpreadingFactor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MinimumDL_PowerCapability                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MinimumDL_PowerCapability (ASN1CTXT* pctxt, MinimumDL_PowerCapability value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MinimumDL_PowerCapability: start\n");

   if ( (value <= 800) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(800));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MinimumDL_PowerCapability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Carrier_Power_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmitted_Carrier_Power_Value (ASN1CTXT* pctxt, Transmitted_Carrier_Power_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Carrier_Power_Value: start\n");

   if ( (value <= 100) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Carrier_Power_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Received_total_wide_band_power_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Received_total_wide_band_power_Value (ASN1CTXT* pctxt, Received_total_wide_band_power_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Received_total_wide_band_power_Value: start\n");

   if ( (value <= 621) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(621));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Received_total_wide_band_power_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Acknowledged_PRACH_preambles_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Acknowledged_PRACH_preambles_Value (ASN1CTXT* pctxt, Acknowledged_PRACH_preambles_Value value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Acknowledged_PRACH_preambles_Value: start\n");

   if ( (value >= 0 && value <= 240) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(240));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Acknowledged_PRACH_preambles_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotISCP_Value                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_TimeslotISCP_Value (ASN1CTXT* pctxt, UL_TimeslotISCP_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeslotISCP_Value: start\n");

   if ( (value <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeslotISCP_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_CommonMeasurementValue                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Extension_CommonMeasurementValue (ASN1CTXT* pctxt, Extension_CommonMeasurementValue* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_CommonMeasurementValue: start\n");

   stat = asn1PE_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_CommonMeasurementValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementValue                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonMeasurementValue (ASN1CTXT* pctxt, CommonMeasurementValue* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 6);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 5);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* transmitted_carrier_power */
         case 1:
            PU_PUSHNAME (pctxt, "u.transmitted_carrier_power");

            stat = asn1PE_Transmitted_Carrier_Power_Value (pctxt, pvalue->u.transmitted_carrier_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* received_total_wide_band_power */
         case 2:
            PU_PUSHNAME (pctxt, "u.received_total_wide_band_power");

            stat = asn1PE_Received_total_wide_band_power_Value (pctxt, pvalue->u.received_total_wide_band_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* acknowledged_prach_preambles */
         case 3:
            PU_PUSHNAME (pctxt, "u.acknowledged_prach_preambles");

            stat = asn1PE_Acknowledged_PRACH_preambles_Value (pctxt, pvalue->u.acknowledged_prach_preambles);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* uL_TimeslotISCP */
         case 4:
            PU_PUSHNAME (pctxt, "u.uL_TimeslotISCP");

            stat = asn1PE_UL_TimeslotISCP_Value (pctxt, pvalue->u.uL_TimeslotISCP);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* notUsed_1_acknowledged_PCPCH_access_preambles */
         case 5:
            PU_PUSHNAME (pctxt, "u.notUsed_1_acknowledged_PCPCH_access_preambles");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* notUsed_2_detected_PCPCH_access_preambles */
         case 6:
            PU_PUSHNAME (pctxt, "u.notUsed_2_detected_PCPCH_access_preambles");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 7);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* extension_CommonMeasurementValue */
         case 7:
            stat = asn1PE_Extension_CommonMeasurementValue (&lctxt, pvalue->u.extension_CommonMeasurementValue);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_POPNAME (pctxt);

      rtFreeContext (&lctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementAvailable                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonMeasurementAvailable (ASN1CTXT* pctxt, CommonMeasurementAvailable* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementAvailable: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode commonmeasurementValue */

   PU_PUSHNAME (pctxt, "commonmeasurementValue");

   stat = asn1PE_CommonMeasurementValue (pctxt, &pvalue->commonmeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementnotAvailable                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonMeasurementnotAvailable_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementnotAvailable: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementnotAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementValueInformation                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonMeasurementValueInformation (ASN1CTXT* pctxt, CommonMeasurementValueInformation* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementValueInformation: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* measurementAvailable */
      case 1:
         PU_PUSHNAME (pctxt, "u.measurementAvailable");

         stat = asn1PE_CommonMeasurementAvailable (pctxt, pvalue->u.measurementAvailable);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      /* measurementnotAvailable */
      case 2:
         PU_PUSHNAME (pctxt, "u.measurementnotAvailable");

         stat = asn1PE_CommonMeasurementnotAvailable (pctxt);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  N_INSYNC_IND                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_N_INSYNC_IND (ASN1CTXT* pctxt, N_INSYNC_IND value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_N_INSYNC_IND: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_N_INSYNC_IND: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  N_OUTSYNC_IND                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_N_OUTSYNC_IND (ASN1CTXT* pctxt, N_OUTSYNC_IND value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_N_OUTSYNC_IND: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_N_OUTSYNC_IND: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T_RLFAILURE                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_T_RLFAILURE (ASN1CTXT* pctxt, T_RLFAILURE value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_T_RLFAILURE: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_T_RLFAILURE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCPICH_Power                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PrimaryCPICH_Power (ASN1CTXT* pctxt, PrimaryCPICH_Power value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrimaryCPICH_Power: start\n");

   if ( (value >= -100 && value <= 500) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-100), OSINTCONST(500));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PrimaryCPICH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmitDiversityIndicator                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransmitDiversityIndicator (ASN1CTXT* pctxt, TransmitDiversityIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmitDiversityIndicator: start\n");

   switch (value) {
      case active_5: ui = 0; break;
      case inactive_4: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmitDiversityIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerRaiseLimit                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PowerRaiseLimit (ASN1CTXT* pctxt, PowerRaiseLimit value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PowerRaiseLimit: start\n");

   if ( (value <= 10) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(10));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PowerRaiseLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DLPowerAveragingWindowSize                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DLPowerAveragingWindowSize (ASN1CTXT* pctxt, DLPowerAveragingWindowSize value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DLPowerAveragingWindowSize: start\n");

   if ( (value >= 1 && value <= 60) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(60));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_DLPowerAveragingWindowSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_FDD_Parameters_iP_SpacingFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_FDD_Parameters_iP_SpacingFDD (ASN1CTXT* pctxt, IPDL_FDD_Parameters_iP_SpacingFDD value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_FDD_Parameters_iP_SpacingFDD: start\n");

   extbit = 0;

   switch (value) {
      case sp5: ui = 0; break;
      case sp7: ui = 1; break;
      case sp10: ui = 2; break;
      case sp15: ui = 3; break;
      case sp20: ui = 4; break;
      case sp30: ui = 5; break;
      case sp40: ui = 6; break;
      case sp50: ui = 7; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_FDD_Parameters_iP_SpacingFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_FDD_Parameters_iP_Length                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_FDD_Parameters_iP_Length (ASN1CTXT* pctxt, IPDL_FDD_Parameters_iP_Length value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_FDD_Parameters_iP_Length: start\n");

   switch (value) {
      case len5: ui = 0; break;
      case len10: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_FDD_Parameters_iP_Length: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BurstModeParams                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BurstModeParams (ASN1CTXT* pctxt, BurstModeParams* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_BurstModeParams: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode burstStart */

   PU_PUSHNAME (pctxt, "burstStart");

   if ( (pvalue->burstStart <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->burstStart, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode burstLength */

   PU_PUSHNAME (pctxt, "burstLength");

   if ( (pvalue->burstLength >= 10 && pvalue->burstLength <= 25) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->burstLength, OSUINTCONST(10), OSUINTCONST(25));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode burstFreq */

   PU_PUSHNAME (pctxt, "burstFreq");

   if ( (pvalue->burstFreq >= 1 && pvalue->burstFreq <= 16) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->burstFreq, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_BurstModeParams: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_FDD_Parameters                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_FDD_Parameters (ASN1CTXT* pctxt, IPDL_FDD_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_FDD_Parameters: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "burstModeParamsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.burstModeParamsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode iP_SpacingFDD */

   PU_PUSHNAME (pctxt, "iP_SpacingFDD");

   stat = asn1PE_IPDL_FDD_Parameters_iP_SpacingFDD (pctxt, pvalue->iP_SpacingFDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iP_Length */

   PU_PUSHNAME (pctxt, "iP_Length");

   stat = asn1PE_IPDL_FDD_Parameters_iP_Length (pctxt, pvalue->iP_Length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode seed */

   PU_PUSHNAME (pctxt, "seed");

   if ( (pvalue->seed <= 63) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->seed, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode burstModeParams */

   if (pvalue->m.burstModeParamsPresent) {
      PU_PUSHNAME (pctxt, "burstModeParams");

      stat = asn1PE_BurstModeParams (pctxt, &pvalue->burstModeParams);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iP_Offset */

   PU_PUSHNAME (pctxt, "iP_Offset");

   if ( (pvalue->iP_Offset <= 9) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->iP_Offset, OSUINTCONST(0), OSUINTCONST(9));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_FDD_Parameters: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_Indicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_Indicator (ASN1CTXT* pctxt, IPDL_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_Indicator: start\n");

   switch (value) {
      case active_2: ui = 0; break;
      case inactive_2: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellPortionID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellPortionID (ASN1CTXT* pctxt, CellPortionID value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellPortionID: start\n");

   if ( (value >= 0 && value <= 63) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(63));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CellPortionID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SCH_TimeSlot                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SCH_TimeSlot (ASN1CTXT* pctxt, SCH_TimeSlot value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SCH_TimeSlot: start\n");

   if ( (value <= 6) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SCH_TimeSlot: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCCPCH_Power                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PCCPCH_Power (ASN1CTXT* pctxt, PCCPCH_Power value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PCCPCH_Power: start\n");

   if ( (value >= -150 && value <= 400) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-150), OSINTCONST(400));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PCCPCH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SCTD_Indicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SCTD_Indicator (ASN1CTXT* pctxt, SCTD_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_SCTD_Indicator: start\n");

   switch (value) {
      case active: ui = 0; break;
      case inactive: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SCTD_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotStatus                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TimeSlotStatus (ASN1CTXT* pctxt, TimeSlotStatus value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeSlotStatus: start\n");

   extbit = 0;

   switch (value) {
      case active_4: ui = 0; break;
      case not_active: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeSlotStatus: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotDirection                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TimeSlotDirection (ASN1CTXT* pctxt, TimeSlotDirection value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeSlotDirection: start\n");

   extbit = 0;

   switch (value) {
      case ul: ui = 0; break;
      case dl: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeSlotDirection: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DwPCH_Power                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DwPCH_Power (ASN1CTXT* pctxt, DwPCH_Power value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DwPCH_Power: start\n");

   if ( (value >= -150 && value <= 400) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-150), OSINTCONST(400));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DwPCH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_iP_SpacingTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_TDD_Parameters_iP_SpacingTDD (ASN1CTXT* pctxt, IPDL_TDD_Parameters_iP_SpacingTDD value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_iP_SpacingTDD: start\n");

   extbit = 0;

   switch (value) {
      case sp30_1: ui = 0; break;
      case sp40_1: ui = 1; break;
      case sp50_1: ui = 2; break;
      case sp70: ui = 3; break;
      case sp100: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_iP_SpacingTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_iP_PCCPCH                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_TDD_Parameters_iP_PCCPCH (ASN1CTXT* pctxt, IPDL_TDD_Parameters_iP_PCCPCH value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_iP_PCCPCH: start\n");

   switch (value) {
      case switchOff_1_Frame: ui = 0; break;
      case switchOff_2_Frames: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_iP_PCCPCH: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_TDD_Parameters (ASN1CTXT* pctxt, IPDL_TDD_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "burstModeParamsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.burstModeParamsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode iP_SpacingTDD */

   PU_PUSHNAME (pctxt, "iP_SpacingTDD");

   stat = asn1PE_IPDL_TDD_Parameters_iP_SpacingTDD (pctxt, pvalue->iP_SpacingTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iP_Start */

   PU_PUSHNAME (pctxt, "iP_Start");

   if ( (pvalue->iP_Start <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->iP_Start, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode iP_Slot */

   PU_PUSHNAME (pctxt, "iP_Slot");

   if ( (pvalue->iP_Slot <= 14) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->iP_Slot, OSUINTCONST(0), OSUINTCONST(14));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode iP_PCCPCH */

   PU_PUSHNAME (pctxt, "iP_PCCPCH");

   stat = asn1PE_IPDL_TDD_Parameters_iP_PCCPCH (pctxt, pvalue->iP_PCCPCH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode burstModeParams */

   if (pvalue->m.burstModeParamsPresent) {
      PU_PUSHNAME (pctxt, "burstModeParams");

      stat = asn1PE_BurstModeParams (pctxt, &pvalue->burstModeParams);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_LCR_iP_SpacingTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_TDD_Parameters_LCR_iP_SpacingTDD (ASN1CTXT* pctxt, IPDL_TDD_Parameters_LCR_iP_SpacingTDD value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_LCR_iP_SpacingTDD: start\n");

   extbit = 0;

   switch (value) {
      case sp30_2: ui = 0; break;
      case sp40_2: ui = 1; break;
      case sp50_2: ui = 2; break;
      case sp70_1: ui = 3; break;
      case sp100_1: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_LCR_iP_SpacingTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_LCR_iP_Sub                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_TDD_Parameters_LCR_iP_Sub (ASN1CTXT* pctxt, IPDL_TDD_Parameters_LCR_iP_Sub value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_LCR_iP_Sub: start\n");

   switch (value) {
      case first: ui = 0; break;
      case second: ui = 1; break;
      case both: ui = 2; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_LCR_iP_Sub: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_LCR                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPDL_TDD_Parameters_LCR (ASN1CTXT* pctxt, IPDL_TDD_Parameters_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "burstModeParamsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.burstModeParamsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode iP_SpacingTDD */

   PU_PUSHNAME (pctxt, "iP_SpacingTDD");

   stat = asn1PE_IPDL_TDD_Parameters_LCR_iP_SpacingTDD (pctxt, pvalue->iP_SpacingTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iP_Start */

   PU_PUSHNAME (pctxt, "iP_Start");

   if ( (pvalue->iP_Start <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->iP_Start, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode iP_Sub */

   PU_PUSHNAME (pctxt, "iP_Sub");

   stat = asn1PE_IPDL_TDD_Parameters_LCR_iP_Sub (pctxt, pvalue->iP_Sub);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode burstModeParams */

   if (pvalue->m.burstModeParamsPresent) {
      PU_PUSHNAME (pctxt, "burstModeParams");

      stat = asn1PE_BurstModeParams (pctxt, &pvalue->burstModeParams);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IPDL_TDD_Parameters_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AddorDeleteIndicator                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AddorDeleteIndicator (ASN1CTXT* pctxt, AddorDeleteIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_AddorDeleteIndicator: start\n");

   switch (value) {
      case add: ui = 0; break;
      case delete_: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_AddorDeleteIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_Type                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IB_Type (ASN1CTXT* pctxt, IB_Type value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_Type: start\n");

   extbit = 0;

   switch (value) {
      case mIB: ui = 0; break;
      case sB1: ui = 1; break;
      case sB2: ui = 2; break;
      case sIB1: ui = 3; break;
      case sIB2: ui = 4; break;
      case sIB3: ui = 5; break;
      case sIB4: ui = 6; break;
      case sIB5: ui = 7; break;
      case sIB6: ui = 8; break;
      case sIB7: ui = 9; break;
      case sIB8: ui = 10; break;
      case sIB9: ui = 11; break;
      case sIB10: ui = 12; break;
      case sIB11: ui = 13; break;
      case sIB12: ui = 14; break;
      case sIB13: ui = 15; break;
      case sIB13dot1: ui = 16; break;
      case sIB13dot2: ui = 17; break;
      case sIB13dot3: ui = 18; break;
      case sIB13dot4: ui = 19; break;
      case sIB14: ui = 20; break;
      case sIB15: ui = 21; break;
      case sIB15dot1: ui = 22; break;
      case sIB15dot2: ui = 23; break;
      case sIB15dot3: ui = 24; break;
      case sIB16: ui = 25; break;
      case sIB17: ui = 0; extbit = 1; break;
      case sIB15dot4: ui = 1; extbit = 1; break;
      case sIB18: ui = 2; extbit = 1; break;
      case sIB15dot5: ui = 3; extbit = 1; break;
      case sIB5bis: ui = 4; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(25));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_Type: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_OC_ID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IB_OC_ID (ASN1CTXT* pctxt, IB_OC_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_OC_ID: start\n");

   if ( (value >= 1 && value <= 16) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_OC_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIB_Originator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SIB_Originator (ASN1CTXT* pctxt, SIB_Originator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SIB_Originator: start\n");

   extbit = 0;

   switch (value) {
      case nodeB: ui = 0; break;
      case cRNC: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SIB_Originator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_SG_REP                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IB_SG_REP (ASN1CTXT* pctxt, IB_SG_REP value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_SG_REP: start\n");

   switch (value) {
      case rep4: ui = 0; break;
      case rep8: ui = 1; break;
      case rep16: ui = 2; break;
      case rep32: ui = 3; break;
      case rep64: ui = 4; break;
      case rep128: ui = 5; break;
      case rep256: ui = 6; break;
      case rep512: ui = 7; break;
      case rep1024: ui = 8; break;
      case rep2048: ui = 9; break;
      case rep4096: ui = 10; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(10));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_SG_REP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_SG_POS                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IB_SG_POS (ASN1CTXT* pctxt, IB_SG_POS value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_SG_POS: start\n");

   if ( (value <= 4094) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4094));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_SG_POS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Segment_Type                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Segment_Type (ASN1CTXT* pctxt, Segment_Type value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Segment_Type: start\n");

   extbit = 0;

   switch (value) {
      case first_segment: ui = 0; break;
      case first_segment_short: ui = 1; break;
      case subsequent_segment: ui = 2; break;
      case last_segment: ui = 3; break;
      case last_segment_short: ui = 4; break;
      case complete_SIB: ui = 5; break;
      case complete_SIB_short: ui = 6; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Segment_Type: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_SG_DATA                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IB_SG_DATA (ASN1CTXT* pctxt, IB_SG_DATA value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_SG_DATA: start\n");

   stat = pe_BitString (pctxt, value.numbits, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_IB_SG_DATA: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_ScramblingCodeNumber                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_ScramblingCodeNumber (ASN1CTXT* pctxt, UL_ScramblingCodeNumber value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_ScramblingCodeNumber: start\n");

   if ( (value <= 16777215) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_ScramblingCodeNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_ScramblingCodeLength                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_ScramblingCodeLength (ASN1CTXT* pctxt, UL_ScramblingCodeLength value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_ScramblingCodeLength: start\n");

   switch (value) {
      case short_: ui = 0; break;
      case long_: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_ScramblingCodeLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_ScramblingCode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_ScramblingCode (ASN1CTXT* pctxt, UL_ScramblingCode* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_ScramblingCode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uL_ScramblingCodeNumber */

   PU_PUSHNAME (pctxt, "uL_ScramblingCodeNumber");

   stat = asn1PE_UL_ScramblingCodeNumber (pctxt, pvalue->uL_ScramblingCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode uL_ScramblingCodeLength */

   PU_PUSHNAME (pctxt, "uL_ScramblingCodeLength");

   stat = asn1PE_UL_ScramblingCodeLength (pctxt, pvalue->uL_ScramblingCodeLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_ScramblingCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MinUL_ChannelisationCodeLength                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MinUL_ChannelisationCodeLength (ASN1CTXT* pctxt, MinUL_ChannelisationCodeLength value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MinUL_ChannelisationCodeLength: start\n");

   extbit = 0;

   switch (value) {
      case v4_6: ui = 0; break;
      case v8_5: ui = 1; break;
      case v16_4: ui = 2; break;
      case v32_2: ui = 3; break;
      case v64_1: ui = 4; break;
      case v128_1: ui = 5; break;
      case v256_1: ui = 6; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MinUL_ChannelisationCodeLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxNrOfUL_DPDCHs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MaxNrOfUL_DPDCHs (ASN1CTXT* pctxt, MaxNrOfUL_DPDCHs value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MaxNrOfUL_DPDCHs: start\n");

   if ( (value >= 1 && value <= 6) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MaxNrOfUL_DPDCHs: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCCH_SlotFormat                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_DPCCH_SlotFormat (ASN1CTXT* pctxt, UL_DPCCH_SlotFormat value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_DPCCH_SlotFormat: start\n");

   if ( (value >= 0 && value <= 5) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_DPCCH_SlotFormat: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_SIR                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_SIR (ASN1CTXT* pctxt, UL_SIR value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_SIR: start\n");

   if ( (value >= -82 && value <= 173) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-82), OSINTCONST(173));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_SIR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityMode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DiversityMode (ASN1CTXT* pctxt, DiversityMode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DiversityMode: start\n");

   extbit = 0;

   switch (value) {
      case none: ui = 0; break;
      case sTTD: ui = 1; break;
      case closed_loop_mode1: ui = 2; break;
      case not_used_closed_loop_mode2: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DiversityMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_SlotFormat                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_DPCH_SlotFormat (ASN1CTXT* pctxt, DL_DPCH_SlotFormat value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_DPCH_SlotFormat: start\n");

   if ( (value >= 0 && value <= 16) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(16));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_DPCH_SlotFormat: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCI_SignallingMode_TFCI_SignallingOption                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCI_SignallingMode_TFCI_SignallingOption (ASN1CTXT* pctxt, TFCI_SignallingMode_TFCI_SignallingOption value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCI_SignallingMode_TFCI_SignallingOption: start\n");

   switch (value) {
      case normal_1: ui = 0; break;
      case not_Used_split: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCI_SignallingMode_TFCI_SignallingOption: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCI_SignallingMode                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TFCI_SignallingMode (ASN1CTXT* pctxt, TFCI_SignallingMode* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCI_SignallingMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_splitTypePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.not_Used_splitTypePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_lengthOfTFCI2Present");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.not_Used_lengthOfTFCI2Present);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode tFCI_SignallingOption */

   PU_PUSHNAME (pctxt, "tFCI_SignallingOption");

   stat = asn1PE_TFCI_SignallingMode_TFCI_SignallingOption (pctxt, pvalue->tFCI_SignallingOption);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode not_Used_splitType */

   if (pvalue->m.not_Used_splitTypePresent) {
      PU_PUSHNAME (pctxt, "not_Used_splitType");

      /* NULL */
      PU_POPNAME (pctxt);
   }

   /* encode not_Used_lengthOfTFCI2 */

   if (pvalue->m.not_Used_lengthOfTFCI2Present) {
      PU_PUSHNAME (pctxt, "not_Used_lengthOfTFCI2");

      /* NULL */
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TFCI_SignallingMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_TPC_DownlinkStepSize                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FDD_TPC_DownlinkStepSize (ASN1CTXT* pctxt, FDD_TPC_DownlinkStepSize value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_TPC_DownlinkStepSize: start\n");

   extbit = 0;

   switch (value) {
      case step_size0_5: ui = 0; break;
      case step_size1: ui = 1; break;
      case step_size1_5: ui = 2; break;
      case step_size2: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_TPC_DownlinkStepSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LimitedPowerIncrease                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LimitedPowerIncrease (ASN1CTXT* pctxt, LimitedPowerIncrease value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_LimitedPowerIncrease: start\n");

   switch (value) {
      case used: ui = 0; break;
      case not_used: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_LimitedPowerIncrease: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InnerLoopDLPCStatus                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InnerLoopDLPCStatus (ASN1CTXT* pctxt, InnerLoopDLPCStatus value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_InnerLoopDLPCStatus: start\n");

   switch (value) {
      case active_1: ui = 0; break;
      case inactive_1: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_InnerLoopDLPCStatus: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_ID                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RL_ID (ASN1CTXT* pctxt, RL_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_ID: start\n");

   if ( (value <= 31) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FirstRLS_Indicator                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FirstRLS_Indicator (ASN1CTXT* pctxt, FirstRLS_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_FirstRLS_Indicator: start\n");

   extbit = 0;

   switch (value) {
      case first_RLS: ui = 0; break;
      case not_first_RLS: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FirstRLS_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrameOffset                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FrameOffset (ASN1CTXT* pctxt, FrameOffset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_FrameOffset: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_FrameOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ChipOffset                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ChipOffset (ASN1CTXT* pctxt, ChipOffset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ChipOffset: start\n");

   if ( (value <= 38399) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(38399));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_ChipOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PropagationDelay                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PropagationDelay (ASN1CTXT* pctxt, PropagationDelay value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PropagationDelay: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_PropagationDelay: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityControlField                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DiversityControlField (ASN1CTXT* pctxt, DiversityControlField value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DiversityControlField: start\n");

   extbit = 0;

   switch (value) {
      case may: ui = 0; break;
      case must: ui = 1; break;
      case must_not: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DiversityControlField: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmissionGapPatternSequenceCodeInformation             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransmissionGapPatternSequenceCodeInformation (ASN1CTXT* pctxt, TransmissionGapPatternSequenceCodeInformation value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionGapPatternSequenceCodeInformation: start\n");

   switch (value) {
      case code_change: ui = 0; break;
      case nocode_change: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionGapPatternSequenceCodeInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DL_CodeInformationItem                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FDD_DL_CodeInformationItem (ASN1CTXT* pctxt, FDD_DL_CodeInformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DL_CodeInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transmissionGapPatternSequenceCodeInformationPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transmissionGapPatternSequenceCodeInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dl_ScramblingCode */

   PU_PUSHNAME (pctxt, "dl_ScramblingCode");

   stat = asn1PE_DL_ScramblingCode (pctxt, pvalue->dl_ScramblingCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode fdd_DL_ChannelisationCodeNumber */

   PU_PUSHNAME (pctxt, "fdd_DL_ChannelisationCodeNumber");

   stat = asn1PE_FDD_DL_ChannelisationCodeNumber (pctxt, pvalue->fdd_DL_ChannelisationCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode transmissionGapPatternSequenceCodeInformation */

   if (pvalue->m.transmissionGapPatternSequenceCodeInformationPresent) {
      PU_PUSHNAME (pctxt, "transmissionGapPatternSequenceCodeInformation");

      stat = asn1PE_TransmissionGapPatternSequenceCodeInformation (pctxt, pvalue->transmissionGapPatternSequenceCodeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DL_CodeInformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DL_CodeInformation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FDD_DL_CodeInformation (ASN1CTXT* pctxt, FDD_DL_CodeInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(10), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DL_CodeInformation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_FDD_DL_CodeInformationItem (pctxt, ((FDD_DL_CodeInformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DL_CodeInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Max_Set_E_DPDCHs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Max_Set_E_DPDCHs (ASN1CTXT* pctxt, Max_Set_E_DPDCHs value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Max_Set_E_DPDCHs: start\n");

   extbit = 0;

   switch (value) {
      case vN64: ui = 0; break;
      case vN32: ui = 1; break;
      case vN16: ui = 2; break;
      case vN8: ui = 3; break;
      case v2xN4: ui = 4; break;
      case v2xN2: ui = 5; break;
      case v2xN2plus2xN4: ui = 6; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Max_Set_E_DPDCHs: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_TFCS_Index                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_TFCS_Index (ASN1CTXT* pctxt, E_DCH_TFCS_Index value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_TFCS_Index: start\n");

   if ( (value >= 1 && value <= 4) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_TFCS_Index: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_TFCI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_TFCI (ASN1CTXT* pctxt, E_TFCI value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_TFCI: start\n");

   if ( (value <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_TFCI: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_E_TFCI_PO                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Reference_E_TFCI_PO (ASN1CTXT* pctxt, Reference_E_TFCI_PO value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Reference_E_TFCI_PO: start\n");

   if ( (value <= 8) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Reference_E_TFCI_PO: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_E_TFCI_Information_Item                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Reference_E_TFCI_Information_Item (ASN1CTXT* pctxt, Reference_E_TFCI_Information_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Reference_E_TFCI_Information_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode reference_E_TFCI */

   PU_PUSHNAME (pctxt, "reference_E_TFCI");

   stat = asn1PE_E_TFCI (pctxt, pvalue->reference_E_TFCI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode reference_E_TFCI_PO */

   PU_PUSHNAME (pctxt, "reference_E_TFCI_PO");

   stat = asn1PE_Reference_E_TFCI_PO (pctxt, pvalue->reference_E_TFCI_PO);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Reference_E_TFCI_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_E_TFCI_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Reference_E_TFCI_Information (ASN1CTXT* pctxt, Reference_E_TFCI_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Reference_E_TFCI_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_Reference_E_TFCI_Information_Item (pctxt, ((Reference_E_TFCI_Information_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Reference_E_TFCI_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_TFCS_Information                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_TFCS_Information (ASN1CTXT* pctxt, E_TFCS_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_TFCS_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_TFCS_Index */

   PU_PUSHNAME (pctxt, "e_DCH_TFCS_Index");

   stat = asn1PE_E_DCH_TFCS_Index (pctxt, pvalue->e_DCH_TFCS_Index);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode e_DCH_Min_Set_E_TFCI */

   PU_PUSHNAME (pctxt, "e_DCH_Min_Set_E_TFCI");

   stat = asn1PE_E_TFCI (pctxt, pvalue->e_DCH_Min_Set_E_TFCI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode reference_E_TFCI_Information */

   PU_PUSHNAME (pctxt, "reference_E_TFCI_Information");

   stat = asn1PE_Reference_E_TFCI_Information (pctxt, &pvalue->reference_E_TFCI_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_TFCS_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_TTI                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_TTI (ASN1CTXT* pctxt, E_TTI value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_TTI: start\n");

   switch (value) {
      case e_TTI_2ms: ui = 0; break;
      case e_TTI_10ms: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_TTI: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DPCCH_PO                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DPCCH_PO (ASN1CTXT* pctxt, E_DPCCH_PO value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DPCCH_PO: start\n");

   if ( (value <= 8) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DPCCH_PO: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DPCHOffset                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_DPCHOffset (ASN1CTXT* pctxt, TDD_DPCHOffset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DPCHOffset: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* initialOffset */
      case 1:
         PU_PUSHNAME (pctxt, "u.initialOffset");

         stat = pe_ConsUnsigned (pctxt, pvalue->u.initialOffset, OSUINTCONST(0), OSUINTCONST(255));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* noinitialOffset */
      case 2:
         PU_PUSHNAME (pctxt, "u.noinitialOffset");

         if ( (pvalue->u.noinitialOffset <= 63) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.noinitialOffset, OSUINTCONST(0), OSUINTCONST(63));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else
            return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DPCHOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DPCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DPCH_ID (ASN1CTXT* pctxt, DPCH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DPCH_ID: start\n");

   if ( (value <= 239) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(239));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_DPCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_Code_InformationItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_UL_Code_InformationItem (ASN1CTXT* pctxt, TDD_UL_Code_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_Code_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PE_DPCH_ID (pctxt, pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PE_TDD_ChannelisationCode (pctxt, pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_Code_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_Code_Information                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_UL_Code_Information (ASN1CTXT* pctxt, TDD_UL_Code_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_Code_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_TDD_UL_Code_InformationItem (pctxt, ((TDD_UL_Code_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_Timeslot_InformationItem (ASN1CTXT* pctxt, UL_Timeslot_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Timeslot_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PE_TimeSlot (pctxt, pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PE_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PE_TFCI_Presence (pctxt, pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode uL_Code_InformationList */

   PU_PUSHNAME (pctxt, "uL_Code_InformationList");

   stat = asn1PE_TDD_UL_Code_Information (pctxt, &pvalue->uL_Code_InformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Timeslot_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_Information                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_Timeslot_Information (ASN1CTXT* pctxt, UL_Timeslot_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Timeslot_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_UL_Timeslot_InformationItem (pctxt, ((UL_Timeslot_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Timeslot_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QPSK_UL_DPCH_TimeSlotFormatTDD_LCR                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_QPSK_UL_DPCH_TimeSlotFormatTDD_LCR (ASN1CTXT* pctxt, QPSK_UL_DPCH_TimeSlotFormatTDD_LCR value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_QPSK_UL_DPCH_TimeSlotFormatTDD_LCR: start\n");

   if ( (value >= 0 && value <= 69) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(69));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_QPSK_UL_DPCH_TimeSlotFormatTDD_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR (ASN1CTXT* pctxt, EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR: start\n");

   if ( (value >= 0 && value <= 24) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_DPCH_TimeSlotFormat_LCR                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_UL_DPCH_TimeSlotFormat_LCR (ASN1CTXT* pctxt, TDD_UL_DPCH_TimeSlotFormat_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_DPCH_TimeSlotFormat_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* qPSK */
         case 1:
            PU_PUSHNAME (pctxt, "u.qPSK");

            stat = asn1PE_QPSK_UL_DPCH_TimeSlotFormatTDD_LCR (pctxt, pvalue->u.qPSK);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* eightPSK */
         case 2:
            PU_PUSHNAME (pctxt, "u.eightPSK");

            stat = asn1PE_EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR (pctxt, pvalue->u.eightPSK);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_DPCH_TimeSlotFormat_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_Code_LCR_InformationItem                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_UL_Code_LCR_InformationItem (ASN1CTXT* pctxt, TDD_UL_Code_LCR_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_Code_LCR_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PE_DPCH_ID (pctxt, pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PE_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tdd_UL_DPCH_TimeSlotFormat_LCR */

   PU_PUSHNAME (pctxt, "tdd_UL_DPCH_TimeSlotFormat_LCR");

   stat = asn1PE_TDD_UL_DPCH_TimeSlotFormat_LCR (pctxt, &pvalue->tdd_UL_DPCH_TimeSlotFormat_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_Code_LCR_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_Code_LCR_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_UL_Code_LCR_Information (ASN1CTXT* pctxt, TDD_UL_Code_LCR_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_Code_LCR_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_TDD_UL_Code_LCR_InformationItem (pctxt, ((TDD_UL_Code_LCR_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_UL_Code_LCR_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotLCR_InformationItem                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_TimeslotLCR_InformationItem (ASN1CTXT* pctxt, UL_TimeslotLCR_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeslotLCR_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PE_TimeSlotLCR (pctxt, pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PE_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PE_TFCI_Presence (pctxt, pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode uL_Code_InformationList */

   PU_PUSHNAME (pctxt, "uL_Code_InformationList");

   stat = asn1PE_TDD_UL_Code_LCR_Information (pctxt, &pvalue->uL_Code_InformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeslotLCR_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotLCR_Information                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_TimeslotLCR_Information (ASN1CTXT* pctxt, UL_TimeslotLCR_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeslotLCR_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_UL_TimeslotLCR_InformationItem (pctxt, ((UL_TimeslotLCR_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeslotLCR_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_TPC_DownlinkStepSize                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_TPC_DownlinkStepSize (ASN1CTXT* pctxt, TDD_TPC_DownlinkStepSize value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_TPC_DownlinkStepSize: start\n");

   extbit = 0;

   switch (value) {
      case step_size1_1: ui = 0; break;
      case step_size2_1: ui = 1; break;
      case step_size3: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_TPC_DownlinkStepSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_Code_InformationItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_DL_Code_InformationItem (ASN1CTXT* pctxt, TDD_DL_Code_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_Code_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PE_DPCH_ID (pctxt, pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PE_TDD_ChannelisationCode (pctxt, pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_Code_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_Code_Information                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_DL_Code_Information (ASN1CTXT* pctxt, TDD_DL_Code_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_Code_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_TDD_DL_Code_InformationItem (pctxt, ((TDD_DL_Code_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_Timeslot_InformationItem (ASN1CTXT* pctxt, DL_Timeslot_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_Timeslot_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PE_TimeSlot (pctxt, pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PE_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PE_TFCI_Presence (pctxt, pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dL_Code_Information */

   PU_PUSHNAME (pctxt, "dL_Code_Information");

   stat = asn1PE_TDD_DL_Code_Information (pctxt, &pvalue->dL_Code_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_Timeslot_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_Information                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_Timeslot_Information (ASN1CTXT* pctxt, DL_Timeslot_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_Timeslot_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DL_Timeslot_InformationItem (pctxt, ((DL_Timeslot_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_Timeslot_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_Code_LCR_InformationItem                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_DL_Code_LCR_InformationItem (ASN1CTXT* pctxt, TDD_DL_Code_LCR_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_Code_LCR_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PE_DPCH_ID (pctxt, pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PE_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tdd_DL_DPCH_TimeSlotFormat_LCR */

   PU_PUSHNAME (pctxt, "tdd_DL_DPCH_TimeSlotFormat_LCR");

   stat = asn1PE_TDD_DL_DPCH_TimeSlotFormat_LCR (pctxt, &pvalue->tdd_DL_DPCH_TimeSlotFormat_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_Code_LCR_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_Code_LCR_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_DL_Code_LCR_Information (ASN1CTXT* pctxt, TDD_DL_Code_LCR_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_Code_LCR_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_TDD_DL_Code_LCR_InformationItem (pctxt, ((TDD_DL_Code_LCR_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DL_Code_LCR_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotLCR_InformationItem                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_TimeslotLCR_InformationItem (ASN1CTXT* pctxt, DL_TimeslotLCR_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotLCR_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PE_TimeSlotLCR (pctxt, pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PE_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PE_TFCI_Presence (pctxt, pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dL_Code_LCR_Information */

   PU_PUSHNAME (pctxt, "dL_Code_LCR_Information");

   stat = asn1PE_TDD_DL_Code_LCR_Information (pctxt, &pvalue->dL_Code_LCR_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotLCR_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotLCR_Information                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_TimeslotLCR_Information (ASN1CTXT* pctxt, DL_TimeslotLCR_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotLCR_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DL_TimeslotLCR_InformationItem (pctxt, ((DL_TimeslotLCR_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotLCR_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SpecialBurstScheduling                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SpecialBurstScheduling (ASN1CTXT* pctxt, SpecialBurstScheduling value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpecialBurstScheduling: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SpecialBurstScheduling: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCP                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_TimeslotISCP (ASN1CTXT* pctxt, DL_TimeslotISCP value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCP: start\n");

   if ( (value <= 91) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(91));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCPInfoItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_TimeslotISCPInfoItem (ASN1CTXT* pctxt, DL_TimeslotISCPInfoItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCPInfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PE_TimeSlot (pctxt, pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dL_TimeslotISCP */

   PU_PUSHNAME (pctxt, "dL_TimeslotISCP");

   stat = asn1PE_DL_TimeslotISCP (pctxt, pvalue->dL_TimeslotISCP);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCPInfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCPInfo                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_TimeslotISCPInfo (ASN1CTXT* pctxt, DL_TimeslotISCPInfo* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCPInfo: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DL_TimeslotISCPInfoItem (pctxt, ((DL_TimeslotISCPInfoItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCPInfo: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_ID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RL_Set_ID (ASN1CTXT* pctxt, RL_Set_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Set_ID: start\n");

   if ( (value <= 31) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Set_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_ID (ASN1CTXT* pctxt, DCH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_InformationResponseItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_InformationResponseItem (ASN1CTXT* pctxt, DCH_InformationResponseItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_InformationResponseItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PE_DCH_ID (pctxt, pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_InformationResponseItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_InformationResponse                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_InformationResponse (ASN1CTXT* pctxt, DCH_InformationResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_InformationResponse: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DCH_InformationResponseItem (pctxt, ((DCH_InformationResponseItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_InformationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SSDT_SupportIndicator                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SSDT_SupportIndicator (ASN1CTXT* pctxt, SSDT_SupportIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_SSDT_SupportIndicator: start\n");

   switch (value) {
      case not_Used_sSDT_Supported: ui = 0; break;
      case sSDT_not_supported: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SSDT_SupportIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeSlot_ISCP_InfoItem                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_TimeSlot_ISCP_InfoItem (ASN1CTXT* pctxt, UL_TimeSlot_ISCP_InfoItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeSlot_ISCP_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PE_TimeSlot (pctxt, pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iSCP */

   PU_PUSHNAME (pctxt, "iSCP");

   stat = asn1PE_UL_TimeslotISCP_Value (pctxt, pvalue->iSCP);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeSlot_ISCP_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeSlot_ISCP_Info                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_TimeSlot_ISCP_Info (ASN1CTXT* pctxt, UL_TimeSlot_ISCP_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeSlot_ISCP_Info: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_UL_TimeSlot_ISCP_InfoItem (pctxt, ((UL_TimeSlot_ISCP_InfoItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeSlot_ISCP_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_PhysCH_SF_Variation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_PhysCH_SF_Variation (ASN1CTXT* pctxt, UL_PhysCH_SF_Variation value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_PhysCH_SF_Variation: start\n");

   switch (value) {
      case sf_variation_supported: ui = 0; break;
      case sf_variation_not_supported: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_PhysCH_SF_Variation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeSlot_ISCP_LCR_InfoItem                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_TimeSlot_ISCP_LCR_InfoItem (ASN1CTXT* pctxt, UL_TimeSlot_ISCP_LCR_InfoItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeSlot_ISCP_LCR_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PE_TimeSlotLCR (pctxt, pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iSCP */

   PU_PUSHNAME (pctxt, "iSCP");

   stat = asn1PE_UL_TimeslotISCP_Value (pctxt, pvalue->iSCP);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeSlot_ISCP_LCR_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeSlot_ISCP_LCR_Info                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_TimeSlot_ISCP_LCR_Info (ASN1CTXT* pctxt, UL_TimeSlot_ISCP_LCR_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeSlot_ISCP_LCR_Info: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_UL_TimeSlot_ISCP_LCR_InfoItem (pctxt, ((UL_TimeSlot_ISCP_LCR_InfoItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeSlot_ISCP_LCR_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseRadioNetwork                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseRadioNetwork (ASN1CTXT* pctxt, CauseRadioNetwork value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CauseRadioNetwork: start\n");

   extbit = 0;

   switch (value) {
      case unknown_C_ID: ui = 0; break;
      case cell_not_available: ui = 1; break;
      case power_level_not_supported: ui = 2; break;
      case dl_radio_resources_not_available: ui = 3; break;
      case ul_radio_resources_not_available: ui = 4; break;
      case rl_already_ActivatedOrAllocated: ui = 5; break;
      case nodeB_Resources_unavailable: ui = 6; break;
      case measurement_not_supported_for_the_object: ui = 7; break;
      case combining_resources_not_available: ui = 8; break;
      case requested_configuration_not_supported: ui = 9; break;
      case synchronisation_failure: ui = 10; break;
      case priority_transport_channel_established: ui = 11; break;
      case sIB_Origination_in_Node_B_not_Supported: ui = 12; break;
      case requested_tx_diversity_mode_not_supported: ui = 13; break;
      case unspecified_2: ui = 14; break;
      case bCCH_scheduling_error: ui = 15; break;
      case measurement_temporarily_not_available: ui = 16; break;
      case invalid_CM_settings: ui = 17; break;
      case reconfiguration_CFN_not_elapsed: ui = 18; break;
      case number_of_DL_codes_not_supported: ui = 19; break;
      case s_cipch_not_supported: ui = 20; break;
      case combining_not_supported: ui = 21; break;
      case ul_sf_not_supported: ui = 22; break;
      case dl_SF_not_supported: ui = 23; break;
      case common_transport_channel_type_not_supported: ui = 24; break;
      case dedicated_transport_channel_type_not_supported: ui = 25; break;
      case downlink_shared_channel_type_not_supported: ui = 26; break;
      case uplink_shared_channel_type_not_supported: ui = 27; break;
      case cm_not_supported: ui = 28; break;
      case tx_diversity_no_longer_supported: ui = 29; break;
      case unknown_Local_Cell_ID: ui = 30; break;
      case number_of_UL_codes_not_supported: ui = 0; extbit = 1; break;
      case information_temporarily_not_available: ui = 1; extbit = 1; break;
      case information_provision_not_supported_for_the_object: ui = 2; extbit = 1; break;
      case cell_synchronisation_not_supported: ui = 3; extbit = 1; break;
      case cell_synchronisation_adjustment_not_supported: ui = 4; extbit = 1; break;
      case dpc_mode_change_not_supported: ui = 5; extbit = 1; break;
      case iPDL_already_activated: ui = 6; extbit = 1; break;
      case iPDL_not_supported: ui = 7; extbit = 1; break;
      case iPDL_parameters_not_available: ui = 8; extbit = 1; break;
      case frequency_acquisition_not_supported: ui = 9; extbit = 1; break;
      case power_balancing_status_not_compatible: ui = 10; extbit = 1; break;
      case requested_typeofbearer_re_arrangement_not_supported: ui = 11; extbit = 1; break;
      case signalling_Bearer_Re_arrangement_not_supported: ui = 12; extbit = 1; break;
      case bearer_Re_arrangement_needed: ui = 13; extbit = 1; break;
      case delayed_activation_not_supported: ui = 14; extbit = 1; break;
      case rl_timing_adjustment_not_supported: ui = 15; extbit = 1; break;
      case mich_not_supported: ui = 16; extbit = 1; break;
      case f_DPCH_not_supported: ui = 17; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(30));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CauseRadioNetwork: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseTransport                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseTransport (ASN1CTXT* pctxt, CauseTransport value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CauseTransport: start\n");

   extbit = 0;

   switch (value) {
      case transport_resource_unavailable: ui = 0; break;
      case unspecified_3: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CauseTransport: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseProtocol                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseProtocol (ASN1CTXT* pctxt, CauseProtocol value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CauseProtocol: start\n");

   extbit = 0;

   switch (value) {
      case transfer_syntax_error: ui = 0; break;
      case abstract_syntax_error_reject: ui = 1; break;
      case abstract_syntax_error_ignore_and_notify: ui = 2; break;
      case message_not_compatible_with_receiver_state: ui = 3; break;
      case semantic_error: ui = 4; break;
      case unspecified_1: ui = 5; break;
      case abstract_syntax_error_falsely_constructed_message: ui = 6; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CauseProtocol: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseMisc                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseMisc (ASN1CTXT* pctxt, CauseMisc value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CauseMisc: start\n");

   extbit = 0;

   switch (value) {
      case control_processing_overload: ui = 0; break;
      case hardware_failure: ui = 1; break;
      case oam_intervention: ui = 2; break;
      case not_enough_user_plane_processing_resources: ui = 3; break;
      case unspecified: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CauseMisc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cause                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Cause (ASN1CTXT* pctxt, Cause* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Cause: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* radioNetwork */
         case 1:
            PU_PUSHNAME (pctxt, "u.radioNetwork");

            stat = asn1PE_CauseRadioNetwork (pctxt, pvalue->u.radioNetwork);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* transport */
         case 2:
            PU_PUSHNAME (pctxt, "u.transport");

            stat = asn1PE_CauseTransport (pctxt, pvalue->u.transport);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* protocol */
         case 3:
            PU_PUSHNAME (pctxt, "u.protocol");

            stat = asn1PE_CauseProtocol (pctxt, pvalue->u.protocol);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* misc */
         case 4:
            PU_PUSHNAME (pctxt, "u.misc");

            stat = asn1PE_CauseMisc (pctxt, pvalue->u.misc);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Cause: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_TPC_UplinkStepSize_LCR                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_TPC_UplinkStepSize_LCR (ASN1CTXT* pctxt, TDD_TPC_UplinkStepSize_LCR value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_TPC_UplinkStepSize_LCR: start\n");

   extbit = 0;

   switch (value) {
      case step_size1_2: ui = 0; break;
      case step_size2_2: ui = 1; break;
      case step_size3_1: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_TPC_UplinkStepSize_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DSCH_ID (ASN1CTXT* pctxt, DSCH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_ID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityLevel                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityLevel (ASN1CTXT* pctxt, PriorityLevel value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityLevel: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityLevel: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionCapability                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Pre_emptionCapability (ASN1CTXT* pctxt, Pre_emptionCapability value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_Pre_emptionCapability: start\n");

   switch (value) {
      case shall_not_trigger_pre_emption: ui = 0; break;
      case may_trigger_pre_emption: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Pre_emptionCapability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionVulnerability                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Pre_emptionVulnerability (ASN1CTXT* pctxt, Pre_emptionVulnerability value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_Pre_emptionVulnerability: start\n");

   switch (value) {
      case not_pre_emptable: ui = 0; break;
      case pre_emptable: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Pre_emptionVulnerability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationRetentionPriority                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AllocationRetentionPriority (ASN1CTXT* pctxt, AllocationRetentionPriority* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_AllocationRetentionPriority: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode priorityLevel */

   PU_PUSHNAME (pctxt, "priorityLevel");

   stat = asn1PE_PriorityLevel (pctxt, pvalue->priorityLevel);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode pre_emptionCapability */

   PU_PUSHNAME (pctxt, "pre_emptionCapability");

   stat = asn1PE_Pre_emptionCapability (pctxt, pvalue->pre_emptionCapability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode pre_emptionVulnerability */

   PU_PUSHNAME (pctxt, "pre_emptionVulnerability");

   stat = asn1PE_Pre_emptionVulnerability (pctxt, pvalue->pre_emptionVulnerability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AllocationRetentionPriority: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrameHandlingPriority                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FrameHandlingPriority (ASN1CTXT* pctxt, FrameHandlingPriority value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_FrameHandlingPriority: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_FrameHandlingPriority: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportBearerRequestIndicator                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportBearerRequestIndicator (ASN1CTXT* pctxt, TransportBearerRequestIndicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportBearerRequestIndicator: start\n");

   extbit = 0;

   switch (value) {
      case bearerRequested_1: ui = 0; break;
      case bearerNotRequested: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransportBearerRequestIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_USCH_ID (ASN1CTXT* pctxt, USCH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_ID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_ID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PUSCH_ID (ASN1CTXT* pctxt, PUSCH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PUSCH_ID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_PUSCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_ID                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SICH_ID (ASN1CTXT* pctxt, HS_SICH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_ID: start\n");

   if ( (value <= 31) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIR_Value                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SIR_Value (ASN1CTXT* pctxt, SIR_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SIR_Value: start\n");

   if ( (value <= 63) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SIR_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIR_Error_Value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SIR_Error_Value (ASN1CTXT* pctxt, SIR_Error_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SIR_Error_Value: start\n");

   if ( (value <= 125) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(125));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SIR_Error_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Code_Power_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmitted_Code_Power_Value (ASN1CTXT* pctxt, Transmitted_Code_Power_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Code_Power_Value: start\n");

   if ( (value <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Code_Power_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RSCP_Value                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RSCP_Value (ASN1CTXT* pctxt, RSCP_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RSCP_Value: start\n");

   if ( (value <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_RSCP_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rx_Timing_Deviation_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Rx_Timing_Deviation_Value (ASN1CTXT* pctxt, Rx_Timing_Deviation_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Rx_Timing_Deviation_Value: start\n");

   if ( (value <= 8191) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(8191));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Rx_Timing_Deviation_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Round_Trip_Time_Value                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Round_Trip_Time_Value (ASN1CTXT* pctxt, Round_Trip_Time_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Round_Trip_Time_Value: start\n");

   if ( (value <= 32767) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(32767));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Round_Trip_Time_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_DedicatedMeasurementValue                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Extension_DedicatedMeasurementValue (ASN1CTXT* pctxt, Extension_DedicatedMeasurementValue* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_DedicatedMeasurementValue: start\n");

   stat = asn1PE_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_DedicatedMeasurementValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementValue                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DedicatedMeasurementValue (ASN1CTXT* pctxt, DedicatedMeasurementValue* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 6);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 5);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sIR_Value */
         case 1:
            PU_PUSHNAME (pctxt, "u.sIR_Value");

            stat = asn1PE_SIR_Value (pctxt, pvalue->u.sIR_Value);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* sIR_ErrorValue */
         case 2:
            PU_PUSHNAME (pctxt, "u.sIR_ErrorValue");

            stat = asn1PE_SIR_Error_Value (pctxt, pvalue->u.sIR_ErrorValue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* transmittedCodePowerValue */
         case 3:
            PU_PUSHNAME (pctxt, "u.transmittedCodePowerValue");

            stat = asn1PE_Transmitted_Code_Power_Value (pctxt, pvalue->u.transmittedCodePowerValue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* rSCP */
         case 4:
            PU_PUSHNAME (pctxt, "u.rSCP");

            stat = asn1PE_RSCP_Value (pctxt, pvalue->u.rSCP);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* rxTimingDeviationValue */
         case 5:
            PU_PUSHNAME (pctxt, "u.rxTimingDeviationValue");

            stat = asn1PE_Rx_Timing_Deviation_Value (pctxt, pvalue->u.rxTimingDeviationValue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* roundTripTime */
         case 6:
            PU_PUSHNAME (pctxt, "u.roundTripTime");

            stat = asn1PE_Round_Trip_Time_Value (pctxt, pvalue->u.roundTripTime);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 7);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* extension_DedicatedMeasurementValue */
         case 7:
            stat = asn1PE_Extension_DedicatedMeasurementValue (&lctxt, pvalue->u.extension_DedicatedMeasurementValue);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_POPNAME (pctxt);

      rtFreeContext (&lctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CFN                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CFN (ASN1CTXT* pctxt, CFN value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CFN: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_CFN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementAvailable                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DedicatedMeasurementAvailable (ASN1CTXT* pctxt, DedicatedMeasurementAvailable* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementAvailable: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cFNPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cFNPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dedicatedmeasurementValue */

   PU_PUSHNAME (pctxt, "dedicatedmeasurementValue");

   stat = asn1PE_DedicatedMeasurementValue (pctxt, &pvalue->dedicatedmeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cFN */

   if (pvalue->m.cFNPresent) {
      PU_PUSHNAME (pctxt, "cFN");

      stat = asn1PE_CFN (pctxt, pvalue->cFN);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementnotAvailable                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DedicatedMeasurementnotAvailable_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementnotAvailable: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementnotAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementValueInformation                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DedicatedMeasurementValueInformation (ASN1CTXT* pctxt, DedicatedMeasurementValueInformation* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementValueInformation: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* measurementAvailable */
      case 1:
         PU_PUSHNAME (pctxt, "u.measurementAvailable");

         stat = asn1PE_DedicatedMeasurementAvailable (pctxt, pvalue->u.measurementAvailable);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      /* measurementnotAvailable */
      case 2:
         PU_PUSHNAME (pctxt, "u.measurementnotAvailable");

         stat = asn1PE_DedicatedMeasurementnotAvailable (pctxt);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_PDSCH_Start_code_number                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_PDSCH_Start_code_number (ASN1CTXT* pctxt, HS_PDSCH_Start_code_number value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_PDSCH_Start_code_number: start\n");

   if ( (value >= 1 && value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_PDSCH_Start_code_number: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_PDSCH_FDD_Code_Information                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_PDSCH_FDD_Code_Information (ASN1CTXT* pctxt, HS_PDSCH_FDD_Code_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_PDSCH_FDD_Code_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_PDSCH_Start_code_numberPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hS_PDSCH_Start_code_numberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode number_of_HS_PDSCH_codes */

   PU_PUSHNAME (pctxt, "number_of_HS_PDSCH_codes");

   if ( (pvalue->number_of_HS_PDSCH_codes <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->number_of_HS_PDSCH_codes, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode hS_PDSCH_Start_code_number */

   if (pvalue->m.hS_PDSCH_Start_code_numberPresent) {
      PU_PUSHNAME (pctxt, "hS_PDSCH_Start_code_number");

      stat = asn1PE_HS_PDSCH_Start_code_number (pctxt, pvalue->hS_PDSCH_Start_code_number);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_PDSCH_FDD_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_FDD_Code_Information_Item                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SCCH_FDD_Code_Information_Item (ASN1CTXT* pctxt, HS_SCCH_FDD_Code_Information_Item value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SCCH_FDD_Code_Information_Item: start\n");

   if ( (value <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SCCH_FDD_Code_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_FDD_Code_List                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SCCH_FDD_Code_List (ASN1CTXT* pctxt, HS_SCCH_FDD_Code_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SCCH_FDD_Code_List: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HS_SCCH_FDD_Code_Information_Item (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SCCH_FDD_Code_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_FDD_Code_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SCCH_FDD_Code_Information (ASN1CTXT* pctxt, HS_SCCH_FDD_Code_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SCCH_FDD_Code_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* replace */
         case 1:
            PU_PUSHNAME (pctxt, "u.replace");

            stat = asn1PE_HS_SCCH_FDD_Code_List (pctxt, pvalue->u.replace);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* remove_ */
         case 2:
            PU_PUSHNAME (pctxt, "u.remove_");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SCCH_FDD_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCHSet_ID                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PDSCHSet_ID (ASN1CTXT* pctxt, PDSCHSet_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDSCHSet_ID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDSCHSet_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCH_ID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PDSCH_ID (ASN1CTXT* pctxt, PDSCH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDSCH_ID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDSCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCHSet_ID                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PUSCHSet_ID (ASN1CTXT* pctxt, PUSCHSet_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PUSCHSet_ID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_PUSCHSet_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaximumTransmissionPower                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MaximumTransmissionPower (ASN1CTXT* pctxt, MaximumTransmissionPower value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MaximumTransmissionPower: start\n");

   if ( (value <= 500) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(500));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MaximumTransmissionPower: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_ID                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SCCH_ID (ASN1CTXT* pctxt, HS_SCCH_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SCCH_ID: start\n");

   if ( (value <= 31) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SCCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CRNC_CommunicationContextID                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CRNC_CommunicationContextID (ASN1CTXT* pctxt, CRNC_CommunicationContextID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CRNC_CommunicationContextID: start\n");

   if ( (value <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_CRNC_CommunicationContextID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NodeB_CommunicationContextID                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NodeB_CommunicationContextID (ASN1CTXT* pctxt, NodeB_CommunicationContextID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeB_CommunicationContextID: start\n");

   if ( (value <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeB_CommunicationContextID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPSTOW                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPSTOW (ASN1CTXT* pctxt, GPSTOW value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPSTOW: start\n");

   if ( (value <= 604799) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(604799));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPSTOW: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Status_Health                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Status_Health (ASN1CTXT* pctxt, GPS_Status_Health value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Status_Health: start\n");

   switch (value) {
      case udre_scale_1dot0: ui = 0; break;
      case udre_scale_0dot75: ui = 1; break;
      case udre_scale_0dot5: ui = 2; break;
      case udre_scale_0dot3: ui = 3; break;
      case udre_scale_0dot1: ui = 4; break;
      case no_data: ui = 5; break;
      case invalid_data: ui = 6; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Status_Health: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_ID (ASN1CTXT* pctxt, SAT_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_ID: start\n");

   if ( (value <= 63) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_DGPSCorrections_Item_iode_dgps                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_DGPSCorrections_Item_iode_dgps (ASN1CTXT* pctxt, SAT_Info_DGPSCorrections_Item_iode_dgps* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_DGPSCorrections_Item_iode_dgps: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_DGPSCorrections_Item_iode_dgps: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UDRE                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UDRE (ASN1CTXT* pctxt, UDRE value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_UDRE: start\n");

   switch (value) {
      case udre_minusequal_one_m: ui = 0; break;
      case udre_betweenoneandfour_m: ui = 1; break;
      case udre_betweenfourandeight_m: ui = 2; break;
      case udre_greaterequaleight_m: ui = 3; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_UDRE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PRC (ASN1CTXT* pctxt, PRC value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PRC: start\n");

   if ( (value >= -2047 && value <= 2047) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-2047), OSINTCONST(2047));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PRC: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Range_Correction_Rate                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Range_Correction_Rate (ASN1CTXT* pctxt, Range_Correction_Rate value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Range_Correction_Rate: start\n");

   if ( (value >= -127) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-127), OSINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Range_Correction_Rate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_DGPSCorrections_Item                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_DGPSCorrections_Item (ASN1CTXT* pctxt, SAT_Info_DGPSCorrections_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_DGPSCorrections_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode sat_id */

   PU_PUSHNAME (pctxt, "sat_id");

   stat = asn1PE_SAT_ID (pctxt, pvalue->sat_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iode_dgps */

   PU_PUSHNAME (pctxt, "iode_dgps");

   stat = asn1PE_SAT_Info_DGPSCorrections_Item_iode_dgps (pctxt, &pvalue->iode_dgps);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode udre */

   PU_PUSHNAME (pctxt, "udre");

   stat = asn1PE_UDRE (pctxt, pvalue->udre);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode prc */

   PU_PUSHNAME (pctxt, "prc");

   stat = asn1PE_PRC (pctxt, pvalue->prc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode range_correction_rate */

   PU_PUSHNAME (pctxt, "range_correction_rate");

   stat = asn1PE_Range_Correction_Rate (pctxt, pvalue->range_correction_rate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_DGPSCorrections_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_DGPSCorrections                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_DGPSCorrections (ASN1CTXT* pctxt, SAT_Info_DGPSCorrections* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_DGPSCorrections: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SAT_Info_DGPSCorrections_Item (pctxt, ((SAT_Info_DGPSCorrections_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_DGPSCorrections: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DGPSCorrections                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DGPSCorrections (ASN1CTXT* pctxt, DGPSCorrections* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DGPSCorrections: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode gpstow */

   PU_PUSHNAME (pctxt, "gpstow");

   stat = asn1PE_GPSTOW (pctxt, pvalue->gpstow);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode status_health */

   PU_PUSHNAME (pctxt, "status_health");

   stat = asn1PE_GPS_Status_Health (pctxt, pvalue->status_health);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode satelliteinfo */

   PU_PUSHNAME (pctxt, "satelliteinfo");

   stat = asn1PE_SAT_Info_DGPSCorrections (pctxt, &pvalue->satelliteinfo);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DGPSCorrections: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_tlm_message_nav                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_tlm_message_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_tlm_message_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(14), OSUINTCONST(14), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_tlm_message_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_tlm_message_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_tlm_revd_c_nav                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_tlm_revd_c_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_tlm_revd_c_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_tlm_revd_c_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_tlm_revd_c_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_ho_word_nav                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_ho_word_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_ho_word_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(22), OSUINTCONST(22), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_ho_word_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_ho_word_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_w_n_nav                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_w_n_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_w_n_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(10), OSUINTCONST(10), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_w_n_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_w_n_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_ca_or_p_on_l2_nav                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_ca_or_p_on_l2_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_ca_or_p_on_l2_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_ca_or_p_on_l2_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_ca_or_p_on_l2_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_user_range_accuracy_index_nav     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_user_range_accuracy_index_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_user_range_accuracy_index_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_user_range_accuracy_index_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_user_range_accuracy_index_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_sv_health_nav                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_sv_health_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_sv_health_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(6), OSUINTCONST(6), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_sv_health_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_sv_health_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_iodc_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_iodc_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_iodc_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(10), OSUINTCONST(10), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_iodc_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_iodc_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_l2_p_dataflag_nav                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_l2_p_dataflag_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_l2_p_dataflag_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_l2_p_dataflag_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_l2_p_dataflag_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_sf1_reserved_nav                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_sf1_reserved_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_sf1_reserved_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(87), OSUINTCONST(87), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_sf1_reserved_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_sf1_reserved_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_t_gd_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_t_gd_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_t_gd_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_t_gd_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_t_gd_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_t_oc_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_t_oc_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_t_oc_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_t_oc_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_t_oc_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_a_f_2_nav                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_a_f_2_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_a_f_2_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_a_f_2_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_a_f_2_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_a_f_1_nav                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_a_f_1_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_a_f_1_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_a_f_1_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_a_f_1_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_a_f_zero_nav                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_a_f_zero_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_a_f_zero_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(22), OSUINTCONST(22), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_a_f_zero_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_a_f_zero_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_rs_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_c_rs_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_rs_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_rs_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_rs_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_delta_n_nav                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_delta_n_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_delta_n_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_delta_n_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_delta_n_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_m_zero_nav                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_m_zero_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_m_zero_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_m_zero_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_m_zero_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_uc_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_c_uc_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_uc_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_uc_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_uc_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_gps_e_nav                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_gps_e_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_gps_e_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_gps_e_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_gps_e_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_us_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_c_us_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_us_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_us_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_us_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_a_sqrt_nav                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_a_sqrt_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_a_sqrt_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_a_sqrt_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_a_sqrt_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_t_oe_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_t_oe_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_t_oe_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_t_oe_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_t_oe_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_fit_interval_flag_nav             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_fit_interval_flag_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_fit_interval_flag_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_fit_interval_flag_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_fit_interval_flag_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_aodo_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_aodo_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_aodo_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(5), OSUINTCONST(5), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_aodo_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_aodo_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_ic_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_c_ic_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_ic_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_ic_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_ic_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_omega_zero_nav                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_omega_zero_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_omega_zero_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_omega_zero_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_omega_zero_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_is_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_c_is_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_is_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_is_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_is_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_i_zero_nav                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_i_zero_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_i_zero_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_i_zero_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_i_zero_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_rc_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_c_rc_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_rc_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_rc_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_c_rc_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_gps_omega_nav                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_gps_omega_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_gps_omega_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_gps_omega_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_gps_omega_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_omegadot_nav                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_omegadot_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_omegadot_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_omegadot_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_omegadot_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_idot_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_idot_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_idot_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(14), OSUINTCONST(14), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_idot_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_idot_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_spare_zero_fill                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item_spare_zero_fill (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_spare_zero_fill* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(20), OSUINTCONST(20), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_spare_zero_fill: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item_spare_zero_fill: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavandRecovery_Item (ASN1CTXT* pctxt, GPS_NavandRecovery_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode tx_tow_nav */

   PU_PUSHNAME (pctxt, "tx_tow_nav");

   if ( (pvalue->tx_tow_nav <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->tx_tow_nav, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode sat_id_nav */

   PU_PUSHNAME (pctxt, "sat_id_nav");

   stat = asn1PE_SAT_ID (pctxt, pvalue->sat_id_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tlm_message_nav */

   PU_PUSHNAME (pctxt, "tlm_message_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_tlm_message_nav (pctxt, &pvalue->tlm_message_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tlm_revd_c_nav */

   PU_PUSHNAME (pctxt, "tlm_revd_c_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_tlm_revd_c_nav (pctxt, &pvalue->tlm_revd_c_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ho_word_nav */

   PU_PUSHNAME (pctxt, "ho_word_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_ho_word_nav (pctxt, &pvalue->ho_word_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode w_n_nav */

   PU_PUSHNAME (pctxt, "w_n_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_w_n_nav (pctxt, &pvalue->w_n_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ca_or_p_on_l2_nav */

   PU_PUSHNAME (pctxt, "ca_or_p_on_l2_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_ca_or_p_on_l2_nav (pctxt, &pvalue->ca_or_p_on_l2_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode user_range_accuracy_index_nav */

   PU_PUSHNAME (pctxt, "user_range_accuracy_index_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_user_range_accuracy_index_nav (pctxt, &pvalue->user_range_accuracy_index_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sv_health_nav */

   PU_PUSHNAME (pctxt, "sv_health_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_sv_health_nav (pctxt, &pvalue->sv_health_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iodc_nav */

   PU_PUSHNAME (pctxt, "iodc_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_iodc_nav (pctxt, &pvalue->iodc_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode l2_p_dataflag_nav */

   PU_PUSHNAME (pctxt, "l2_p_dataflag_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_l2_p_dataflag_nav (pctxt, &pvalue->l2_p_dataflag_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sf1_reserved_nav */

   PU_PUSHNAME (pctxt, "sf1_reserved_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_sf1_reserved_nav (pctxt, &pvalue->sf1_reserved_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode t_gd_nav */

   PU_PUSHNAME (pctxt, "t_gd_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_t_gd_nav (pctxt, &pvalue->t_gd_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode t_oc_nav */

   PU_PUSHNAME (pctxt, "t_oc_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_t_oc_nav (pctxt, &pvalue->t_oc_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode a_f_2_nav */

   PU_PUSHNAME (pctxt, "a_f_2_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_a_f_2_nav (pctxt, &pvalue->a_f_2_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode a_f_1_nav */

   PU_PUSHNAME (pctxt, "a_f_1_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_a_f_1_nav (pctxt, &pvalue->a_f_1_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode a_f_zero_nav */

   PU_PUSHNAME (pctxt, "a_f_zero_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_a_f_zero_nav (pctxt, &pvalue->a_f_zero_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode c_rs_nav */

   PU_PUSHNAME (pctxt, "c_rs_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_c_rs_nav (pctxt, &pvalue->c_rs_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode delta_n_nav */

   PU_PUSHNAME (pctxt, "delta_n_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_delta_n_nav (pctxt, &pvalue->delta_n_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode m_zero_nav */

   PU_PUSHNAME (pctxt, "m_zero_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_m_zero_nav (pctxt, &pvalue->m_zero_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode c_uc_nav */

   PU_PUSHNAME (pctxt, "c_uc_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_c_uc_nav (pctxt, &pvalue->c_uc_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_e_nav */

   PU_PUSHNAME (pctxt, "gps_e_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_gps_e_nav (pctxt, &pvalue->gps_e_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode c_us_nav */

   PU_PUSHNAME (pctxt, "c_us_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_c_us_nav (pctxt, &pvalue->c_us_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode a_sqrt_nav */

   PU_PUSHNAME (pctxt, "a_sqrt_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_a_sqrt_nav (pctxt, &pvalue->a_sqrt_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode t_oe_nav */

   PU_PUSHNAME (pctxt, "t_oe_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_t_oe_nav (pctxt, &pvalue->t_oe_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode fit_interval_flag_nav */

   PU_PUSHNAME (pctxt, "fit_interval_flag_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_fit_interval_flag_nav (pctxt, &pvalue->fit_interval_flag_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode aodo_nav */

   PU_PUSHNAME (pctxt, "aodo_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_aodo_nav (pctxt, &pvalue->aodo_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode c_ic_nav */

   PU_PUSHNAME (pctxt, "c_ic_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_c_ic_nav (pctxt, &pvalue->c_ic_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode omega_zero_nav */

   PU_PUSHNAME (pctxt, "omega_zero_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_omega_zero_nav (pctxt, &pvalue->omega_zero_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode c_is_nav */

   PU_PUSHNAME (pctxt, "c_is_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_c_is_nav (pctxt, &pvalue->c_is_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode i_zero_nav */

   PU_PUSHNAME (pctxt, "i_zero_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_i_zero_nav (pctxt, &pvalue->i_zero_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode c_rc_nav */

   PU_PUSHNAME (pctxt, "c_rc_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_c_rc_nav (pctxt, &pvalue->c_rc_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_omega_nav */

   PU_PUSHNAME (pctxt, "gps_omega_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_gps_omega_nav (pctxt, &pvalue->gps_omega_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode omegadot_nav */

   PU_PUSHNAME (pctxt, "omegadot_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_omegadot_nav (pctxt, &pvalue->omegadot_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode idot_nav */

   PU_PUSHNAME (pctxt, "idot_nav");

   stat = asn1PE_GPS_NavandRecovery_Item_idot_nav (pctxt, &pvalue->idot_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode spare_zero_fill */

   PU_PUSHNAME (pctxt, "spare_zero_fill");

   stat = asn1PE_GPS_NavandRecovery_Item_spare_zero_fill (pctxt, &pvalue->spare_zero_fill);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavandRecovery_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavigationModel_and_TimeRecovery                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_NavigationModel_and_TimeRecovery (ASN1CTXT* pctxt, GPS_NavigationModel_and_TimeRecovery* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavigationModel_and_TimeRecovery: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_GPS_NavandRecovery_Item (pctxt, ((GPS_NavandRecovery_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_NavigationModel_and_TimeRecovery: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_alpha_zero_ionos                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model_alpha_zero_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_alpha_zero_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_alpha_zero_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_alpha_zero_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_alpha_one_ionos                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model_alpha_one_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_alpha_one_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_alpha_one_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_alpha_one_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_alpha_two_ionos                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model_alpha_two_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_alpha_two_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_alpha_two_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_alpha_two_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_alpha_three_ionos                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model_alpha_three_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_alpha_three_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_alpha_three_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_alpha_three_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_beta_zero_ionos                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model_beta_zero_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_beta_zero_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_beta_zero_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_beta_zero_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_beta_one_ionos                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model_beta_one_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_beta_one_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_beta_one_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_beta_one_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_beta_two_ionos                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model_beta_two_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_beta_two_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_beta_two_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_beta_two_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_beta_three_ionos                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model_beta_three_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_beta_three_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_beta_three_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model_beta_three_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Ionospheric_Model (ASN1CTXT* pctxt, GPS_Ionospheric_Model* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode alpha_zero_ionos */

   PU_PUSHNAME (pctxt, "alpha_zero_ionos");

   stat = asn1PE_GPS_Ionospheric_Model_alpha_zero_ionos (pctxt, &pvalue->alpha_zero_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode alpha_one_ionos */

   PU_PUSHNAME (pctxt, "alpha_one_ionos");

   stat = asn1PE_GPS_Ionospheric_Model_alpha_one_ionos (pctxt, &pvalue->alpha_one_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode alpha_two_ionos */

   PU_PUSHNAME (pctxt, "alpha_two_ionos");

   stat = asn1PE_GPS_Ionospheric_Model_alpha_two_ionos (pctxt, &pvalue->alpha_two_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode alpha_three_ionos */

   PU_PUSHNAME (pctxt, "alpha_three_ionos");

   stat = asn1PE_GPS_Ionospheric_Model_alpha_three_ionos (pctxt, &pvalue->alpha_three_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode beta_zero_ionos */

   PU_PUSHNAME (pctxt, "beta_zero_ionos");

   stat = asn1PE_GPS_Ionospheric_Model_beta_zero_ionos (pctxt, &pvalue->beta_zero_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode beta_one_ionos */

   PU_PUSHNAME (pctxt, "beta_one_ionos");

   stat = asn1PE_GPS_Ionospheric_Model_beta_one_ionos (pctxt, &pvalue->beta_one_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode beta_two_ionos */

   PU_PUSHNAME (pctxt, "beta_two_ionos");

   stat = asn1PE_GPS_Ionospheric_Model_beta_two_ionos (pctxt, &pvalue->beta_two_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode beta_three_ionos */

   PU_PUSHNAME (pctxt, "beta_three_ionos");

   stat = asn1PE_GPS_Ionospheric_Model_beta_three_ionos (pctxt, &pvalue->beta_three_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Ionospheric_Model: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_a_one_utc                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model_a_one_utc (ASN1CTXT* pctxt, GPS_UTC_Model_a_one_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_a_one_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_a_one_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_a_zero_utc                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model_a_zero_utc (ASN1CTXT* pctxt, GPS_UTC_Model_a_zero_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_a_zero_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_a_zero_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_t_ot_utc                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model_t_ot_utc (ASN1CTXT* pctxt, GPS_UTC_Model_t_ot_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_t_ot_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_t_ot_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_delta_t_ls_utc                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model_delta_t_ls_utc (ASN1CTXT* pctxt, GPS_UTC_Model_delta_t_ls_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_delta_t_ls_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_delta_t_ls_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_w_n_t_utc                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model_w_n_t_utc (ASN1CTXT* pctxt, GPS_UTC_Model_w_n_t_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_w_n_t_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_w_n_t_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_w_n_lsf_utc                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model_w_n_lsf_utc (ASN1CTXT* pctxt, GPS_UTC_Model_w_n_lsf_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_w_n_lsf_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_w_n_lsf_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_dn_utc                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model_dn_utc (ASN1CTXT* pctxt, GPS_UTC_Model_dn_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_dn_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_dn_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_delta_t_lsf_utc                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model_delta_t_lsf_utc (ASN1CTXT* pctxt, GPS_UTC_Model_delta_t_lsf_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_delta_t_lsf_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model_delta_t_lsf_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_UTC_Model (ASN1CTXT* pctxt, GPS_UTC_Model* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode a_one_utc */

   PU_PUSHNAME (pctxt, "a_one_utc");

   stat = asn1PE_GPS_UTC_Model_a_one_utc (pctxt, &pvalue->a_one_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode a_zero_utc */

   PU_PUSHNAME (pctxt, "a_zero_utc");

   stat = asn1PE_GPS_UTC_Model_a_zero_utc (pctxt, &pvalue->a_zero_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode t_ot_utc */

   PU_PUSHNAME (pctxt, "t_ot_utc");

   stat = asn1PE_GPS_UTC_Model_t_ot_utc (pctxt, &pvalue->t_ot_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode delta_t_ls_utc */

   PU_PUSHNAME (pctxt, "delta_t_ls_utc");

   stat = asn1PE_GPS_UTC_Model_delta_t_ls_utc (pctxt, &pvalue->delta_t_ls_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode w_n_t_utc */

   PU_PUSHNAME (pctxt, "w_n_t_utc");

   stat = asn1PE_GPS_UTC_Model_w_n_t_utc (pctxt, &pvalue->w_n_t_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode w_n_lsf_utc */

   PU_PUSHNAME (pctxt, "w_n_lsf_utc");

   stat = asn1PE_GPS_UTC_Model_w_n_lsf_utc (pctxt, &pvalue->w_n_lsf_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dn_utc */

   PU_PUSHNAME (pctxt, "dn_utc");

   stat = asn1PE_GPS_UTC_Model_dn_utc (pctxt, &pvalue->dn_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode delta_t_lsf_utc */

   PU_PUSHNAME (pctxt, "delta_t_lsf_utc");

   stat = asn1PE_GPS_UTC_Model_delta_t_lsf_utc (pctxt, &pvalue->delta_t_lsf_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_UTC_Model: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Almanac_wna_alm                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Almanac_wna_alm (ASN1CTXT* pctxt, GPS_Almanac_wna_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Almanac_wna_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Almanac_wna_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DATA_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DATA_ID (ASN1CTXT* pctxt, DATA_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DATA_ID: start\n");

   if ( (value <= 3) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_DATA_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_e_alm                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_gps_e_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_e_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_e_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_e_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_toa_alm                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_gps_toa_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_toa_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_toa_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_toa_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_delta_I_alm                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_gps_delta_I_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_delta_I_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_delta_I_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_delta_I_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_omegadot_alm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_omegadot_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_omegadot_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_omegadot_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_omegadot_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_svhealth_alm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_svhealth_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_svhealth_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_svhealth_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_svhealth_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_a_sqrt_alm                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_gps_a_sqrt_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_a_sqrt_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_a_sqrt_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_a_sqrt_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_omegazero_alm                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_omegazero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_omegazero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_omegazero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_omegazero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_m_zero_alm                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_m_zero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_m_zero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_m_zero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_m_zero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_omega_alm                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_gps_omega_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_omega_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_omega_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_omega_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_af_zero_alm                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_gps_af_zero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_af_zero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(11), OSUINTCONST(11), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_af_zero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_af_zero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_af_one_alm                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item_gps_af_one_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_af_one_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(11), OSUINTCONST(11), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_af_one_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item_gps_af_one_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_Item (ASN1CTXT* pctxt, SAT_Info_Almanac_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode data_id */

   PU_PUSHNAME (pctxt, "data_id");

   stat = asn1PE_DATA_ID (pctxt, pvalue->data_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sat_id */

   PU_PUSHNAME (pctxt, "sat_id");

   stat = asn1PE_SAT_ID (pctxt, pvalue->sat_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_e_alm */

   PU_PUSHNAME (pctxt, "gps_e_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_gps_e_alm (pctxt, &pvalue->gps_e_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_toa_alm */

   PU_PUSHNAME (pctxt, "gps_toa_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_gps_toa_alm (pctxt, &pvalue->gps_toa_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_delta_I_alm */

   PU_PUSHNAME (pctxt, "gps_delta_I_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_gps_delta_I_alm (pctxt, &pvalue->gps_delta_I_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode omegadot_alm */

   PU_PUSHNAME (pctxt, "omegadot_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_omegadot_alm (pctxt, &pvalue->omegadot_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode svhealth_alm */

   PU_PUSHNAME (pctxt, "svhealth_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_svhealth_alm (pctxt, &pvalue->svhealth_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_a_sqrt_alm */

   PU_PUSHNAME (pctxt, "gps_a_sqrt_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_gps_a_sqrt_alm (pctxt, &pvalue->gps_a_sqrt_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode omegazero_alm */

   PU_PUSHNAME (pctxt, "omegazero_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_omegazero_alm (pctxt, &pvalue->omegazero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode m_zero_alm */

   PU_PUSHNAME (pctxt, "m_zero_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_m_zero_alm (pctxt, &pvalue->m_zero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_omega_alm */

   PU_PUSHNAME (pctxt, "gps_omega_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_gps_omega_alm (pctxt, &pvalue->gps_omega_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_af_zero_alm */

   PU_PUSHNAME (pctxt, "gps_af_zero_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_gps_af_zero_alm (pctxt, &pvalue->gps_af_zero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_af_one_alm */

   PU_PUSHNAME (pctxt, "gps_af_one_alm");

   stat = asn1PE_SAT_Info_Almanac_Item_gps_af_one_alm (pctxt, &pvalue->gps_af_one_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac (ASN1CTXT* pctxt, SAT_Info_Almanac* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SAT_Info_Almanac_Item (pctxt, ((SAT_Info_Almanac_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Almanac_sVGlobalHealth_alm                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Almanac_sVGlobalHealth_alm (ASN1CTXT* pctxt, GPS_Almanac_sVGlobalHealth_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(364), OSUINTCONST(364), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Almanac_sVGlobalHealth_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Almanac_sVGlobalHealth_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Almanac                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Almanac (ASN1CTXT* pctxt, GPS_Almanac* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Almanac: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sVGlobalHealth_almPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.sVGlobalHealth_almPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode wna_alm */

   PU_PUSHNAME (pctxt, "wna_alm");

   stat = asn1PE_GPS_Almanac_wna_alm (pctxt, &pvalue->wna_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sat_info_almanac */

   PU_PUSHNAME (pctxt, "sat_info_almanac");

   stat = asn1PE_SAT_Info_Almanac (pctxt, &pvalue->sat_info_almanac);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sVGlobalHealth_alm */

   if (pvalue->m.sVGlobalHealth_almPresent) {
      PU_PUSHNAME (pctxt, "sVGlobalHealth_alm");

      stat = asn1PE_GPS_Almanac_sVGlobalHealth_alm (pctxt, &pvalue->sVGlobalHealth_alm);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Almanac: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_RealTime_Integrity_Item                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_RealTime_Integrity_Item (ASN1CTXT* pctxt, SAT_Info_RealTime_Integrity_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_RealTime_Integrity_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode bad_sat_id */

   PU_PUSHNAME (pctxt, "bad_sat_id");

   stat = asn1PE_SAT_ID (pctxt, pvalue->bad_sat_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_RealTime_Integrity_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SATInfo_RealTime_Integrity                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SATInfo_RealTime_Integrity (ASN1CTXT* pctxt, SATInfo_RealTime_Integrity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SATInfo_RealTime_Integrity: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SAT_Info_RealTime_Integrity_Item (pctxt, ((SAT_Info_RealTime_Integrity_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SATInfo_RealTime_Integrity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPSBadSat_Info_RealTime_Integrity                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPSBadSat_Info_RealTime_Integrity (ASN1CTXT* pctxt, GPSBadSat_Info_RealTime_Integrity* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPSBadSat_Info_RealTime_Integrity: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode sat_info */

   PU_PUSHNAME (pctxt, "sat_info");

   stat = asn1PE_SATInfo_RealTime_Integrity (pctxt, &pvalue->sat_info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPSBadSat_Info_RealTime_Integrity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_RealTime_Integrity                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_RealTime_Integrity (ASN1CTXT* pctxt, GPS_RealTime_Integrity* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_RealTime_Integrity: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* bad_satellites */
      case 1:
         PU_PUSHNAME (pctxt, "u.bad_satellites");

         stat = asn1PE_GPSBadSat_Info_RealTime_Integrity (pctxt, pvalue->u.bad_satellites);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      /* no_bad_satellites */
      case 2:
         PU_PUSHNAME (pctxt, "u.no_bad_satellites");

         /* NULL */
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_RealTime_Integrity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_RX_POS_latitudeSign                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_RX_POS_latitudeSign (ASN1CTXT* pctxt, GPS_RX_POS_latitudeSign value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_RX_POS_latitudeSign: start\n");

   switch (value) {
      case north: ui = 0; break;
      case south: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_RX_POS_latitudeSign: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_RX_POS_directionOfAltitude                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_RX_POS_directionOfAltitude (ASN1CTXT* pctxt, GPS_RX_POS_directionOfAltitude value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_RX_POS_directionOfAltitude: start\n");

   switch (value) {
      case height: ui = 0; break;
      case depth: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_RX_POS_directionOfAltitude: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_RX_POS                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_RX_POS (ASN1CTXT* pctxt, GPS_RX_POS* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_RX_POS: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode latitudeSign */

   PU_PUSHNAME (pctxt, "latitudeSign");

   stat = asn1PE_GPS_RX_POS_latitudeSign (pctxt, pvalue->latitudeSign);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode latitude */

   PU_PUSHNAME (pctxt, "latitude");

   if ( (pvalue->latitude <= 8388607) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->latitude, OSUINTCONST(0), OSUINTCONST(8388607));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode longitude */

   PU_PUSHNAME (pctxt, "longitude");

   if ( (pvalue->longitude >= -8388608 && pvalue->longitude <= 8388607) ) {
      stat = pe_ConsInteger (pctxt, pvalue->longitude, OSINTCONST(-8388608), OSINTCONST(8388607));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode directionOfAltitude */

   PU_PUSHNAME (pctxt, "directionOfAltitude");

   stat = asn1PE_GPS_RX_POS_directionOfAltitude (pctxt, pvalue->directionOfAltitude);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode altitude */

   PU_PUSHNAME (pctxt, "altitude");

   if ( (pvalue->altitude <= 32767) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->altitude, OSUINTCONST(0), OSUINTCONST(32767));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_RX_POS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedDataValue                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RequestedDataValue (ASN1CTXT* pctxt, RequestedDataValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestedDataValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dgps_correctionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dgps_correctionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_navandrecoveryPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.gps_navandrecoveryPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_ionos_modelPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.gps_ionos_modelPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_utc_modelPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.gps_utc_modelPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_almanacPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.gps_almanacPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_rt_integrityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.gps_rt_integrityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gpsrxposPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.gpsrxposPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dgps_corrections */

   if (pvalue->m.dgps_correctionsPresent) {
      PU_PUSHNAME (pctxt, "dgps_corrections");

      stat = asn1PE_DGPSCorrections (pctxt, &pvalue->dgps_corrections);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode gps_navandrecovery */

   if (pvalue->m.gps_navandrecoveryPresent) {
      PU_PUSHNAME (pctxt, "gps_navandrecovery");

      stat = asn1PE_GPS_NavigationModel_and_TimeRecovery (pctxt, &pvalue->gps_navandrecovery);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode gps_ionos_model */

   if (pvalue->m.gps_ionos_modelPresent) {
      PU_PUSHNAME (pctxt, "gps_ionos_model");

      stat = asn1PE_GPS_Ionospheric_Model (pctxt, &pvalue->gps_ionos_model);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode gps_utc_model */

   if (pvalue->m.gps_utc_modelPresent) {
      PU_PUSHNAME (pctxt, "gps_utc_model");

      stat = asn1PE_GPS_UTC_Model (pctxt, &pvalue->gps_utc_model);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode gps_almanac */

   if (pvalue->m.gps_almanacPresent) {
      PU_PUSHNAME (pctxt, "gps_almanac");

      stat = asn1PE_GPS_Almanac (pctxt, &pvalue->gps_almanac);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode gps_rt_integrity */

   if (pvalue->m.gps_rt_integrityPresent) {
      PU_PUSHNAME (pctxt, "gps_rt_integrity");

      stat = asn1PE_GPS_RealTime_Integrity (pctxt, &pvalue->gps_rt_integrity);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode gpsrxpos */

   if (pvalue->m.gpsrxposPresent) {
      PU_PUSHNAME (pctxt, "gpsrxpos");

      stat = asn1PE_GPS_RX_POS (pctxt, &pvalue->gpsrxpos);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestedDataValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationAvailable                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationAvailable (ASN1CTXT* pctxt, InformationAvailable* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationAvailable: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode requesteddataValue */

   PU_PUSHNAME (pctxt, "requesteddataValue");

   stat = asn1PE_RequestedDataValue (pctxt, &pvalue->requesteddataValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationnotAvailable                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationnotAvailable_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationnotAvailable: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationnotAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedDataValueInformation                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RequestedDataValueInformation (ASN1CTXT* pctxt, RequestedDataValueInformation* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestedDataValueInformation: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* informationAvailable */
      case 1:
         PU_PUSHNAME (pctxt, "u.informationAvailable");

         stat = asn1PE_InformationAvailable (pctxt, pvalue->u.informationAvailable);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      /* informationnotAvailable */
      case 2:
         PU_PUSHNAME (pctxt, "u.informationnotAvailable");

         stat = asn1PE_InformationnotAvailable (pctxt);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestedDataValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CSBTransmissionID                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CSBTransmissionID (ASN1CTXT* pctxt, CSBTransmissionID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CSBTransmissionID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_CSBTransmissionID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFN                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFN (ASN1CTXT* pctxt, SFN value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFN: start\n");

   if ( (value <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SFN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstCode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellSyncBurstCode (ASN1CTXT* pctxt, CellSyncBurstCode value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstCode: start\n");

   if ( (value >= 0 && value <= 7) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstCodeShift                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellSyncBurstCodeShift (ASN1CTXT* pctxt, CellSyncBurstCodeShift value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstCodeShift: start\n");

   if ( (value <= 7) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstCodeShift: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CSBMeasurementID                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CSBMeasurementID (ASN1CTXT* pctxt, CSBMeasurementID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CSBMeasurementID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_CSBMeasurementID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SynchronisationReportType (ASN1CTXT* pctxt, SynchronisationReportType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportType: start\n");

   extbit = 0;

   switch (value) {
      case initialPhase: ui = 0; break;
      case steadyStatePhase: ui = 1; break;
      case lateEntrantCell: ui = 2; break;
      case frequencyAcquisition: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharacteristicsType                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SynchronisationReportCharacteristicsType (ASN1CTXT* pctxt, SynchronisationReportCharacteristicsType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharacteristicsType: start\n");

   extbit = 0;

   switch (value) {
      case frameRelated: ui = 0; break;
      case sFNperiodRelated: ui = 1; break;
      case cycleLengthRelated: ui = 2; break;
      case thresholdExceeding: ui = 3; break;
      case frequencyAcquisitionCompleted: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharacteristicsType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncFrameNumber                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SyncFrameNumber (ASN1CTXT* pctxt, SyncFrameNumber value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncFrameNumber: start\n");

   if ( (value >= 1 && value <= 10) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(10));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncFrameNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTiming                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellSyncBurstTiming (ASN1CTXT* pctxt, CellSyncBurstTiming* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstTiming: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* initialPhase */
      case 1:
         PU_PUSHNAME (pctxt, "u.initialPhase");

         if ( (pvalue->u.initialPhase >= 0 && pvalue->u.initialPhase <= 1048575) ) {
            extbit = 0;
         }
         else extbit = 1;

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = pe_bit (pctxt, extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit) {
            stat = pe_UnconsInteger (pctxt, pvalue->u.initialPhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pe_ConsInteger (pctxt, pvalue->u.initialPhase, OSINTCONST(0), OSINTCONST(1048575));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         PU_POPNAME (pctxt);

         break;

      /* steadyStatePhase */
      case 2:
         PU_PUSHNAME (pctxt, "u.steadyStatePhase");

         if ( (pvalue->u.steadyStatePhase >= 0 && pvalue->u.steadyStatePhase <= 255) ) {
            extbit = 0;
         }
         else extbit = 1;

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = pe_bit (pctxt, extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit) {
            stat = pe_UnconsInteger (pctxt, pvalue->u.steadyStatePhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pe_ConsInteger (pctxt, pvalue->u.steadyStatePhase, OSINTCONST(0), OSINTCONST(255));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstTiming: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTimingThreshold                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellSyncBurstTimingThreshold (ASN1CTXT* pctxt, CellSyncBurstTimingThreshold value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstTimingThreshold: start\n");

   if ( (value <= 254) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(254));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstTimingThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharactCellSyncBurstInfoItem         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SynchronisationReportCharactCellSyncBurstInfoItem (ASN1CTXT* pctxt, SynchronisationReportCharactCellSyncBurstInfoItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharactCellSyncBurstInfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cellSyncBurstTimingPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cellSyncBurstTimingPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cellSyncBurstTimingThresholdPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cellSyncBurstTimingThresholdPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cellSyncBurstCode */

   PU_PUSHNAME (pctxt, "cellSyncBurstCode");

   stat = asn1PE_CellSyncBurstCode (pctxt, pvalue->cellSyncBurstCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cellSyncBurstCodeShift */

   PU_PUSHNAME (pctxt, "cellSyncBurstCodeShift");

   stat = asn1PE_CellSyncBurstCodeShift (pctxt, pvalue->cellSyncBurstCodeShift);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cellSyncBurstTiming */

   if (pvalue->m.cellSyncBurstTimingPresent) {
      PU_PUSHNAME (pctxt, "cellSyncBurstTiming");

      stat = asn1PE_CellSyncBurstTiming (pctxt, &pvalue->cellSyncBurstTiming);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode cellSyncBurstTimingThreshold */

   if (pvalue->m.cellSyncBurstTimingThresholdPresent) {
      PU_PUSHNAME (pctxt, "cellSyncBurstTimingThreshold");

      stat = asn1PE_CellSyncBurstTimingThreshold (pctxt, pvalue->cellSyncBurstTimingThreshold);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharactCellSyncBurstInfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharactThreInfoItem_cellSyncBurstIn  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation (ASN1CTXT* pctxt, SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SynchronisationReportCharactCellSyncBurstInfoItem (pctxt, ((SynchronisationReportCharactCellSyncBurstInfoItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharactThreInfoItem                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SynchronisationReportCharactThreInfoItem (ASN1CTXT* pctxt, SynchronisationReportCharactThreInfoItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharactThreInfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode syncFrameNumber */

   PU_PUSHNAME (pctxt, "syncFrameNumber");

   stat = asn1PE_SyncFrameNumber (pctxt, pvalue->syncFrameNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cellSyncBurstInformation */

   PU_PUSHNAME (pctxt, "cellSyncBurstInformation");

   stat = asn1PE_SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation (pctxt, &pvalue->cellSyncBurstInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharactThreInfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharactThreExc                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SynchronisationReportCharactThreExc (ASN1CTXT* pctxt, SynchronisationReportCharactThreExc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(10), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharactThreExc: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SynchronisationReportCharactThreInfoItem (pctxt, ((SynchronisationReportCharactThreInfoItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharactThreExc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharacteristics                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SynchronisationReportCharacteristics (ASN1CTXT* pctxt, SynchronisationReportCharacteristics* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharacteristics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "synchronisationReportCharactThreExcPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.synchronisationReportCharactThreExcPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode synchronisationReportCharacteristicsType */

   PU_PUSHNAME (pctxt, "synchronisationReportCharacteristicsType");

   stat = asn1PE_SynchronisationReportCharacteristicsType (pctxt, pvalue->synchronisationReportCharacteristicsType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode synchronisationReportCharactThreExc */

   if (pvalue->m.synchronisationReportCharactThreExcPresent) {
      PU_PUSHNAME (pctxt, "synchronisationReportCharactThreExc");

      stat = asn1PE_SynchronisationReportCharactThreExc (pctxt, &pvalue->synchronisationReportCharactThreExc);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationReportCharacteristics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UARFCN                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UARFCN (ASN1CTXT* pctxt, UARFCN value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UARFCN: start\n");

   if ( (value >= 0 && value <= 16383) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(16383));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UARFCN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeId                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SYNCDlCodeId (ASN1CTXT* pctxt, SYNCDlCodeId value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SYNCDlCodeId: start\n");

   if ( (value >= 1 && value <= 32) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(32));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SYNCDlCodeId: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimingAdjustmentValueLCR                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TimingAdjustmentValueLCR (ASN1CTXT* pctxt, TimingAdjustmentValueLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimingAdjustmentValueLCR: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* initialPhase */
      case 1:
         PU_PUSHNAME (pctxt, "u.initialPhase");

         if ( (pvalue->u.initialPhase >= 0 && pvalue->u.initialPhase <= 524287) ) {
            extbit = 0;
         }
         else extbit = 1;

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = pe_bit (pctxt, extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit) {
            stat = pe_UnconsInteger (pctxt, pvalue->u.initialPhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pe_ConsInteger (pctxt, pvalue->u.initialPhase, OSINTCONST(0), OSINTCONST(524287));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         PU_POPNAME (pctxt);

         break;

      /* steadyStatePhase */
      case 2:
         PU_PUSHNAME (pctxt, "u.steadyStatePhase");

         if ( (pvalue->u.steadyStatePhase >= 0 && pvalue->u.steadyStatePhase <= 127) ) {
            extbit = 0;
         }
         else extbit = 1;

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = pe_bit (pctxt, extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit) {
            stat = pe_UnconsInteger (pctxt, pvalue->u.steadyStatePhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pe_ConsInteger (pctxt, pvalue->u.steadyStatePhase, OSINTCONST(0), OSINTCONST(127));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TimingAdjustmentValueLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrameAdjustmentValue                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FrameAdjustmentValue (ASN1CTXT* pctxt, FrameAdjustmentValue value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_FrameAdjustmentValue: start\n");

   if ( (value <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_FrameAdjustmentValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimingAdjustmentValue                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TimingAdjustmentValue (ASN1CTXT* pctxt, TimingAdjustmentValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimingAdjustmentValue: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* initialPhase */
      case 1:
         PU_PUSHNAME (pctxt, "u.initialPhase");

         if ( (pvalue->u.initialPhase >= 0 && pvalue->u.initialPhase <= 1048575) ) {
            extbit = 0;
         }
         else extbit = 1;

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = pe_bit (pctxt, extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit) {
            stat = pe_UnconsInteger (pctxt, pvalue->u.initialPhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pe_ConsInteger (pctxt, pvalue->u.initialPhase, OSINTCONST(0), OSINTCONST(1048575));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         PU_POPNAME (pctxt);

         break;

      /* steadyStatePhase */
      case 2:
         PU_PUSHNAME (pctxt, "u.steadyStatePhase");

         if ( (pvalue->u.steadyStatePhase >= 0 && pvalue->u.steadyStatePhase <= 255) ) {
            extbit = 0;
         }
         else extbit = 1;

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = pe_bit (pctxt, extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit) {
            stat = pe_UnconsInteger (pctxt, pvalue->u.steadyStatePhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pe_ConsInteger (pctxt, pvalue->u.steadyStatePhase, OSINTCONST(0), OSINTCONST(255));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TimingAdjustmentValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstSIR                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellSyncBurstSIR (ASN1CTXT* pctxt, CellSyncBurstSIR value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstSIR: start\n");

   if ( (value <= 31) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstSIR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTimingLCR                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellSyncBurstTimingLCR (ASN1CTXT* pctxt, CellSyncBurstTimingLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstTimingLCR: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* initialPhase */
      case 1:
         PU_PUSHNAME (pctxt, "u.initialPhase");

         if ( (pvalue->u.initialPhase >= 0 && pvalue->u.initialPhase <= 524287) ) {
            extbit = 0;
         }
         else extbit = 1;

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = pe_bit (pctxt, extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit) {
            stat = pe_UnconsInteger (pctxt, pvalue->u.initialPhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pe_ConsInteger (pctxt, pvalue->u.initialPhase, OSINTCONST(0), OSINTCONST(524287));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         PU_POPNAME (pctxt);

         break;

      /* steadyStatePhase */
      case 2:
         PU_PUSHNAME (pctxt, "u.steadyStatePhase");

         if ( (pvalue->u.steadyStatePhase >= 0 && pvalue->u.steadyStatePhase <= 127) ) {
            extbit = 0;
         }
         else extbit = 1;

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = pe_bit (pctxt, extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit) {
            stat = pe_UnconsInteger (pctxt, pvalue->u.steadyStatePhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pe_ConsInteger (pctxt, pvalue->u.steadyStatePhase, OSINTCONST(0), OSINTCONST(127));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstTimingLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_ID                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlow_ID (ASN1CTXT* pctxt, HSDSCH_MACdFlow_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_ID: start\n");

   if ( (value <= 7) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Execution_Type                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Execution_Type (ASN1CTXT* pctxt, Execution_Type* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Execution_Type: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* synchronised */
      case 1:
         PU_PUSHNAME (pctxt, "u.synchronised");

         stat = asn1PE_CFN (pctxt, pvalue->u.synchronised);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      /* unsynchronised */
      case 2:
         PU_PUSHNAME (pctxt, "u.unsynchronised");

         /* NULL */
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Execution_Type: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Activate_Info                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Activate_Info (ASN1CTXT* pctxt, Activate_Info* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Activate_Info: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "firstRLS_IndicatorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.firstRLS_IndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "propagation_delayPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.propagation_delayPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode activation_type */

   PU_PUSHNAME (pctxt, "activation_type");

   stat = asn1PE_Execution_Type (pctxt, &pvalue->activation_type);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode initial_dl_tx_power */

   PU_PUSHNAME (pctxt, "initial_dl_tx_power");

   stat = asn1PE_DL_Power (pctxt, pvalue->initial_dl_tx_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode firstRLS_Indicator */

   if (pvalue->m.firstRLS_IndicatorPresent) {
      PU_PUSHNAME (pctxt, "firstRLS_Indicator");

      stat = asn1PE_FirstRLS_Indicator (pctxt, pvalue->firstRLS_Indicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode propagation_delay */

   if (pvalue->m.propagation_delayPresent) {
      PU_PUSHNAME (pctxt, "propagation_delay");

      stat = asn1PE_PropagationDelay (pctxt, pvalue->propagation_delay);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Activate_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deactivate_Info                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Deactivate_Info (ASN1CTXT* pctxt, Deactivate_Info* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Deactivate_Info: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode deactivation_type */

   PU_PUSHNAME (pctxt, "deactivation_type");

   stat = asn1PE_Execution_Type (pctxt, &pvalue->deactivation_type);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Deactivate_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DelayedActivationUpdate                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DelayedActivationUpdate (ASN1CTXT* pctxt, DelayedActivationUpdate* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DelayedActivationUpdate: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* activate */
      case 1:
         PU_PUSHNAME (pctxt, "u.activate");

         stat = asn1PE_Activate_Info (pctxt, pvalue->u.activate);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      /* deactivate */
      case 2:
         PU_PUSHNAME (pctxt, "u.deactivate");

         stat = asn1PE_Deactivate_Info (pctxt, pvalue->u.deactivate);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DelayedActivationUpdate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AckNack_RepetitionFactor                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AckNack_RepetitionFactor (ASN1CTXT* pctxt, AckNack_RepetitionFactor value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_AckNack_RepetitionFactor: start\n");

   if ( (value >= 1 && value <= 4) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AckNack_RepetitionFactor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ack_Power_Offset                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Ack_Power_Offset (ASN1CTXT* pctxt, Ack_Power_Offset value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Ack_Power_Offset: start\n");

   if ( (value >= 0 && value <= 8) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Ack_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AOA_LCR                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AOA_LCR (ASN1CTXT* pctxt, AOA_LCR value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AOA_LCR: start\n");

   if ( (value <= 719) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(719));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_AOA_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AOA_LCR_Accuracy_Class                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AOA_LCR_Accuracy_Class (ASN1CTXT* pctxt, AOA_LCR_Accuracy_Class value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_AOA_LCR_Accuracy_Class: start\n");

   extbit = 0;

   switch (value) {
      case a: ui = 0; break;
      case b: ui = 1; break;
      case c: ui = 2; break;
      case d: ui = 3; break;
      case e: ui = 4; break;
      case f: ui = 5; break;
      case g: ui = 6; break;
      case h: ui = 7; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AOA_LCR_Accuracy_Class: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BCCH_ModificationTime                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BCCH_ModificationTime (ASN1CTXT* pctxt, BCCH_ModificationTime value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BCCH_ModificationTime: start\n");

   if ( (value <= 511) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(511));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_BCCH_ModificationTime: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BlockingPriorityIndicator                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BlockingPriorityIndicator (ASN1CTXT* pctxt, BlockingPriorityIndicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_BlockingPriorityIndicator: start\n");

   extbit = 0;

   switch (value) {
      case high: ui = 0; break;
      case normal: ui = 1; break;
      case low: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_BlockingPriorityIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BundlingModeIndicator                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BundlingModeIndicator (ASN1CTXT* pctxt, BundlingModeIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_BundlingModeIndicator: start\n");

   switch (value) {
      case bundling: ui = 0; break;
      case no_bundling: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_BundlingModeIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellParameterID                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellParameterID (ASN1CTXT* pctxt, CellParameterID value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellParameterID: start\n");

   if ( (value >= 0 && value <= 127) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CellParameterID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstRepetitionPeriod                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellSyncBurstRepetitionPeriod (ASN1CTXT* pctxt, CellSyncBurstRepetitionPeriod value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstRepetitionPeriod: start\n");

   if ( (value <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_CellSyncBurstRepetitionPeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Closedlooptimingadjustmentmode                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Closedlooptimingadjustmentmode (ASN1CTXT* pctxt, Closedlooptimingadjustmentmode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Closedlooptimingadjustmentmode: start\n");

   extbit = 0;

   switch (value) {
      case adj_1_slot: ui = 0; break;
      case adj_2_slot: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Closedlooptimingadjustmentmode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonMeasurementType (ASN1CTXT* pctxt, CommonMeasurementType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementType: start\n");

   extbit = 0;

   switch (value) {
      case received_total_wide_band_power: ui = 0; break;
      case transmitted_carrier_power: ui = 1; break;
      case acknowledged_prach_preambles: ui = 2; break;
      case ul_timeslot_iscp: ui = 3; break;
      case notUsed_1_acknowledged_PCPCH_access_preambles: ui = 4; break;
      case notUsed_2_detected_PCPCH_access_preambles: ui = 5; break;
      case uTRAN_GPS_Timing_of_Cell_Frames_for_UE_Positioning: ui = 0; extbit = 1; break;
      case sFN_SFN_Observed_Time_Difference: ui = 1; extbit = 1; break;
      case transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmission: ui = 2; extbit = 1; break;
      case hS_DSCH_Required_Power: ui = 3; extbit = 1; break;
      case hS_DSCH_Provided_Bit_Rate: ui = 4; extbit = 1; break;
      case received_total_wide_band_power_for_cellPortion: ui = 5; extbit = 1; break;
      case transmitted_carrier_power_for_cellPortion: ui = 6; extbit = 1; break;
      case transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmission_for_cellPortion: ui = 7; extbit = 1; break;
      case upPTS_Interference: ui = 8; extbit = 1; break;
      case dLTransmissionBranchLoad: ui = 9; extbit = 1; break;
      case hS_DSCH_Required_Power_for_cell_portion: ui = 10; extbit = 1; break;
      case hS_DSCH_Provided_Bit_Rate_for_cell_portion: ui = 11; extbit = 1; break;
      case e_DCH_Provided_Bit_Rate: ui = 12; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Compressed_Mode_Deactivation_Flag                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Compressed_Mode_Deactivation_Flag (ASN1CTXT* pctxt, Compressed_Mode_Deactivation_Flag value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_Compressed_Mode_Deactivation_Flag: start\n");

   switch (value) {
      case deactivate: ui = 0; break;
      case maintain_Active: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Compressed_Mode_Deactivation_Flag: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConstantValue                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ConstantValue (ASN1CTXT* pctxt, ConstantValue value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ConstantValue: start\n");

   if ( (value >= -10 && value <= 10) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-10), OSINTCONST(10));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ConstantValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CQI_Feedback_Cycle                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CQI_Feedback_Cycle (ASN1CTXT* pctxt, CQI_Feedback_Cycle value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CQI_Feedback_Cycle: start\n");

   extbit = 0;

   switch (value) {
      case v0_1: ui = 0; break;
      case v2: ui = 1; break;
      case v4: ui = 2; break;
      case v8: ui = 3; break;
      case v10: ui = 4; break;
      case v20: ui = 5; break;
      case v40: ui = 6; break;
      case v80: ui = 7; break;
      case v160: ui = 8; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CQI_Feedback_Cycle: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CQI_Power_Offset                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CQI_Power_Offset (ASN1CTXT* pctxt, CQI_Power_Offset value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CQI_Power_Offset: start\n");

   if ( (value >= 0 && value <= 8) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CQI_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CQI_RepetitionFactor                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CQI_RepetitionFactor (ASN1CTXT* pctxt, CQI_RepetitionFactor value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CQI_RepetitionFactor: start\n");

   if ( (value >= 1 && value <= 4) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CQI_RepetitionFactor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DedicatedMeasurementType (ASN1CTXT* pctxt, DedicatedMeasurementType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementType: start\n");

   extbit = 0;

   switch (value) {
      case sir: ui = 0; break;
      case sir_error: ui = 1; break;
      case transmitted_code_power: ui = 2; break;
      case rscp: ui = 3; break;
      case rx_timing_deviation: ui = 4; break;
      case round_trip_time: ui = 5; break;
      case rx_timing_deviation_LCR: ui = 0; extbit = 1; break;
      case angle_Of_Arrival_LCR: ui = 1; extbit = 1; break;
      case hs_sich_quality: ui = 2; extbit = 1; break;
      case best_Cell_Portions: ui = 3; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DedicatedMeasurementType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaSIR                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DeltaSIR (ASN1CTXT* pctxt, DeltaSIR value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DeltaSIR: start\n");

   if ( (value <= 30) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(30));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_DeltaSIR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiscardTimer                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DiscardTimer (ASN1CTXT* pctxt, DiscardTimer value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DiscardTimer: start\n");

   extbit = 0;

   switch (value) {
      case v20_1: ui = 0; break;
      case v40_1: ui = 1; break;
      case v60: ui = 2; break;
      case v80_1: ui = 3; break;
      case v100: ui = 4; break;
      case v120: ui = 5; break;
      case v140: ui = 6; break;
      case v160_1: ui = 7; break;
      case v180: ui = 8; break;
      case v200: ui = 9; break;
      case v250: ui = 10; break;
      case v300: ui = 11; break;
      case v400: ui = 12; break;
      case v500: ui = 13; break;
      case v750: ui = 14; break;
      case v1000: ui = 15; break;
      case v1250: ui = 16; break;
      case v1500: ui = 17; break;
      case v1750: ui = 18; break;
      case v2000: ui = 19; break;
      case v2500: ui = 20; break;
      case v3000: ui = 21; break;
      case v3500: ui = 22; break;
      case v4000: ui = 23; break;
      case v4500: ui = 24; break;
      case v5000: ui = 25; break;
      case v7500: ui = 26; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(26));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DiscardTimer: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_TimingAdjustment                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_DPCH_TimingAdjustment (ASN1CTXT* pctxt, DL_DPCH_TimingAdjustment value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_DPCH_TimingAdjustment: start\n");

   switch (value) {
      case timing_advance: ui = 0; break;
      case timing_delay: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_DPCH_TimingAdjustment: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_FrameType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_FrameType (ASN1CTXT* pctxt, DL_FrameType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_FrameType: start\n");

   extbit = 0;

   switch (value) {
      case typeA: ui = 0; break;
      case typeB: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_FrameType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_PowerBalancing_ActivationIndicator                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_PowerBalancing_ActivationIndicator (ASN1CTXT* pctxt, DL_PowerBalancing_ActivationIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_PowerBalancing_ActivationIndicator: start\n");

   switch (value) {
      case dL_PowerBalancing_Activated: ui = 0; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_PowerBalancing_ActivationIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_PowerBalancing_UpdatedIndicator                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_PowerBalancing_UpdatedIndicator (ASN1CTXT* pctxt, DL_PowerBalancing_UpdatedIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_PowerBalancing_UpdatedIndicator: start\n");

   switch (value) {
      case dL_PowerBalancing_Updated: ui = 0; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_PowerBalancing_UpdatedIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TPC_Pattern01Count                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_TPC_Pattern01Count (ASN1CTXT* pctxt, DL_TPC_Pattern01Count value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TPC_Pattern01Count: start\n");

   if ( (value >= 0 && value <= 30) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(30));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TPC_Pattern01Count: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DLTransmissionBranchLoadValue                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DLTransmissionBranchLoadValue (ASN1CTXT* pctxt, DLTransmissionBranchLoadValue value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DLTransmissionBranchLoadValue: start\n");

   if ( (value >= 0 && value <= 101) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(101));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DLTransmissionBranchLoadValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Downlink_Compressed_Mode_Method                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Downlink_Compressed_Mode_Method (ASN1CTXT* pctxt, Downlink_Compressed_Mode_Method value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Downlink_Compressed_Mode_Method: start\n");

   extbit = 0;

   switch (value) {
      case not_Used_puncturing: ui = 0; break;
      case sFdiv2: ui = 1; break;
      case higher_layer_scheduling: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Downlink_Compressed_Mode_Method: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DPC_Mode                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DPC_Mode (ASN1CTXT* pctxt, DPC_Mode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DPC_Mode: start\n");

   extbit = 0;

   switch (value) {
      case mode0: ui = 0; break;
      case mode1: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DPC_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DsField                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DsField (ASN1CTXT* pctxt, DsField* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DsField: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_DsField: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_AGCH_FDD_Code_Information_Item                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_AGCH_FDD_Code_Information_Item (ASN1CTXT* pctxt, E_AGCH_FDD_Code_Information_Item value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_AGCH_FDD_Code_Information_Item: start\n");

   if ( (value <= 1) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_AGCH_FDD_Code_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_Capability                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_Capability (ASN1CTXT* pctxt, E_DCH_Capability value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_Capability: start\n");

   switch (value) {
      case e_DCH_capable: ui = 0; break;
      case e_DCH_non_capable: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_Capability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_DDI_Value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_DDI_Value (ASN1CTXT* pctxt, E_DCH_DDI_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_DDI_Value: start\n");

   if ( (value <= 63) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_DDI_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_HARQ_PO_FDD                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_HARQ_PO_FDD (ASN1CTXT* pctxt, E_DCH_HARQ_PO_FDD value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_HARQ_PO_FDD: start\n");

   if ( (value <= 6) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_HARQ_PO_FDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_ID                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_ID (ASN1CTXT* pctxt, E_DCH_MACdFlow_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_ID: start\n");

   if ( (value <= 7) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Multiplexing_List                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_Multiplexing_List (ASN1CTXT* pctxt, E_DCH_MACdFlow_Multiplexing_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Multiplexing_List: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Multiplexing_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCHProvidedBitRateValue                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCHProvidedBitRateValue (ASN1CTXT* pctxt, E_DCHProvidedBitRateValue value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCHProvidedBitRateValue: start\n");

   if ( (value >= 0 && value <= 16777215) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCHProvidedBitRateValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Maximum_Target_ReceivedTotalWideBandPower                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Maximum_Target_ReceivedTotalWideBandPower (ASN1CTXT* pctxt, Maximum_Target_ReceivedTotalWideBandPower value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Maximum_Target_ReceivedTotalWideBandPower: start\n");

   if ( (value <= 621) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(621));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Maximum_Target_ReceivedTotalWideBandPower: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_RL_Indication                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_RL_Indication (ASN1CTXT* pctxt, E_DCH_RL_Indication value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_RL_Indication: start\n");

   switch (value) {
      case e_DCH: ui = 0; break;
      case non_e_DCH: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_RL_Indication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_HICH_Signature_Sequence                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_HICH_Signature_Sequence (ASN1CTXT* pctxt, E_HICH_Signature_Sequence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_HICH_Signature_Sequence: start\n");

   if ( (value <= 39) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(39));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_HICH_Signature_Sequence: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  End_Of_Audit_Sequence_Indicator                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_End_Of_Audit_Sequence_Indicator (ASN1CTXT* pctxt, End_Of_Audit_Sequence_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_End_Of_Audit_Sequence_Indicator: start\n");

   switch (value) {
      case end_of_audit_sequence: ui = 0; break;
      case not_end_of_audit_sequence: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_End_Of_Audit_Sequence_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RGCH_E_HICH_FDD_Code_Information_Item                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_RGCH_E_HICH_FDD_Code_Information_Item (ASN1CTXT* pctxt, E_RGCH_E_HICH_FDD_Code_Information_Item value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RGCH_E_HICH_FDD_Code_Information_Item: start\n");

   if ( (value <= 1) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RGCH_E_HICH_FDD_Code_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RGCH_Signature_Sequence                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_RGCH_Signature_Sequence (ASN1CTXT* pctxt, E_RGCH_Signature_Sequence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RGCH_Signature_Sequence: start\n");

   if ( (value <= 39) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(39));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RGCH_Signature_Sequence: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RNTI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_RNTI (ASN1CTXT* pctxt, E_RNTI value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RNTI: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RNTI: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_S_CCPCH_FrameOffset                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FDD_S_CCPCH_FrameOffset (ASN1CTXT* pctxt, FDD_S_CCPCH_FrameOffset value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_S_CCPCH_FrameOffset: start\n");

   extbit = 0;

   switch (value) {
      case v1_1: ui = 0; break;
      case v2_1: ui = 1; break;
      case v4_1: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_S_CCPCH_FrameOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FNReportingIndicator                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FNReportingIndicator (ASN1CTXT* pctxt, FNReportingIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_FNReportingIndicator: start\n");

   switch (value) {
      case fN_reporting_required: ui = 0; break;
      case fN_reporting_not_required: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_FNReportingIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GapLength                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GapLength (ASN1CTXT* pctxt, GapLength value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GapLength: start\n");

   if ( (value >= 1 && value <= 14) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(14));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_GapLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GapDuration                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GapDuration (ASN1CTXT* pctxt, GapDuration value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_GapDuration: start\n");

   if ( (value >= 1 && value <= 144) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(144));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GapDuration: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenericTrafficCategory                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GenericTrafficCategory (ASN1CTXT* pctxt, GenericTrafficCategory* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericTrafficCategory: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericTrafficCategory: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Information_Item                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Information_Item (ASN1CTXT* pctxt, GPS_Information_Item value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Information_Item: start\n");

   extbit = 0;

   switch (value) {
      case gps_navigation_model_and_time_recovery: ui = 0; break;
      case gps_ionospheric_model: ui = 1; break;
      case gps_utc_model: ui = 2; break;
      case gps_almanac: ui = 3; break;
      case gps_rt_integrity: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_Preamble_Mode                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_Preamble_Mode (ASN1CTXT* pctxt, HARQ_Preamble_Mode value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_Preamble_Mode: start\n");

   switch (value) {
      case mode0_1: ui = 0; break;
      case mode1_1: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_Preamble_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_Process_Allocation_2ms_EDCH                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_Process_Allocation_2ms_EDCH (ASN1CTXT* pctxt, HARQ_Process_Allocation_2ms_EDCH* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_Process_Allocation_2ms_EDCH: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_Process_Allocation_2ms_EDCH: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_Preamble_Mode_Activation_Indicator                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_Preamble_Mode_Activation_Indicator (ASN1CTXT* pctxt, HARQ_Preamble_Mode_Activation_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_Preamble_Mode_Activation_Indicator: start\n");

   switch (value) {
      case harqPreambleModeActivated: ui = 0; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_Preamble_Mode_Activation_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDPA_Capability                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDPA_Capability (ASN1CTXT* pctxt, HSDPA_Capability value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDPA_Capability: start\n");

   switch (value) {
      case hsdpa_capable: ui = 0; break;
      case hsdpa_non_capable: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDPA_Capability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRateValue                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHProvidedBitRateValue (ASN1CTXT* pctxt, HS_DSCHProvidedBitRateValue value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRateValue: start\n");

   if ( (value >= 0 && value <= 16777215) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRateValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerValue                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHRequiredPowerValue (ASN1CTXT* pctxt, HS_DSCHRequiredPowerValue value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerValue: start\n");

   if ( (value <= 1000) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerPerUEWeight                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHRequiredPowerPerUEWeight (ASN1CTXT* pctxt, HS_DSCHRequiredPowerPerUEWeight value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerPerUEWeight: start\n");

   if ( (value <= 100) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerPerUEWeight: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_PowerOffset                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_PowerOffset (ASN1CTXT* pctxt, HSSCCH_PowerOffset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_PowerOffset: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_PowerOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_InitialWindowSize                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_InitialWindowSize (ASN1CTXT* pctxt, HSDSCH_InitialWindowSize value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_InitialWindowSize: start\n");

   if ( (value >= 1) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(255));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_InitialWindowSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_failed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SICH_failed (ASN1CTXT* pctxt, HS_SICH_failed value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_failed: start\n");

   if ( (value <= 20) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(20));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_failed: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_missed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SICH_missed (ASN1CTXT* pctxt, HS_SICH_missed value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_missed: start\n");

   if ( (value <= 20) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(20));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_missed: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_total                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SICH_total (ASN1CTXT* pctxt, HS_SICH_total value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_total: start\n");

   if ( (value <= 20) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(20));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_total: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_Reception_Quality_Measurement_Value               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SICH_Reception_Quality_Measurement_Value (ASN1CTXT* pctxt, HS_SICH_Reception_Quality_Measurement_Value value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_Reception_Quality_Measurement_Value: start\n");

   if ( (value <= 20) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(20));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_Reception_Quality_Measurement_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_RNTI                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_RNTI (ASN1CTXT* pctxt, HSDSCH_RNTI value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_RNTI: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_RNTI: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_CodeChangeIndicator                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_CodeChangeIndicator (ASN1CTXT* pctxt, HSSCCH_CodeChangeIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_CodeChangeIndicator: start\n");

   switch (value) {
      case hsSCCHCodeChangeNeeded: ui = 0; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_CodeChangeIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Code_Change_Grant                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_Code_Change_Grant (ASN1CTXT* pctxt, HSSCCH_Code_Change_Grant value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Code_Change_Grant: start\n");

   switch (value) {
      case changeGranted: ui = 0; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Code_Change_Grant: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationExchangeID (ASN1CTXT* pctxt, InformationExchangeID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationExchangeID: start\n");

   if ( (value <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationExchangeID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Information_Type_Item                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Information_Type_Item (ASN1CTXT* pctxt, Information_Type_Item value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Information_Type_Item: start\n");

   extbit = 0;

   switch (value) {
      case gpsinformation: ui = 0; break;
      case dgpscorrections: ui = 1; break;
      case gpsrxpos: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Information_Type_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Initial_DL_DPCH_TimingAdjustment_Allowed                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Initial_DL_DPCH_TimingAdjustment_Allowed (ASN1CTXT* pctxt, Initial_DL_DPCH_TimingAdjustment_Allowed value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_Initial_DL_DPCH_TimingAdjustment_Allowed: start\n");

   switch (value) {
      case initial_DL_DPCH_TimingAdjustment_Allowed: ui = 0; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Initial_DL_DPCH_TimingAdjustment_Allowed: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MACdPDU_Size (ASN1CTXT* pctxt, MACdPDU_Size value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size: start\n");

   if ( (value >= 1 && value <= 5000) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(5000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACesGuaranteedBitRate                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MACesGuaranteedBitRate (ASN1CTXT* pctxt, MACesGuaranteedBitRate value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MACesGuaranteedBitRate: start\n");

   if ( (value >= 0 && value <= 16777215) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MACesGuaranteedBitRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MAChsGuaranteedBitRate                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MAChsGuaranteedBitRate (ASN1CTXT* pctxt, MAChsGuaranteedBitRate value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MAChsGuaranteedBitRate: start\n");

   if ( (value >= 0 && value <= 16777215) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MAChsGuaranteedBitRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MAChsReorderingBufferSize_for_RLC_UM                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MAChsReorderingBufferSize_for_RLC_UM (ASN1CTXT* pctxt, MAChsReorderingBufferSize_for_RLC_UM value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MAChsReorderingBufferSize_for_RLC_UM: start\n");

   if ( (value >= 0 && value <= 300) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(300));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MAChsReorderingBufferSize_for_RLC_UM: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MAC_hsWindowSize                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MAC_hsWindowSize (ASN1CTXT* pctxt, MAC_hsWindowSize value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MAC_hsWindowSize: start\n");

   extbit = 0;

   switch (value) {
      case v4_2: ui = 0; break;
      case v6: ui = 1; break;
      case v8_1: ui = 2; break;
      case v12: ui = 3; break;
      case v16: ui = 4; break;
      case v24: ui = 5; break;
      case v32: ui = 6; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MAC_hsWindowSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Max_Bits_MACe_PDU_non_scheduled                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Max_Bits_MACe_PDU_non_scheduled (ASN1CTXT* pctxt, Max_Bits_MACe_PDU_non_scheduled value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Max_Bits_MACe_PDU_non_scheduled: start\n");

   if ( (value >= 1 && value <= 19982) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(19982));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Max_Bits_MACe_PDU_non_scheduled: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Maximum_Number_of_Retransmissions_For_E_DCH               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Maximum_Number_of_Retransmissions_For_E_DCH (ASN1CTXT* pctxt, Maximum_Number_of_Retransmissions_For_E_DCH value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Maximum_Number_of_Retransmissions_For_E_DCH: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Maximum_Number_of_Retransmissions_For_E_DCH: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Maximum_Allowed_UE_UL_Tx_Power                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Maximum_Allowed_UE_UL_Tx_Power (ASN1CTXT* pctxt, Maximum_Allowed_UE_UL_Tx_Power value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Maximum_Allowed_UE_UL_Tx_Power: start\n");

   if ( (value >= -55 && value <= 33) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-55), OSINTCONST(33));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Maximum_Allowed_UE_UL_Tx_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementFilterCoefficient                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MeasurementFilterCoefficient (ASN1CTXT* pctxt, MeasurementFilterCoefficient value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementFilterCoefficient: start\n");

   extbit = 0;

   switch (value) {
      case k0: ui = 0; break;
      case k1: ui = 1; break;
      case k2: ui = 2; break;
      case k3: ui = 3; break;
      case k4: ui = 4; break;
      case k5: ui = 5; break;
      case k6: ui = 6; break;
      case k7: ui = 7; break;
      case k8: ui = 8; break;
      case k9: ui = 9; break;
      case k11: ui = 10; break;
      case k13: ui = 11; break;
      case k15: ui = 12; break;
      case k17: ui = 13; break;
      case k19: ui = 14; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(14));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementFilterCoefficient: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MeasurementID (ASN1CTXT* pctxt, MeasurementID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementID: start\n");

   if ( (value <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measurement_Power_Offset                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Measurement_Power_Offset (ASN1CTXT* pctxt, Measurement_Power_Offset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Measurement_Power_Offset: start\n");

   if ( (value >= -12 && value <= 26) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-12), OSINTCONST(26));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Measurement_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementRecoveryBehavior                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MeasurementRecoveryBehavior_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementRecoveryBehavior: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementRecoveryBehavior: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementRecoveryReportingIndicator                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MeasurementRecoveryReportingIndicator_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementRecoveryReportingIndicator: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementRecoveryReportingIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementRecoverySupportIndicator                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MeasurementRecoverySupportIndicator_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementRecoverySupportIndicator: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementRecoverySupportIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_CFN                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MICH_CFN (ASN1CTXT* pctxt, MICH_CFN value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MICH_CFN: start\n");

   if ( (value <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MICH_CFN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modification_Period                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Modification_Period (ASN1CTXT* pctxt, Modification_Period value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Modification_Period: start\n");

   extbit = 0;

   switch (value) {
      case v5120: ui = 0; break;
      case v10240: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Modification_Period: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Nack_Power_Offset                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Nack_Power_Offset (ASN1CTXT* pctxt, Nack_Power_Offset value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Nack_Power_Offset: start\n");

   if ( (value >= 0 && value <= 8) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Nack_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NCyclesPerSFNperiod                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NCyclesPerSFNperiod (ASN1CTXT* pctxt, NCyclesPerSFNperiod value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_NCyclesPerSFNperiod: start\n");

   extbit = 0;

   switch (value) {
      case v1_2: ui = 0; break;
      case v2_3: ui = 1; break;
      case v4_7: ui = 2; break;
      case v8_6: ui = 3; break;
      case v16_5: ui = 0; extbit = 1; break;
      case v32_3: ui = 1; extbit = 1; break;
      case v64_2: ui = 2; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NCyclesPerSFNperiod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NRepetitionsPerCyclePeriod                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NRepetitionsPerCyclePeriod (ASN1CTXT* pctxt, NRepetitionsPerCyclePeriod value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NRepetitionsPerCyclePeriod: start\n");

   if ( (value >= 2 && value <= 10) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(2), OSUINTCONST(10));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_NRepetitionsPerCyclePeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_neighbouringCellMeasurementInformation          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Extension_neighbouringCellMeasurementInformation (ASN1CTXT* pctxt, Extension_neighbouringCellMeasurementInformation* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_neighbouringCellMeasurementInformation: start\n");

   stat = asn1PE_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_neighbouringCellMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notification_Indicator                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Notification_Indicator (ASN1CTXT* pctxt, Notification_Indicator value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Notification_Indicator: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Notification_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberOfReportedCellPortions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NumberOfReportedCellPortions (ASN1CTXT* pctxt, NumberOfReportedCellPortions value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_NumberOfReportedCellPortions: start\n");

   if ( (value >= 1 && value <= 64) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(64));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NumberOfReportedCellPortions: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NSubCyclesPerCyclePeriod                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NSubCyclesPerCyclePeriod (ASN1CTXT* pctxt, NSubCyclesPerCyclePeriod value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_NSubCyclesPerCyclePeriod: start\n");

   if ( (value >= 1 && value <= 16) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(16));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NSubCyclesPerCyclePeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PayloadCRC_PresenceIndicator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PayloadCRC_PresenceIndicator (ASN1CTXT* pctxt, PayloadCRC_PresenceIndicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PayloadCRC_PresenceIndicator: start\n");

   extbit = 0;

   switch (value) {
      case cRC_Included: ui = 0; break;
      case cRC_NotIncluded: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PayloadCRC_PresenceIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerAdjustmentType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PowerAdjustmentType (ASN1CTXT* pctxt, PowerAdjustmentType value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_PowerAdjustmentType: start\n");

   switch (value) {
      case none_1: ui = 0; break;
      case common: ui = 1; break;
      case individual: ui = 2; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_PowerAdjustmentType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRCDeviation                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PRCDeviation (ASN1CTXT* pctxt, PRCDeviation value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PRCDeviation: start\n");

   extbit = 0;

   switch (value) {
      case one: ui = 0; break;
      case two: ui = 1; break;
      case five: ui = 2; break;
      case ten: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PRCDeviation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PredictedSFNSFNDeviationLimit                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PredictedSFNSFNDeviationLimit (ASN1CTXT* pctxt, PredictedSFNSFNDeviationLimit value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PredictedSFNSFNDeviationLimit: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PredictedSFNSFNDeviationLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PredictedTUTRANGPSDeviationLimit                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PredictedTUTRANGPSDeviationLimit (ASN1CTXT* pctxt, PredictedTUTRANGPSDeviationLimit value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PredictedTUTRANGPSDeviationLimit: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PredictedTUTRANGPSDeviationLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Primary_CPICH_Usage_for_Channel_Estimation                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Primary_CPICH_Usage_for_Channel_Estimation (ASN1CTXT* pctxt, Primary_CPICH_Usage_for_Channel_Estimation value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_Primary_CPICH_Usage_for_Channel_Estimation: start\n");

   switch (value) {
      case primary_CPICH_may_be_used: ui = 0; break;
      case primary_CPICH_shall_not_be_used: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Primary_CPICH_Usage_for_Channel_Estimation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryScramblingCode                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PrimaryScramblingCode (ASN1CTXT* pctxt, PrimaryScramblingCode value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrimaryScramblingCode: start\n");

   if ( (value <= 511) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(511));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PrimaryScramblingCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_Id                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityQueue_Id (ASN1CTXT* pctxt, PriorityQueue_Id value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_Id: start\n");

   if ( (value <= 7) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_Id: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCCPCH_RSCP                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PrimaryCCPCH_RSCP (ASN1CTXT* pctxt, PrimaryCCPCH_RSCP value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrimaryCCPCH_RSCP: start\n");

   if ( (value <= 91) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(91));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_PrimaryCCPCH_RSCP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCCPCH_RSCP_Delta                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PrimaryCCPCH_RSCP_Delta (ASN1CTXT* pctxt, PrimaryCCPCH_RSCP_Delta value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrimaryCCPCH_RSCP_Delta: start\n");

   if ( (value >= -5 && value <= -1) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-5), OSINTCONST(-1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PrimaryCCPCH_RSCP_Delta: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QE_Selector                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_QE_Selector (ASN1CTXT* pctxt, QE_Selector value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_QE_Selector: start\n");

   switch (value) {
      case selected: ui = 0; break;
      case non_selected: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_QE_Selector: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceClockAvailability                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReferenceClockAvailability (ASN1CTXT* pctxt, ReferenceClockAvailability value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReferenceClockAvailability: start\n");

   switch (value) {
      case available: ui = 0; break;
      case notAvailable: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_ReferenceClockAvailability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceSFNoffset                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReferenceSFNoffset (ASN1CTXT* pctxt, ReferenceSFNoffset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReferenceSFNoffset: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_ReferenceSFNoffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber0                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RepetitionNumber0 (ASN1CTXT* pctxt, RepetitionNumber0 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RepetitionNumber0: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_RepetitionNumber0: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RepetitionNumber1 (ASN1CTXT* pctxt, RepetitionNumber1 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RepetitionNumber1: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_RepetitionNumber1: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_ReportCharacteristics                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Extension_ReportCharacteristics (ASN1CTXT* pctxt, Extension_ReportCharacteristics* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_ReportCharacteristics: start\n");

   stat = asn1PE_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_ReportCharacteristics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_ReportCharacteristicsType_MeasurementIncreaseD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (ASN1CTXT* pctxt, Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold: start\n");

   stat = asn1PE_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_ReportCharacteristicsType_MeasurementThreshold  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Extension_ReportCharacteristicsType_MeasurementThreshold (ASN1CTXT* pctxt, Extension_ReportCharacteristicsType_MeasurementThreshold* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_ReportCharacteristicsType_MeasurementThreshold: start\n");

   stat = asn1PE_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Extension_ReportCharacteristicsType_MeasurementThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementChangeTime_Scaledmsec                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MeasurementChangeTime_Scaledmsec (ASN1CTXT* pctxt, MeasurementChangeTime_Scaledmsec value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementChangeTime_Scaledmsec: start\n");

   if ( (value >= 1 && value <= 6000) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(6000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementChangeTime_Scaledmsec: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementHysteresisTime_Scaledmsec                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MeasurementHysteresisTime_Scaledmsec (ASN1CTXT* pctxt, MeasurementHysteresisTime_Scaledmsec value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementHysteresisTime_Scaledmsec: start\n");

   if ( (value >= 1 && value <= 6000) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(6000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MeasurementHysteresisTime_Scaledmsec: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportPeriodicity_Scaledmsec                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportPeriodicity_Scaledmsec (ASN1CTXT* pctxt, ReportPeriodicity_Scaledmsec value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportPeriodicity_Scaledmsec: start\n");

   if ( (value >= 1 && value <= 6000) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(6000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportPeriodicity_Scaledmsec: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportPeriodicity_Scaledmin                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportPeriodicity_Scaledmin (ASN1CTXT* pctxt, ReportPeriodicity_Scaledmin value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportPeriodicity_Scaledmin: start\n");

   if ( (value >= 1 && value <= 60) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(60));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportPeriodicity_Scaledmin: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportPeriodicity_Scaledhour                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportPeriodicity_Scaledhour (ASN1CTXT* pctxt, ReportPeriodicity_Scaledhour value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportPeriodicity_Scaledhour: start\n");

   if ( (value >= 1 && value <= 24) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportPeriodicity_Scaledhour: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RLC_Mode                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RLC_Mode (ASN1CTXT* pctxt, RLC_Mode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_RLC_Mode: start\n");

   extbit = 0;

   switch (value) {
      case rLC_AM: ui = 0; break;
      case rLC_UM: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RLC_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Round_Trip_Time_IncrDecrThres                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Round_Trip_Time_IncrDecrThres (ASN1CTXT* pctxt, Round_Trip_Time_IncrDecrThres value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Round_Trip_Time_IncrDecrThres: start\n");

   if ( (value <= 32766) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(32766));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Round_Trip_Time_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNC_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RNC_ID (ASN1CTXT* pctxt, RNC_ID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RNC_ID: start\n");

   if ( (value <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_RNC_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RSCP_Value_IncrDecrThres                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RSCP_Value_IncrDecrThres (ASN1CTXT* pctxt, RSCP_Value_IncrDecrThres value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RSCP_Value_IncrDecrThres: start\n");

   if ( (value <= 126) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(126));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_RSCP_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Received_total_wide_band_power_Value_IncrDecrThres        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Received_total_wide_band_power_Value_IncrDecrThres (ASN1CTXT* pctxt, Received_total_wide_band_power_Value_IncrDecrThres value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Received_total_wide_band_power_Value_IncrDecrThres: start\n");

   if ( (value <= 620) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(620));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Received_total_wide_band_power_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rx_Timing_Deviation_Value_LCR                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Rx_Timing_Deviation_Value_LCR (ASN1CTXT* pctxt, Rx_Timing_Deviation_Value_LCR value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Rx_Timing_Deviation_Value_LCR: start\n");

   if ( (value <= 511) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(511));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_Rx_Timing_Deviation_Value_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustmentPeriod                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AdjustmentPeriod (ASN1CTXT* pctxt, AdjustmentPeriod value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AdjustmentPeriod: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_AdjustmentPeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScaledAdjustmentRatio                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ScaledAdjustmentRatio (ASN1CTXT* pctxt, ScaledAdjustmentRatio value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ScaledAdjustmentRatio: start\n");

   if ( (value <= 100) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_ScaledAdjustmentRatio: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxAdjustmentStep                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MaxAdjustmentStep (ASN1CTXT* pctxt, MaxAdjustmentStep value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MaxAdjustmentStep: start\n");

   if ( (value >= 1 && value <= 10) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(10));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_MaxAdjustmentStep: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SchedulingPriorityIndicator                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SchedulingPriorityIndicator (ASN1CTXT* pctxt, SchedulingPriorityIndicator value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SchedulingPriorityIndicator: start\n");

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SchedulingPriorityIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SID                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SID (ASN1CTXT* pctxt, SID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SID: start\n");

   if ( (value <= 7) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFN_FDD                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFN_FDD (ASN1CTXT* pctxt, SFNSFN_FDD value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFN_FDD: start\n");

   if ( (value <= 614399) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(614399));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFN_FDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFN_TDD                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFN_TDD (ASN1CTXT* pctxt, SFNSFN_TDD value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFN_TDD: start\n");

   if ( (value <= 40961) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(40961));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFN_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNChangeLimit                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNChangeLimit (ASN1CTXT* pctxt, SFNSFNChangeLimit value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNChangeLimit: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNChangeLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNDriftRate                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNDriftRate (ASN1CTXT* pctxt, SFNSFNDriftRate value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNDriftRate: start\n");

   if ( (value >= -100 && value <= 100) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-100), OSINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNDriftRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNDriftRateQuality                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNDriftRateQuality (ASN1CTXT* pctxt, SFNSFNDriftRateQuality value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNDriftRateQuality: start\n");

   if ( (value <= 100) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNDriftRateQuality: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNQuality                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNQuality (ASN1CTXT* pctxt, SFNSFNQuality value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNQuality: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNQuality: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ShutdownTimer                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ShutdownTimer (ASN1CTXT* pctxt, ShutdownTimer value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ShutdownTimer: start\n");

   if ( (value >= 1 && value <= 3600) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(3600));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_ShutdownTimer: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIR_Error_Value_IncrDecrThres                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SIR_Error_Value_IncrDecrThres (ASN1CTXT* pctxt, SIR_Error_Value_IncrDecrThres value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SIR_Error_Value_IncrDecrThres: start\n");

   if ( (value <= 124) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(124));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SIR_Error_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIR_Value_IncrDecrThres                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SIR_Value_IncrDecrThres (ASN1CTXT* pctxt, SIR_Value_IncrDecrThres value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SIR_Value_IncrDecrThres: start\n");

   if ( (value <= 62) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(62));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_SIR_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignallingBearerRequestIndicator                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SignallingBearerRequestIndicator (ASN1CTXT* pctxt, SignallingBearerRequestIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignallingBearerRequestIndicator: start\n");

   switch (value) {
      case bearerRequested: ui = 0; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SignallingBearerRequestIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Start_Of_Audit_Sequence_Indicator                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Start_Of_Audit_Sequence_Indicator (ASN1CTXT* pctxt, Start_Of_Audit_Sequence_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_Start_Of_Audit_Sequence_Indicator: start\n");

   switch (value) {
      case start_of_audit_sequence: ui = 0; break;
      case not_start_of_audit_sequence: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Start_Of_Audit_Sequence_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncCase                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SyncCase (ASN1CTXT* pctxt, SyncCase value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncCase: start\n");

   if ( (value >= 1 && value <= 2) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncCase: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T1                                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_T1 (ASN1CTXT* pctxt, T1 value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_T1: start\n");

   extbit = 0;

   switch (value) {
      case v10_2: ui = 0; break;
      case v20_2: ui = 1; break;
      case v30: ui = 2; break;
      case v40_2: ui = 3; break;
      case v50: ui = 4; break;
      case v60_1: ui = 5; break;
      case v70: ui = 6; break;
      case v80_2: ui = 7; break;
      case v90: ui = 8; break;
      case v100_1: ui = 9; break;
      case v120_1: ui = 10; break;
      case v140_1: ui = 11; break;
      case v160_2: ui = 12; break;
      case v200_1: ui = 13; break;
      case v300_1: ui = 14; break;
      case v400_1: ui = 15; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_T1: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T_Cell                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_T_Cell (ASN1CTXT* pctxt, T_Cell value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_T_Cell: start\n");

   switch (value) {
      case v0_3: ui = 0; break;
      case v1_5: ui = 1; break;
      case v2_8: ui = 2; break;
      case v3_2: ui = 3; break;
      case v4_11: ui = 4; break;
      case v5: ui = 5; break;
      case v6_3: ui = 6; break;
      case v7: ui = 7; break;
      case v8_10: ui = 8; break;
      case v9: ui = 9; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_T_Cell: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_AckNack_Power_Offset                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_AckNack_Power_Offset (ASN1CTXT* pctxt, TDD_AckNack_Power_Offset value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_AckNack_Power_Offset: start\n");

   if ( (value >= -7 && value <= 8) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-7), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_AckNack_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TGD                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TGD (ASN1CTXT* pctxt, TGD value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TGD: start\n");

   if ( (value == 0 || (value >= 15 && value <= 269)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(269));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TGD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TGPRC                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TGPRC (ASN1CTXT* pctxt, TGPRC value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TGPRC: start\n");

   if ( (value <= 511) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(511));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TGPRC: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TGPSID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TGPSID (ASN1CTXT* pctxt, TGPSID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TGPSID: start\n");

   if ( (value >= 1 && value <= 6) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TGPSID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TGSN                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TGSN (ASN1CTXT* pctxt, TGSN value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TGSN: start\n");

   if ( (value <= 14) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(14));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TGSN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimingAdvanceApplied                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TimingAdvanceApplied (ASN1CTXT* pctxt, TimingAdvanceApplied value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimingAdvanceApplied: start\n");

   switch (value) {
      case yes: ui = 0; break;
      case no: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_TimingAdvanceApplied: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationIndicator                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SynchronisationIndicator (ASN1CTXT* pctxt, SynchronisationIndicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationIndicator: start\n");

   extbit = 0;

   switch (value) {
      case timingMaintainedSynchronisation: ui = 0; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SynchronisationIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue (ASN1CTXT* pctxt, TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue: start\n");

   if ( (value <= 100) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Code_Power_Value_IncrDecrThres                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmitted_Code_Power_Value_IncrDecrThres (ASN1CTXT* pctxt, Transmitted_Code_Power_Value_IncrDecrThres value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Code_Power_Value_IncrDecrThres: start\n");

   if ( (value >= 0 && value <= 112) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(112));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Code_Power_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmissionDiversityApplied                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransmissionDiversityApplied (ASN1CTXT* pctxt, TransmissionDiversityApplied value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionDiversityApplied: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = pe_bit (pctxt, (OSBOOL)value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionDiversityApplied: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSChangeLimit                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TUTRANGPSChangeLimit (ASN1CTXT* pctxt, TUTRANGPSChangeLimit value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSChangeLimit: start\n");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSChangeLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSDriftRate                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TUTRANGPSDriftRate (ASN1CTXT* pctxt, TUTRANGPSDriftRate value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSDriftRate: start\n");

   if ( (value >= -50 && value <= 50) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-50), OSINTCONST(50));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSDriftRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSDriftRateQuality                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TUTRANGPSDriftRateQuality (ASN1CTXT* pctxt, TUTRANGPSDriftRateQuality value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSDriftRateQuality: start\n");

   if ( (value <= 50) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(50));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSDriftRateQuality: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSAccuracyClass                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TUTRANGPSAccuracyClass (ASN1CTXT* pctxt, TUTRANGPSAccuracyClass value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSAccuracyClass: start\n");

   extbit = 0;

   switch (value) {
      case accuracy_class_A: ui = 0; break;
      case accuracy_class_B: ui = 1; break;
      case accuracy_class_C: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSAccuracyClass: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSQuality                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TUTRANGPSQuality (ASN1CTXT* pctxt, TUTRANGPSQuality value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSQuality: start\n");

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSQuality: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TypeOfError                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TypeOfError (ASN1CTXT* pctxt, TypeOfError value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TypeOfError: start\n");

   extbit = 0;

   switch (value) {
      case not_understood: ui = 0; break;
      case missing: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TypeOfError: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DL_mode                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_DL_mode (ASN1CTXT* pctxt, UL_DL_mode value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_DL_mode: start\n");

   switch (value) {
      case ul_only: ui = 0; break;
      case dl_only: ui = 1; break;
      case both_ul_and_dl: ui = 2; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_DL_mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPDCH_Indicator_For_E_DCH_Operation                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_DPDCH_Indicator_For_E_DCH_Operation (ASN1CTXT* pctxt, UL_DPDCH_Indicator_For_E_DCH_Operation value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_DPDCH_Indicator_For_E_DCH_Operation: start\n");

   switch (value) {
      case ul_DPDCH_present: ui = 0; break;
      case ul_DPDCH_not_present: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_DPDCH_Indicator_For_E_DCH_Operation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Uplink_Compressed_Mode_Method                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Uplink_Compressed_Mode_Method (ASN1CTXT* pctxt, Uplink_Compressed_Mode_Method value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Uplink_Compressed_Mode_Method: start\n");

   extbit = 0;

   switch (value) {
      case sFdiv2_1: ui = 0; break;
      case higher_layer_scheduling_1: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Uplink_Compressed_Mode_Method: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_FP_Mode                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_FP_Mode (ASN1CTXT* pctxt, UL_FP_Mode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_FP_Mode: start\n");

   extbit = 0;

   switch (value) {
      case normal_2: ui = 0; break;
      case silent: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_FP_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Synchronisation_StepSize                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_Synchronisation_StepSize (ASN1CTXT* pctxt, UL_Synchronisation_StepSize value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Synchronisation_StepSize: start\n");

   if ( (value >= 1 && value <= 8) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Synchronisation_StepSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Synchronisation_Frequency                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_Synchronisation_Frequency (ASN1CTXT* pctxt, UL_Synchronisation_Frequency value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Synchronisation_Frequency: start\n");

   if ( (value >= 1 && value <= 8) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Synchronisation_Frequency: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UpPTSInterferenceValue                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UpPTSInterferenceValue (ASN1CTXT* pctxt, UpPTSInterferenceValue value)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UpPTSInterferenceValue: start\n");

   if ( (value >= 0 && value <= 127) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(0), OSINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UpPTSInterferenceValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unidirectional_DCH_Indicator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Unidirectional_DCH_Indicator (ASN1CTXT* pctxt, Unidirectional_DCH_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt, "asn1PE_Unidirectional_DCH_Indicator: start\n");

   switch (value) {
      case downlink_DCH_only: ui = 0; break;
      case uplink_DCH_only: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_Unidirectional_DCH_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotISCP_Value_IncrDecrThres                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_TimeslotISCP_Value_IncrDecrThres (ASN1CTXT* pctxt, UL_TimeslotISCP_Value_IncrDecrThres value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeslotISCP_Value_IncrDecrThres: start\n");

   if ( (value <= 126) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(126));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_TimeslotISCP_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioningItem_process_Memory_Size           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_MemoryPartitioningItem_process_Memory_Size (ASN1CTXT* pctxt, HARQ_MemoryPartitioningItem_process_Memory_Size value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioningItem_process_Memory_Size: start\n");

   extbit = 0;

   switch (value) {
      case hms800: ui = 0; break;
      case hms1600: ui = 1; break;
      case hms2400: ui = 2; break;
      case hms3200: ui = 3; break;
      case hms4000: ui = 4; break;
      case hms4800: ui = 5; break;
      case hms5600: ui = 6; break;
      case hms6400: ui = 7; break;
      case hms7200: ui = 8; break;
      case hms8000: ui = 9; break;
      case hms8800: ui = 10; break;
      case hms9600: ui = 11; break;
      case hms10400: ui = 12; break;
      case hms11200: ui = 13; break;
      case hms12000: ui = 14; break;
      case hms12800: ui = 15; break;
      case hms13600: ui = 16; break;
      case hms14400: ui = 17; break;
      case hms15200: ui = 18; break;
      case hms16000: ui = 19; break;
      case hms17600: ui = 20; break;
      case hms19200: ui = 21; break;
      case hms20800: ui = 22; break;
      case hms22400: ui = 23; break;
      case hms24000: ui = 24; break;
      case hms25600: ui = 25; break;
      case hms27200: ui = 26; break;
      case hms28800: ui = 27; break;
      case hms30400: ui = 28; break;
      case hms32000: ui = 29; break;
      case hms36000: ui = 30; break;
      case hms40000: ui = 31; break;
      case hms44000: ui = 32; break;
      case hms48000: ui = 33; break;
      case hms52000: ui = 34; break;
      case hms56000: ui = 35; break;
      case hms60000: ui = 36; break;
      case hms64000: ui = 37; break;
      case hms68000: ui = 38; break;
      case hms72000: ui = 39; break;
      case hms76000: ui = 40; break;
      case hms80000: ui = 41; break;
      case hms88000: ui = 42; break;
      case hms96000: ui = 43; break;
      case hms104000: ui = 44; break;
      case hms112000: ui = 45; break;
      case hms120000: ui = 46; break;
      case hms128000: ui = 47; break;
      case hms136000: ui = 48; break;
      case hms144000: ui = 49; break;
      case hms152000: ui = 50; break;
      case hms160000: ui = 51; break;
      case hms176000: ui = 52; break;
      case hms192000: ui = 53; break;
      case hms208000: ui = 54; break;
      case hms224000: ui = 55; break;
      case hms240000: ui = 56; break;
      case hms256000: ui = 57; break;
      case hms272000: ui = 58; break;
      case hms288000: ui = 59; break;
      case hms304000: ui = 60; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pe_SmallNonNegWholeNumber (pctxt, ui);

      PU_SETBITCOUNT (pctxt);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(60));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioningItem_process_Memory_Size: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_e_alm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_gps_e_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_e_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_e_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_e_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_toa_alm                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_gps_toa_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_toa_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_toa_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_toa_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_delta_I_alm                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_gps_delta_I_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_delta_I_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_delta_I_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_delta_I_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_omegadot_alm                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_omegadot_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_omegadot_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_omegadot_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_omegadot_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_svhealth_alm                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_svhealth_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_svhealth_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_svhealth_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_svhealth_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_omegazero_alm                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_omegazero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_omegazero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_omegazero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_omegazero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_m_zero_alm                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_m_zero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_m_zero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_m_zero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_m_zero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_omega_alm                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_gps_omega_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_omega_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_omega_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_omega_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_af_zero_alm                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_gps_af_zero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_af_zero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(11), OSUINTCONST(11), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_af_zero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_af_zero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_af_one_alm                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem_gps_af_one_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_af_one_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(11), OSUINTCONST(11), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_af_one_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem_gps_af_one_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmission_Gap_Pattern_Sequence_Status_List_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmission_Gap_Pattern_Sequence_Status_List_element (ASN1CTXT* pctxt, Transmission_Gap_Pattern_Sequence_Status_List_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmission_Gap_Pattern_Sequence_Status_List_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode tGPSID */

   PU_PUSHNAME (pctxt, "tGPSID");

   stat = asn1PE_TGPSID (pctxt, pvalue->tGPSID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tGPRC */

   PU_PUSHNAME (pctxt, "tGPRC");

   stat = asn1PE_TGPRC (pctxt, pvalue->tGPRC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tGCFN */

   PU_PUSHNAME (pctxt, "tGCFN");

   stat = asn1PE_CFN (pctxt, pvalue->tGCFN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmission_Gap_Pattern_Sequence_Status_List_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmission_Gap_Pattern_Sequence_Status_List             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmission_Gap_Pattern_Sequence_Status_List (ASN1CTXT* pctxt, Transmission_Gap_Pattern_Sequence_Status_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(6), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmission_Gap_Pattern_Sequence_Status_List: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_Transmission_Gap_Pattern_Sequence_Status_List_element (pctxt, ((Transmission_Gap_Pattern_Sequence_Status_List_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmission_Gap_Pattern_Sequence_Status_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Active_Pattern_Sequence_Information                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Active_Pattern_Sequence_Information (ASN1CTXT* pctxt, Active_Pattern_Sequence_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Active_Pattern_Sequence_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transmission_Gap_Pattern_Sequence_StatusPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transmission_Gap_Pattern_Sequence_StatusPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cMConfigurationChangeCFN */

   PU_PUSHNAME (pctxt, "cMConfigurationChangeCFN");

   stat = asn1PE_CFN (pctxt, pvalue->cMConfigurationChangeCFN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode transmission_Gap_Pattern_Sequence_Status */

   if (pvalue->m.transmission_Gap_Pattern_Sequence_StatusPresent) {
      PU_PUSHNAME (pctxt, "transmission_Gap_Pattern_Sequence_Status");

      stat = asn1PE_Transmission_Gap_Pattern_Sequence_Status_List (pctxt, &pvalue->transmission_Gap_Pattern_Sequence_Status);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Active_Pattern_Sequence_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Angle_Of_Arrival_Value_LCR                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Angle_Of_Arrival_Value_LCR (ASN1CTXT* pctxt, Angle_Of_Arrival_Value_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Angle_Of_Arrival_Value_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode aOA_LCR */

   PU_PUSHNAME (pctxt, "aOA_LCR");

   stat = asn1PE_AOA_LCR (pctxt, pvalue->aOA_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode aOA_LCR_Accuracy_Class */

   PU_PUSHNAME (pctxt, "aOA_LCR_Accuracy_Class");

   stat = asn1PE_AOA_LCR_Accuracy_Class (pctxt, pvalue->aOA_LCR_Accuracy_Class);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Angle_Of_Arrival_Value_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Best_Cell_Portions_Item                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Best_Cell_Portions_Item (ASN1CTXT* pctxt, Best_Cell_Portions_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Best_Cell_Portions_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PE_CellPortionID (pctxt, pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sIRValue */

   PU_PUSHNAME (pctxt, "sIRValue");

   stat = asn1PE_SIR_Value (pctxt, pvalue->sIRValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Best_Cell_Portions_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Best_Cell_Portions_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Best_Cell_Portions_Value (ASN1CTXT* pctxt, Best_Cell_Portions_Value* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Best_Cell_Portions_Value: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_Best_Cell_Portions_Item (pctxt, ((Best_Cell_Portions_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Best_Cell_Portions_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementAccuracy                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonMeasurementAccuracy (ASN1CTXT* pctxt, CommonMeasurementAccuracy* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementAccuracy: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* tUTRANGPSMeasurementAccuracyClass */
         case 1:
            PU_PUSHNAME (pctxt, "u.tUTRANGPSMeasurementAccuracyClass");

            stat = asn1PE_TUTRANGPSAccuracyClass (pctxt, pvalue->u.tUTRANGPSMeasurementAccuracyClass);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonMeasurementAccuracy: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Common_PhysicalChannel_Status_Information                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Common_PhysicalChannel_Status_Information (ASN1CTXT* pctxt, Common_PhysicalChannel_Status_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Common_PhysicalChannel_Status_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PE_CommonPhysicalChannelID (pctxt, pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PE_ResourceOperationalState (pctxt, pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PE_AvailabilityStatus (pctxt, pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Common_PhysicalChannel_Status_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Common_TransportChannel_Status_Information                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Common_TransportChannel_Status_Information (ASN1CTXT* pctxt, Common_TransportChannel_Status_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Common_TransportChannel_Status_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PE_CommonTransportChannelID (pctxt, pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PE_ResourceOperationalState (pctxt, pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PE_AvailabilityStatus (pctxt, pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Common_TransportChannel_Status_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics_IE_List_element (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CriticalityDiagnostics_IE_List_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "repetitionNumberPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.repetitionNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode iECriticality */

   PU_PUSHNAME (pctxt, "iECriticality");

   stat = asn1PE_Criticality (pctxt, pvalue->iECriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_ID */

   PU_PUSHNAME (pctxt, "iE_ID");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      PU_PUSHNAME (pctxt, "repetitionNumber");

      stat = asn1PE_RepetitionNumber0 (pctxt, pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CriticalityDiagnostics_IE_List_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics_IE_List (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_CriticalityDiagnostics_IE_List: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_CriticalityDiagnostics_IE_List_element (pctxt, ((CriticalityDiagnostics_IE_List_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CriticalityDiagnostics_IE_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics (ASN1CTXT* pctxt, CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_CriticalityDiagnostics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "procedureIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.procedureIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "triggeringMessagePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.triggeringMessagePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "procedureCriticalityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.procedureCriticalityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transactionIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transactionIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iEsCriticalityDiagnosticsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iEsCriticalityDiagnosticsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode procedureID */

   if (pvalue->m.procedureIDPresent) {
      PU_PUSHNAME (pctxt, "procedureID");

      stat = asn1PE_ProcedureID (pctxt, &pvalue->procedureID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      PU_PUSHNAME (pctxt, "triggeringMessage");

      stat = asn1PE_TriggeringMessage (pctxt, pvalue->triggeringMessage);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      PU_PUSHNAME (pctxt, "procedureCriticality");

      stat = asn1PE_Criticality (pctxt, pvalue->procedureCriticality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transactionID */

   if (pvalue->m.transactionIDPresent) {
      PU_PUSHNAME (pctxt, "transactionID");

      stat = asn1PE_TransactionID (pctxt, &pvalue->transactionID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      PU_PUSHNAME (pctxt, "iEsCriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CriticalityDiagnostics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_Description_Indicator_Item                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Data_Description_Indicator_Item (ASN1CTXT* pctxt, Data_Description_Indicator_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Data_Description_Indicator_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mACesGuaranteedBitRatePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.mACesGuaranteedBitRatePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_DDI_Value */

   PU_PUSHNAME (pctxt, "e_DCH_DDI_Value");

   stat = asn1PE_E_DCH_DDI_Value (pctxt, pvalue->e_DCH_DDI_Value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode associated_E_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "associated_E_DCH_MACdFlow_ID");

   stat = asn1PE_E_DCH_MACdFlow_ID (pctxt, pvalue->associated_E_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode macdPDU_Size */

   PU_PUSHNAME (pctxt, "macdPDU_Size");

   stat = asn1PE_MACdPDU_Size (pctxt, pvalue->macdPDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode mACesGuaranteedBitRate */

   if (pvalue->m.mACesGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mACesGuaranteedBitRate");

      stat = asn1PE_MACesGuaranteedBitRate (pctxt, pvalue->mACesGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Data_Description_Indicator_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_Description_Indicator                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Data_Description_Indicator (ASN1CTXT* pctxt, Data_Description_Indicator* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Data_Description_Indicator: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_Data_Description_Indicator_Item (pctxt, ((Data_Description_Indicator_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Data_Description_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Specific_FDD_Item                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_Specific_FDD_Item (ASN1CTXT* pctxt, DCH_Specific_FDD_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_Specific_FDD_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PE_DCH_ID (pctxt, pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ul_TransportFormatSet */

   PU_PUSHNAME (pctxt, "ul_TransportFormatSet");

   stat = asn1PE_TransportFormatSet (pctxt, &pvalue->ul_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dl_TransportFormatSet */

   PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

   stat = asn1PE_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode frameHandlingPriority */

   PU_PUSHNAME (pctxt, "frameHandlingPriority");

   stat = asn1PE_FrameHandlingPriority (pctxt, pvalue->frameHandlingPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode qE_Selector */

   PU_PUSHNAME (pctxt, "qE_Selector");

   stat = asn1PE_QE_Selector (pctxt, pvalue->qE_Selector);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_Specific_FDD_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Specific_FDD_InformationList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_Specific_FDD_InformationList (ASN1CTXT* pctxt, DCH_Specific_FDD_InformationList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_Specific_FDD_InformationList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DCH_Specific_FDD_Item (pctxt, ((DCH_Specific_FDD_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_Specific_FDD_InformationList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_FDD_InformationItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_FDD_InformationItem (ASN1CTXT* pctxt, DCH_FDD_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_FDD_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode payloadCRC_PresenceIndicator */

   PU_PUSHNAME (pctxt, "payloadCRC_PresenceIndicator");

   stat = asn1PE_PayloadCRC_PresenceIndicator (pctxt, pvalue->payloadCRC_PresenceIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ul_FP_Mode */

   PU_PUSHNAME (pctxt, "ul_FP_Mode");

   stat = asn1PE_UL_FP_Mode (pctxt, pvalue->ul_FP_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PE_ToAWS (pctxt, pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PE_ToAWE (pctxt, pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dCH_SpecificInformationList */

   PU_PUSHNAME (pctxt, "dCH_SpecificInformationList");

   stat = asn1PE_DCH_Specific_FDD_InformationList (pctxt, &pvalue->dCH_SpecificInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_FDD_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_FDD_Information                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_FDD_Information (ASN1CTXT* pctxt, DCH_FDD_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_FDD_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DCH_FDD_InformationItem (pctxt, ((DCH_FDD_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_FDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Specific_TDD_Item                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_Specific_TDD_Item (ASN1CTXT* pctxt, DCH_Specific_TDD_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_Specific_TDD_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "qE_SelectorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.qE_SelectorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PE_DCH_ID (pctxt, pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ul_CCTrCH_ID */

   PU_PUSHNAME (pctxt, "ul_CCTrCH_ID");

   stat = asn1PE_CCTrCH_ID (pctxt, pvalue->ul_CCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dl_CCTrCH_ID */

   PU_PUSHNAME (pctxt, "dl_CCTrCH_ID");

   stat = asn1PE_CCTrCH_ID (pctxt, pvalue->dl_CCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ul_TransportFormatSet */

   PU_PUSHNAME (pctxt, "ul_TransportFormatSet");

   stat = asn1PE_TransportFormatSet (pctxt, &pvalue->ul_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dl_TransportFormatSet */

   PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

   stat = asn1PE_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode frameHandlingPriority */

   PU_PUSHNAME (pctxt, "frameHandlingPriority");

   stat = asn1PE_FrameHandlingPriority (pctxt, pvalue->frameHandlingPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode qE_Selector */

   if (pvalue->m.qE_SelectorPresent) {
      PU_PUSHNAME (pctxt, "qE_Selector");

      stat = asn1PE_QE_Selector (pctxt, pvalue->qE_Selector);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_Specific_TDD_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Specific_TDD_InformationList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_Specific_TDD_InformationList (ASN1CTXT* pctxt, DCH_Specific_TDD_InformationList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_Specific_TDD_InformationList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DCH_Specific_TDD_Item (pctxt, ((DCH_Specific_TDD_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_Specific_TDD_InformationList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_TDD_InformationItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_TDD_InformationItem (ASN1CTXT* pctxt, DCH_TDD_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_TDD_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode payloadCRC_PresenceIndicator */

   PU_PUSHNAME (pctxt, "payloadCRC_PresenceIndicator");

   stat = asn1PE_PayloadCRC_PresenceIndicator (pctxt, pvalue->payloadCRC_PresenceIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ul_FP_Mode */

   PU_PUSHNAME (pctxt, "ul_FP_Mode");

   stat = asn1PE_UL_FP_Mode (pctxt, pvalue->ul_FP_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PE_ToAWS (pctxt, pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PE_ToAWE (pctxt, pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dCH_SpecificInformationList */

   PU_PUSHNAME (pctxt, "dCH_SpecificInformationList");

   stat = asn1PE_DCH_Specific_TDD_InformationList (pctxt, &pvalue->dCH_SpecificInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_TDD_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_TDD_Information                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_TDD_Information (ASN1CTXT* pctxt, DCH_TDD_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_TDD_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DCH_TDD_InformationItem (pctxt, ((DCH_TDD_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_TDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifySpecificItem_FDD                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_ModifySpecificItem_FDD (ASN1CTXT* pctxt, DCH_ModifySpecificItem_FDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifySpecificItem_FDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_TransportFormatSetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_TransportFormatSetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_TransportFormatSetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_TransportFormatSetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.allocationRetentionPriorityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "frameHandlingPriorityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.frameHandlingPriorityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PE_DCH_ID (pctxt, pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ul_TransportFormatSet */

   if (pvalue->m.ul_TransportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "ul_TransportFormatSet");

      stat = asn1PE_TransportFormatSet (pctxt, &pvalue->ul_TransportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode dl_TransportFormatSet */

   if (pvalue->m.dl_TransportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

      stat = asn1PE_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode frameHandlingPriority */

   if (pvalue->m.frameHandlingPriorityPresent) {
      PU_PUSHNAME (pctxt, "frameHandlingPriority");

      stat = asn1PE_FrameHandlingPriority (pctxt, pvalue->frameHandlingPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifySpecificItem_FDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifySpecificInformation_FDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_ModifySpecificInformation_FDD (ASN1CTXT* pctxt, DCH_ModifySpecificInformation_FDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifySpecificInformation_FDD: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DCH_ModifySpecificItem_FDD (pctxt, ((DCH_ModifySpecificItem_FDD*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifySpecificInformation_FDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DCHs_to_ModifyItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FDD_DCHs_to_ModifyItem (ASN1CTXT* pctxt, FDD_DCHs_to_ModifyItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DCHs_to_ModifyItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_FP_ModePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_FP_ModePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.toAWSPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.toAWEPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode ul_FP_Mode */

   if (pvalue->m.ul_FP_ModePresent) {
      PU_PUSHNAME (pctxt, "ul_FP_Mode");

      stat = asn1PE_UL_FP_Mode (pctxt, pvalue->ul_FP_Mode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PE_ToAWS (pctxt, pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PE_ToAWE (pctxt, pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PE_TransportBearerRequestIndicator (pctxt, pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dCH_SpecificInformationList */

   PU_PUSHNAME (pctxt, "dCH_SpecificInformationList");

   stat = asn1PE_DCH_ModifySpecificInformation_FDD (pctxt, &pvalue->dCH_SpecificInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DCHs_to_ModifyItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DCHs_to_Modify                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FDD_DCHs_to_Modify (ASN1CTXT* pctxt, FDD_DCHs_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DCHs_to_Modify: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_FDD_DCHs_to_ModifyItem (pctxt, ((FDD_DCHs_to_ModifyItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FDD_DCHs_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifySpecificItem_TDD                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_ModifySpecificItem_TDD (ASN1CTXT* pctxt, DCH_ModifySpecificItem_TDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifySpecificItem_TDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_CCTrCH_IDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_CCTrCH_IDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_CCTrCH_IDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_CCTrCH_IDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_TransportFormatSetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_TransportFormatSetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_TransportFormatSetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_TransportFormatSetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.allocationRetentionPriorityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "frameHandlingPriorityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.frameHandlingPriorityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PE_DCH_ID (pctxt, pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ul_CCTrCH_ID */

   if (pvalue->m.ul_CCTrCH_IDPresent) {
      PU_PUSHNAME (pctxt, "ul_CCTrCH_ID");

      stat = asn1PE_CCTrCH_ID (pctxt, pvalue->ul_CCTrCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode dl_CCTrCH_ID */

   if (pvalue->m.dl_CCTrCH_IDPresent) {
      PU_PUSHNAME (pctxt, "dl_CCTrCH_ID");

      stat = asn1PE_CCTrCH_ID (pctxt, pvalue->dl_CCTrCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ul_TransportFormatSet */

   if (pvalue->m.ul_TransportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "ul_TransportFormatSet");

      stat = asn1PE_TransportFormatSet (pctxt, &pvalue->ul_TransportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode dl_TransportFormatSet */

   if (pvalue->m.dl_TransportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

      stat = asn1PE_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode frameHandlingPriority */

   if (pvalue->m.frameHandlingPriorityPresent) {
      PU_PUSHNAME (pctxt, "frameHandlingPriority");

      stat = asn1PE_FrameHandlingPriority (pctxt, pvalue->frameHandlingPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifySpecificItem_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifySpecificInformation_TDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_ModifySpecificInformation_TDD (ASN1CTXT* pctxt, DCH_ModifySpecificInformation_TDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifySpecificInformation_TDD: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DCH_ModifySpecificItem_TDD (pctxt, ((DCH_ModifySpecificItem_TDD*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifySpecificInformation_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifyItem_TDD                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_ModifyItem_TDD (ASN1CTXT* pctxt, DCH_ModifyItem_TDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifyItem_TDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_FP_ModePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_FP_ModePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.toAWSPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.toAWEPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode ul_FP_Mode */

   if (pvalue->m.ul_FP_ModePresent) {
      PU_PUSHNAME (pctxt, "ul_FP_Mode");

      stat = asn1PE_UL_FP_Mode (pctxt, pvalue->ul_FP_Mode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PE_ToAWS (pctxt, pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PE_ToAWE (pctxt, pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PE_TransportBearerRequestIndicator (pctxt, pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dCH_SpecificInformationList */

   PU_PUSHNAME (pctxt, "dCH_SpecificInformationList");

   stat = asn1PE_DCH_ModifySpecificInformation_TDD (pctxt, &pvalue->dCH_SpecificInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DCH_ModifyItem_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DCHs_to_Modify                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TDD_DCHs_to_Modify (ASN1CTXT* pctxt, TDD_DCHs_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DCHs_to_Modify: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DCH_ModifyItem_TDD (pctxt, ((DCH_ModifyItem_TDD*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TDD_DCHs_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DelayedActivation                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DelayedActivation (ASN1CTXT* pctxt, DelayedActivation* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DelayedActivation: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* cfn */
      case 1:
         PU_PUSHNAME (pctxt, "u.cfn");

         stat = asn1PE_CFN (pctxt, pvalue->u.cfn);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         PU_POPNAME (pctxt);

         break;

      /* separate_indication */
      case 2:
         PU_PUSHNAME (pctxt, "u.separate_indication");

         /* NULL */
         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DelayedActivation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DGPSThresholds                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DGPSThresholds (ASN1CTXT* pctxt, DGPSThresholds* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DGPSThresholds: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode prcdeviation */

   PU_PUSHNAME (pctxt, "prcdeviation");

   stat = asn1PE_PRCDeviation (pctxt, pvalue->prcdeviation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DGPSThresholds: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_ReferencePowerInformationItem                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_ReferencePowerInformationItem (ASN1CTXT* pctxt, DL_ReferencePowerInformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_ReferencePowerInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PE_RL_ID (pctxt, pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dl_Reference_Power */

   PU_PUSHNAME (pctxt, "dl_Reference_Power");

   stat = asn1PE_DL_Power (pctxt, pvalue->dl_Reference_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_ReferencePowerInformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_ReferencePowerInformationList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_ReferencePowerInformationList (ASN1CTXT* pctxt, DL_ReferencePowerInformationList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_ReferencePowerInformationList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DL_ReferencePowerInformationItem (pctxt, ((DL_ReferencePowerInformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_ReferencePowerInformationList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_PowerBalancing_Information                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_PowerBalancing_Information (ASN1CTXT* pctxt, DL_PowerBalancing_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_PowerBalancing_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dLReferencePowerPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dLReferencePowerPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dLReferencePowerList_DL_PC_RqstPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dLReferencePowerList_DL_PC_RqstPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maxAdjustmentStepPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.maxAdjustmentStepPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "adjustmentPeriodPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.adjustmentPeriodPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "adjustmentRatioPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.adjustmentRatioPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode powerAdjustmentType */

   PU_PUSHNAME (pctxt, "powerAdjustmentType");

   stat = asn1PE_PowerAdjustmentType (pctxt, pvalue->powerAdjustmentType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dLReferencePower */

   if (pvalue->m.dLReferencePowerPresent) {
      PU_PUSHNAME (pctxt, "dLReferencePower");

      stat = asn1PE_DL_Power (pctxt, pvalue->dLReferencePower);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode dLReferencePowerList_DL_PC_Rqst */

   if (pvalue->m.dLReferencePowerList_DL_PC_RqstPresent) {
      PU_PUSHNAME (pctxt, "dLReferencePowerList_DL_PC_Rqst");

      stat = asn1PE_DL_ReferencePowerInformationList (pctxt, &pvalue->dLReferencePowerList_DL_PC_Rqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode maxAdjustmentStep */

   if (pvalue->m.maxAdjustmentStepPresent) {
      PU_PUSHNAME (pctxt, "maxAdjustmentStep");

      stat = asn1PE_MaxAdjustmentStep (pctxt, pvalue->maxAdjustmentStep);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode adjustmentPeriod */

   if (pvalue->m.adjustmentPeriodPresent) {
      PU_PUSHNAME (pctxt, "adjustmentPeriod");

      stat = asn1PE_AdjustmentPeriod (pctxt, pvalue->adjustmentPeriod);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode adjustmentRatio */

   if (pvalue->m.adjustmentRatioPresent) {
      PU_PUSHNAME (pctxt, "adjustmentRatio");

      stat = asn1PE_ScaledAdjustmentRatio (pctxt, pvalue->adjustmentRatio);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_PowerBalancing_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCPInfoItemLCR                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_TimeslotISCPInfoItemLCR (ASN1CTXT* pctxt, DL_TimeslotISCPInfoItemLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCPInfoItemLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PE_TimeSlotLCR (pctxt, pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode dL_TimeslotISCP */

   PU_PUSHNAME (pctxt, "dL_TimeslotISCP");

   stat = asn1PE_DL_TimeslotISCP (pctxt, pvalue->dL_TimeslotISCP);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCPInfoItemLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCPInfoLCR                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_TimeslotISCPInfoLCR (ASN1CTXT* pctxt, DL_TimeslotISCPInfoLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCPInfoLCR: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DL_TimeslotISCPInfoItemLCR (pctxt, ((DL_TimeslotISCPInfoItemLCR*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DL_TimeslotISCPInfoLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_InformationResponseItem                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DSCH_InformationResponseItem (ASN1CTXT* pctxt, DSCH_InformationResponseItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_InformationResponseItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dSCH_ID */

   PU_PUSHNAME (pctxt, "dSCH_ID");

   stat = asn1PE_DSCH_ID (pctxt, pvalue->dSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_InformationResponseItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_InformationResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DSCH_InformationResponse (ASN1CTXT* pctxt, DSCH_InformationResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_InformationResponse: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DSCH_InformationResponseItem (pctxt, ((DSCH_InformationResponseItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_InformationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_TDD_InformationItem                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DSCH_TDD_InformationItem (ASN1CTXT* pctxt, DSCH_TDD_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_TDD_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dSCH_ID */

   PU_PUSHNAME (pctxt, "dSCH_ID");

   stat = asn1PE_DSCH_ID (pctxt, pvalue->dSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PE_CCTrCH_ID (pctxt, pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode transportFormatSet */

   PU_PUSHNAME (pctxt, "transportFormatSet");

   stat = asn1PE_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode frameHandlingPriority */

   PU_PUSHNAME (pctxt, "frameHandlingPriority");

   stat = asn1PE_FrameHandlingPriority (pctxt, pvalue->frameHandlingPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PE_ToAWS (pctxt, pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PE_ToAWE (pctxt, pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_TDD_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_TDD_Information                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DSCH_TDD_Information (ASN1CTXT* pctxt, DSCH_TDD_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_TDD_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_DSCH_TDD_InformationItem (pctxt, ((DSCH_TDD_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DSCH_TDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_AGCH_FDD_Code_List                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_AGCH_FDD_Code_List (ASN1CTXT* pctxt, E_AGCH_FDD_Code_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_AGCH_FDD_Code_List: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_E_AGCH_FDD_Code_Information_Item (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_AGCH_FDD_Code_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_AGCH_FDD_Code_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_AGCH_FDD_Code_Information (ASN1CTXT* pctxt, E_AGCH_FDD_Code_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_AGCH_FDD_Code_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* replace */
         case 1:
            PU_PUSHNAME (pctxt, "u.replace");

            stat = asn1PE_E_AGCH_FDD_Code_List (pctxt, pvalue->u.replace);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* remove_ */
         case 2:
            PU_PUSHNAME (pctxt, "u.remove_");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_AGCH_FDD_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_FDD_DL_Control_Channel_Information                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_FDD_DL_Control_Channel_Information (ASN1CTXT* pctxt, E_DCH_FDD_DL_Control_Channel_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_FDD_DL_Control_Channel_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_CodePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_CodePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_AGCH_Channelisation_CodePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.e_AGCH_Channelisation_CodePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "primary_e_RNTIPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.primary_e_RNTIPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondary_e_RNTIPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.secondary_e_RNTIPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_RGCH_Signature_SequencePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.e_RGCH_Signature_SequencePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_Code */

   if (pvalue->m.e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_CodePresent) {
      PU_PUSHNAME (pctxt, "e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_Code");

      stat = asn1PE_DL_ScramblingCode (pctxt, pvalue->e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_Code);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode e_AGCH_Channelisation_Code */

   if (pvalue->m.e_AGCH_Channelisation_CodePresent) {
      PU_PUSHNAME (pctxt, "e_AGCH_Channelisation_Code");

      stat = asn1PE_FDD_DL_ChannelisationCodeNumber (pctxt, pvalue->e_AGCH_Channelisation_Code);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode primary_e_RNTI */

   if (pvalue->m.primary_e_RNTIPresent) {
      PU_PUSHNAME (pctxt, "primary_e_RNTI");

      stat = asn1PE_E_RNTI (pctxt, pvalue->primary_e_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode secondary_e_RNTI */

   if (pvalue->m.secondary_e_RNTIPresent) {
      PU_PUSHNAME (pctxt, "secondary_e_RNTI");

      stat = asn1PE_E_RNTI (pctxt, pvalue->secondary_e_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode e_RGCH_E_HICH_Channelisation_Code */

   PU_PUSHNAME (pctxt, "e_RGCH_E_HICH_Channelisation_Code");

   stat = asn1PE_FDD_DL_ChannelisationCodeNumber (pctxt, pvalue->e_RGCH_E_HICH_Channelisation_Code);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode e_RGCH_Signature_Sequence */

   if (pvalue->m.e_RGCH_Signature_SequencePresent) {
      PU_PUSHNAME (pctxt, "e_RGCH_Signature_Sequence");

      stat = asn1PE_E_RGCH_Signature_Sequence (pctxt, pvalue->e_RGCH_Signature_Sequence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode e_HICH_Signature_Sequence */

   PU_PUSHNAME (pctxt, "e_HICH_Signature_Sequence");

   stat = asn1PE_E_HICH_Signature_Sequence (pctxt, pvalue->e_HICH_Signature_Sequence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_FDD_DL_Control_Channel_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TnlQos                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TnlQos (ASN1CTXT* pctxt, TnlQos* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TnlQos: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* dsField */
         case 1:
            PU_PUSHNAME (pctxt, "u.dsField");

            stat = asn1PE_DsField (pctxt, pvalue->u.dsField);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* genericTrafficCategory */
         case 2:
            PU_PUSHNAME (pctxt, "u.genericTrafficCategory");

            stat = asn1PE_GenericTrafficCategory (pctxt, pvalue->u.genericTrafficCategory);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TnlQos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_Non_Scheduled_Transmission_Grant_Items              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_Non_Scheduled_Transmission_Grant_Items (ASN1CTXT* pctxt, E_DCH_Non_Scheduled_Transmission_Grant_Items* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_Non_Scheduled_Transmission_Grant_Items: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hARQ_Process_Allocation_2msPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hARQ_Process_Allocation_2msPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode maxBits_MACe_PDU_non_scheduled */

   PU_PUSHNAME (pctxt, "maxBits_MACe_PDU_non_scheduled");

   stat = asn1PE_Max_Bits_MACe_PDU_non_scheduled (pctxt, pvalue->maxBits_MACe_PDU_non_scheduled);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hARQ_Process_Allocation_2ms */

   if (pvalue->m.hARQ_Process_Allocation_2msPresent) {
      PU_PUSHNAME (pctxt, "hARQ_Process_Allocation_2ms");

      stat = asn1PE_HARQ_Process_Allocation_2ms_EDCH (pctxt, &pvalue->hARQ_Process_Allocation_2ms);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_Non_Scheduled_Transmission_Grant_Items: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_Grant_Type_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_Grant_Type_Information (ASN1CTXT* pctxt, E_DCH_Grant_Type_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_Grant_Type_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* e_DCH_Non_Scheduled_Transmission_Grant */
         case 1:
            PU_PUSHNAME (pctxt, "u.e_DCH_Non_Scheduled_Transmission_Grant");

            stat = asn1PE_E_DCH_Non_Scheduled_Transmission_Grant_Items (pctxt, pvalue->u.e_DCH_Non_Scheduled_Transmission_Grant);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* e_DCH_Scheduled_Transmission_Grant */
         case 2:
            PU_PUSHNAME (pctxt, "u.e_DCH_Scheduled_Transmission_Grant");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_Grant_Type_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InfoItem                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_Specific_InfoItem (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InfoItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tnlQosPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tnlQosPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eDCH_MACdFlow_Multiplexing_ListPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.eDCH_MACdFlow_Multiplexing_ListPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bundlingModeIndicatorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bundlingModeIndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PE_E_DCH_MACdFlow_ID (pctxt, pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tnlQos */

   if (pvalue->m.tnlQosPresent) {
      PU_PUSHNAME (pctxt, "tnlQos");

      stat = asn1PE_TnlQos (pctxt, &pvalue->tnlQos);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode payloadCRC_PresenceIndicator */

   PU_PUSHNAME (pctxt, "payloadCRC_PresenceIndicator");

   stat = asn1PE_PayloadCRC_PresenceIndicator (pctxt, pvalue->payloadCRC_PresenceIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode maximum_Number_of_Retransmissions_For_E_DCH */

   PU_PUSHNAME (pctxt, "maximum_Number_of_Retransmissions_For_E_DCH");

   stat = asn1PE_Maximum_Number_of_Retransmissions_For_E_DCH (pctxt, pvalue->maximum_Number_of_Retransmissions_For_E_DCH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode eDCH_HARQ_PO_FDD */

   PU_PUSHNAME (pctxt, "eDCH_HARQ_PO_FDD");

   stat = asn1PE_E_DCH_HARQ_PO_FDD (pctxt, pvalue->eDCH_HARQ_PO_FDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode eDCH_MACdFlow_Multiplexing_List */

   if (pvalue->m.eDCH_MACdFlow_Multiplexing_ListPresent) {
      PU_PUSHNAME (pctxt, "eDCH_MACdFlow_Multiplexing_List");

      stat = asn1PE_E_DCH_MACdFlow_Multiplexing_List (pctxt, &pvalue->eDCH_MACdFlow_Multiplexing_List);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode eDCH_Grant_Type_Information */

   PU_PUSHNAME (pctxt, "eDCH_Grant_Type_Information");

   stat = asn1PE_E_DCH_Grant_Type_Information (pctxt, &pvalue->eDCH_Grant_Type_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bundlingModeIndicator */

   if (pvalue->m.bundlingModeIndicatorPresent) {
      PU_PUSHNAME (pctxt, "bundlingModeIndicator");

      stat = asn1PE_BundlingModeIndicator (pctxt, pvalue->bundlingModeIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InfoList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_Specific_InfoList (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InfoList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InfoList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_E_DCH_MACdFlow_Specific_InfoItem (pctxt, ((E_DCH_MACdFlow_Specific_InfoItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InfoList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlows_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlows_Information (ASN1CTXT* pctxt, E_DCH_MACdFlows_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlows_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlow_Specific_Info */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_Specific_Info");

   stat = asn1PE_E_DCH_MACdFlow_Specific_InfoList (pctxt, &pvalue->e_DCH_MACdFlow_Specific_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode data_Description_Indicator */

   PU_PUSHNAME (pctxt, "data_Description_Indicator");

   stat = asn1PE_Data_Description_Indicator (pctxt, &pvalue->data_Description_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlows_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UE_E_DCH_Capability_Information                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UE_E_DCH_Capability_Information (ASN1CTXT* pctxt, UE_E_DCH_Capability_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UE_E_DCH_Capability_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode maximum_Allowed_UE_UL_Tx_Power */

   PU_PUSHNAME (pctxt, "maximum_Allowed_UE_UL_Tx_Power");

   stat = asn1PE_Maximum_Allowed_UE_UL_Tx_Power (pctxt, pvalue->maximum_Allowed_UE_UL_Tx_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UE_E_DCH_Capability_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_FDD_Information                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_FDD_Information (ASN1CTXT* pctxt, E_DCH_FDD_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_FDD_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlows_Information */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlows_Information");

   stat = asn1PE_E_DCH_MACdFlows_Information (pctxt, &pvalue->e_DCH_MACdFlows_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ue_E_DCH_Capability_Info */

   PU_PUSHNAME (pctxt, "ue_E_DCH_Capability_Info");

   stat = asn1PE_UE_E_DCH_Capability_Information (pctxt, &pvalue->ue_E_DCH_Capability_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_FDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InformationResp_Item              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_Specific_InformationResp_Item (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InformationResp_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InformationResp_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PE_E_DCH_MACdFlow_ID (pctxt, pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InformationResp_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InformationResp                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_Specific_InformationResp (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InformationResp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InformationResp: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_E_DCH_MACdFlow_Specific_InformationResp_Item (pctxt, ((E_DCH_MACdFlow_Specific_InformationResp_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InformationResp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_FDD_Information_Response                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_FDD_Information_Response (ASN1CTXT* pctxt, E_DCH_FDD_Information_Response* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_FDD_Information_Response: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_DCH_MACdFlow_Specific_InformationRespPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.e_DCH_MACdFlow_Specific_InformationRespPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlow_Specific_InformationResp */

   if (pvalue->m.e_DCH_MACdFlow_Specific_InformationRespPresent) {
      PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_Specific_InformationResp");

      stat = asn1PE_E_DCH_MACdFlow_Specific_InformationResp (pctxt, &pvalue->e_DCH_MACdFlow_Specific_InformationResp);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_FDD_Information_Response: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InfoItem_to_Modify                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_Specific_InfoItem_to_Modify (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InfoItem_to_Modify* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InfoItem_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.allocationRetentionPriorityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tnlQosPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tnlQosPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maximum_Number_of_Retransmissions_For_E_DCHPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.maximum_Number_of_Retransmissions_For_E_DCHPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eDCH_MACdFlow_Multiplexing_ListPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.eDCH_MACdFlow_Multiplexing_ListPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eDCH_Grant_Type_InformationPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.eDCH_Grant_Type_InformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PE_E_DCH_MACdFlow_ID (pctxt, pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PE_TransportBearerRequestIndicator (pctxt, pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode tnlQos */

   if (pvalue->m.tnlQosPresent) {
      PU_PUSHNAME (pctxt, "tnlQos");

      stat = asn1PE_TnlQos (pctxt, &pvalue->tnlQos);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode maximum_Number_of_Retransmissions_For_E_DCH */

   if (pvalue->m.maximum_Number_of_Retransmissions_For_E_DCHPresent) {
      PU_PUSHNAME (pctxt, "maximum_Number_of_Retransmissions_For_E_DCH");

      stat = asn1PE_Maximum_Number_of_Retransmissions_For_E_DCH (pctxt, pvalue->maximum_Number_of_Retransmissions_For_E_DCH);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode eDCH_HARQ_PO_FDD */

   PU_PUSHNAME (pctxt, "eDCH_HARQ_PO_FDD");

   stat = asn1PE_E_DCH_HARQ_PO_FDD (pctxt, pvalue->eDCH_HARQ_PO_FDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode eDCH_MACdFlow_Multiplexing_List */

   if (pvalue->m.eDCH_MACdFlow_Multiplexing_ListPresent) {
      PU_PUSHNAME (pctxt, "eDCH_MACdFlow_Multiplexing_List");

      stat = asn1PE_E_DCH_MACdFlow_Multiplexing_List (pctxt, &pvalue->eDCH_MACdFlow_Multiplexing_List);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode eDCH_Grant_Type_Information */

   if (pvalue->m.eDCH_Grant_Type_InformationPresent) {
      PU_PUSHNAME (pctxt, "eDCH_Grant_Type_Information");

      stat = asn1PE_E_DCH_Grant_Type_Information (pctxt, &pvalue->eDCH_Grant_Type_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InfoItem_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InfoList_to_Modify                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_Specific_InfoList_to_Modify (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InfoList_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InfoList_to_Modify: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_E_DCH_MACdFlow_Specific_InfoItem_to_Modify (pctxt, ((E_DCH_MACdFlow_Specific_InfoItem_to_Modify*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_Specific_InfoList_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_FDD_Information_to_Modify                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_FDD_Information_to_Modify (ASN1CTXT* pctxt, E_DCH_FDD_Information_to_Modify* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_FDD_Information_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_DCH_MACdFlow_Specific_Info_to_ModifyPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.e_DCH_MACdFlow_Specific_Info_to_ModifyPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "data_Description_IndicatorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.data_Description_IndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlow_Specific_Info_to_Modify */

   if (pvalue->m.e_DCH_MACdFlow_Specific_Info_to_ModifyPresent) {
      PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_Specific_Info_to_Modify");

      stat = asn1PE_E_DCH_MACdFlow_Specific_InfoList_to_Modify (pctxt, &pvalue->e_DCH_MACdFlow_Specific_Info_to_Modify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode data_Description_Indicator */

   if (pvalue->m.data_Description_IndicatorPresent) {
      PU_PUSHNAME (pctxt, "data_Description_Indicator");

      stat = asn1PE_Data_Description_Indicator (pctxt, &pvalue->data_Description_Indicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ue_E_DCH_Capability_Info */

   PU_PUSHNAME (pctxt, "ue_E_DCH_Capability_Info");

   stat = asn1PE_UE_E_DCH_Capability_Information (pctxt, &pvalue->ue_E_DCH_Capability_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_FDD_Information_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_to_Delete_Item                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlow_to_Delete_Item (ASN1CTXT* pctxt, E_DCH_MACdFlow_to_Delete_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_to_Delete_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PE_E_DCH_MACdFlow_ID (pctxt, pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlow_to_Delete_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlows_to_Delete                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MACdFlows_to_Delete (ASN1CTXT* pctxt, E_DCH_MACdFlows_to_Delete* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlows_to_Delete: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_E_DCH_MACdFlow_to_Delete_Item (pctxt, ((E_DCH_MACdFlow_to_Delete_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCH_MACdFlows_to_Delete: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RGCH_E_HICH_FDD_Code_List                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_RGCH_E_HICH_FDD_Code_List (ASN1CTXT* pctxt, E_RGCH_E_HICH_FDD_Code_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RGCH_E_HICH_FDD_Code_List: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_E_RGCH_E_HICH_FDD_Code_Information_Item (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RGCH_E_HICH_FDD_Code_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RGCH_E_HICH_FDD_Code_Information                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_RGCH_E_HICH_FDD_Code_Information (ASN1CTXT* pctxt, E_RGCH_E_HICH_FDD_Code_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RGCH_E_HICH_FDD_Code_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* replace */
         case 1:
            PU_PUSHNAME (pctxt, "u.replace");

            stat = asn1PE_E_RGCH_E_HICH_FDD_Code_List (pctxt, pvalue->u.replace);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* remove_ */
         case 2:
            PU_PUSHNAME (pctxt, "u.remove_");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_RGCH_E_HICH_FDD_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCHProvidedBitRate_Item                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCHProvidedBitRate_Item (ASN1CTXT* pctxt, E_DCHProvidedBitRate_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCHProvidedBitRate_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode e_DCHProvidedBitRateValue */

   PU_PUSHNAME (pctxt, "e_DCHProvidedBitRateValue");

   stat = asn1PE_E_DCHProvidedBitRateValue (pctxt, pvalue->e_DCHProvidedBitRateValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCHProvidedBitRate_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCHProvidedBitRate                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCHProvidedBitRate (ASN1CTXT* pctxt, E_DCHProvidedBitRate* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCHProvidedBitRate: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_E_DCHProvidedBitRate_Item (pctxt, ((E_DCHProvidedBitRate_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_E_DCHProvidedBitRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Information                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GPS_Information (ASN1CTXT* pctxt, GPS_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(8), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_GPS_Information_Item (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GPS_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioning_Implicit                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_MemoryPartitioning_Implicit (ASN1CTXT* pctxt, HARQ_MemoryPartitioning_Implicit* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioning_Implicit: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode number_of_Processes */

   PU_PUSHNAME (pctxt, "number_of_Processes");

   if ( (pvalue->number_of_Processes >= 1 && pvalue->number_of_Processes <= 8) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, pvalue->number_of_Processes);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, pvalue->number_of_Processes, OSINTCONST(1), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioning_Implicit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioningItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_MemoryPartitioningItem (ASN1CTXT* pctxt, HARQ_MemoryPartitioningItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioningItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode process_Memory_Size */

   PU_PUSHNAME (pctxt, "process_Memory_Size");

   stat = asn1PE_HARQ_MemoryPartitioningItem_process_Memory_Size (pctxt, pvalue->process_Memory_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioningItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioningList                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_MemoryPartitioningList (ASN1CTXT* pctxt, HARQ_MemoryPartitioningList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioningList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HARQ_MemoryPartitioningItem (pctxt, ((HARQ_MemoryPartitioningItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioningList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioning_Explicit                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_MemoryPartitioning_Explicit (ASN1CTXT* pctxt, HARQ_MemoryPartitioning_Explicit* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioning_Explicit: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hARQ_MemoryPartitioningList */

   PU_PUSHNAME (pctxt, "hARQ_MemoryPartitioningList");

   stat = asn1PE_HARQ_MemoryPartitioningList (pctxt, &pvalue->hARQ_MemoryPartitioningList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioning_Explicit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioning                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HARQ_MemoryPartitioning (ASN1CTXT* pctxt, HARQ_MemoryPartitioning* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioning: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* implicit */
         case 1:
            PU_PUSHNAME (pctxt, "u.implicit");

            stat = asn1PE_HARQ_MemoryPartitioning_Implicit (pctxt, pvalue->u.implicit);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* explicit_ */
         case 2:
            PU_PUSHNAME (pctxt, "u.explicit_");

            stat = asn1PE_HARQ_MemoryPartitioning_Explicit (pctxt, pvalue->u.explicit_);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HARQ_MemoryPartitioning: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRate_Item                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHProvidedBitRate_Item (ASN1CTXT* pctxt, HS_DSCHProvidedBitRate_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRate_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hS_DSCHProvidedBitRateValue */

   PU_PUSHNAME (pctxt, "hS_DSCHProvidedBitRateValue");

   stat = asn1PE_HS_DSCHProvidedBitRateValue (pctxt, pvalue->hS_DSCHProvidedBitRateValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRate_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRate                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHProvidedBitRate (ASN1CTXT* pctxt, HS_DSCHProvidedBitRate* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRate: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HS_DSCHProvidedBitRate_Item (pctxt, ((HS_DSCHProvidedBitRate_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRateValueInformation_For_CellPortion_I  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item (ASN1CTXT* pctxt, HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PE_CellPortionID (pctxt, pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hS_DSCHProvidedBitRateValue */

   PU_PUSHNAME (pctxt, "hS_DSCHProvidedBitRateValue");

   stat = asn1PE_HS_DSCHProvidedBitRateValue (pctxt, pvalue->hS_DSCHProvidedBitRateValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRateValueInformation_For_CellPortion    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHProvidedBitRateValueInformation_For_CellPortion (ASN1CTXT* pctxt, HS_DSCHProvidedBitRateValueInformation_For_CellPortion* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRateValueInformation_For_CellPortion: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item (pctxt, ((HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHProvidedBitRateValueInformation_For_CellPortion: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerPerUEInformation_Item                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHRequiredPowerPerUEInformation_Item (ASN1CTXT* pctxt, HS_DSCHRequiredPowerPerUEInformation_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerPerUEInformation_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_DSCHRequiredPowerPerUEWeightPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hS_DSCHRequiredPowerPerUEWeightPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cRNC_CommunicationContextID */

   PU_PUSHNAME (pctxt, "cRNC_CommunicationContextID");

   stat = asn1PE_CRNC_CommunicationContextID (pctxt, pvalue->cRNC_CommunicationContextID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hS_DSCHRequiredPowerPerUEWeight */

   if (pvalue->m.hS_DSCHRequiredPowerPerUEWeightPresent) {
      PU_PUSHNAME (pctxt, "hS_DSCHRequiredPowerPerUEWeight");

      stat = asn1PE_HS_DSCHRequiredPowerPerUEWeight (pctxt, pvalue->hS_DSCHRequiredPowerPerUEWeight);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerPerUEInformation_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerPerUEInformation                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHRequiredPowerPerUEInformation (ASN1CTXT* pctxt, HS_DSCHRequiredPowerPerUEInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerPerUEInformation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HS_DSCHRequiredPowerPerUEInformation_Item (pctxt, ((HS_DSCHRequiredPowerPerUEInformation_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerPerUEInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPower_Item                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHRequiredPower_Item (ASN1CTXT* pctxt, HS_DSCHRequiredPower_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPower_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_DSCHRequiredPowerPerUEInformationPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hS_DSCHRequiredPowerPerUEInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hS_DSCHRequiredPowerValue */

   PU_PUSHNAME (pctxt, "hS_DSCHRequiredPowerValue");

   stat = asn1PE_HS_DSCHRequiredPowerValue (pctxt, pvalue->hS_DSCHRequiredPowerValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hS_DSCHRequiredPowerPerUEInformation */

   if (pvalue->m.hS_DSCHRequiredPowerPerUEInformationPresent) {
      PU_PUSHNAME (pctxt, "hS_DSCHRequiredPowerPerUEInformation");

      stat = asn1PE_HS_DSCHRequiredPowerPerUEInformation (pctxt, &pvalue->hS_DSCHRequiredPowerPerUEInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPower_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPower                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHRequiredPower (ASN1CTXT* pctxt, HS_DSCHRequiredPower* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPower: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HS_DSCHRequiredPower_Item (pctxt, ((HS_DSCHRequiredPower_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPower: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerValueInformation_For_CellPortion_Ite  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item (ASN1CTXT* pctxt, HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PE_CellPortionID (pctxt, pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hS_DSCHRequiredPowerValue */

   PU_PUSHNAME (pctxt, "hS_DSCHRequiredPowerValue");

   stat = asn1PE_HS_DSCHRequiredPowerValue (pctxt, pvalue->hS_DSCHRequiredPowerValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerValueInformation_For_CellPortion      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCHRequiredPowerValueInformation_For_CellPortion (ASN1CTXT* pctxt, HS_DSCHRequiredPowerValueInformation_For_CellPortion* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerValueInformation_For_CellPortion: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item (pctxt, ((HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_DSCHRequiredPowerValueInformation_For_CellPortion: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InfoItem                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlow_Specific_InfoItem (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InfoItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsDSCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_ID");

   stat = asn1PE_HSDSCH_MACdFlow_ID (pctxt, pvalue->hsDSCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InfoList                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlow_Specific_InfoList (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InfoList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InfoList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HSDSCH_MACdFlow_Specific_InfoItem (pctxt, ((HSDSCH_MACdFlow_Specific_InfoItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InfoList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size_IndexItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MACdPDU_Size_IndexItem (ASN1CTXT* pctxt, MACdPDU_Size_IndexItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size_IndexItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode sID */

   PU_PUSHNAME (pctxt, "sID");

   stat = asn1PE_SID (pctxt, pvalue->sID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode macdPDU_Size */

   PU_PUSHNAME (pctxt, "macdPDU_Size");

   stat = asn1PE_MACdPDU_Size (pctxt, pvalue->macdPDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size_IndexItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size_Indexlist                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MACdPDU_Size_Indexlist (ASN1CTXT* pctxt, MACdPDU_Size_Indexlist* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size_Indexlist: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_MACdPDU_Size_IndexItem (pctxt, ((MACdPDU_Size_IndexItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size_Indexlist: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityQueue_InfoItem (ASN1CTXT* pctxt, PriorityQueue_InfoItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "discardTimerPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.discardTimerPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChsGuaranteedBitRatePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.mAChsGuaranteedBitRatePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode priorityQueueId */

   PU_PUSHNAME (pctxt, "priorityQueueId");

   stat = asn1PE_PriorityQueue_Id (pctxt, pvalue->priorityQueueId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode associatedHSDSCH_MACdFlow */

   PU_PUSHNAME (pctxt, "associatedHSDSCH_MACdFlow");

   stat = asn1PE_HSDSCH_MACdFlow_ID (pctxt, pvalue->associatedHSDSCH_MACdFlow);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode t1 */

   PU_PUSHNAME (pctxt, "t1");

   stat = asn1PE_T1 (pctxt, pvalue->t1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      PU_PUSHNAME (pctxt, "discardTimer");

      stat = asn1PE_DiscardTimer (pctxt, pvalue->discardTimer);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode mAC_hsWindowSize */

   PU_PUSHNAME (pctxt, "mAC_hsWindowSize");

   stat = asn1PE_MAC_hsWindowSize (pctxt, pvalue->mAC_hsWindowSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode mAChsGuaranteedBitRate */

   if (pvalue->m.mAChsGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mAChsGuaranteedBitRate");

      stat = asn1PE_MAChsGuaranteedBitRate (pctxt, pvalue->mAChsGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode macdPDU_Size_Index */

   PU_PUSHNAME (pctxt, "macdPDU_Size_Index");

   stat = asn1PE_MACdPDU_Size_Indexlist (pctxt, &pvalue->macdPDU_Size_Index);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode rLC_Mode */

   PU_PUSHNAME (pctxt, "rLC_Mode");

   stat = asn1PE_RLC_Mode (pctxt, pvalue->rLC_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoList                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityQueue_InfoList (ASN1CTXT* pctxt, PriorityQueue_InfoList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_PriorityQueue_InfoItem (pctxt, ((PriorityQueue_InfoItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlows_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlows_Information (ASN1CTXT* pctxt, HSDSCH_MACdFlows_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlows_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hSDSCH_MACdFlow_Specific_Info */

   PU_PUSHNAME (pctxt, "hSDSCH_MACdFlow_Specific_Info");

   stat = asn1PE_HSDSCH_MACdFlow_Specific_InfoList (pctxt, &pvalue->hSDSCH_MACdFlow_Specific_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode priorityQueue_Info */

   PU_PUSHNAME (pctxt, "priorityQueue_Info");

   stat = asn1PE_PriorityQueue_InfoList (pctxt, &pvalue->priorityQueue_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlows_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UE_Capability_Information                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UE_Capability_Information (ASN1CTXT* pctxt, UE_Capability_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UE_Capability_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hSDSCH_Physical_Layer_Category */

   PU_PUSHNAME (pctxt, "hSDSCH_Physical_Layer_Category");

   if ( (pvalue->hSDSCH_Physical_Layer_Category >= 1 && pvalue->hSDSCH_Physical_Layer_Category <= 64) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, pvalue->hSDSCH_Physical_Layer_Category);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, pvalue->hSDSCH_Physical_Layer_Category, OSINTCONST(1), OSINTCONST(64));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UE_Capability_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_FDD_Information                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_FDD_Information (ASN1CTXT* pctxt, HSDSCH_FDD_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_FDD_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiRepetitionFactorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cqiRepetitionFactorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsscch_PowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsscch_PowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurement_Power_OffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.measurement_Power_OffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hSDSCH_MACdFlows_Information */

   PU_PUSHNAME (pctxt, "hSDSCH_MACdFlows_Information");

   stat = asn1PE_HSDSCH_MACdFlows_Information (pctxt, &pvalue->hSDSCH_MACdFlows_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ueCapability_Info */

   PU_PUSHNAME (pctxt, "ueCapability_Info");

   stat = asn1PE_UE_Capability_Information (pctxt, &pvalue->ueCapability_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode mAChs_Reordering_Buffer_Size_for_RLC_UM */

   PU_PUSHNAME (pctxt, "mAChs_Reordering_Buffer_Size_for_RLC_UM");

   stat = asn1PE_MAChsReorderingBufferSize_for_RLC_UM (pctxt, pvalue->mAChs_Reordering_Buffer_Size_for_RLC_UM);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cqiFeedback_CycleK */

   PU_PUSHNAME (pctxt, "cqiFeedback_CycleK");

   stat = asn1PE_CQI_Feedback_Cycle (pctxt, pvalue->cqiFeedback_CycleK);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cqiRepetitionFactor */

   if (pvalue->m.cqiRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "cqiRepetitionFactor");

      stat = asn1PE_CQI_RepetitionFactor (pctxt, pvalue->cqiRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ackNackRepetitionFactor */

   PU_PUSHNAME (pctxt, "ackNackRepetitionFactor");

   stat = asn1PE_AckNack_RepetitionFactor (pctxt, pvalue->ackNackRepetitionFactor);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cqiPowerOffset */

   PU_PUSHNAME (pctxt, "cqiPowerOffset");

   stat = asn1PE_CQI_Power_Offset (pctxt, pvalue->cqiPowerOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ackPowerOffset */

   PU_PUSHNAME (pctxt, "ackPowerOffset");

   stat = asn1PE_Ack_Power_Offset (pctxt, pvalue->ackPowerOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode nackPowerOffset */

   PU_PUSHNAME (pctxt, "nackPowerOffset");

   stat = asn1PE_Nack_Power_Offset (pctxt, pvalue->nackPowerOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hsscch_PowerOffset */

   if (pvalue->m.hsscch_PowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "hsscch_PowerOffset");

      stat = asn1PE_HSSCCH_PowerOffset (pctxt, pvalue->hsscch_PowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode measurement_Power_Offset */

   if (pvalue->m.measurement_Power_OffsetPresent) {
      PU_PUSHNAME (pctxt, "measurement_Power_Offset");

      stat = asn1PE_Measurement_Power_Offset (pctxt, pvalue->measurement_Power_Offset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_FDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_TDD_Information                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_TDD_Information (ASN1CTXT* pctxt, HSDSCH_TDD_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_TDD_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hSDSCH_MACdFlows_Information */

   PU_PUSHNAME (pctxt, "hSDSCH_MACdFlows_Information");

   stat = asn1PE_HSDSCH_MACdFlows_Information (pctxt, &pvalue->hSDSCH_MACdFlows_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ueCapability_Info */

   PU_PUSHNAME (pctxt, "ueCapability_Info");

   stat = asn1PE_UE_Capability_Information (pctxt, &pvalue->ueCapability_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode mAChs_Reordering_Buffer_Size_for_RLC_UM */

   PU_PUSHNAME (pctxt, "mAChs_Reordering_Buffer_Size_for_RLC_UM");

   stat = asn1PE_MAChsReorderingBufferSize_for_RLC_UM (pctxt, pvalue->mAChs_Reordering_Buffer_Size_for_RLC_UM);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tDD_AckNack_Power_Offset */

   PU_PUSHNAME (pctxt, "tDD_AckNack_Power_Offset");

   stat = asn1PE_TDD_AckNack_Power_Offset (pctxt, pvalue->tDD_AckNack_Power_Offset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_TDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InfoItem_to_Modify               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlow_Specific_InfoItem_to_Modify (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InfoItem_to_Modify* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InfoItem_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.allocationRetentionPriorityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsDSCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_ID");

   stat = asn1PE_HSDSCH_MACdFlow_ID (pctxt, pvalue->hsDSCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PE_TransportBearerRequestIndicator (pctxt, pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InfoItem_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InfoList_to_Modify               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlow_Specific_InfoList_to_Modify (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InfoList_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InfoList_to_Modify: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HSDSCH_MACdFlow_Specific_InfoItem_to_Modify (pctxt, ((HSDSCH_MACdFlow_Specific_InfoItem_to_Modify*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InfoList_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoItem_to_Add                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityQueue_InfoItem_to_Add (ASN1CTXT* pctxt, PriorityQueue_InfoItem_to_Add* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoItem_to_Add: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "discardTimerPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.discardTimerPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChsGuaranteedBitRatePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.mAChsGuaranteedBitRatePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode priorityQueueId */

   PU_PUSHNAME (pctxt, "priorityQueueId");

   stat = asn1PE_PriorityQueue_Id (pctxt, pvalue->priorityQueueId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode associatedHSDSCH_MACdFlow */

   PU_PUSHNAME (pctxt, "associatedHSDSCH_MACdFlow");

   stat = asn1PE_HSDSCH_MACdFlow_ID (pctxt, pvalue->associatedHSDSCH_MACdFlow);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode t1 */

   PU_PUSHNAME (pctxt, "t1");

   stat = asn1PE_T1 (pctxt, pvalue->t1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      PU_PUSHNAME (pctxt, "discardTimer");

      stat = asn1PE_DiscardTimer (pctxt, pvalue->discardTimer);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode mAC_hsWindowSize */

   PU_PUSHNAME (pctxt, "mAC_hsWindowSize");

   stat = asn1PE_MAC_hsWindowSize (pctxt, pvalue->mAC_hsWindowSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode mAChsGuaranteedBitRate */

   if (pvalue->m.mAChsGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mAChsGuaranteedBitRate");

      stat = asn1PE_MAChsGuaranteedBitRate (pctxt, pvalue->mAChsGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode macdPDU_Size_Index */

   PU_PUSHNAME (pctxt, "macdPDU_Size_Index");

   stat = asn1PE_MACdPDU_Size_Indexlist (pctxt, &pvalue->macdPDU_Size_Index);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode rLC_Mode */

   PU_PUSHNAME (pctxt, "rLC_Mode");

   stat = asn1PE_RLC_Mode (pctxt, pvalue->rLC_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoItem_to_Add: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size_IndexItem_to_Modify                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MACdPDU_Size_IndexItem_to_Modify (ASN1CTXT* pctxt, MACdPDU_Size_IndexItem_to_Modify* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size_IndexItem_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode sID */

   PU_PUSHNAME (pctxt, "sID");

   stat = asn1PE_SID (pctxt, pvalue->sID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode macdPDU_Size */

   PU_PUSHNAME (pctxt, "macdPDU_Size");

   stat = asn1PE_MACdPDU_Size (pctxt, pvalue->macdPDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size_IndexItem_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size_Indexlist_to_Modify                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MACdPDU_Size_Indexlist_to_Modify (ASN1CTXT* pctxt, MACdPDU_Size_Indexlist_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size_Indexlist_to_Modify: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_MACdPDU_Size_IndexItem_to_Modify (pctxt, ((MACdPDU_Size_IndexItem_to_Modify*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MACdPDU_Size_Indexlist_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoItem_to_Modify                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityQueue_InfoItem_to_Modify (ASN1CTXT* pctxt, PriorityQueue_InfoItem_to_Modify* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoItem_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "schedulingPriorityIndicatorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.schedulingPriorityIndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "t1Present");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.t1Present);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "discardTimerPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.discardTimerPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAC_hsWindowSizePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.mAC_hsWindowSizePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChsGuaranteedBitRatePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.mAChsGuaranteedBitRatePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "macdPDU_Size_Index_to_ModifyPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.macdPDU_Size_Index_to_ModifyPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode priorityQueueId */

   PU_PUSHNAME (pctxt, "priorityQueueId");

   stat = asn1PE_PriorityQueue_Id (pctxt, pvalue->priorityQueueId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode schedulingPriorityIndicator */

   if (pvalue->m.schedulingPriorityIndicatorPresent) {
      PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

      stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode t1 */

   if (pvalue->m.t1Present) {
      PU_PUSHNAME (pctxt, "t1");

      stat = asn1PE_T1 (pctxt, pvalue->t1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      PU_PUSHNAME (pctxt, "discardTimer");

      stat = asn1PE_DiscardTimer (pctxt, pvalue->discardTimer);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode mAC_hsWindowSize */

   if (pvalue->m.mAC_hsWindowSizePresent) {
      PU_PUSHNAME (pctxt, "mAC_hsWindowSize");

      stat = asn1PE_MAC_hsWindowSize (pctxt, pvalue->mAC_hsWindowSize);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode mAChsGuaranteedBitRate */

   if (pvalue->m.mAChsGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mAChsGuaranteedBitRate");

      stat = asn1PE_MAChsGuaranteedBitRate (pctxt, pvalue->mAChsGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode macdPDU_Size_Index_to_Modify */

   if (pvalue->m.macdPDU_Size_Index_to_ModifyPresent) {
      PU_PUSHNAME (pctxt, "macdPDU_Size_Index_to_Modify");

      stat = asn1PE_MACdPDU_Size_Indexlist_to_Modify (pctxt, &pvalue->macdPDU_Size_Index_to_Modify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoItem_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModifyPriorityQueue                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ModifyPriorityQueue (ASN1CTXT* pctxt, ModifyPriorityQueue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ModifyPriorityQueue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* addPriorityQueue */
         case 1:
            PU_PUSHNAME (pctxt, "u.addPriorityQueue");

            stat = asn1PE_PriorityQueue_InfoItem_to_Add (pctxt, pvalue->u.addPriorityQueue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* modifyPriorityQueue */
         case 2:
            PU_PUSHNAME (pctxt, "u.modifyPriorityQueue");

            stat = asn1PE_PriorityQueue_InfoItem_to_Modify (pctxt, pvalue->u.modifyPriorityQueue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* deletePriorityQueue */
         case 3:
            PU_PUSHNAME (pctxt, "u.deletePriorityQueue");

            stat = asn1PE_PriorityQueue_Id (pctxt, pvalue->u.deletePriorityQueue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ModifyPriorityQueue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoList_to_Modify                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityQueue_InfoList_to_Modify (ASN1CTXT* pctxt, PriorityQueue_InfoList_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoList_to_Modify: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_ModifyPriorityQueue (pctxt, ((ModifyPriorityQueue*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoList_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_Information_to_Modify                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_Information_to_Modify (ASN1CTXT* pctxt, HSDSCH_Information_to_Modify* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_Information_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "priorityQueueInfotoModifyPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.priorityQueueInfotoModifyPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChs_Reordering_Buffer_Size_for_RLC_UMPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.mAChs_Reordering_Buffer_Size_for_RLC_UMPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiFeedback_CycleKPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cqiFeedback_CycleKPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiRepetitionFactorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cqiRepetitionFactorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackNackRepetitionFactorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ackNackRepetitionFactorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cqiPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "nackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.nackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsscch_PowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsscch_PowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurement_Power_OffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.measurement_Power_OffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hSSCCHCodeChangeGrantPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hSSCCHCodeChangeGrantPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDDAckNackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tDDAckNackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsDSCH_MACdFlow_Specific_Info_to_Modify */

   if (pvalue->m.hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent) {
      PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_Specific_Info_to_Modify");

      stat = asn1PE_HSDSCH_MACdFlow_Specific_InfoList_to_Modify (pctxt, &pvalue->hsDSCH_MACdFlow_Specific_Info_to_Modify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode priorityQueueInfotoModify */

   if (pvalue->m.priorityQueueInfotoModifyPresent) {
      PU_PUSHNAME (pctxt, "priorityQueueInfotoModify");

      stat = asn1PE_PriorityQueue_InfoList_to_Modify (pctxt, &pvalue->priorityQueueInfotoModify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode mAChs_Reordering_Buffer_Size_for_RLC_UM */

   if (pvalue->m.mAChs_Reordering_Buffer_Size_for_RLC_UMPresent) {
      PU_PUSHNAME (pctxt, "mAChs_Reordering_Buffer_Size_for_RLC_UM");

      stat = asn1PE_MAChsReorderingBufferSize_for_RLC_UM (pctxt, pvalue->mAChs_Reordering_Buffer_Size_for_RLC_UM);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode cqiFeedback_CycleK */

   if (pvalue->m.cqiFeedback_CycleKPresent) {
      PU_PUSHNAME (pctxt, "cqiFeedback_CycleK");

      stat = asn1PE_CQI_Feedback_Cycle (pctxt, pvalue->cqiFeedback_CycleK);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode cqiRepetitionFactor */

   if (pvalue->m.cqiRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "cqiRepetitionFactor");

      stat = asn1PE_CQI_RepetitionFactor (pctxt, pvalue->cqiRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ackNackRepetitionFactor */

   if (pvalue->m.ackNackRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "ackNackRepetitionFactor");

      stat = asn1PE_AckNack_RepetitionFactor (pctxt, pvalue->ackNackRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode cqiPowerOffset */

   if (pvalue->m.cqiPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "cqiPowerOffset");

      stat = asn1PE_CQI_Power_Offset (pctxt, pvalue->cqiPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ackPowerOffset */

   if (pvalue->m.ackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "ackPowerOffset");

      stat = asn1PE_Ack_Power_Offset (pctxt, pvalue->ackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode nackPowerOffset */

   if (pvalue->m.nackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "nackPowerOffset");

      stat = asn1PE_Nack_Power_Offset (pctxt, pvalue->nackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hsscch_PowerOffset */

   if (pvalue->m.hsscch_PowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "hsscch_PowerOffset");

      stat = asn1PE_HSSCCH_PowerOffset (pctxt, pvalue->hsscch_PowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode measurement_Power_Offset */

   if (pvalue->m.measurement_Power_OffsetPresent) {
      PU_PUSHNAME (pctxt, "measurement_Power_Offset");

      stat = asn1PE_Measurement_Power_Offset (pctxt, pvalue->measurement_Power_Offset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hSSCCHCodeChangeGrant */

   if (pvalue->m.hSSCCHCodeChangeGrantPresent) {
      PU_PUSHNAME (pctxt, "hSSCCHCodeChangeGrant");

      stat = asn1PE_HSSCCH_Code_Change_Grant (pctxt, pvalue->hSSCCHCodeChangeGrant);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode tDDAckNackPowerOffset */

   if (pvalue->m.tDDAckNackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "tDDAckNackPowerOffset");

      stat = asn1PE_TDD_AckNack_Power_Offset (pctxt, pvalue->tDDAckNackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_Information_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoItem_to_Modify_Unsynchronised           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityQueue_InfoItem_to_Modify_Unsynchronised (ASN1CTXT* pctxt, PriorityQueue_InfoItem_to_Modify_Unsynchronised* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoItem_to_Modify_Unsynchronised: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "schedulingPriorityIndicatorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.schedulingPriorityIndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "discardTimerPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.discardTimerPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChsGuaranteedBitRatePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.mAChsGuaranteedBitRatePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode priorityQueueId */

   PU_PUSHNAME (pctxt, "priorityQueueId");

   stat = asn1PE_PriorityQueue_Id (pctxt, pvalue->priorityQueueId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode schedulingPriorityIndicator */

   if (pvalue->m.schedulingPriorityIndicatorPresent) {
      PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

      stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      PU_PUSHNAME (pctxt, "discardTimer");

      stat = asn1PE_DiscardTimer (pctxt, pvalue->discardTimer);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode mAChsGuaranteedBitRate */

   if (pvalue->m.mAChsGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mAChsGuaranteedBitRate");

      stat = asn1PE_MAChsGuaranteedBitRate (pctxt, pvalue->mAChsGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoItem_to_Modify_Unsynchronised: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoList_to_Modify_Unsynchronised           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityQueue_InfoList_to_Modify_Unsynchronised (ASN1CTXT* pctxt, PriorityQueue_InfoList_to_Modify_Unsynchronised* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoList_to_Modify_Unsynchronised: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_PriorityQueue_InfoItem_to_Modify_Unsynchronised (pctxt, ((PriorityQueue_InfoItem_to_Modify_Unsynchronised*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityQueue_InfoList_to_Modify_Unsynchronised: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_Information_to_Modify_Unsynchronised               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_Information_to_Modify_Unsynchronised (ASN1CTXT* pctxt, HSDSCH_Information_to_Modify_Unsynchronised* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_Information_to_Modify_Unsynchronised: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "priorityQueueInfotoModifyUnsynchronisedPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.priorityQueueInfotoModifyUnsynchronisedPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cqiPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "nackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.nackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsscch_PowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsscch_PowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDDAckNackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tDDAckNackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsDSCH_MACdFlow_Specific_Info_to_Modify */

   if (pvalue->m.hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent) {
      PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_Specific_Info_to_Modify");

      stat = asn1PE_HSDSCH_MACdFlow_Specific_InfoList_to_Modify (pctxt, &pvalue->hsDSCH_MACdFlow_Specific_Info_to_Modify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode priorityQueueInfotoModifyUnsynchronised */

   if (pvalue->m.priorityQueueInfotoModifyUnsynchronisedPresent) {
      PU_PUSHNAME (pctxt, "priorityQueueInfotoModifyUnsynchronised");

      stat = asn1PE_PriorityQueue_InfoList_to_Modify_Unsynchronised (pctxt, &pvalue->priorityQueueInfotoModifyUnsynchronised);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode cqiPowerOffset */

   if (pvalue->m.cqiPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "cqiPowerOffset");

      stat = asn1PE_CQI_Power_Offset (pctxt, pvalue->cqiPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ackPowerOffset */

   if (pvalue->m.ackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "ackPowerOffset");

      stat = asn1PE_Ack_Power_Offset (pctxt, pvalue->ackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode nackPowerOffset */

   if (pvalue->m.nackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "nackPowerOffset");

      stat = asn1PE_Nack_Power_Offset (pctxt, pvalue->nackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hsscch_PowerOffset */

   if (pvalue->m.hsscch_PowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "hsscch_PowerOffset");

      stat = asn1PE_HSSCCH_PowerOffset (pctxt, pvalue->hsscch_PowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode tDDAckNackPowerOffset */

   if (pvalue->m.tDDAckNackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "tDDAckNackPowerOffset");

      stat = asn1PE_TDD_AckNack_Power_Offset (pctxt, pvalue->tDDAckNackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_Information_to_Modify_Unsynchronised: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_Initial_Capacity_AllocationItem                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_Initial_Capacity_AllocationItem (ASN1CTXT* pctxt, HSDSCH_Initial_Capacity_AllocationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_Initial_Capacity_AllocationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PE_SchedulingPriorityIndicator (pctxt, pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode maximum_MACdPDU_Size */

   PU_PUSHNAME (pctxt, "maximum_MACdPDU_Size");

   stat = asn1PE_MACdPDU_Size (pctxt, pvalue->maximum_MACdPDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hSDSCH_InitialWindowSize */

   PU_PUSHNAME (pctxt, "hSDSCH_InitialWindowSize");

   stat = asn1PE_HSDSCH_InitialWindowSize (pctxt, pvalue->hSDSCH_InitialWindowSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_Initial_Capacity_AllocationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_Initial_Capacity_Allocation                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_Initial_Capacity_Allocation (ASN1CTXT* pctxt, HSDSCH_Initial_Capacity_Allocation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_Initial_Capacity_Allocation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HSDSCH_Initial_Capacity_AllocationItem (pctxt, ((HSDSCH_Initial_Capacity_AllocationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_Initial_Capacity_Allocation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InformationResp_Item             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlow_Specific_InformationResp_Item (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InformationResp_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InformationResp_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hSDSCH_Initial_Capacity_AllocationPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hSDSCH_Initial_Capacity_AllocationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsDSCHMacdFlow_Id */

   PU_PUSHNAME (pctxt, "hsDSCHMacdFlow_Id");

   stat = asn1PE_HSDSCH_MACdFlow_ID (pctxt, pvalue->hsDSCHMacdFlow_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hSDSCH_Initial_Capacity_Allocation */

   if (pvalue->m.hSDSCH_Initial_Capacity_AllocationPresent) {
      PU_PUSHNAME (pctxt, "hSDSCH_Initial_Capacity_Allocation");

      stat = asn1PE_HSDSCH_Initial_Capacity_Allocation (pctxt, &pvalue->hSDSCH_Initial_Capacity_Allocation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InformationResp_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InformationResp                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlow_Specific_InformationResp (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InformationResp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InformationResp: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HSDSCH_MACdFlow_Specific_InformationResp_Item (pctxt, ((HSDSCH_MACdFlow_Specific_InformationResp_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlow_Specific_InformationResp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Codes                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_Codes (ASN1CTXT* pctxt, HSSCCH_Codes* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Codes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode codeNumber */

   PU_PUSHNAME (pctxt, "codeNumber");

   if ( (pvalue->codeNumber <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->codeNumber, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Codes: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespListFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_Specific_InformationRespListFDD (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespListFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespListFDD: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HSSCCH_Codes (pctxt, ((HSSCCH_Codes*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespListFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_FDD_Information_Response                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_FDD_Information_Response (ASN1CTXT* pctxt, HSDSCH_FDD_Information_Response* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_FDD_Information_Response: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsDSCH_MACdFlow_Specific_InformationRespPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsDSCH_MACdFlow_Specific_InformationRespPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsSCCH_Specific_Information_ResponseFDDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsSCCH_Specific_Information_ResponseFDDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hARQ_MemoryPartitioningPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hARQ_MemoryPartitioningPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsDSCH_MACdFlow_Specific_InformationResp */

   if (pvalue->m.hsDSCH_MACdFlow_Specific_InformationRespPresent) {
      PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_Specific_InformationResp");

      stat = asn1PE_HSDSCH_MACdFlow_Specific_InformationResp (pctxt, &pvalue->hsDSCH_MACdFlow_Specific_InformationResp);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hsSCCH_Specific_Information_ResponseFDD */

   if (pvalue->m.hsSCCH_Specific_Information_ResponseFDDPresent) {
      PU_PUSHNAME (pctxt, "hsSCCH_Specific_Information_ResponseFDD");

      stat = asn1PE_HSSCCH_Specific_InformationRespListFDD (pctxt, &pvalue->hsSCCH_Specific_Information_ResponseFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hARQ_MemoryPartitioning */

   if (pvalue->m.hARQ_MemoryPartitioningPresent) {
      PU_PUSHNAME (pctxt, "hARQ_MemoryPartitioning");

      stat = asn1PE_HARQ_MemoryPartitioning (pctxt, &pvalue->hARQ_MemoryPartitioning);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_FDD_Information_Response: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSICH_Info                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSICH_Info (ASN1CTXT* pctxt, HSSICH_Info* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSICH_Info: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsSICH_ID */

   PU_PUSHNAME (pctxt, "hsSICH_ID");

   stat = asn1PE_HS_SICH_ID (pctxt, pvalue->hsSICH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode timeslot */

   PU_PUSHNAME (pctxt, "timeslot");

   stat = asn1PE_TimeSlot (pctxt, pvalue->timeslot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PE_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tDD_ChannelisationCode");

   stat = asn1PE_TDD_ChannelisationCode (pctxt, pvalue->tDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSICH_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespItemTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_Specific_InformationRespItemTDD (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespItemTDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespItemTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeslot */

   PU_PUSHNAME (pctxt, "timeslot");

   stat = asn1PE_TimeSlot (pctxt, pvalue->timeslot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PE_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tDD_ChannelisationCode");

   stat = asn1PE_TDD_ChannelisationCode (pctxt, pvalue->tDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hSSICH_Info */

   PU_PUSHNAME (pctxt, "hSSICH_Info");

   stat = asn1PE_HSSICH_Info (pctxt, &pvalue->hSSICH_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespItemTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespListTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_Specific_InformationRespListTDD (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespListTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespListTDD: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HSSCCH_Specific_InformationRespItemTDD (pctxt, ((HSSCCH_Specific_InformationRespItemTDD*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespListTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSICH_InfoLCR                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSICH_InfoLCR (ASN1CTXT* pctxt, HSSICH_InfoLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSICH_InfoLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsSICH_ID */

   PU_PUSHNAME (pctxt, "hsSICH_ID");

   stat = asn1PE_HS_SICH_ID (pctxt, pvalue->hsSICH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode timeslotLCR */

   PU_PUSHNAME (pctxt, "timeslotLCR");

   stat = asn1PE_TimeSlotLCR (pctxt, pvalue->timeslotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PE_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tDD_ChannelisationCode");

   stat = asn1PE_TDD_ChannelisationCode (pctxt, pvalue->tDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSICH_InfoLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespItemTDDLCR                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_Specific_InformationRespItemTDDLCR (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespItemTDDLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespItemTDDLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode timeslotLCR */

   PU_PUSHNAME (pctxt, "timeslotLCR");

   stat = asn1PE_TimeSlotLCR (pctxt, pvalue->timeslotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PE_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode first_TDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "first_TDD_ChannelisationCode");

   stat = asn1PE_TDD_ChannelisationCode (pctxt, pvalue->first_TDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode second_TDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "second_TDD_ChannelisationCode");

   stat = asn1PE_TDD_ChannelisationCode (pctxt, pvalue->second_TDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode hSSICH_InfoLCR */

   PU_PUSHNAME (pctxt, "hSSICH_InfoLCR");

   stat = asn1PE_HSSICH_InfoLCR (pctxt, &pvalue->hSSICH_InfoLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespItemTDDLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespListTDDLCR                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSSCCH_Specific_InformationRespListTDDLCR (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespListTDDLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespListTDDLCR: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HSSCCH_Specific_InformationRespItemTDDLCR (pctxt, ((HSSCCH_Specific_InformationRespItemTDDLCR*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSSCCH_Specific_InformationRespListTDDLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_TDD_Information_Response                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_TDD_Information_Response (ASN1CTXT* pctxt, HSDSCH_TDD_Information_Response* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_TDD_Information_Response: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsDSCH_MACdFlow_Specific_InformationRespPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsDSCH_MACdFlow_Specific_InformationRespPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsSCCH_Specific_Information_ResponseTDDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsSCCH_Specific_Information_ResponseTDDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsSCCH_Specific_Information_ResponseTDDLCRPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsSCCH_Specific_Information_ResponseTDDLCRPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hARQ_MemoryPartitioningPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hARQ_MemoryPartitioningPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsDSCH_MACdFlow_Specific_InformationResp */

   if (pvalue->m.hsDSCH_MACdFlow_Specific_InformationRespPresent) {
      PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_Specific_InformationResp");

      stat = asn1PE_HSDSCH_MACdFlow_Specific_InformationResp (pctxt, &pvalue->hsDSCH_MACdFlow_Specific_InformationResp);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hsSCCH_Specific_Information_ResponseTDD */

   if (pvalue->m.hsSCCH_Specific_Information_ResponseTDDPresent) {
      PU_PUSHNAME (pctxt, "hsSCCH_Specific_Information_ResponseTDD");

      stat = asn1PE_HSSCCH_Specific_InformationRespListTDD (pctxt, &pvalue->hsSCCH_Specific_Information_ResponseTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hsSCCH_Specific_Information_ResponseTDDLCR */

   if (pvalue->m.hsSCCH_Specific_Information_ResponseTDDLCRPresent) {
      PU_PUSHNAME (pctxt, "hsSCCH_Specific_Information_ResponseTDDLCR");

      stat = asn1PE_HSSCCH_Specific_InformationRespListTDDLCR (pctxt, &pvalue->hsSCCH_Specific_Information_ResponseTDDLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode hARQ_MemoryPartitioning */

   if (pvalue->m.hARQ_MemoryPartitioningPresent) {
      PU_PUSHNAME (pctxt, "hARQ_MemoryPartitioning");

      stat = asn1PE_HARQ_MemoryPartitioning (pctxt, &pvalue->hARQ_MemoryPartitioning);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_TDD_Information_Response: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlows_to_Delete_Item                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlows_to_Delete_Item (ASN1CTXT* pctxt, HSDSCH_MACdFlows_to_Delete_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlows_to_Delete_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsDSCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_ID");

   stat = asn1PE_HSDSCH_MACdFlow_ID (pctxt, pvalue->hsDSCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlows_to_Delete_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlows_to_Delete                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_MACdFlows_to_Delete (ASN1CTXT* pctxt, HSDSCH_MACdFlows_to_Delete* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlows_to_Delete: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_HSDSCH_MACdFlows_to_Delete_Item (pctxt, ((HSDSCH_MACdFlows_to_Delete_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_MACdFlows_to_Delete: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_Reception_Quality_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_SICH_Reception_Quality_Value (ASN1CTXT* pctxt, HS_SICH_Reception_Quality_Value* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_Reception_Quality_Value: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode failed_HS_SICH */

   PU_PUSHNAME (pctxt, "failed_HS_SICH");

   stat = asn1PE_HS_SICH_failed (pctxt, pvalue->failed_HS_SICH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode missed_HS_SICH */

   PU_PUSHNAME (pctxt, "missed_HS_SICH");

   stat = asn1PE_HS_SICH_missed (pctxt, pvalue->missed_HS_SICH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode total_HS_SICH */

   PU_PUSHNAME (pctxt, "total_HS_SICH");

   stat = asn1PE_HS_SICH_total (pctxt, pvalue->total_HS_SICH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HS_SICH_Reception_Quality_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_FDD_Update_Information                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_FDD_Update_Information (ASN1CTXT* pctxt, HSDSCH_FDD_Update_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_FDD_Update_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsSCCHCodeChangeIndicatorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsSCCHCodeChangeIndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiFeedback_CycleKPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cqiFeedback_CycleKPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiRepetitionFactorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cqiRepetitionFactorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackNackRepetitionFactorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ackNackRepetitionFactorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cqiPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "nackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.nackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsSCCHCodeChangeIndicator */

   if (pvalue->m.hsSCCHCodeChangeIndicatorPresent) {
      PU_PUSHNAME (pctxt, "hsSCCHCodeChangeIndicator");

      stat = asn1PE_HSSCCH_CodeChangeIndicator (pctxt, pvalue->hsSCCHCodeChangeIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode cqiFeedback_CycleK */

   if (pvalue->m.cqiFeedback_CycleKPresent) {
      PU_PUSHNAME (pctxt, "cqiFeedback_CycleK");

      stat = asn1PE_CQI_Feedback_Cycle (pctxt, pvalue->cqiFeedback_CycleK);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode cqiRepetitionFactor */

   if (pvalue->m.cqiRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "cqiRepetitionFactor");

      stat = asn1PE_CQI_RepetitionFactor (pctxt, pvalue->cqiRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ackNackRepetitionFactor */

   if (pvalue->m.ackNackRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "ackNackRepetitionFactor");

      stat = asn1PE_AckNack_RepetitionFactor (pctxt, pvalue->ackNackRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode cqiPowerOffset */

   if (pvalue->m.cqiPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "cqiPowerOffset");

      stat = asn1PE_CQI_Power_Offset (pctxt, pvalue->cqiPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ackPowerOffset */

   if (pvalue->m.ackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "ackPowerOffset");

      stat = asn1PE_Ack_Power_Offset (pctxt, pvalue->ackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode nackPowerOffset */

   if (pvalue->m.nackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "nackPowerOffset");

      stat = asn1PE_Nack_Power_Offset (pctxt, pvalue->nackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_FDD_Update_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_TDD_Update_Information                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HSDSCH_TDD_Update_Information (ASN1CTXT* pctxt, HSDSCH_TDD_Update_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_TDD_Update_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsSCCHCodeChangeIndicatorPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.hsSCCHCodeChangeIndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDDAckNackPowerOffsetPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tDDAckNackPowerOffsetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode hsSCCHCodeChangeIndicator */

   if (pvalue->m.hsSCCHCodeChangeIndicatorPresent) {
      PU_PUSHNAME (pctxt, "hsSCCHCodeChangeIndicator");

      stat = asn1PE_HSSCCH_CodeChangeIndicator (pctxt, pvalue->hsSCCHCodeChangeIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode tDDAckNackPowerOffset */

   if (pvalue->m.tDDAckNackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "tDDAckNackPowerOffset");

      stat = asn1PE_TDD_AckNack_Power_Offset (pctxt, pvalue->tDDAckNackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HSDSCH_TDD_Update_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationReportCharacteristicsType_ReportPeriodicity    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationReportCharacteristicsType_ReportPeriodicity (ASN1CTXT* pctxt, InformationReportCharacteristicsType_ReportPeriodicity* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationReportCharacteristicsType_ReportPeriodicity: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* min */
         case 1:
            PU_PUSHNAME (pctxt, "u.min");

            stat = asn1PE_ReportPeriodicity_Scaledmin (pctxt, pvalue->u.min);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* hours */
         case 2:
            PU_PUSHNAME (pctxt, "u.hours");

            stat = asn1PE_ReportPeriodicity_Scaledhour (pctxt, pvalue->u.hours);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationReportCharacteristicsType_ReportPeriodicity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationThresholds                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationThresholds (ASN1CTXT* pctxt, InformationThresholds* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationThresholds: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* dgps */
         case 1:
            PU_PUSHNAME (pctxt, "u.dgps");

            stat = asn1PE_DGPSThresholds (pctxt, pvalue->u.dgps);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationThresholds: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationReportCharacteristicsType_OnModification       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationReportCharacteristicsType_OnModification (ASN1CTXT* pctxt, InformationReportCharacteristicsType_OnModification* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationReportCharacteristicsType_OnModification: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "information_thresholdsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.information_thresholdsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode information_thresholds */

   if (pvalue->m.information_thresholdsPresent) {
      PU_PUSHNAME (pctxt, "information_thresholds");

      stat = asn1PE_InformationThresholds (pctxt, &pvalue->information_thresholds);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationReportCharacteristicsType_OnModification: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationReportCharacteristics                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationReportCharacteristics (ASN1CTXT* pctxt, InformationReportCharacteristics* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationReportCharacteristics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* onDemand */
         case 1:
            PU_PUSHNAME (pctxt, "u.onDemand");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* periodic */
         case 2:
            PU_PUSHNAME (pctxt, "u.periodic");

            stat = asn1PE_InformationReportCharacteristicsType_ReportPeriodicity (pctxt, pvalue->u.periodic);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* onModification */
         case 3:
            PU_PUSHNAME (pctxt, "u.onModification");

            stat = asn1PE_InformationReportCharacteristicsType_OnModification (pctxt, pvalue->u.onModification);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationReportCharacteristics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationType (ASN1CTXT* pctxt, InformationType* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gPSInformationPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.gPSInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode information_Type_Item */

   PU_PUSHNAME (pctxt, "information_Type_Item");

   stat = asn1PE_Information_Type_Item (pctxt, pvalue->information_Type_Item);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gPSInformation */

   if (pvalue->m.gPSInformationPresent) {
      PU_PUSHNAME (pctxt, "gPSInformation");

      stat = asn1PE_GPS_Information (pctxt, &pvalue->gPSInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InformationType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MessageStructure_element (ASN1CTXT* pctxt, MessageStructure_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_MessageStructure_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "repetitionNumberPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.repetitionNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode iE_ID */

   PU_PUSHNAME (pctxt, "iE_ID");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      PU_PUSHNAME (pctxt, "repetitionNumber");

      stat = asn1PE_RepetitionNumber1 (pctxt, pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MessageStructure_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MessageStructure (ASN1CTXT* pctxt, MessageStructure* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_MessageStructure: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_MessageStructure_element (pctxt, ((MessageStructure_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MessageStructure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UC_Id                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UC_Id (ASN1CTXT* pctxt, UC_Id* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UC_Id: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode rNC_ID */

   PU_PUSHNAME (pctxt, "rNC_ID");

   stat = asn1PE_RNC_ID (pctxt, pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PE_C_ID (pctxt, pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UC_Id: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringFDDCellMeasurementInformation                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NeighbouringFDDCellMeasurementInformation (ASN1CTXT* pctxt, NeighbouringFDDCellMeasurementInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringFDDCellMeasurementInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PE_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PE_UARFCN (pctxt, pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode primaryScramblingCode */

   PU_PUSHNAME (pctxt, "primaryScramblingCode");

   stat = asn1PE_PrimaryScramblingCode (pctxt, pvalue->primaryScramblingCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringFDDCellMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringTDDCellMeasurementInformation                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NeighbouringTDDCellMeasurementInformation (ASN1CTXT* pctxt, NeighbouringTDDCellMeasurementInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringTDDCellMeasurementInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeSlotPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.timeSlotPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftAndBurstTypePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.midambleShiftAndBurstTypePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PE_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PE_UARFCN (pctxt, pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cellParameterID */

   PU_PUSHNAME (pctxt, "cellParameterID");

   stat = asn1PE_CellParameterID (pctxt, pvalue->cellParameterID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode timeSlot */

   if (pvalue->m.timeSlotPresent) {
      PU_PUSHNAME (pctxt, "timeSlot");

      stat = asn1PE_TimeSlot (pctxt, pvalue->timeSlot);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode midambleShiftAndBurstType */

   if (pvalue->m.midambleShiftAndBurstTypePresent) {
      PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

      stat = asn1PE_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringTDDCellMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringCellMeasurementInformation_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NeighbouringCellMeasurementInformation_element (ASN1CTXT* pctxt, NeighbouringCellMeasurementInformation_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringCellMeasurementInformation_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* neighbouringFDDCellMeasurementInformation */
         case 1:
            PU_PUSHNAME (pctxt, "u.neighbouringFDDCellMeasurementInformation");

            stat = asn1PE_NeighbouringFDDCellMeasurementInformation (pctxt, pvalue->u.neighbouringFDDCellMeasurementInformation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* neighbouringTDDCellMeasurementInformation */
         case 2:
            PU_PUSHNAME (pctxt, "u.neighbouringTDDCellMeasurementInformation");

            stat = asn1PE_NeighbouringTDDCellMeasurementInformation (pctxt, pvalue->u.neighbouringTDDCellMeasurementInformation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* extension_neighbouringCellMeasurementInformation */
         case 3:
            stat = asn1PE_Extension_neighbouringCellMeasurementInformation (&lctxt, pvalue->u.extension_neighbouringCellMeasurementInformation);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_POPNAME (pctxt);

      rtFreeContext (&lctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringCellMeasurementInformation_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringCellMeasurementInformation                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NeighbouringCellMeasurementInformation (ASN1CTXT* pctxt, NeighbouringCellMeasurementInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(96), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringCellMeasurementInformation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_NeighbouringCellMeasurementInformation_element (pctxt, ((NeighbouringCellMeasurementInformation_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringCellMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringTDDCellMeasurementInformationLCR              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NeighbouringTDDCellMeasurementInformationLCR (ASN1CTXT* pctxt, NeighbouringTDDCellMeasurementInformationLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringTDDCellMeasurementInformationLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeSlotLCRPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.timeSlotLCRPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftLCRPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.midambleShiftLCRPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PE_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PE_UARFCN (pctxt, pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cellParameterID */

   PU_PUSHNAME (pctxt, "cellParameterID");

   stat = asn1PE_CellParameterID (pctxt, pvalue->cellParameterID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode timeSlotLCR */

   if (pvalue->m.timeSlotLCRPresent) {
      PU_PUSHNAME (pctxt, "timeSlotLCR");

      stat = asn1PE_TimeSlotLCR (pctxt, pvalue->timeSlotLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode midambleShiftLCR */

   if (pvalue->m.midambleShiftLCRPresent) {
      PU_PUSHNAME (pctxt, "midambleShiftLCR");

      stat = asn1PE_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NeighbouringTDDCellMeasurementInformationLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NI_Information                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NI_Information (ASN1CTXT* pctxt, NI_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NI_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_Notification_Indicator (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NI_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Specific_DCH_Info_Item                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RL_Specific_DCH_Info_Item (ASN1CTXT* pctxt, RL_Specific_DCH_Info_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Specific_DCH_Info_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportlayeraddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportlayeraddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode dCH_id */

   PU_PUSHNAME (pctxt, "dCH_id");

   stat = asn1PE_DCH_ID (pctxt, pvalue->dCH_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportlayeraddress */

   if (pvalue->m.transportlayeraddressPresent) {
      PU_PUSHNAME (pctxt, "transportlayeraddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportlayeraddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Specific_DCH_Info_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Specific_DCH_Info                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RL_Specific_DCH_Info (ASN1CTXT* pctxt, RL_Specific_DCH_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Specific_DCH_Info: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_RL_Specific_DCH_Info_Item (pctxt, ((RL_Specific_DCH_Info_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Specific_DCH_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Specific_E_DCH_Info_Item                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RL_Specific_E_DCH_Info_Item (ASN1CTXT* pctxt, RL_Specific_E_DCH_Info_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Specific_E_DCH_Info_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportlayeraddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportlayeraddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PE_E_DCH_MACdFlow_ID (pctxt, pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportlayeraddress */

   if (pvalue->m.transportlayeraddressPresent) {
      PU_PUSHNAME (pctxt, "transportlayeraddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportlayeraddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Specific_E_DCH_Info_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Specific_E_DCH_Info                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RL_Specific_E_DCH_Info (ASN1CTXT* pctxt, RL_Specific_E_DCH_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Specific_E_DCH_Info: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_RL_Specific_E_DCH_Info_Item (pctxt, ((RL_Specific_E_DCH_Info_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RL_Specific_E_DCH_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_ReportPeriodicity               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_ReportPeriodicity (ASN1CTXT* pctxt, ReportCharacteristicsType_ReportPeriodicity* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_ReportPeriodicity: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* msec */
         case 1:
            PU_PUSHNAME (pctxt, "u.msec");

            stat = asn1PE_ReportPeriodicity_Scaledmsec (pctxt, pvalue->u.msec);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* min */
         case 2:
            PU_PUSHNAME (pctxt, "u.min");

            stat = asn1PE_ReportPeriodicity_Scaledmin (pctxt, pvalue->u.min);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_ReportPeriodicity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_MeasurementThreshold            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_MeasurementThreshold (ASN1CTXT* pctxt, ReportCharacteristicsType_MeasurementThreshold* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_MeasurementThreshold: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 12);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 11);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* received_total_wide_band_power */
         case 1:
            PU_PUSHNAME (pctxt, "u.received_total_wide_band_power");

            stat = asn1PE_Received_total_wide_band_power_Value (pctxt, pvalue->u.received_total_wide_band_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* transmitted_carrier_power */
         case 2:
            PU_PUSHNAME (pctxt, "u.transmitted_carrier_power");

            stat = asn1PE_Transmitted_Carrier_Power_Value (pctxt, pvalue->u.transmitted_carrier_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* acknowledged_prach_preambles */
         case 3:
            PU_PUSHNAME (pctxt, "u.acknowledged_prach_preambles");

            stat = asn1PE_Acknowledged_PRACH_preambles_Value (pctxt, pvalue->u.acknowledged_prach_preambles);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* uL_TimeslotISCP */
         case 4:
            PU_PUSHNAME (pctxt, "u.uL_TimeslotISCP");

            stat = asn1PE_UL_TimeslotISCP_Value (pctxt, pvalue->u.uL_TimeslotISCP);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* sir */
         case 5:
            PU_PUSHNAME (pctxt, "u.sir");

            stat = asn1PE_SIR_Value (pctxt, pvalue->u.sir);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* sir_error */
         case 6:
            PU_PUSHNAME (pctxt, "u.sir_error");

            stat = asn1PE_SIR_Error_Value (pctxt, pvalue->u.sir_error);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* transmitted_code_power */
         case 7:
            PU_PUSHNAME (pctxt, "u.transmitted_code_power");

            stat = asn1PE_Transmitted_Code_Power_Value (pctxt, pvalue->u.transmitted_code_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* rscp */
         case 8:
            PU_PUSHNAME (pctxt, "u.rscp");

            stat = asn1PE_RSCP_Value (pctxt, pvalue->u.rscp);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* rx_timing_deviation */
         case 9:
            PU_PUSHNAME (pctxt, "u.rx_timing_deviation");

            stat = asn1PE_Rx_Timing_Deviation_Value (pctxt, pvalue->u.rx_timing_deviation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* round_trip_time */
         case 10:
            PU_PUSHNAME (pctxt, "u.round_trip_time");

            stat = asn1PE_Round_Trip_Time_Value (pctxt, pvalue->u.round_trip_time);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* notUsed_1_acknowledged_PCPCH_access_preambles */
         case 11:
            PU_PUSHNAME (pctxt, "u.notUsed_1_acknowledged_PCPCH_access_preambles");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* notUsed_2_detected_PCPCH_access_preambles */
         case 12:
            PU_PUSHNAME (pctxt, "u.notUsed_2_detected_PCPCH_access_preambles");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 13);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* extension_ReportCharacteristicsType_MeasurementThreshold */
         case 13:
            stat = asn1PE_Extension_ReportCharacteristicsType_MeasurementThreshold (&lctxt, pvalue->u.extension_ReportCharacteristicsType_MeasurementThreshold);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_POPNAME (pctxt);

      rtFreeContext (&lctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_MeasurementThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_ScaledMeasurementHysteresisTim  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (ASN1CTXT* pctxt, ReportCharacteristicsType_ScaledMeasurementHysteresisTime* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_ScaledMeasurementHysteresisTime: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* msec */
         case 1:
            PU_PUSHNAME (pctxt, "u.msec");

            stat = asn1PE_MeasurementHysteresisTime_Scaledmsec (pctxt, pvalue->u.msec);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_ScaledMeasurementHysteresisTime: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventA                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_EventA (ASN1CTXT* pctxt, ReportCharacteristicsType_EventA* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventA: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurementHysteresisTimePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.measurementHysteresisTimePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode measurementThreshold */

   PU_PUSHNAME (pctxt, "measurementThreshold");

   stat = asn1PE_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode measurementHysteresisTime */

   if (pvalue->m.measurementHysteresisTimePresent) {
      PU_PUSHNAME (pctxt, "measurementHysteresisTime");

      stat = asn1PE_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (pctxt, &pvalue->measurementHysteresisTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventA: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventB                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_EventB (ASN1CTXT* pctxt, ReportCharacteristicsType_EventB* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventB: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurementHysteresisTimePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.measurementHysteresisTimePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode measurementThreshold */

   PU_PUSHNAME (pctxt, "measurementThreshold");

   stat = asn1PE_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode measurementHysteresisTime */

   if (pvalue->m.measurementHysteresisTimePresent) {
      PU_PUSHNAME (pctxt, "measurementHysteresisTime");

      stat = asn1PE_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (pctxt, &pvalue->measurementHysteresisTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventB: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_MeasurementIncreaseDecreaseThr  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (ASN1CTXT* pctxt, ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 11);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 10);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* received_total_wide_band_power */
         case 1:
            PU_PUSHNAME (pctxt, "u.received_total_wide_band_power");

            stat = asn1PE_Received_total_wide_band_power_Value_IncrDecrThres (pctxt, pvalue->u.received_total_wide_band_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* transmitted_carrier_power */
         case 2:
            PU_PUSHNAME (pctxt, "u.transmitted_carrier_power");

            stat = asn1PE_Transmitted_Carrier_Power_Value (pctxt, pvalue->u.transmitted_carrier_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* acknowledged_prach_preambles */
         case 3:
            PU_PUSHNAME (pctxt, "u.acknowledged_prach_preambles");

            stat = asn1PE_Acknowledged_PRACH_preambles_Value (pctxt, pvalue->u.acknowledged_prach_preambles);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* uL_TimeslotISCP */
         case 4:
            PU_PUSHNAME (pctxt, "u.uL_TimeslotISCP");

            stat = asn1PE_UL_TimeslotISCP_Value_IncrDecrThres (pctxt, pvalue->u.uL_TimeslotISCP);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* sir */
         case 5:
            PU_PUSHNAME (pctxt, "u.sir");

            stat = asn1PE_SIR_Value_IncrDecrThres (pctxt, pvalue->u.sir);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* sir_error */
         case 6:
            PU_PUSHNAME (pctxt, "u.sir_error");

            stat = asn1PE_SIR_Error_Value_IncrDecrThres (pctxt, pvalue->u.sir_error);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* transmitted_code_power */
         case 7:
            PU_PUSHNAME (pctxt, "u.transmitted_code_power");

            stat = asn1PE_Transmitted_Code_Power_Value_IncrDecrThres (pctxt, pvalue->u.transmitted_code_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* rscp */
         case 8:
            PU_PUSHNAME (pctxt, "u.rscp");

            stat = asn1PE_RSCP_Value_IncrDecrThres (pctxt, pvalue->u.rscp);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* round_trip_time */
         case 9:
            PU_PUSHNAME (pctxt, "u.round_trip_time");

            stat = asn1PE_Round_Trip_Time_IncrDecrThres (pctxt, pvalue->u.round_trip_time);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* notUsed_1_acknowledged_PCPCH_access_preambles */
         case 10:
            PU_PUSHNAME (pctxt, "u.notUsed_1_acknowledged_PCPCH_access_preambles");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* notUsed_2_detected_PCPCH_access_preambles */
         case 11:
            PU_PUSHNAME (pctxt, "u.notUsed_2_detected_PCPCH_access_preambles");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 12);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold */
         case 12:
            stat = asn1PE_Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (&lctxt, pvalue->u.extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_POPNAME (pctxt);

      rtFreeContext (&lctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_ScaledMeasurementChangeTime     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_ScaledMeasurementChangeTime (ASN1CTXT* pctxt, ReportCharacteristicsType_ScaledMeasurementChangeTime* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_ScaledMeasurementChangeTime: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* msec */
         case 1:
            PU_PUSHNAME (pctxt, "u.msec");

            stat = asn1PE_MeasurementChangeTime_Scaledmsec (pctxt, pvalue->u.msec);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_ScaledMeasurementChangeTime: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventC                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_EventC (ASN1CTXT* pctxt, ReportCharacteristicsType_EventC* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventC: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode measurementIncreaseThreshold */

   PU_PUSHNAME (pctxt, "measurementIncreaseThreshold");

   stat = asn1PE_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (pctxt, &pvalue->measurementIncreaseThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode measurementChangeTime */

   PU_PUSHNAME (pctxt, "measurementChangeTime");

   stat = asn1PE_ReportCharacteristicsType_ScaledMeasurementChangeTime (pctxt, &pvalue->measurementChangeTime);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventC: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventD                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_EventD (ASN1CTXT* pctxt, ReportCharacteristicsType_EventD* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode measurementDecreaseThreshold */

   PU_PUSHNAME (pctxt, "measurementDecreaseThreshold");

   stat = asn1PE_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (pctxt, &pvalue->measurementDecreaseThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode measurementChangeTime */

   PU_PUSHNAME (pctxt, "measurementChangeTime");

   stat = asn1PE_ReportCharacteristicsType_ScaledMeasurementChangeTime (pctxt, &pvalue->measurementChangeTime);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventE                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_EventE (ASN1CTXT* pctxt, ReportCharacteristicsType_EventE* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventE: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurementThreshold2Present");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.measurementThreshold2Present);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurementHysteresisTimePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.measurementHysteresisTimePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "reportPeriodicityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.reportPeriodicityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode measurementThreshold1 */

   PU_PUSHNAME (pctxt, "measurementThreshold1");

   stat = asn1PE_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode measurementThreshold2 */

   if (pvalue->m.measurementThreshold2Present) {
      PU_PUSHNAME (pctxt, "measurementThreshold2");

      stat = asn1PE_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode measurementHysteresisTime */

   if (pvalue->m.measurementHysteresisTimePresent) {
      PU_PUSHNAME (pctxt, "measurementHysteresisTime");

      stat = asn1PE_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (pctxt, &pvalue->measurementHysteresisTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode reportPeriodicity */

   if (pvalue->m.reportPeriodicityPresent) {
      PU_PUSHNAME (pctxt, "reportPeriodicity");

      stat = asn1PE_ReportCharacteristicsType_ReportPeriodicity (pctxt, &pvalue->reportPeriodicity);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventF                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_EventF (ASN1CTXT* pctxt, ReportCharacteristicsType_EventF* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventF: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurementThreshold2Present");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.measurementThreshold2Present);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurementHysteresisTimePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.measurementHysteresisTimePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "reportPeriodicityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.reportPeriodicityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode measurementThreshold1 */

   PU_PUSHNAME (pctxt, "measurementThreshold1");

   stat = asn1PE_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode measurementThreshold2 */

   if (pvalue->m.measurementThreshold2Present) {
      PU_PUSHNAME (pctxt, "measurementThreshold2");

      stat = asn1PE_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode measurementHysteresisTime */

   if (pvalue->m.measurementHysteresisTimePresent) {
      PU_PUSHNAME (pctxt, "measurementHysteresisTime");

      stat = asn1PE_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (pctxt, &pvalue->measurementHysteresisTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode reportPeriodicity */

   if (pvalue->m.reportPeriodicityPresent) {
      PU_PUSHNAME (pctxt, "reportPeriodicity");

      stat = asn1PE_ReportCharacteristicsType_ReportPeriodicity (pctxt, &pvalue->reportPeriodicity);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_EventF: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristics                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristics (ASN1CTXT* pctxt, ReportCharacteristics* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 8);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* onDemand */
         case 1:
            PU_PUSHNAME (pctxt, "u.onDemand");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         /* periodic */
         case 2:
            PU_PUSHNAME (pctxt, "u.periodic");

            stat = asn1PE_ReportCharacteristicsType_ReportPeriodicity (pctxt, pvalue->u.periodic);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* event_a */
         case 3:
            PU_PUSHNAME (pctxt, "u.event_a");

            stat = asn1PE_ReportCharacteristicsType_EventA (pctxt, pvalue->u.event_a);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* event_b */
         case 4:
            PU_PUSHNAME (pctxt, "u.event_b");

            stat = asn1PE_ReportCharacteristicsType_EventB (pctxt, pvalue->u.event_b);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* event_c */
         case 5:
            PU_PUSHNAME (pctxt, "u.event_c");

            stat = asn1PE_ReportCharacteristicsType_EventC (pctxt, pvalue->u.event_c);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* event_d */
         case 6:
            PU_PUSHNAME (pctxt, "u.event_d");

            stat = asn1PE_ReportCharacteristicsType_EventD (pctxt, pvalue->u.event_d);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* event_e */
         case 7:
            PU_PUSHNAME (pctxt, "u.event_e");

            stat = asn1PE_ReportCharacteristicsType_EventE (pctxt, pvalue->u.event_e);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* event_f */
         case 8:
            PU_PUSHNAME (pctxt, "u.event_f");

            stat = asn1PE_ReportCharacteristicsType_EventF (pctxt, pvalue->u.event_f);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 9);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* extension_ReportCharacteristics */
         case 9:
            stat = asn1PE_Extension_ReportCharacteristics (&lctxt, pvalue->u.extension_ReportCharacteristics);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      PU_POPNAME (pctxt);

      rtFreeContext (&lctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_OnModification                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportCharacteristicsType_OnModification (ASN1CTXT* pctxt, ReportCharacteristicsType_OnModification* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_OnModification: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode measurementThreshold */

   PU_PUSHNAME (pctxt, "measurementThreshold");

   stat = asn1PE_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ReportCharacteristicsType_OnModification: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Received_total_wide_band_power_For_CellPortion_Value_Ite  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Received_total_wide_band_power_For_CellPortion_Value_Item (ASN1CTXT* pctxt, Received_total_wide_band_power_For_CellPortion_Value_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Received_total_wide_band_power_For_CellPortion_Value_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PE_CellPortionID (pctxt, pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode received_total_wide_band_power_value */

   PU_PUSHNAME (pctxt, "received_total_wide_band_power_value");

   stat = asn1PE_Received_total_wide_band_power_Value (pctxt, pvalue->received_total_wide_band_power_value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Received_total_wide_band_power_For_CellPortion_Value_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Received_total_wide_band_power_For_CellPortion_Value      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Received_total_wide_band_power_For_CellPortion_Value (ASN1CTXT* pctxt, Received_total_wide_band_power_For_CellPortion_Value* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Received_total_wide_band_power_For_CellPortion_Value: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_Received_total_wide_band_power_For_CellPortion_Value_Item (pctxt, ((Received_total_wide_band_power_For_CellPortion_Value_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Received_total_wide_band_power_For_CellPortion_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtItem (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ie_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode data_id */

   PU_PUSHNAME (pctxt, "data_id");

   stat = asn1PE_DATA_ID (pctxt, pvalue->data_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sat_id */

   PU_PUSHNAME (pctxt, "sat_id");

   stat = asn1PE_SAT_ID (pctxt, pvalue->sat_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_e_alm */

   PU_PUSHNAME (pctxt, "gps_e_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_gps_e_alm (pctxt, &pvalue->gps_e_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_toa_alm */

   PU_PUSHNAME (pctxt, "gps_toa_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_gps_toa_alm (pctxt, &pvalue->gps_toa_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_delta_I_alm */

   PU_PUSHNAME (pctxt, "gps_delta_I_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_gps_delta_I_alm (pctxt, &pvalue->gps_delta_I_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode omegadot_alm */

   PU_PUSHNAME (pctxt, "omegadot_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_omegadot_alm (pctxt, &pvalue->omegadot_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode svhealth_alm */

   PU_PUSHNAME (pctxt, "svhealth_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_svhealth_alm (pctxt, &pvalue->svhealth_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_a_sqrt_alm */

   PU_PUSHNAME (pctxt, "gps_a_sqrt_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm (pctxt, &pvalue->gps_a_sqrt_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode omegazero_alm */

   PU_PUSHNAME (pctxt, "omegazero_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_omegazero_alm (pctxt, &pvalue->omegazero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode m_zero_alm */

   PU_PUSHNAME (pctxt, "m_zero_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_m_zero_alm (pctxt, &pvalue->m_zero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_omega_alm */

   PU_PUSHNAME (pctxt, "gps_omega_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_gps_omega_alm (pctxt, &pvalue->gps_omega_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_af_zero_alm */

   PU_PUSHNAME (pctxt, "gps_af_zero_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_gps_af_zero_alm (pctxt, &pvalue->gps_af_zero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode gps_af_one_alm */

   PU_PUSHNAME (pctxt, "gps_af_one_alm");

   stat = asn1PE_SAT_Info_Almanac_ExtItem_gps_af_one_alm (pctxt, &pvalue->gps_af_one_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtList                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAT_Info_Almanac_ExtList (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SAT_Info_Almanac_ExtItem (pctxt, ((SAT_Info_Almanac_ExtItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SAT_Info_Almanac_ExtList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CPICH_Information_Change                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Secondary_CPICH_Information_Change (ASN1CTXT* pctxt, Secondary_CPICH_Information_Change* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Secondary_CPICH_Information_Change: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* new_secondary_CPICH */
         case 1:
            PU_PUSHNAME (pctxt, "u.new_secondary_CPICH");

            stat = asn1PE_CommonPhysicalChannelID (pctxt, pvalue->u.new_secondary_CPICH);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* secondary_CPICH_shall_not_be_used */
         case 2:
            PU_PUSHNAME (pctxt, "u.secondary_CPICH_shall_not_be_used");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Secondary_CPICH_Information_Change: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Serving_E_DCH_RL_in_this_NodeB                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Serving_E_DCH_RL_in_this_NodeB (ASN1CTXT* pctxt, Serving_E_DCH_RL_in_this_NodeB* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Serving_E_DCH_RL_in_this_NodeB: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PE_RL_ID (pctxt, pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Serving_E_DCH_RL_in_this_NodeB: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Serving_E_DCH_RL_ID                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Serving_E_DCH_RL_ID (ASN1CTXT* pctxt, Serving_E_DCH_RL_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Serving_E_DCH_RL_ID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* serving_E_DCH_RL_in_this_NodeB */
         case 1:
            PU_PUSHNAME (pctxt, "u.serving_E_DCH_RL_in_this_NodeB");

            stat = asn1PE_Serving_E_DCH_RL_in_this_NodeB (pctxt, pvalue->u.serving_E_DCH_RL_in_this_NodeB);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* serving_E_DCH_RL_not_in_this_NodeB */
         case 2:
            PU_PUSHNAME (pctxt, "u.serving_E_DCH_RL_not_in_this_NodeB");

            /* NULL */
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Serving_E_DCH_RL_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementThresholdInformation                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNMeasurementThresholdInformation (ASN1CTXT* pctxt, SFNSFNMeasurementThresholdInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementThresholdInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sFNSFNChangeLimitPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.sFNSFNChangeLimitPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "predictedSFNSFNDeviationLimitPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.predictedSFNSFNDeviationLimitPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode sFNSFNChangeLimit */

   if (pvalue->m.sFNSFNChangeLimitPresent) {
      PU_PUSHNAME (pctxt, "sFNSFNChangeLimit");

      stat = asn1PE_SFNSFNChangeLimit (pctxt, pvalue->sFNSFNChangeLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode predictedSFNSFNDeviationLimit */

   if (pvalue->m.predictedSFNSFNDeviationLimitPresent) {
      PU_PUSHNAME (pctxt, "predictedSFNSFNDeviationLimit");

      stat = asn1PE_PredictedSFNSFNDeviationLimit (pctxt, pvalue->predictedSFNSFNDeviationLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementThresholdInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNValue (ASN1CTXT* pctxt, SFNSFNValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sFNSFN_FDD */
         case 1:
            PU_PUSHNAME (pctxt, "u.sFNSFN_FDD");

            stat = asn1PE_SFNSFN_FDD (pctxt, pvalue->u.sFNSFN_FDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* sFNSFN_TDD */
         case 2:
            PU_PUSHNAME (pctxt, "u.sFNSFN_TDD");

            stat = asn1PE_SFNSFN_TDD (pctxt, pvalue->u.sFNSFN_TDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNTimeStamp_TDD                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNTimeStamp_TDD (ASN1CTXT* pctxt, SFNSFNTimeStamp_TDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNTimeStamp_TDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode sFN */

   PU_PUSHNAME (pctxt, "sFN");

   stat = asn1PE_SFN (pctxt, pvalue->sFN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PE_TimeSlot (pctxt, pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNTimeStamp_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNTimeStampInformation                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNTimeStampInformation (ASN1CTXT* pctxt, SFNSFNTimeStampInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNTimeStampInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      PU_PUSHNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sFNSFNTimeStamp_FDD */
         case 1:
            PU_PUSHNAME (pctxt, "u.sFNSFNTimeStamp_FDD");

            stat = asn1PE_SFN (pctxt, pvalue->u.sFNSFNTimeStamp_FDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         /* sFNSFNTimeStamp_TDD */
         case 2:
            PU_PUSHNAME (pctxt, "u.sFNSFNTimeStamp_TDD");

            stat = asn1PE_SFNSFNTimeStamp_TDD (pctxt, pvalue->u.sFNSFNTimeStamp_TDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      PU_PUSHNAME (pctxt, "extension");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNTimeStampInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation_successfullNeighbourin  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sFNSFNQualityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.sFNSFNQualityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sFNSFNDriftRateQualityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.sFNSFNDriftRateQualityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PE_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sFNSFNValue */

   PU_PUSHNAME (pctxt, "sFNSFNValue");

   stat = asn1PE_SFNSFNValue (pctxt, &pvalue->sFNSFNValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sFNSFNQuality */

   if (pvalue->m.sFNSFNQualityPresent) {
      PU_PUSHNAME (pctxt, "sFNSFNQuality");

      stat = asn1PE_SFNSFNQuality (pctxt, pvalue->sFNSFNQuality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode sFNSFNDriftRate */

   PU_PUSHNAME (pctxt, "sFNSFNDriftRate");

   stat = asn1PE_SFNSFNDriftRate (pctxt, pvalue->sFNSFNDriftRate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode sFNSFNDriftRateQuality */

   if (pvalue->m.sFNSFNDriftRateQualityPresent) {
      PU_PUSHNAME (pctxt, "sFNSFNDriftRateQuality");

      stat = asn1PE_SFNSFNDriftRateQuality (pctxt, pvalue->sFNSFNDriftRateQuality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode sFNSFNTimeStampInformation */

   PU_PUSHNAME (pctxt, "sFNSFNTimeStampInformation");

   stat = asn1PE_SFNSFNTimeStampInformation (pctxt, &pvalue->sFNSFNTimeStampInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation_successfullNeighbourin  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(96), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element (pctxt, ((SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation_unsuccessfullNeighbour  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PE_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation_unsuccessfullNeighbour  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(95), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element (pctxt, ((SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SFNSFNMeasurementValueInformation (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation */

   PU_PUSHNAME (pctxt, "successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation");

   stat = asn1PE_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation (pctxt, &pvalue->successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation */

   PU_PUSHNAME (pctxt, "unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation");

   stat = asn1PE_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation (pctxt, &pvalue->unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SFNSFNMeasurementValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeInfoItemLCR                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SyncDLCodeInfoItemLCR (ASN1CTXT* pctxt, SyncDLCodeInfoItemLCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncDLCodeInfoItemLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "syncDLCodeIdArrivTimePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.syncDLCodeIdArrivTimePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "syncDLCodeIdTimingThrePresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.syncDLCodeIdTimingThrePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode syncDLCodeId */

   PU_PUSHNAME (pctxt, "syncDLCodeId");

   stat = asn1PE_SYNCDlCodeId (pctxt, pvalue->syncDLCodeId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode syncDLCodeIdArrivTime */

   if (pvalue->m.syncDLCodeIdArrivTimePresent) {
      PU_PUSHNAME (pctxt, "syncDLCodeIdArrivTime");

      stat = asn1PE_CellSyncBurstTimingLCR (pctxt, &pvalue->syncDLCodeIdArrivTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode syncDLCodeIdTimingThre */

   if (pvalue->m.syncDLCodeIdTimingThrePresent) {
      PU_PUSHNAME (pctxt, "syncDLCodeIdTimingThre");

      stat = asn1PE_CellSyncBurstTimingThreshold (pctxt, pvalue->syncDLCodeIdTimingThre);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncDLCodeInfoItemLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeInfoListLCR                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SyncDLCodeInfoListLCR (ASN1CTXT* pctxt, SyncDLCodeInfoListLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncDLCodeInfoListLCR: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SyncDLCodeInfoItemLCR (pctxt, ((SyncDLCodeInfoItemLCR*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncDLCodeInfoListLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdThreInfoList                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SyncDLCodeIdThreInfoList (ASN1CTXT* pctxt, SyncDLCodeIdThreInfoList* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncDLCodeIdThreInfoList: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode syncFrameNoToReceive */

   PU_PUSHNAME (pctxt, "syncFrameNoToReceive");

   stat = asn1PE_SyncFrameNumber (pctxt, pvalue->syncFrameNoToReceive);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode syncDLCodeIdInfoLCR */

   PU_PUSHNAME (pctxt, "syncDLCodeIdInfoLCR");

   stat = asn1PE_SyncDLCodeInfoListLCR (pctxt, &pvalue->syncDLCodeIdInfoLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncDLCodeIdThreInfoList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdThreInfoLCR                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SyncDLCodeIdThreInfoLCR (ASN1CTXT* pctxt, SyncDLCodeIdThreInfoLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(512), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncDLCodeIdThreInfoLCR: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_SyncDLCodeIdThreInfoList (pctxt, ((SyncDLCodeIdThreInfoList*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SyncDLCodeIdThreInfoLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmission_Gap_Pattern_Sequence_Information_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmission_Gap_Pattern_Sequence_Information_element (ASN1CTXT* pctxt, Transmission_Gap_Pattern_Sequence_Information_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmission_Gap_Pattern_Sequence_Information_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tGL2Present");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tGL2Present);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_to_be_used_1Present");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.not_to_be_used_1Present);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "downlink_Compressed_Mode_MethodPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.downlink_Compressed_Mode_MethodPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uplink_Compressed_Mode_MethodPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.uplink_Compressed_Mode_MethodPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "delta_SIR2Present");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.delta_SIR2Present);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "delta_SIR_after2Present");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.delta_SIR_after2Present);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode tGPSID */

   PU_PUSHNAME (pctxt, "tGPSID");

   stat = asn1PE_TGPSID (pctxt, pvalue->tGPSID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tGSN */

   PU_PUSHNAME (pctxt, "tGSN");

   stat = asn1PE_TGSN (pctxt, pvalue->tGSN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tGL1 */

   PU_PUSHNAME (pctxt, "tGL1");

   stat = asn1PE_GapLength (pctxt, pvalue->tGL1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tGL2 */

   if (pvalue->m.tGL2Present) {
      PU_PUSHNAME (pctxt, "tGL2");

      stat = asn1PE_GapLength (pctxt, pvalue->tGL2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode tGD */

   PU_PUSHNAME (pctxt, "tGD");

   stat = asn1PE_TGD (pctxt, pvalue->tGD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tGPL1 */

   PU_PUSHNAME (pctxt, "tGPL1");

   stat = asn1PE_GapDuration (pctxt, pvalue->tGPL1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode not_to_be_used_1 */

   if (pvalue->m.not_to_be_used_1Present) {
      PU_PUSHNAME (pctxt, "not_to_be_used_1");

      stat = asn1PE_GapDuration (pctxt, pvalue->not_to_be_used_1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode uL_DL_mode */

   PU_PUSHNAME (pctxt, "uL_DL_mode");

   stat = asn1PE_UL_DL_mode (pctxt, pvalue->uL_DL_mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode downlink_Compressed_Mode_Method */

   if (pvalue->m.downlink_Compressed_Mode_MethodPresent) {
      PU_PUSHNAME (pctxt, "downlink_Compressed_Mode_Method");

      stat = asn1PE_Downlink_Compressed_Mode_Method (pctxt, pvalue->downlink_Compressed_Mode_Method);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode uplink_Compressed_Mode_Method */

   if (pvalue->m.uplink_Compressed_Mode_MethodPresent) {
      PU_PUSHNAME (pctxt, "uplink_Compressed_Mode_Method");

      stat = asn1PE_Uplink_Compressed_Mode_Method (pctxt, pvalue->uplink_Compressed_Mode_Method);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode dL_FrameType */

   PU_PUSHNAME (pctxt, "dL_FrameType");

   stat = asn1PE_DL_FrameType (pctxt, pvalue->dL_FrameType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode delta_SIR1 */

   PU_PUSHNAME (pctxt, "delta_SIR1");

   stat = asn1PE_DeltaSIR (pctxt, pvalue->delta_SIR1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode delta_SIR_after1 */

   PU_PUSHNAME (pctxt, "delta_SIR_after1");

   stat = asn1PE_DeltaSIR (pctxt, pvalue->delta_SIR_after1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode delta_SIR2 */

   if (pvalue->m.delta_SIR2Present) {
      PU_PUSHNAME (pctxt, "delta_SIR2");

      stat = asn1PE_DeltaSIR (pctxt, pvalue->delta_SIR2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode delta_SIR_after2 */

   if (pvalue->m.delta_SIR_after2Present) {
      PU_PUSHNAME (pctxt, "delta_SIR_after2");

      stat = asn1PE_DeltaSIR (pctxt, pvalue->delta_SIR_after2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmission_Gap_Pattern_Sequence_Information_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmission_Gap_Pattern_Sequence_Information             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmission_Gap_Pattern_Sequence_Information (ASN1CTXT* pctxt, Transmission_Gap_Pattern_Sequence_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmission_Gap_Pattern_Sequence_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_Transmission_Gap_Pattern_Sequence_Information_element (pctxt, ((Transmission_Gap_Pattern_Sequence_Information_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmission_Gap_Pattern_Sequence_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item (ASN1CTXT* pctxt, TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PE_CellPortionID (pctxt, pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue */

   PU_PUSHNAME (pctxt, "transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue");

   stat = asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue (pctxt, pvalue->transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue (ASN1CTXT* pctxt, TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item (pctxt, ((TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Carrier_Power_For_CellPortion_Value_Item      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmitted_Carrier_Power_For_CellPortion_Value_Item (ASN1CTXT* pctxt, Transmitted_Carrier_Power_For_CellPortion_Value_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Carrier_Power_For_CellPortion_Value_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PE_CellPortionID (pctxt, pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode transmitted_Carrier_Power_Value */

   PU_PUSHNAME (pctxt, "transmitted_Carrier_Power_Value");

   stat = asn1PE_Transmitted_Carrier_Power_Value (pctxt, pvalue->transmitted_Carrier_Power_Value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Carrier_Power_For_CellPortion_Value_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Carrier_Power_For_CellPortion_Value           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Transmitted_Carrier_Power_For_CellPortion_Value (ASN1CTXT* pctxt, Transmitted_Carrier_Power_For_CellPortion_Value* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Carrier_Power_For_CellPortion_Value: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_Transmitted_Carrier_Power_For_CellPortion_Value_Item (pctxt, ((Transmitted_Carrier_Power_For_CellPortion_Value_Item*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Transmitted_Carrier_Power_For_CellPortion_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPS                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TUTRANGPS (ASN1CTXT* pctxt, TUTRANGPS* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPS: start\n");

   /* encode ms_part */

   PU_PUSHNAME (pctxt, "ms_part");

   if ( (pvalue->ms_part <= 16383) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ms_part, OSUINTCONST(0), OSUINTCONST(16383));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   PU_POPNAME (pctxt);

   /* encode ls_part */

   PU_PUSHNAME (pctxt, "ls_part");

   stat = pe_ConsUnsigned (pctxt, pvalue->ls_part, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSMeasurementThresholdInformation                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TUTRANGPSMeasurementThresholdInformation (ASN1CTXT* pctxt, TUTRANGPSMeasurementThresholdInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSMeasurementThresholdInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tUTRANGPSChangeLimitPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tUTRANGPSChangeLimitPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "predictedTUTRANGPSDeviationLimitPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.predictedTUTRANGPSDeviationLimitPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode tUTRANGPSChangeLimit */

   if (pvalue->m.tUTRANGPSChangeLimitPresent) {
      PU_PUSHNAME (pctxt, "tUTRANGPSChangeLimit");

      stat = asn1PE_TUTRANGPSChangeLimit (pctxt, pvalue->tUTRANGPSChangeLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode predictedTUTRANGPSDeviationLimit */

   if (pvalue->m.predictedTUTRANGPSDeviationLimitPresent) {
      PU_PUSHNAME (pctxt, "predictedTUTRANGPSDeviationLimit");

      stat = asn1PE_PredictedTUTRANGPSDeviationLimit (pctxt, pvalue->predictedTUTRANGPSDeviationLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSMeasurementThresholdInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSMeasurementValueInformation                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TUTRANGPSMeasurementValueInformation (ASN1CTXT* pctxt, TUTRANGPSMeasurementValueInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSMeasurementValueInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tUTRANGPSQualityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tUTRANGPSQualityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tUTRANGPSDriftRateQualityPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.tUTRANGPSDriftRateQualityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode tUTRANGPS */

   PU_PUSHNAME (pctxt, "tUTRANGPS");

   stat = asn1PE_TUTRANGPS (pctxt, &pvalue->tUTRANGPS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tUTRANGPSQuality */

   if (pvalue->m.tUTRANGPSQualityPresent) {
      PU_PUSHNAME (pctxt, "tUTRANGPSQuality");

      stat = asn1PE_TUTRANGPSQuality (pctxt, pvalue->tUTRANGPSQuality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode tUTRANGPSDriftRate */

   PU_PUSHNAME (pctxt, "tUTRANGPSDriftRate");

   stat = asn1PE_TUTRANGPSDriftRate (pctxt, pvalue->tUTRANGPSDriftRate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode tUTRANGPSDriftRateQuality */

   if (pvalue->m.tUTRANGPSDriftRateQualityPresent) {
      PU_PUSHNAME (pctxt, "tUTRANGPSDriftRateQuality");

      stat = asn1PE_TUTRANGPSDriftRateQuality (pctxt, pvalue->tUTRANGPSDriftRateQuality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TUTRANGPSMeasurementValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Synchronisation_Parameters_LCR                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_Synchronisation_Parameters_LCR (ASN1CTXT* pctxt, UL_Synchronisation_Parameters_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Synchronisation_Parameters_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uL_Synchronisation_StepSize */

   PU_PUSHNAME (pctxt, "uL_Synchronisation_StepSize");

   stat = asn1PE_UL_Synchronisation_StepSize (pctxt, pvalue->uL_Synchronisation_StepSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode uL_Synchronisation_Frequency */

   PU_PUSHNAME (pctxt, "uL_Synchronisation_Frequency");

   stat = asn1PE_UL_Synchronisation_Frequency (pctxt, pvalue->uL_Synchronisation_Frequency);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UL_Synchronisation_Parameters_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_USCH_InformationItem (ASN1CTXT* pctxt, USCH_InformationItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uSCH_ID */

   PU_PUSHNAME (pctxt, "uSCH_ID");

   stat = asn1PE_USCH_ID (pctxt, pvalue->uSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PE_CCTrCH_ID (pctxt, pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode transportFormatSet */

   PU_PUSHNAME (pctxt, "transportFormatSet");

   stat = asn1PE_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PE_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_Information                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_USCH_Information (ASN1CTXT* pctxt, USCH_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_Information: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_USCH_InformationItem (pctxt, ((USCH_InformationItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationResponseItem                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_USCH_InformationResponseItem (ASN1CTXT* pctxt, USCH_InformationResponseItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_InformationResponseItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.bindingIDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode uSCH_ID */

   PU_PUSHNAME (pctxt, "uSCH_ID");

   stat = asn1PE_USCH_ID (pctxt, pvalue->uSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   PU_POPNAME (pctxt);

   /* encode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PE_BindingID (pctxt, pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_InformationResponseItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_USCH_InformationResponse (ASN1CTXT* pctxt, USCH_InformationResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_InformationResponse: start\n");

   /* encode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PE_USCH_InformationResponseItem (pctxt, ((USCH_InformationResponseItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_USCH_InformationResponse: end\n");

   return (stat);
}

