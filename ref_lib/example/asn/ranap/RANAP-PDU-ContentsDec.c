/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 20-Mar-2007.
 */
#include "asn1intl.h"
#include "RANAP-PDU-ContentsTable.h"
#include "RANAP-IEsTable.h"

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCommandIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCommandIEs_Value *pvalue = (_Iu_ReleaseCommandIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseCommand_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseCommand_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCommandIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, Iu_ReleaseCommandIEs[index].ValueSize);
   stat = Iu_ReleaseCommandIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseCommand_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseCommand_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseCommand_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Iu_ReleaseCommandExtensions[index].ExtensionSize);
   stat = Iu_ReleaseCommandExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseCommand_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseCommand_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseCommand_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseCommand (ASN1CTXT* pctxt, Iu_ReleaseCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Iu_ReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Iu_ReleaseCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeList_element_iE_Extensions_element (ASN1CTXT* pctxt, DataVolumeList_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeList_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeList_element_iE_Extensions_element (ASN1CTXT* pctxt,
   DataVolumeList_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeList_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeList_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeList_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DataVolumeList_ExtIEs[index].ExtensionSize);
   stat = DataVolumeList_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeList_element_iE_Extensions (ASN1CTXT* pctxt, DataVolumeList_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeList_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeList_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeList_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeList_element (ASN1CTXT* pctxt, DataVolumeList_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataVolumeReferencePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode dl_UnsuccessfullyTransmittedDataVolume */

   stat = asn1PD_UnsuccessfullyTransmittedDataVolume (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dataVolumeReference */

   if (pvalue->m.dataVolumeReferencePresent) {
      stat = asn1PD_DataVolumeReference (pctxt, &pvalue->dataVolumeReference);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_DataVolumeList_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeList (ASN1CTXT* pctxt, DataVolumeList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   DataVolumeList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataVolumeReportItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataVolumeReportItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataVolumeReportItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_DataVolumeReportItem_ExtIEs[index].ExtensionSize);
   stat = RAB_DataVolumeReportItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataVolumeReportItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataVolumeReportItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportItem (ASN1CTXT* pctxt, RAB_DataVolumeReportItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dl_UnsuccessfullyTransmittedDataVolume */

   if (pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent) {
      stat = asn1PD_DataVolumeList (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_DataVolumeReportItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataVolumeReportItemIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataVolumeReportItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataVolumeReportItemIEs_Value *pvalue = (_RAB_DataVolumeReportItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportList_element_element (ASN1CTXT* pctxt, RAB_DataVolumeReportList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataVolumeReportList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataVolumeReportList_element_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_DataVolumeReportItemIEs[index].ValueSize);
   stat = RAB_DataVolumeReportItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportList_element (ASN1CTXT* pctxt, RAB_DataVolumeReportList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataVolumeReportList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportList (ASN1CTXT* pctxt, RAB_DataVolumeReportList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_DataVolumeReportList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseCompleteIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value *pvalue = (_Iu_ReleaseCompleteIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleasedItem_IuRelComp_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_IuRelComp_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_IuRelComp_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_IuRelComp_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ReleasedItem_IuRelComp_ExtIEs[index].ExtensionSize);
   stat = RAB_ReleasedItem_IuRelComp_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_IuRelComp_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleasedItem_IuRelComp_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedItem_IuRelComp_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_IuRelComp (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dL_GTP_PDU_SequenceNumber */

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uL_GTP_PDU_SequenceNumber */

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ReleasedItem_IuRelComp_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleasedItem_IuRelComp_IEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ReleasedItem_IuRelComp_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleasedItem_IuRelComp_IEs_Value *pvalue = (_RAB_ReleasedItem_IuRelComp_IEs_Value*) pvalue_;

   stat = asn1PD_RAB_ReleasedItem_IuRelComp (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_IuRelComp_element_element (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleasedList_IuRelComp_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleasedList_IuRelComp_element_element (ASN1CTXT* pctxt,
   RAB_ReleasedList_IuRelComp_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_IuRelComp_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_IuRelComp_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_IuRelComp_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ReleasedItem_IuRelComp_IEs[index].ValueSize);
   stat = RAB_ReleasedItem_IuRelComp_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_IuRelComp_element (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleasedList_IuRelComp_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedList_IuRelComp_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedList_IuRelComp_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_IuRelComp (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ReleasedList_IuRelComp_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedList_IuRelComp_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedList_IuRelComp_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseCompleteIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value_1 *pvalue = (_Iu_ReleaseCompleteIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ReleasedList_IuRelComp (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value_2                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseCompleteIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value_2 *pvalue = (_Iu_ReleaseCompleteIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseComplete_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseComplete_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCompleteIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, Iu_ReleaseCompleteIEs[index].ValueSize);
   stat = Iu_ReleaseCompleteIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseComplete_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseComplete_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseComplete_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseComplete_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Iu_ReleaseCompleteExtensions[index].ExtensionSize);
   stat = Iu_ReleaseCompleteExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseComplete_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseComplete_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseComplete_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseComplete (ASN1CTXT* pctxt, Iu_ReleaseComplete* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Iu_ReleaseComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Iu_ReleaseComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value *pvalue = (_RelocationRequiredIEs_Value*) pvalue_;

   stat = asn1PD_RelocationType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_1 *pvalue = (_RelocationRequiredIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_2                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_2 *pvalue = (_RelocationRequiredIEs_Value_2*) pvalue_;

   stat = asn1PD_SourceID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_3                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_3 *pvalue = (_RelocationRequiredIEs_Value_3*) pvalue_;

   stat = asn1PD_TargetID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_4                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_4 *pvalue = (_RelocationRequiredIEs_Value_4*) pvalue_;

   stat = asn1PD_ClassmarkInformation2 (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_5                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_5 *pvalue = (_RelocationRequiredIEs_Value_5*) pvalue_;

   stat = asn1PD_ClassmarkInformation3 (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_6                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_6 *pvalue = (_RelocationRequiredIEs_Value_6*) pvalue_;

   stat = asn1PD_SourceRNC_ToTargetRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_7                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_7 *pvalue = (_RelocationRequiredIEs_Value_7*) pvalue_;

   stat = asn1PD_OldBSS_ToNewBSS_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequired_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequired_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequired_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequired_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequiredIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequiredIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequiredIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationRequiredIEs[index].ValueSize);
   stat = RelocationRequiredIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired_protocolIEs (ASN1CTXT* pctxt, RelocationRequired_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequired_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequired_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequired_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredExtensions_Extension                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredExtensions_Extension *pvalue = (_RelocationRequiredExtensions_Extension*) pvalue_;

   stat = asn1PD_GERAN_Classmark (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredExtensions_Extension_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequiredExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredExtensions_Extension_1 *pvalue = (_RelocationRequiredExtensions_Extension_1*) pvalue_;

   stat = asn1PD_SourceBSS_ToTargetBSS_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequired_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequired_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequired_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequired_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequiredExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequiredExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequiredExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationRequiredExtensions[index].ExtensionSize);
   stat = RelocationRequiredExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired_protocolExtensions (ASN1CTXT* pctxt, RelocationRequired_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequired_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequired_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequired_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequired (ASN1CTXT* pctxt, RelocationRequired* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationRequired_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value *pvalue = (_RelocationCommandIEs_Value*) pvalue_;

   stat = asn1PD_TargetRNC_ToSourceRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_1 *pvalue = (_RelocationCommandIEs_Value_1*) pvalue_;

   stat = asn1PD_L3_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_RelocationReleaseItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_RelocationReleaseItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_RelocationReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_RelocationReleaseItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_RelocationReleaseItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_RelocationReleaseItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_RelocationReleaseItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_RelocationReleaseItem_ExtIEs[index].ExtensionSize);
   stat = RAB_RelocationReleaseItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseItem_iE_Extensions (ASN1CTXT* pctxt, RAB_RelocationReleaseItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_RelocationReleaseItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_RelocationReleaseItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_RelocationReleaseItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseItem (ASN1CTXT* pctxt, RAB_RelocationReleaseItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_RelocationReleaseItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_RelocationReleaseItemIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_RelocationReleaseItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_RelocationReleaseItemIEs_Value *pvalue = (_RAB_RelocationReleaseItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_RelocationReleaseItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseList_element_element (ASN1CTXT* pctxt, RAB_RelocationReleaseList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_RelocationReleaseList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_RelocationReleaseList_element_element (ASN1CTXT* pctxt,
   RAB_RelocationReleaseList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_RelocationReleaseItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_RelocationReleaseItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_RelocationReleaseItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_RelocationReleaseItemIEs[index].ValueSize);
   stat = RAB_RelocationReleaseItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseList_element (ASN1CTXT* pctxt, RAB_RelocationReleaseList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_RelocationReleaseList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_RelocationReleaseList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_RelocationReleaseList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_RelocationReleaseList (ASN1CTXT* pctxt, RAB_RelocationReleaseList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_RelocationReleaseList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_RelocationReleaseList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_RelocationReleaseList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_2 *pvalue = (_RelocationCommandIEs_Value_2*) pvalue_;

   stat = asn1PD_RAB_RelocationReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_ExtIEs_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataForwardingItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_ExtIEs_Extension *pvalue = (_RAB_DataForwardingItem_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_TransportLayerAddress (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_ExtIEs_Extension_1                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataForwardingItem_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_ExtIEs_Extension_1 *pvalue = (_RAB_DataForwardingItem_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_IuTransportAssociation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataForwardingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataForwardingItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataForwardingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataForwardingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_DataForwardingItem_ExtIEs[index].ExtensionSize);
   stat = RAB_DataForwardingItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataForwardingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataForwardingItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem (ASN1CTXT* pctxt, RAB_DataForwardingItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transportLayerAddress */

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iuTransportAssociation */

   stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_DataForwardingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItemIEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataForwardingItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItemIEs_Value *pvalue = (_RAB_DataForwardingItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataForwardingItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_element_element (ASN1CTXT* pctxt, RAB_DataForwardingList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataForwardingList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataForwardingList_element_element (ASN1CTXT* pctxt,
   RAB_DataForwardingList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_DataForwardingItemIEs[index].ValueSize);
   stat = RAB_DataForwardingItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_element (ASN1CTXT* pctxt, RAB_DataForwardingList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataForwardingList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList (ASN1CTXT* pctxt, RAB_DataForwardingList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_DataForwardingList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_3 *pvalue = (_RelocationCommandIEs_Value_3*) pvalue_;

   stat = asn1PD_RAB_DataForwardingList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_4 *pvalue = (_RelocationCommandIEs_Value_4*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand_protocolIEs_element (ASN1CTXT* pctxt, RelocationCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCommand_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCommand_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCommandIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationCommandIEs[index].ValueSize);
   stat = RelocationCommandIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand_protocolIEs (ASN1CTXT* pctxt, RelocationCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCommand_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCommand_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandExtensions_Extension *pvalue = (_RelocationCommandExtensions_Extension*) pvalue_;

   stat = asn1PD_InterSystemInformation_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCommandExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandExtensions_Extension_1 *pvalue = (_RelocationCommandExtensions_Extension_1*) pvalue_;

   stat = asn1PD_TargetBSS_ToSourceBSS_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCommand_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationCommandExtensions[index].ExtensionSize);
   stat = RelocationCommandExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand_protocolExtensions (ASN1CTXT* pctxt, RelocationCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCommand_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCommand_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCommand_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCommand (ASN1CTXT* pctxt, RelocationCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationPreparationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureIEs_Value *pvalue = (_RelocationPreparationFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationPreparationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureIEs_Value_1 *pvalue = (_RelocationPreparationFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure_protocolIEs_element (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationPreparationFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationPreparationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationPreparationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationPreparationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationPreparationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationPreparationFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationPreparationFailureIEs[index].ValueSize);
   stat = RelocationPreparationFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure_protocolIEs (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationPreparationFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationPreparationFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationPreparationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureExtensions_Extension         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationPreparationFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureExtensions_Extension *pvalue = (_RelocationPreparationFailureExtensions_Extension*) pvalue_;

   stat = asn1PD_InterSystemInformation_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure_protocolExtensions_element (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationPreparationFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationPreparationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationPreparationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationPreparationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationPreparationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationPreparationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationPreparationFailureExtensions[index].ExtensionSize);
   stat = RelocationPreparationFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure_protocolExtensions (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationPreparationFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationPreparationFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationPreparationFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationPreparationFailure (ASN1CTXT* pctxt, RelocationPreparationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationPreparationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationPreparationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value *pvalue = (_RelocationRequestIEs_Value*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_1 *pvalue = (_RelocationRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_2 *pvalue = (_RelocationRequestIEs_Value_2*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_3 *pvalue = (_RelocationRequestIEs_Value_3*) pvalue_;

   stat = asn1PD_SourceRNC_ToTargetRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UserPlaneInformation_iE_Extensions_element (ASN1CTXT* pctxt, UserPlaneInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UserPlaneInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UserPlaneInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   UserPlaneInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UserPlaneInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UserPlaneInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UserPlaneInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UserPlaneInformation_ExtIEs[index].ExtensionSize);
   stat = UserPlaneInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UserPlaneInformation_iE_Extensions (ASN1CTXT* pctxt, UserPlaneInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UserPlaneInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UserPlaneInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UserPlaneInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UserPlaneInformation (ASN1CTXT* pctxt, UserPlaneInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode userPlaneMode */

   stat = asn1PD_UserPlaneMode (pctxt, &pvalue->userPlaneMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uP_ModeVersions */

   stat = asn1PD_UP_ModeVersions (pctxt, &pvalue->uP_ModeVersions);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_UserPlaneInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_ExtIEs_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReq_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_ExtIEs_Extension *pvalue = (_RAB_SetupItem_RelocReq_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_Alt_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_ExtIEs_Extension_1                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReq_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_ExtIEs_Extension_1 *pvalue = (_RAB_SetupItem_RelocReq_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_GERAN_BSC_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReq_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupItem_RelocReq_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupItem_RelocReq_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupItem_RelocReq_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReq_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReq_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReq_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupItem_RelocReq_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupItem_RelocReq_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReq_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupItem_RelocReq_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupItem_RelocReq_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupItem_RelocReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReq (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nAS_SynchronisationIndicatorPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataVolumeReportingIndicationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pDP_TypeInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.service_HandoverPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode nAS_SynchronisationIndicator */

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      stat = asn1PD_NAS_SynchronisationIndicator (pctxt, &pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAB_Parameters */

   stat = asn1PD_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      stat = asn1PD_DataVolumeReportingIndication (pctxt, &pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      stat = asn1PD_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode userPlaneInformation */

   stat = asn1PD_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transportLayerAddress */

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iuTransportAssociation */

   stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      stat = asn1PD_Service_Handover (pctxt, &pvalue->service_Handover);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupItem_RelocReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_IEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReq_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_IEs_Value *pvalue = (_RAB_SetupItem_RelocReq_IEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupItem_RelocReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReq_element_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReq_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupList_RelocReq_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupList_RelocReq_element_element (ASN1CTXT* pctxt,
   RAB_SetupList_RelocReq_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReq_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReq_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReq_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_SetupItem_RelocReq_IEs[index].ValueSize);
   stat = RAB_SetupItem_RelocReq_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReq_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReq_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupList_RelocReq_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupList_RelocReq_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupList_RelocReq_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReq (ASN1CTXT* pctxt, RAB_SetupList_RelocReq* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_SetupList_RelocReq_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupList_RelocReq_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupList_RelocReq_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_4 *pvalue = (_RelocationRequestIEs_Value_4*) pvalue_;

   stat = asn1PD_RAB_SetupList_RelocReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_5                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_5 *pvalue = (_RelocationRequestIEs_Value_5*) pvalue_;

   stat = asn1PD_IntegrityProtectionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_6                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_6 *pvalue = (_RelocationRequestIEs_Value_6*) pvalue_;

   stat = asn1PD_EncryptionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_7                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_7 *pvalue = (_RelocationRequestIEs_Value_7*) pvalue_;

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationRequestIEs[index].ValueSize);
   stat = RelocationRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest_protocolIEs (ASN1CTXT* pctxt, RelocationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension *pvalue = (_RelocationRequestExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_1 *pvalue = (_RelocationRequestExtensions_Extension_1*) pvalue_;

   stat = asn1PD_SNA_Access_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_2 *pvalue = (_RelocationRequestExtensions_Extension_2*) pvalue_;

   stat = asn1PD_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_3 *pvalue = (_RelocationRequestExtensions_Extension_3*) pvalue_;

   stat = asn1PD_PLMNidentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   JoinedMBMSBearerService_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < JoinedMBMSBearerService_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &JoinedMBMSBearerService_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == JoinedMBMSBearerService_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, JoinedMBMSBearerService_ExtIEs[index].ExtensionSize);
   stat = JoinedMBMSBearerService_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_JoinedMBMSBearerService_IEs_element_iE_Extensions (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   JoinedMBMSBearerService_IEs_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, JoinedMBMSBearerService_IEs_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_JoinedMBMSBearerService_IEs_element (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode tMGI */

   stat = asn1PD_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode mBMS_PTP_RAB_ID */

   stat = asn1PD_MBMS_PTP_RAB_ID (pctxt, &pvalue->mBMS_PTP_RAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_JoinedMBMSBearerService_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_JoinedMBMSBearerService_IEs (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   JoinedMBMSBearerService_IEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, JoinedMBMSBearerService_IEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_JoinedMBMSBearerService_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CNMBMSLinkingInformation_iE_Extensions_element (ASN1CTXT* pctxt, CNMBMSLinkingInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CNMBMSLinkingInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CNMBMSLinkingInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   CNMBMSLinkingInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CNMBMSLinkingInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CNMBMSLinkingInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CNMBMSLinkingInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CNMBMSLinkingInformation_ExtIEs[index].ExtensionSize);
   stat = CNMBMSLinkingInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CNMBMSLinkingInformation_iE_Extensions (ASN1CTXT* pctxt, CNMBMSLinkingInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CNMBMSLinkingInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CNMBMSLinkingInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CNMBMSLinkingInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CNMBMSLinkingInformation (ASN1CTXT* pctxt, CNMBMSLinkingInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode joinedMBMSBearerService_IEs */

   stat = asn1PD_JoinedMBMSBearerService_IEs (pctxt, &pvalue->joinedMBMSBearerService_IEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CNMBMSLinkingInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_4                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestExtensions_Extension_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_4 *pvalue = (_RelocationRequestExtensions_Extension_4*) pvalue_;

   stat = asn1PD_CNMBMSLinkingInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationRequestExtensions[index].ExtensionSize);
   stat = RelocationRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest_protocolExtensions (ASN1CTXT* pctxt, RelocationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequest (ASN1CTXT* pctxt, RelocationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value *pvalue = (_RelocationRequestAcknowledgeIEs_Value*) pvalue_;

   stat = asn1PD_TargetRNC_ToSourceRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_Ass_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1 *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_TransportLayerAddress (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2 *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2*) pvalue_;

   stat = asn1PD_IuTransportAssociation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReqAck_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupItem_RelocReqAck_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupItem_RelocReqAck_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupItem_RelocReqAck_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReqAck_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReqAck_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReqAck_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupItem_RelocReqAck_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupItem_RelocReqAck_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReqAck_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupItem_RelocReqAck_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupItem_RelocReqAck_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupItem_RelocReqAck_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupItem_RelocReqAck (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iuTransportAssociationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iuTransportAssociation */

   if (pvalue->m.iuTransportAssociationPresent) {
      stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupItem_RelocReqAck_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_IEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupItem_RelocReqAck_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_IEs_Value *pvalue = (_RAB_SetupItem_RelocReqAck_IEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupItem_RelocReqAck (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReqAck_element_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupList_RelocReqAck_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupList_RelocReqAck_element_element (ASN1CTXT* pctxt,
   RAB_SetupList_RelocReqAck_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReqAck_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReqAck_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReqAck_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_SetupItem_RelocReqAck_IEs[index].ValueSize);
   stat = RAB_SetupItem_RelocReqAck_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReqAck_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupList_RelocReqAck_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupList_RelocReqAck_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupList_RelocReqAck_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupList_RelocReqAck (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_SetupList_RelocReqAck_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupList_RelocReqAck_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupList_RelocReqAck_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_1 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_SetupList_RelocReqAck (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_FailedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_FailedItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_FailedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_FailedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_FailedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_FailedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_FailedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_FailedItem_ExtIEs[index].ExtensionSize);
   stat = RAB_FailedItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_FailedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_FailedItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedItem (ASN1CTXT* pctxt, RAB_FailedItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_FailedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_FailedItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_FailedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_FailedItemIEs_Value *pvalue = (_RAB_FailedItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_FailedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedList_element_element (ASN1CTXT* pctxt, RAB_FailedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_FailedList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_FailedList_element_element (ASN1CTXT* pctxt,
   RAB_FailedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_FailedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_FailedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_FailedItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_FailedItemIEs[index].ValueSize);
   stat = RAB_FailedItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedList_element (ASN1CTXT* pctxt, RAB_FailedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_FailedList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedList (ASN1CTXT* pctxt, RAB_FailedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_FailedList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_2 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_2*) pvalue_;

   stat = asn1PD_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_3 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_3*) pvalue_;

   stat = asn1PD_ChosenIntegrityProtectionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_4                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_4 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_4*) pvalue_;

   stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_5                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_5 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_5*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequestAcknowledge_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequestAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequestAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationRequestAcknowledgeIEs[index].ValueSize);
   stat = RelocationRequestAcknowledgeIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge_protocolIEs (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequestAcknowledge_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequestAcknowledge_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequestAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeExtensions_Extension         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationRequestAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeExtensions_Extension *pvalue = (_RelocationRequestAcknowledgeExtensions_Extension*) pvalue_;

   stat = asn1PD_NewBSS_To_OldBSS_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationRequestAcknowledge_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationRequestAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequestAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationRequestAcknowledgeExtensions[index].ExtensionSize);
   stat = RelocationRequestAcknowledgeExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge_protocolExtensions (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationRequestAcknowledge_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationRequestAcknowledge_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationRequestAcknowledge_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequestAcknowledge (ASN1CTXT* pctxt, RelocationRequestAcknowledge* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationRequestAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureIEs_Value *pvalue = (_RelocationFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureIEs_Value_1 *pvalue = (_RelocationFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure_protocolIEs_element (ASN1CTXT* pctxt, RelocationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationFailureIEs[index].ValueSize);
   stat = RelocationFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure_protocolIEs (ASN1CTXT* pctxt, RelocationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureExtensions_Extension *pvalue = (_RelocationFailureExtensions_Extension*) pvalue_;

   stat = asn1PD_NewBSS_To_OldBSS_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationFailureExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureExtensions_Extension_1 *pvalue = (_RelocationFailureExtensions_Extension_1*) pvalue_;

   stat = asn1PD_GERAN_Classmark (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure_protocolExtensions_element (ASN1CTXT* pctxt, RelocationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationFailureExtensions[index].ExtensionSize);
   stat = RelocationFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure_protocolExtensions (ASN1CTXT* pctxt, RelocationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationFailure (ASN1CTXT* pctxt, RelocationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCancelIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCancelIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCancelIEs_Value *pvalue = (_RelocationCancelIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel_protocolIEs_element (ASN1CTXT* pctxt, RelocationCancel_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCancel_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCancel_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCancel_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationCancelIEs[index].ValueSize);
   stat = RelocationCancelIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel_protocolIEs (ASN1CTXT* pctxt, RelocationCancel_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCancel_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCancel_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCancel_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCancel_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCancel_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCancel_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCancel_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationCancelExtensions[index].ExtensionSize);
   stat = RelocationCancelExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel_protocolExtensions (ASN1CTXT* pctxt, RelocationCancel_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCancel_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCancel_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCancel_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancel (ASN1CTXT* pctxt, RelocationCancel* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationCancel_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationCancel_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCancelAcknowledgeIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RelocationCancelAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCancelAcknowledgeIEs_Value *pvalue = (_RelocationCancelAcknowledgeIEs_Value*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCancelAcknowledge_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCancelAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCancelAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationCancelAcknowledgeIEs[index].ValueSize);
   stat = RelocationCancelAcknowledgeIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge_protocolIEs (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCancelAcknowledge_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCancelAcknowledge_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCancelAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationCancelAcknowledge_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationCancelAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCancelAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationCancelAcknowledgeExtensions[index].ExtensionSize);
   stat = RelocationCancelAcknowledgeExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge_protocolExtensions (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationCancelAcknowledge_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationCancelAcknowledge_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationCancelAcknowledge_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationCancelAcknowledge (ASN1CTXT* pctxt, RelocationCancelAcknowledge* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationCancelAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationCancelAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].ExtensionSize);
   stat = RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingItem_SRNS_CtxReq (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value *pvalue = (_RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataForwardingItem_SRNS_CtxReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_SRNS_CtxReq_element_element (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataForwardingList_SRNS_CtxReq_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataForwardingList_SRNS_CtxReq_element_element (ASN1CTXT* pctxt,
   RAB_DataForwardingList_SRNS_CtxReq_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].ValueSize);
   stat = RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_SRNS_CtxReq_element (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataForwardingList_SRNS_CtxReq_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingList_SRNS_CtxReq_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingList_SRNS_CtxReq_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataForwardingList_SRNS_CtxReq (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_DataForwardingList_SRNS_CtxReq_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataForwardingList_SRNS_CtxReq_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataForwardingList_SRNS_CtxReq_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextRequestIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_ContextRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextRequestIEs_Value *pvalue = (_SRNS_ContextRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataForwardingList_SRNS_CtxReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest_protocolIEs_element (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_ContextRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_ContextRequest_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_ContextRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SRNS_ContextRequestIEs[index].ValueSize);
   stat = SRNS_ContextRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest_protocolIEs (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_ContextRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_ContextRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_ContextRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_ContextRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_ContextRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_ContextRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SRNS_ContextRequestExtensions[index].ExtensionSize);
   stat = SRNS_ContextRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest_protocolExtensions (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_ContextRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_ContextRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_ContextRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextRequest (ASN1CTXT* pctxt, SRNS_ContextRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SRNS_ContextRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SRNS_ContextRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ContextItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ContextItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ContextItem_ExtIEs[index].ExtensionSize);
   stat = RAB_ContextItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ContextItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem (ASN1CTXT* pctxt, RAB_ContextItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ContextItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ContextItemIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ContextItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ContextItemIEs_Value *pvalue = (_RAB_ContextItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ContextItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_element_element (ASN1CTXT* pctxt, RAB_ContextList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextList_element_element (ASN1CTXT* pctxt,
   RAB_ContextList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ContextItemIEs[index].ValueSize);
   stat = RAB_ContextItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_element (ASN1CTXT* pctxt, RAB_ContextList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList (ASN1CTXT* pctxt, RAB_ContextList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ContextList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_ContextResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value *pvalue = (_SRNS_ContextResponseIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ContextList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_ContextFailedtoTransferItem_iE_Extensions_element (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RABs_ContextFailedtoTransferItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RABs_ContextFailedtoTransferItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RABs_ContextFailedtoTransferItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_ContextFailedtoTransferItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_ContextFailedtoTransferItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_ContextFailedtoTransferItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RABs_ContextFailedtoTransferItem_ExtIEs[index].ExtensionSize);
   stat = RABs_ContextFailedtoTransferItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_ContextFailedtoTransferItem_iE_Extensions (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RABs_ContextFailedtoTransferItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RABs_ContextFailedtoTransferItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RABs_ContextFailedtoTransferItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_ContextFailedtoTransferItem (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RABs_ContextFailedtoTransferItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RABs_ContextFailedtoTransferItemIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RABs_ContextFailedtoTransferItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RABs_ContextFailedtoTransferItemIEs_Value *pvalue = (_RABs_ContextFailedtoTransferItemIEs_Value*) pvalue_;

   stat = asn1PD_RABs_ContextFailedtoTransferItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextFailedtoTransferList_element_element (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextFailedtoTransferList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextFailedtoTransferList_element_element (ASN1CTXT* pctxt,
   RAB_ContextFailedtoTransferList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_ContextFailedtoTransferItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_ContextFailedtoTransferItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_ContextFailedtoTransferItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RABs_ContextFailedtoTransferItemIEs[index].ValueSize);
   stat = RABs_ContextFailedtoTransferItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextFailedtoTransferList_element (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextFailedtoTransferList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextFailedtoTransferList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextFailedtoTransferList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextFailedtoTransferList (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ContextFailedtoTransferList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextFailedtoTransferList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextFailedtoTransferList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_ContextResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value_1 *pvalue = (_SRNS_ContextResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ContextFailedtoTransferList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value_2                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_ContextResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value_2 *pvalue = (_SRNS_ContextResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse_protocolIEs_element (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_ContextResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_ContextResponse_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_ContextResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SRNS_ContextResponseIEs[index].ValueSize);
   stat = SRNS_ContextResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse_protocolIEs (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_ContextResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_ContextResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_ContextResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_ContextResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_ContextResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_ContextResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SRNS_ContextResponseExtensions[index].ExtensionSize);
   stat = SRNS_ContextResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse_protocolExtensions (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_ContextResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_ContextResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_ContextResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_ContextResponse (ASN1CTXT* pctxt, SRNS_ContextResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SRNS_ContextResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SRNS_ContextResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value *pvalue = (_SecurityModeCommandIEs_Value*) pvalue_;

   stat = asn1PD_IntegrityProtectionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCommandIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value_1 *pvalue = (_SecurityModeCommandIEs_Value_1*) pvalue_;

   stat = asn1PD_EncryptionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value_2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCommandIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value_2 *pvalue = (_SecurityModeCommandIEs_Value_2*) pvalue_;

   stat = asn1PD_KeyStatus (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeCommand_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeCommand_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCommandIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SecurityModeCommandIEs[index].ValueSize);
   stat = SecurityModeCommandIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand_protocolIEs (ASN1CTXT* pctxt, SecurityModeCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeCommand_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeCommand_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeCommand_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SecurityModeCommandExtensions[index].ExtensionSize);
   stat = SecurityModeCommandExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand_protocolExtensions (ASN1CTXT* pctxt, SecurityModeCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeCommand_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeCommand_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeCommand_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeCommand (ASN1CTXT* pctxt, SecurityModeCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SecurityModeCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SecurityModeCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCompleteIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value *pvalue = (_SecurityModeCompleteIEs_Value*) pvalue_;

   stat = asn1PD_ChosenIntegrityProtectionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCompleteIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value_1 *pvalue = (_SecurityModeCompleteIEs_Value_1*) pvalue_;

   stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value_2                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeCompleteIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value_2 *pvalue = (_SecurityModeCompleteIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeComplete_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeComplete_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCompleteIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SecurityModeCompleteIEs[index].ValueSize);
   stat = SecurityModeCompleteIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete_protocolIEs (ASN1CTXT* pctxt, SecurityModeComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeComplete_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeComplete_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeComplete_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeComplete_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SecurityModeCompleteExtensions[index].ExtensionSize);
   stat = SecurityModeCompleteExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete_protocolExtensions (ASN1CTXT* pctxt, SecurityModeComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeComplete_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeComplete_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeComplete_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeComplete (ASN1CTXT* pctxt, SecurityModeComplete* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SecurityModeComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SecurityModeComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeRejectIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeRejectIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeRejectIEs_Value *pvalue = (_SecurityModeRejectIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeRejectIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SecurityModeRejectIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeRejectIEs_Value_1 *pvalue = (_SecurityModeRejectIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeReject_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeReject_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeReject_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeReject_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeRejectIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeRejectIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeRejectIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SecurityModeRejectIEs[index].ValueSize);
   stat = SecurityModeRejectIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject_protocolIEs (ASN1CTXT* pctxt, SecurityModeReject_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeReject_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeReject_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeReject_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeReject_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SecurityModeReject_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SecurityModeReject_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeReject_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeRejectExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeRejectExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeRejectExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SecurityModeRejectExtensions[index].ExtensionSize);
   stat = SecurityModeRejectExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject_protocolExtensions (ASN1CTXT* pctxt, SecurityModeReject_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SecurityModeReject_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecurityModeReject_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SecurityModeReject_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecurityModeReject (ASN1CTXT* pctxt, SecurityModeReject* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SecurityModeReject_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SecurityModeReject_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataVolumeReportRequestItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataVolumeReportRequestItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportRequestItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportRequestItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportRequestItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportRequestItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_DataVolumeReportRequestItem_ExtIEs[index].ExtensionSize);
   stat = RAB_DataVolumeReportRequestItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataVolumeReportRequestItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportRequestItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportRequestItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestItem (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_DataVolumeReportRequestItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataVolumeReportRequestItemIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_DataVolumeReportRequestItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataVolumeReportRequestItemIEs_Value *pvalue = (_RAB_DataVolumeReportRequestItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportRequestItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestList_element_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_DataVolumeReportRequestList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_DataVolumeReportRequestList_element_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportRequestList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportRequestItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportRequestItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportRequestItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_DataVolumeReportRequestItemIEs[index].ValueSize);
   stat = RAB_DataVolumeReportRequestItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestList_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_DataVolumeReportRequestList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportRequestList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportRequestList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_DataVolumeReportRequestList (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_DataVolumeReportRequestList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_DataVolumeReportRequestList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_DataVolumeReportRequestList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportRequestIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DataVolumeReportRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportRequestIEs_Value *pvalue = (_DataVolumeReportRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportRequestList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest_protocolIEs_element (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeReportRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeReportRequest_protocolIEs_element (ASN1CTXT* pctxt,
   DataVolumeReportRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DataVolumeReportRequestIEs[index].ValueSize);
   stat = DataVolumeReportRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest_protocolIEs (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeReportRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeReportRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeReportRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest_protocolExtensions_element (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeReportRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeReportRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   DataVolumeReportRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DataVolumeReportRequestExtensions[index].ExtensionSize);
   stat = DataVolumeReportRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest_protocolExtensions (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeReportRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeReportRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeReportRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportRequest (ASN1CTXT* pctxt, DataVolumeReportRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_DataVolumeReportRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_DataVolumeReportRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DataVolumeReportIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value *pvalue = (_DataVolumeReportIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataVolumeReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_failed_to_reportItem_iE_Extensions_element (ASN1CTXT* pctxt, RABs_failed_to_reportItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RABs_failed_to_reportItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RABs_failed_to_reportItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RABs_failed_to_reportItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_failed_to_reportItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_failed_to_reportItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_failed_to_reportItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RABs_failed_to_reportItem_ExtIEs[index].ExtensionSize);
   stat = RABs_failed_to_reportItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_failed_to_reportItem_iE_Extensions (ASN1CTXT* pctxt, RABs_failed_to_reportItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RABs_failed_to_reportItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RABs_failed_to_reportItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RABs_failed_to_reportItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RABs_failed_to_reportItem (ASN1CTXT* pctxt, RABs_failed_to_reportItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RABs_failed_to_reportItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RABs_failed_to_reportItemIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RABs_failed_to_reportItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RABs_failed_to_reportItemIEs_Value *pvalue = (_RABs_failed_to_reportItemIEs_Value*) pvalue_;

   stat = asn1PD_RABs_failed_to_reportItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedtoReportList_element_element (ASN1CTXT* pctxt, RAB_FailedtoReportList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_FailedtoReportList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_FailedtoReportList_element_element (ASN1CTXT* pctxt,
   RAB_FailedtoReportList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_failed_to_reportItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_failed_to_reportItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_failed_to_reportItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RABs_failed_to_reportItemIEs[index].ValueSize);
   stat = RABs_failed_to_reportItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedtoReportList_element (ASN1CTXT* pctxt, RAB_FailedtoReportList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_FailedtoReportList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedtoReportList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedtoReportList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_FailedtoReportList (ASN1CTXT* pctxt, RAB_FailedtoReportList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_FailedtoReportList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_FailedtoReportList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_FailedtoReportList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DataVolumeReportIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value_1 *pvalue = (_DataVolumeReportIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_FailedtoReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DataVolumeReportIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value_2 *pvalue = (_DataVolumeReportIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport_protocolIEs_element (ASN1CTXT* pctxt, DataVolumeReport_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeReport_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeReport_protocolIEs_element (ASN1CTXT* pctxt,
   DataVolumeReport_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DataVolumeReportIEs[index].ValueSize);
   stat = DataVolumeReportIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport_protocolIEs (ASN1CTXT* pctxt, DataVolumeReport_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeReport_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeReport_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport_protocolExtensions_element (ASN1CTXT* pctxt, DataVolumeReport_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DataVolumeReport_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DataVolumeReport_protocolExtensions_element (ASN1CTXT* pctxt,
   DataVolumeReport_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DataVolumeReportExtensions[index].ExtensionSize);
   stat = DataVolumeReportExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport_protocolExtensions (ASN1CTXT* pctxt, DataVolumeReport_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DataVolumeReport_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DataVolumeReport_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DataVolumeReport_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReport (ASN1CTXT* pctxt, DataVolumeReport* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_DataVolumeReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_DataVolumeReport_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value *pvalue = (_ResetIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value_1 *pvalue = (_ResetIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value_2                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value_2 *pvalue = (_ResetIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset_protocolIEs_element (ASN1CTXT* pctxt, Reset_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Reset_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Reset_protocolIEs_element (ASN1CTXT* pctxt,
   Reset_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetIEs[index].ValueSize);
   stat = ResetIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset_protocolIEs (ASN1CTXT* pctxt, Reset_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Reset_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Reset_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Reset_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetExtensions_Extension                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetExtensions_Extension *pvalue = (_ResetExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset_protocolExtensions_element (ASN1CTXT* pctxt, Reset_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Reset_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Reset_protocolExtensions_element (ASN1CTXT* pctxt,
   Reset_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetExtensions[index].ExtensionSize);
   stat = ResetExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset_protocolExtensions (ASN1CTXT* pctxt, Reset_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Reset_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Reset_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Reset_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reset (ASN1CTXT* pctxt, Reset* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Reset_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Reset_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value *pvalue = (_ResetAcknowledgeIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value_1 *pvalue = (_ResetAcknowledgeIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value_2 *pvalue = (_ResetAcknowledgeIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, ResetAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetAcknowledge_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   ResetAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetAcknowledgeIEs[index].ValueSize);
   stat = ResetAcknowledgeIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge_protocolIEs (ASN1CTXT* pctxt, ResetAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetAcknowledge_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetAcknowledge_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeExtensions_Extension                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeExtensions_Extension *pvalue = (_ResetAcknowledgeExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, ResetAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetAcknowledge_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetAcknowledgeExtensions[index].ExtensionSize);
   stat = ResetAcknowledgeExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge_protocolExtensions (ASN1CTXT* pctxt, ResetAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetAcknowledge_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetAcknowledge_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetAcknowledge_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetAcknowledge (ASN1CTXT* pctxt, ResetAcknowledge* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ResetAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ResetAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleaseItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleaseItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleaseItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ReleaseItem_ExtIEs[index].ExtensionSize);
   stat = RAB_ReleaseItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleaseItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleaseItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseItem (ASN1CTXT* pctxt, RAB_ReleaseItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ReleaseItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleaseItemIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ReleaseItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleaseItemIEs_Value *pvalue = (_RAB_ReleaseItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ReleaseItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseList_element_element (ASN1CTXT* pctxt, RAB_ReleaseList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleaseList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleaseList_element_element (ASN1CTXT* pctxt,
   RAB_ReleaseList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ReleaseItemIEs[index].ValueSize);
   stat = RAB_ReleaseItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseList_element (ASN1CTXT* pctxt, RAB_ReleaseList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleaseList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseList (ASN1CTXT* pctxt, RAB_ReleaseList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ReleaseList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleaseRequestIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleaseRequestIEs_Value *pvalue = (_RAB_ReleaseRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleaseRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_ReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ReleaseRequestIEs[index].ValueSize);
   stat = RAB_ReleaseRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest_protocolIEs (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleaseRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleaseRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_ReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ReleaseRequestExtensions[index].ExtensionSize);
   stat = RAB_ReleaseRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleaseRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleaseRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleaseRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseRequest (ASN1CTXT* pctxt, RAB_ReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RAB_ReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RAB_ReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Iu_ReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseRequestIEs_Value *pvalue = (_Iu_ReleaseRequestIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, Iu_ReleaseRequestIEs[index].ValueSize);
   stat = Iu_ReleaseRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Iu_ReleaseRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Iu_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Iu_ReleaseRequestExtensions[index].ExtensionSize);
   stat = Iu_ReleaseRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Iu_ReleaseRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Iu_ReleaseRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Iu_ReleaseRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Iu_ReleaseRequest (ASN1CTXT* pctxt, Iu_ReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Iu_ReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Iu_ReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect_protocolIEs_element (ASN1CTXT* pctxt, RelocationDetect_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationDetect_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationDetect_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationDetect_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationDetectIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationDetectIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationDetectIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationDetectIEs[index].ValueSize);
   stat = RelocationDetectIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect_protocolIEs (ASN1CTXT* pctxt, RelocationDetect_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationDetect_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationDetect_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationDetect_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect_protocolExtensions_element (ASN1CTXT* pctxt, RelocationDetect_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationDetect_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationDetect_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationDetect_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationDetectExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationDetectExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationDetectExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationDetectExtensions[index].ExtensionSize);
   stat = RelocationDetectExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect_protocolExtensions (ASN1CTXT* pctxt, RelocationDetect_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationDetect_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationDetect_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationDetect_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationDetect (ASN1CTXT* pctxt, RelocationDetect* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationDetect_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationDetect_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete_protocolIEs_element (ASN1CTXT* pctxt, RelocationComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationComplete_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationComplete_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCompleteIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RelocationCompleteIEs[index].ValueSize);
   stat = RelocationCompleteIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete_protocolIEs (ASN1CTXT* pctxt, RelocationComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationComplete_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationComplete_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationComplete_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete_protocolExtensions_element (ASN1CTXT* pctxt, RelocationComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RelocationComplete_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RelocationComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RelocationCompleteExtensions[index].ExtensionSize);
   stat = RelocationCompleteExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete_protocolExtensions (ASN1CTXT* pctxt, RelocationComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RelocationComplete_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RelocationComplete_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RelocationComplete_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationComplete (ASN1CTXT* pctxt, RelocationComplete* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RelocationComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RelocationComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value *pvalue = (_PagingIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_1                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_1 *pvalue = (_PagingIEs_Value_1*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_2                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_2 *pvalue = (_PagingIEs_Value_2*) pvalue_;

   stat = asn1PD_TemporaryUE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_3                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_3 *pvalue = (_PagingIEs_Value_3*) pvalue_;

   stat = asn1PD_PagingAreaID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_4                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_4 *pvalue = (_PagingIEs_Value_4*) pvalue_;

   stat = asn1PD_PagingCause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_5                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_5 *pvalue = (_PagingIEs_Value_5*) pvalue_;

   stat = asn1PD_NonSearchingIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_6                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_6 *pvalue = (_PagingIEs_Value_6*) pvalue_;

   stat = asn1PD_DRX_CycleLengthCoefficient (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging_protocolIEs_element (ASN1CTXT* pctxt, Paging_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Paging_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Paging_protocolIEs_element (ASN1CTXT* pctxt,
   Paging_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PagingIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PagingIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PagingIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, PagingIEs[index].ValueSize);
   stat = PagingIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging_protocolIEs (ASN1CTXT* pctxt, Paging_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Paging_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Paging_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Paging_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingExtensions_Extension                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__PagingExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingExtensions_Extension *pvalue = (_PagingExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging_protocolExtensions_element (ASN1CTXT* pctxt, Paging_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Paging_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Paging_protocolExtensions_element (ASN1CTXT* pctxt,
   Paging_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PagingExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PagingExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == PagingExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, PagingExtensions[index].ExtensionSize);
   stat = PagingExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging_protocolExtensions (ASN1CTXT* pctxt, Paging_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Paging_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Paging_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Paging_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Paging (ASN1CTXT* pctxt, Paging* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Paging_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Paging_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonID_IEs_Value                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CommonID_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonID_IEs_Value *pvalue = (_CommonID_IEs_Value*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID_protocolIEs_element (ASN1CTXT* pctxt, CommonID_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CommonID_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CommonID_protocolIEs_element (ASN1CTXT* pctxt,
   CommonID_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CommonID_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CommonID_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == CommonID_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, CommonID_IEs[index].ValueSize);
   stat = CommonID_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID_protocolIEs (ASN1CTXT* pctxt, CommonID_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   CommonID_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CommonID_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CommonID_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CommonIDExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension *pvalue = (_CommonIDExtensions_Extension*) pvalue_;

   stat = asn1PD_SNA_Access_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CommonIDExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension_1 *pvalue = (_CommonIDExtensions_Extension_1*) pvalue_;

   stat = asn1PD_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension_2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CommonIDExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension_2 *pvalue = (_CommonIDExtensions_Extension_2*) pvalue_;

   stat = asn1PD_PLMNidentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID_protocolExtensions_element (ASN1CTXT* pctxt, CommonID_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CommonID_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CommonID_protocolExtensions_element (ASN1CTXT* pctxt,
   CommonID_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CommonIDExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CommonIDExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CommonIDExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CommonIDExtensions[index].ExtensionSize);
   stat = CommonIDExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID_protocolExtensions (ASN1CTXT* pctxt, CommonID_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CommonID_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CommonID_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CommonID_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonID (ASN1CTXT* pctxt, CommonID* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_CommonID_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_CommonID_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value *pvalue = (_CN_InvokeTraceIEs_Value*) pvalue_;

   stat = asn1PD_TraceType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_1 *pvalue = (_CN_InvokeTraceIEs_Value_1*) pvalue_;

   stat = asn1PD_TraceReference (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_2 *pvalue = (_CN_InvokeTraceIEs_Value_2*) pvalue_;

   stat = asn1PD_TriggerID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_3                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_3 *pvalue = (_CN_InvokeTraceIEs_Value_3*) pvalue_;

   stat = asn1PD_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_4                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_4 *pvalue = (_CN_InvokeTraceIEs_Value_4*) pvalue_;

   stat = asn1PD_OMC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace_protocolIEs_element (ASN1CTXT* pctxt, CN_InvokeTrace_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CN_InvokeTrace_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CN_InvokeTrace_protocolIEs_element (ASN1CTXT* pctxt,
   CN_InvokeTrace_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_InvokeTraceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_InvokeTraceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CN_InvokeTraceIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, CN_InvokeTraceIEs[index].ValueSize);
   stat = CN_InvokeTraceIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace_protocolIEs (ASN1CTXT* pctxt, CN_InvokeTrace_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   CN_InvokeTrace_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CN_InvokeTrace_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CN_InvokeTrace_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_InvokeTraceExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceExtensions_Extension *pvalue = (_CN_InvokeTraceExtensions_Extension*) pvalue_;

   stat = asn1PD_TracePropagationParameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace_protocolExtensions_element (ASN1CTXT* pctxt, CN_InvokeTrace_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CN_InvokeTrace_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CN_InvokeTrace_protocolExtensions_element (ASN1CTXT* pctxt,
   CN_InvokeTrace_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_InvokeTraceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_InvokeTraceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CN_InvokeTraceExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CN_InvokeTraceExtensions[index].ExtensionSize);
   stat = CN_InvokeTraceExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace_protocolExtensions (ASN1CTXT* pctxt, CN_InvokeTrace_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CN_InvokeTrace_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CN_InvokeTrace_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CN_InvokeTrace_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_InvokeTrace (ASN1CTXT* pctxt, CN_InvokeTrace* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_CN_InvokeTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_CN_InvokeTrace_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_DeactivateTraceIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_DeactivateTraceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_DeactivateTraceIEs_Value *pvalue = (_CN_DeactivateTraceIEs_Value*) pvalue_;

   stat = asn1PD_TraceReference (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_DeactivateTraceIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CN_DeactivateTraceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_DeactivateTraceIEs_Value_1 *pvalue = (_CN_DeactivateTraceIEs_Value_1*) pvalue_;

   stat = asn1PD_TriggerID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace_protocolIEs_element (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CN_DeactivateTrace_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CN_DeactivateTrace_protocolIEs_element (ASN1CTXT* pctxt,
   CN_DeactivateTrace_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_DeactivateTraceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_DeactivateTraceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CN_DeactivateTraceIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, CN_DeactivateTraceIEs[index].ValueSize);
   stat = CN_DeactivateTraceIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace_protocolIEs (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   CN_DeactivateTrace_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CN_DeactivateTrace_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CN_DeactivateTrace_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace_protocolExtensions_element (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CN_DeactivateTrace_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CN_DeactivateTrace_protocolExtensions_element (ASN1CTXT* pctxt,
   CN_DeactivateTrace_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_DeactivateTraceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_DeactivateTraceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CN_DeactivateTraceExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CN_DeactivateTraceExtensions[index].ExtensionSize);
   stat = CN_DeactivateTraceExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace_protocolExtensions (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CN_DeactivateTrace_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CN_DeactivateTrace_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CN_DeactivateTrace_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DeactivateTrace (ASN1CTXT* pctxt, CN_DeactivateTrace* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_CN_DeactivateTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_CN_DeactivateTrace_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlIEs_Value *pvalue = (_LocationReportingControlIEs_Value*) pvalue_;

   stat = asn1PD_RequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl_protocolIEs_element (ASN1CTXT* pctxt, LocationReportingControl_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationReportingControl_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationReportingControl_protocolIEs_element (ASN1CTXT* pctxt,
   LocationReportingControl_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportingControlIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportingControlIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportingControlIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationReportingControlIEs[index].ValueSize);
   stat = LocationReportingControlIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl_protocolIEs (ASN1CTXT* pctxt, LocationReportingControl_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationReportingControl_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationReportingControl_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationReportingControl_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension *pvalue = (_LocationReportingControlExtensions_Extension*) pvalue_;

   stat = asn1PD_VerticalAccuracyCode (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_1           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_1 *pvalue = (_LocationReportingControlExtensions_Extension_1*) pvalue_;

   stat = asn1PD_ResponseTime (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_2           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_2 *pvalue = (_LocationReportingControlExtensions_Extension_2*) pvalue_;

   stat = asn1PD_PositioningPriority (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_3           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportingControlExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_3 *pvalue = (_LocationReportingControlExtensions_Extension_3*) pvalue_;

   stat = asn1PD_ClientType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl_protocolExtensions_element (ASN1CTXT* pctxt, LocationReportingControl_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationReportingControl_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationReportingControl_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationReportingControl_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportingControlExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportingControlExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportingControlExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationReportingControlExtensions[index].ExtensionSize);
   stat = LocationReportingControlExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl_protocolExtensions (ASN1CTXT* pctxt, LocationReportingControl_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationReportingControl_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationReportingControl_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationReportingControl_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReportingControl (ASN1CTXT* pctxt, LocationReportingControl* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationReportingControl_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationReportingControl_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value *pvalue = (_LocationReportIEs_Value*) pvalue_;

   stat = asn1PD_AreaIdentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value_1 *pvalue = (_LocationReportIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value_2 *pvalue = (_LocationReportIEs_Value_2*) pvalue_;

   stat = asn1PD_RequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport_protocolIEs_element (ASN1CTXT* pctxt, LocationReport_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationReport_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationReport_protocolIEs_element (ASN1CTXT* pctxt,
   LocationReport_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationReportIEs[index].ValueSize);
   stat = LocationReportIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport_protocolIEs (ASN1CTXT* pctxt, LocationReport_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationReport_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationReport_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension *pvalue = (_LocationReportExtensions_Extension*) pvalue_;

   stat = asn1PD_LastKnownServiceArea (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_1 *pvalue = (_LocationReportExtensions_Extension_1*) pvalue_;

   stat = asn1PD_PositionData (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_2 *pvalue = (_LocationReportExtensions_Extension_2*) pvalue_;

   stat = asn1PD_PositionDataSpecificToGERANIuMode (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationReportExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_3 *pvalue = (_LocationReportExtensions_Extension_3*) pvalue_;

   stat = asn1PD_AccuracyFulfilmentIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport_protocolExtensions_element (ASN1CTXT* pctxt, LocationReport_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationReport_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationReport_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationReport_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationReportExtensions[index].ExtensionSize);
   stat = LocationReportExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport_protocolExtensions (ASN1CTXT* pctxt, LocationReport_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationReport_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationReport_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationReport_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationReport (ASN1CTXT* pctxt, LocationReport* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationReport_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value *pvalue = (_InitialUE_MessageIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_1 *pvalue = (_InitialUE_MessageIEs_Value_1*) pvalue_;

   stat = asn1PD_LAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_2 *pvalue = (_InitialUE_MessageIEs_Value_2*) pvalue_;

   stat = asn1PD_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_3 *pvalue = (_InitialUE_MessageIEs_Value_3*) pvalue_;

   stat = asn1PD_SAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_4 *pvalue = (_InitialUE_MessageIEs_Value_4*) pvalue_;

   stat = asn1PD_NAS_PDU (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_5                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_5 *pvalue = (_InitialUE_MessageIEs_Value_5*) pvalue_;

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_6                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_6 *pvalue = (_InitialUE_MessageIEs_Value_6*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message_protocolIEs_element (ASN1CTXT* pctxt, InitialUE_Message_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InitialUE_Message_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InitialUE_Message_protocolIEs_element (ASN1CTXT* pctxt,
   InitialUE_Message_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InitialUE_MessageIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InitialUE_MessageIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InitialUE_MessageIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, InitialUE_MessageIEs[index].ValueSize);
   stat = InitialUE_MessageIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message_protocolIEs (ASN1CTXT* pctxt, InitialUE_Message_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   InitialUE_Message_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InitialUE_Message_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InitialUE_Message_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension *pvalue = (_InitialUE_MessageExtensions_Extension*) pvalue_;

   stat = asn1PD_GERAN_Classmark (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_1 *pvalue = (_InitialUE_MessageExtensions_Extension_1*) pvalue_;

   stat = asn1PD_PLMNidentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_2 *pvalue = (_InitialUE_MessageExtensions_Extension_2*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InitialUE_MessageExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_3 *pvalue = (_InitialUE_MessageExtensions_Extension_3*) pvalue_;

   stat = asn1PD_NAS_SequenceNumber (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message_protocolExtensions_element (ASN1CTXT* pctxt, InitialUE_Message_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InitialUE_Message_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InitialUE_Message_protocolExtensions_element (ASN1CTXT* pctxt,
   InitialUE_Message_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InitialUE_MessageExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InitialUE_MessageExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InitialUE_MessageExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InitialUE_MessageExtensions[index].ExtensionSize);
   stat = InitialUE_MessageExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message_protocolExtensions (ASN1CTXT* pctxt, InitialUE_Message_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InitialUE_Message_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InitialUE_Message_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InitialUE_Message_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InitialUE_Message (ASN1CTXT* pctxt, InitialUE_Message* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_InitialUE_Message_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_InitialUE_Message_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value *pvalue = (_DirectTransferIEs_Value*) pvalue_;

   stat = asn1PD_NAS_PDU (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_1 *pvalue = (_DirectTransferIEs_Value_1*) pvalue_;

   stat = asn1PD_LAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_2 *pvalue = (_DirectTransferIEs_Value_2*) pvalue_;

   stat = asn1PD_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_3                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_3 *pvalue = (_DirectTransferIEs_Value_3*) pvalue_;

   stat = asn1PD_SAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_4                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_4 *pvalue = (_DirectTransferIEs_Value_4*) pvalue_;

   stat = asn1PD_SAPI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer_protocolIEs_element (ASN1CTXT* pctxt, DirectTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectTransfer_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectTransfer_protocolIEs_element (ASN1CTXT* pctxt,
   DirectTransfer_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DirectTransferIEs[index].ValueSize);
   stat = DirectTransferIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer_protocolIEs (ASN1CTXT* pctxt, DirectTransfer_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectTransfer_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransfer_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RedirectionIndication_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value *pvalue = (_RedirectionIndication_IEs_Value*) pvalue_;

   stat = asn1PD_NAS_PDU (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_1                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RedirectionIndication_IEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_1 *pvalue = (_RedirectionIndication_IEs_Value_1*) pvalue_;

   stat = asn1PD_RejectCauseValue (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_2                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RedirectionIndication_IEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_2 *pvalue = (_RedirectionIndication_IEs_Value_2*) pvalue_;

   stat = asn1PD_NAS_SequenceNumber (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_3                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RedirectionIndication_IEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_3 *pvalue = (_RedirectionIndication_IEs_Value_3*) pvalue_;

   stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RedirectionIndication_element (ASN1CTXT* pctxt, RedirectionIndication_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RedirectionIndication_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RedirectionIndication_element (ASN1CTXT* pctxt,
   RedirectionIndication_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RedirectionIndication_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RedirectionIndication_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RedirectionIndication_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RedirectionIndication_IEs[index].ValueSize);
   stat = RedirectionIndication_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RedirectionIndication (ASN1CTXT* pctxt, RedirectionIndication* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RedirectionIndication_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RedirectionIndication_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RedirectionIndication_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferExtensions_Extension *pvalue = (_DirectTransferExtensions_Extension*) pvalue_;

   stat = asn1PD_RedirectionIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferExtensions_Extension_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferExtensions_Extension_1 *pvalue = (_DirectTransferExtensions_Extension_1*) pvalue_;

   stat = asn1PD_RedirectionCompleted (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer_protocolExtensions_element (ASN1CTXT* pctxt, DirectTransfer_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectTransfer_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectTransfer_protocolExtensions_element (ASN1CTXT* pctxt,
   DirectTransfer_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DirectTransferExtensions[index].ExtensionSize);
   stat = DirectTransferExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer_protocolExtensions (ASN1CTXT* pctxt, DirectTransfer_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectTransfer_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransfer_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransfer_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransfer (ASN1CTXT* pctxt, DirectTransfer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_DirectTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_DirectTransfer_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadIEs_Value                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__OverloadIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadIEs_Value *pvalue = (_OverloadIEs_Value*) pvalue_;

   stat = asn1PD_NumberOfSteps (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadIEs_Value_1                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__OverloadIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadIEs_Value_1 *pvalue = (_OverloadIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload_protocolIEs_element (ASN1CTXT* pctxt, Overload_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Overload_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Overload_protocolIEs_element (ASN1CTXT* pctxt,
   Overload_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < OverloadIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &OverloadIEs[index].id) == 0) {
         break;
      }
   }
   if(index == OverloadIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, OverloadIEs[index].ValueSize);
   stat = OverloadIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload_protocolIEs (ASN1CTXT* pctxt, Overload_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Overload_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Overload_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Overload_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadExtensions_Extension                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__OverloadExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadExtensions_Extension *pvalue = (_OverloadExtensions_Extension*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadExtensions_Extension_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__OverloadExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadExtensions_Extension_1 *pvalue = (_OverloadExtensions_Extension_1*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload_protocolExtensions_element (ASN1CTXT* pctxt, Overload_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Overload_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Overload_protocolExtensions_element (ASN1CTXT* pctxt,
   Overload_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < OverloadExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &OverloadExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == OverloadExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, OverloadExtensions[index].ExtensionSize);
   stat = OverloadExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload_protocolExtensions (ASN1CTXT* pctxt, Overload_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Overload_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Overload_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Overload_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Overload (ASN1CTXT* pctxt, Overload* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_Overload_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_Overload_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value *pvalue = (_ErrorIndicationIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_1 *pvalue = (_ErrorIndicationIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_2                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_2 *pvalue = (_ErrorIndicationIEs_Value_2*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_3                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_3 *pvalue = (_ErrorIndicationIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication_protocolIEs_element (ASN1CTXT* pctxt, ErrorIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ErrorIndication_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ErrorIndication_protocolIEs_element (ASN1CTXT* pctxt,
   ErrorIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ErrorIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ErrorIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ErrorIndicationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ErrorIndicationIEs[index].ValueSize);
   stat = ErrorIndicationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication_protocolIEs (ASN1CTXT* pctxt, ErrorIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ErrorIndication_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ErrorIndication_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ErrorIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationExtensions_Extension                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ErrorIndicationExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationExtensions_Extension *pvalue = (_ErrorIndicationExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication_protocolExtensions_element (ASN1CTXT* pctxt, ErrorIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ErrorIndication_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ErrorIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   ErrorIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ErrorIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ErrorIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ErrorIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ErrorIndicationExtensions[index].ExtensionSize);
   stat = ErrorIndicationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication_protocolExtensions (ASN1CTXT* pctxt, ErrorIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ErrorIndication_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ErrorIndication_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ErrorIndication_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication (ASN1CTXT* pctxt, ErrorIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ErrorIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_DataForwardCommandIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SRNS_DataForwardCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_DataForwardCommandIEs_Value *pvalue = (_SRNS_DataForwardCommandIEs_Value*) pvalue_;

   stat = asn1PD_RAB_DataForwardingList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand_protocolIEs_element (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_DataForwardCommand_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_DataForwardCommand_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_DataForwardCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_DataForwardCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_DataForwardCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_DataForwardCommandIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, SRNS_DataForwardCommandIEs[index].ValueSize);
   stat = SRNS_DataForwardCommandIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand_protocolIEs (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_DataForwardCommand_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_DataForwardCommand_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_DataForwardCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRNS_DataForwardCommand_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRNS_DataForwardCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_DataForwardCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_DataForwardCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_DataForwardCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_DataForwardCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SRNS_DataForwardCommandExtensions[index].ExtensionSize);
   stat = SRNS_DataForwardCommandExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand_protocolExtensions (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRNS_DataForwardCommand_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRNS_DataForwardCommand_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRNS_DataForwardCommand_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRNS_DataForwardCommand (ASN1CTXT* pctxt, SRNS_DataForwardCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_SRNS_DataForwardCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_SRNS_DataForwardCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ForwardSRNS_ContextIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ForwardSRNS_ContextIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ForwardSRNS_ContextIEs_Value *pvalue = (_ForwardSRNS_ContextIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ContextList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context_protocolIEs_element (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ForwardSRNS_Context_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ForwardSRNS_Context_protocolIEs_element (ASN1CTXT* pctxt,
   ForwardSRNS_Context_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ForwardSRNS_ContextIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ForwardSRNS_ContextIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ForwardSRNS_ContextIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ForwardSRNS_ContextIEs[index].ValueSize);
   stat = ForwardSRNS_ContextIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context_protocolIEs (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ForwardSRNS_Context_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ForwardSRNS_Context_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ForwardSRNS_Context_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ForwardSRNS_ContextExtensions_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ForwardSRNS_ContextExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ForwardSRNS_ContextExtensions_Extension *pvalue = (_ForwardSRNS_ContextExtensions_Extension*) pvalue_;

   stat = asn1PD_RRC_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context_protocolExtensions_element (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ForwardSRNS_Context_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ForwardSRNS_Context_protocolExtensions_element (ASN1CTXT* pctxt,
   ForwardSRNS_Context_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ForwardSRNS_ContextExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ForwardSRNS_ContextExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ForwardSRNS_ContextExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ForwardSRNS_ContextExtensions[index].ExtensionSize);
   stat = ForwardSRNS_ContextExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context_protocolExtensions (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ForwardSRNS_Context_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ForwardSRNS_Context_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ForwardSRNS_Context_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ForwardSRNS_Context (ASN1CTXT* pctxt, ForwardSRNS_Context* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ForwardSRNS_Context_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ForwardSRNS_Context_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerInformation_iE_Extensions_element (ASN1CTXT* pctxt, TransportLayerInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TransportLayerInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TransportLayerInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   TransportLayerInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TransportLayerInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TransportLayerInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TransportLayerInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TransportLayerInformation_ExtIEs[index].ExtensionSize);
   stat = TransportLayerInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerInformation_iE_Extensions (ASN1CTXT* pctxt, TransportLayerInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TransportLayerInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TransportLayerInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TransportLayerInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerInformation (ASN1CTXT* pctxt, TransportLayerInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode transportLayerAddress */

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iuTransportAssociation */

   stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TransportLayerInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemFirst_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifyItemFirst_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifyItemFirst_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyItemFirst_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItemFirst_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItemFirst_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItemFirst_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifyItemFirst_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupOrModifyItemFirst_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemFirst_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifyItemFirst_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifyItemFirst_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifyItemFirst_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemFirst (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nAS_SynchronisationIndicatorPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rAB_ParametersPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.userPlaneInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.service_HandoverPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode nAS_SynchronisationIndicator */

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      stat = asn1PD_NAS_SynchronisationIndicator (pctxt, &pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAB_Parameters */

   if (pvalue->m.rAB_ParametersPresent) {
      stat = asn1PD_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode userPlaneInformation */

   if (pvalue->m.userPlaneInformationPresent) {
      stat = asn1PD_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode transportLayerInformation */

   if (pvalue->m.transportLayerInformationPresent) {
      stat = asn1PD_TransportLayerInformation (pctxt, &pvalue->transportLayerInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      stat = asn1PD_Service_Handover (pctxt, &pvalue->service_Handover);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupOrModifyItemFirst_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItem_IEs_FirstValue                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifyItem_IEs_FirstValue (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItem_IEs_FirstValue *pvalue = (_RAB_SetupOrModifyItem_IEs_FirstValue*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifyItemFirst (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItemSecond_ExtIEs_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifyItemSecond_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItemSecond_ExtIEs_Extension *pvalue = (_RAB_SetupOrModifyItemSecond_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_Alt_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1 *pvalue = (_RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_GERAN_BSC_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemSecond_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifyItemSecond_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifyItemSecond_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyItemSecond_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItemSecond_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItemSecond_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItemSecond_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifyItemSecond_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupOrModifyItemSecond_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemSecond_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifyItemSecond_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifyItemSecond_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifyItemSecond_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyItemSecond (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pDP_TypeInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataVolumeReportingIndicationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      stat = asn1PD_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      stat = asn1PD_DataVolumeReportingIndication (pctxt, &pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupOrModifyItemSecond_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItem_IEs_SecondValue                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifyItem_IEs_SecondValue (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItem_IEs_SecondValue *pvalue = (_RAB_SetupOrModifyItem_IEs_SecondValue*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifyItemSecond (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyList_element_element (ASN1CTXT* pctxt, RAB_SetupOrModifyList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode firstCriticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->firstCriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode firstValue */

   stat = pd_OpenType (pctxt, &pvalue->firstValue.encoded.data, &pvalue->firstValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode secondCriticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->secondCriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode secondValue */

   stat = pd_OpenType (pctxt, &pvalue->secondValue.encoded.data, &pvalue->secondValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifyList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifyList_element_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItem_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItem_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItem_IEs_Size) return 0;

   /* check secondValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->secondValue.encoded.data,
         pvalue->secondValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->secondValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifyItem_IEs[index].SecondValueSize);
   stat = RAB_SetupOrModifyItem_IEs[index].decodeSecondValue(pctxt, pvalue->secondValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "secondCriticality" element */
   /* check firstValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->firstValue.encoded.data,
         pvalue->firstValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->firstValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifyItem_IEs[index].FirstValueSize);
   stat = RAB_SetupOrModifyItem_IEs[index].decodeFirstValue(pctxt, pvalue->firstValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "firstCriticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyList_element (ASN1CTXT* pctxt, RAB_SetupOrModifyList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifyList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifyList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifyList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifyList (ASN1CTXT* pctxt, RAB_SetupOrModifyList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_SetupOrModifyList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifyList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifyList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentRequestIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentRequestIEs_Value *pvalue = (_RAB_AssignmentRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifyList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentRequestIEs_Value_1                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentRequestIEs_Value_1 *pvalue = (_RAB_AssignmentRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_AssignmentRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_AssignmentRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_AssignmentRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_AssignmentRequestIEs[index].ValueSize);
   stat = RAB_AssignmentRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest_protocolIEs (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_AssignmentRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_AssignmentRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_AssignmentRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_AssignmentRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_AssignmentRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_AssignmentRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_AssignmentRequestExtensions[index].ExtensionSize);
   stat = RAB_AssignmentRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_AssignmentRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_AssignmentRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_AssignmentRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentRequest (ASN1CTXT* pctxt, RAB_AssignmentRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RAB_AssignmentRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RAB_AssignmentRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifiedItem_ExtIEs_Extension                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifiedItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifiedItem_ExtIEs_Extension *pvalue = (_RAB_SetupOrModifiedItem_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_Ass_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifiedItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifiedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifiedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifiedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifiedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifiedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifiedItem_ExtIEs[index].ExtensionSize);
   stat = RAB_SetupOrModifiedItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifiedItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifiedItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifiedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedItem (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iuTransportAssociationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_dataVolumesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iuTransportAssociation */

   if (pvalue->m.iuTransportAssociationPresent) {
      stat = asn1PD_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_dataVolumes */

   if (pvalue->m.dl_dataVolumesPresent) {
      stat = asn1PD_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_SetupOrModifiedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifiedItemIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_SetupOrModifiedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifiedItemIEs_Value *pvalue = (_RAB_SetupOrModifiedItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifiedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedList_element_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_SetupOrModifiedList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_SetupOrModifiedList_element_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifiedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifiedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifiedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifiedItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_SetupOrModifiedItemIEs[index].ValueSize);
   stat = RAB_SetupOrModifiedItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedList_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_SetupOrModifiedList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifiedList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifiedList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SetupOrModifiedList (ASN1CTXT* pctxt, RAB_SetupOrModifiedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_SetupOrModifiedList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_SetupOrModifiedList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_SetupOrModifiedList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value *pvalue = (_RAB_AssignmentResponseIEs_Value*) pvalue_;

   stat = asn1PD_RAB_SetupOrModifiedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleasedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleasedItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleasedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleasedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ReleasedItem_ExtIEs[index].ExtensionSize);
   stat = RAB_ReleasedItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleasedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleasedItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedItem (ASN1CTXT* pctxt, RAB_ReleasedItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_dataVolumesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dl_dataVolumes */

   if (pvalue->m.dl_dataVolumesPresent) {
      stat = asn1PD_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dL_GTP_PDU_SequenceNumber */

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uL_GTP_PDU_SequenceNumber */

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ReleasedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleasedItemIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ReleasedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleasedItemIEs_Value *pvalue = (_RAB_ReleasedItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ReleasedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_element_element (ASN1CTXT* pctxt, RAB_ReleasedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ReleasedList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ReleasedList_element_element (ASN1CTXT* pctxt,
   RAB_ReleasedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ReleasedItemIEs[index].ValueSize);
   stat = RAB_ReleasedItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList_element (ASN1CTXT* pctxt, RAB_ReleasedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ReleasedList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleasedList (ASN1CTXT* pctxt, RAB_ReleasedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ReleasedList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ReleasedList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ReleasedList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_1                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_1 *pvalue = (_RAB_AssignmentResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ReleasedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_QueuedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_QueuedItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_QueuedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_QueuedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_QueuedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_QueuedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_QueuedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_QueuedItem_ExtIEs[index].ExtensionSize);
   stat = RAB_QueuedItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_QueuedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_QueuedItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_QueuedItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_QueuedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedItem (ASN1CTXT* pctxt, RAB_QueuedItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_QueuedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_QueuedItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_QueuedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_QueuedItemIEs_Value *pvalue = (_RAB_QueuedItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_QueuedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedList_element_element (ASN1CTXT* pctxt, RAB_QueuedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_QueuedList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_QueuedList_element_element (ASN1CTXT* pctxt,
   RAB_QueuedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_QueuedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_QueuedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_QueuedItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_QueuedItemIEs[index].ValueSize);
   stat = RAB_QueuedItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedList_element (ASN1CTXT* pctxt, RAB_QueuedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_QueuedList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_QueuedList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_QueuedList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_QueuedList (ASN1CTXT* pctxt, RAB_QueuedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_QueuedList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_QueuedList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_QueuedList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_2                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_2 *pvalue = (_RAB_AssignmentResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_RAB_QueuedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_3                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_3 *pvalue = (_RAB_AssignmentResponseIEs_Value_3*) pvalue_;

   stat = asn1PD_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseFailedList                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ReleaseFailedList (ASN1CTXT* pctxt, RAB_ReleaseFailedList* pvalue)
{
   int stat = 0;

   stat = asn1PD_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_4                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_4 *pvalue = (_RAB_AssignmentResponseIEs_Value_4*) pvalue_;

   stat = asn1PD_RAB_ReleaseFailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_5                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_5 *pvalue = (_RAB_AssignmentResponseIEs_Value_5*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse_protocolIEs_element (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_AssignmentResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_AssignmentResponse_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_AssignmentResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_AssignmentResponseIEs[index].ValueSize);
   stat = RAB_AssignmentResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse_protocolIEs (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_AssignmentResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_AssignmentResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_AssignmentResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (ASN1CTXT* pctxt,
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].ExtensionSize);
   stat = GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gERAN_ClassmarkPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode gERAN_Classmark */

   if (pvalue->m.gERAN_ClassmarkPresent) {
      stat = asn1PD_GERAN_Classmark (pctxt, &pvalue->gERAN_Classmark);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value *pvalue = (_GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value*) pvalue_;

   stat = asn1PD_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (ASN1CTXT* pctxt,
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].ValueSize);
   stat = GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseExtensions_Extension               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_AssignmentResponseExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseExtensions_Extension *pvalue = (_RAB_AssignmentResponseExtensions_Extension*) pvalue_;

   stat = asn1PD_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse_protocolExtensions_element (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_AssignmentResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_AssignmentResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_AssignmentResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_AssignmentResponseExtensions[index].ExtensionSize);
   stat = RAB_AssignmentResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse_protocolExtensions (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_AssignmentResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_AssignmentResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_AssignmentResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AssignmentResponse (ASN1CTXT* pctxt, RAB_AssignmentResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RAB_AssignmentResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RAB_AssignmentResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrivateMessage_privateIEs_element (ASN1CTXT* pctxt, PrivateMessage_privateIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_PrivateMessage_privateIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_PrivateMessage_privateIEs_element (ASN1CTXT* pctxt,
   PrivateMessage_privateIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PrivateMessage_IEs_Size; index++) {
      if(asn1CmpTC_PrivateIE_ID(&pvalue->id, &PrivateMessage_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == PrivateMessage_IEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, PrivateMessage_IEs[index].ValueSize);
   stat = PrivateMessage_IEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrivateMessage_privateIEs (ASN1CTXT* pctxt, PrivateMessage_privateIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   PrivateMessage_privateIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PrivateMessage_privateIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PrivateMessage_privateIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrivateMessage (ASN1CTXT* pctxt, PrivateMessage* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   rtDListInit (&pvalue->extElem1);

   /* decode privateIEs */

   stat = asn1PD_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value *pvalue = (_ResetResourceIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_1                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_1 *pvalue = (_ResetResourceIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceItem_iE_Extensions_element (ASN1CTXT* pctxt, ResetResourceItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceItem_iE_Extensions_element (ASN1CTXT* pctxt,
   ResetResourceItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetResourceItem_ExtIEs[index].ExtensionSize);
   stat = ResetResourceItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceItem_iE_Extensions (ASN1CTXT* pctxt, ResetResourceItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceItem (ASN1CTXT* pctxt, ResetResourceItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iuSigConId */

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, &pvalue->iuSigConId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_ResetResourceItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceItemIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceItemIEs_Value *pvalue = (_ResetResourceItemIEs_Value*) pvalue_;

   stat = asn1PD_ResetResourceItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceList_element_element (ASN1CTXT* pctxt, ResetResourceList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceList_element_element (ASN1CTXT* pctxt,
   ResetResourceList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetResourceItemIEs[index].ValueSize);
   stat = ResetResourceItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceList_element (ASN1CTXT* pctxt, ResetResourceList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceList (ASN1CTXT* pctxt, ResetResourceList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(250), 0 };
   int stat = 0;
   ResetResourceList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_2                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_2 *pvalue = (_ResetResourceIEs_Value_2*) pvalue_;

   stat = asn1PD_ResetResourceList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_3                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_3 *pvalue = (_ResetResourceIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource_protocolIEs_element (ASN1CTXT* pctxt, ResetResource_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResource_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResource_protocolIEs_element (ASN1CTXT* pctxt,
   ResetResource_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetResourceIEs[index].ValueSize);
   stat = ResetResourceIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource_protocolIEs (ASN1CTXT* pctxt, ResetResource_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResource_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResource_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResource_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceExtensions_Extension                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceExtensions_Extension *pvalue = (_ResetResourceExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource_protocolExtensions_element (ASN1CTXT* pctxt, ResetResource_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResource_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResource_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetResource_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetResourceExtensions[index].ExtensionSize);
   stat = ResetResourceExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource_protocolExtensions (ASN1CTXT* pctxt, ResetResource_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResource_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResource_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResource_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResource (ASN1CTXT* pctxt, ResetResource* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ResetResource_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ResetResource_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value *pvalue = (_ResetResourceAcknowledgeIEs_Value*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckItem_iE_Extensions_element (ASN1CTXT* pctxt, ResetResourceAckItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceAckItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceAckItem_iE_Extensions_element (ASN1CTXT* pctxt,
   ResetResourceAckItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAckItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAckItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAckItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetResourceAckItem_ExtIEs[index].ExtensionSize);
   stat = ResetResourceAckItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckItem_iE_Extensions (ASN1CTXT* pctxt, ResetResourceAckItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceAckItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAckItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAckItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckItem (ASN1CTXT* pctxt, ResetResourceAckItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iuSigConId */

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, &pvalue->iuSigConId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_ResetResourceAckItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAckItemIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAckItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAckItemIEs_Value *pvalue = (_ResetResourceAckItemIEs_Value*) pvalue_;

   stat = asn1PD_ResetResourceAckItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckList_element_element (ASN1CTXT* pctxt, ResetResourceAckList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceAckList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceAckList_element_element (ASN1CTXT* pctxt,
   ResetResourceAckList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAckItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAckItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAckItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetResourceAckItemIEs[index].ValueSize);
   stat = ResetResourceAckItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckList_element (ASN1CTXT* pctxt, ResetResourceAckList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceAckList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAckList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAckList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAckList (ASN1CTXT* pctxt, ResetResourceAckList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(250), 0 };
   int stat = 0;
   ResetResourceAckList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAckList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAckList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_1 *pvalue = (_ResetResourceAcknowledgeIEs_Value_1*) pvalue_;

   stat = asn1PD_ResetResourceAckList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_2 *pvalue = (_ResetResourceAcknowledgeIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_3                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_3 *pvalue = (_ResetResourceAcknowledgeIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceAcknowledge_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   ResetResourceAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, ResetResourceAcknowledgeIEs[index].ValueSize);
   stat = ResetResourceAcknowledgeIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge_protocolIEs (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceAcknowledge_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAcknowledge_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeExtensions_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__ResetResourceAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeExtensions_Extension *pvalue = (_ResetResourceAcknowledgeExtensions_Extension*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResetResourceAcknowledge_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResetResourceAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetResourceAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResetResourceAcknowledgeExtensions[index].ExtensionSize);
   stat = ResetResourceAcknowledgeExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge_protocolExtensions (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResetResourceAcknowledge_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResetResourceAcknowledge_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResetResourceAcknowledge_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResourceAcknowledge (ASN1CTXT* pctxt, ResetResourceAcknowledge* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_ResetResourceAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_ResetResourceAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt,
   DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].ExtensionSize);
   stat = RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationItem_RANAP_RelocInf (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode nAS_PDU */

   stat = asn1PD_NAS_PDU (pctxt, &pvalue->nAS_PDU);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode sAPI */

   stat = asn1PD_SAPI (pctxt, &pvalue->sAPI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cN_DomainIndicator */

   stat = asn1PD_CN_DomainIndicator (pctxt, &pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferInformationItemIEs_RANAP_RelocInf_Value    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectTransferInformationItemIEs_RANAP_RelocInf_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferInformationItemIEs_RANAP_RelocInf_Value *pvalue = (_DirectTransferInformationItemIEs_RANAP_RelocInf_Value*) pvalue_;

   stat = asn1PD_DirectTransferInformationItem_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectTransferInformationList_RANAP_RelocInf_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectTransferInformationList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt,
   DirectTransferInformationList_RANAP_RelocInf_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferInformationItemIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferInformationItemIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferInformationItemIEs_RANAP_RelocInf_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DirectTransferInformationItemIEs_RANAP_RelocInf[index].ValueSize);
   stat = DirectTransferInformationItemIEs_RANAP_RelocInf[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationList_RANAP_RelocInf_element (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectTransferInformationList_RANAP_RelocInf_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransferInformationList_RANAP_RelocInf_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransferInformationList_RANAP_RelocInf_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectTransferInformationList_RANAP_RelocInf (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   DirectTransferInformationList_RANAP_RelocInf_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectTransferInformationList_RANAP_RelocInf_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectTransferInformationList_RANAP_RelocInf_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RANAP_RelocationInformationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationIEs_Value *pvalue = (_RANAP_RelocationInformationIEs_Value*) pvalue_;

   stat = asn1PD_DirectTransferInformationList_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].ExtensionSize);
   stat = RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_RANAP_RelocInf_iE_Extensions (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextItem_RANAP_RelocInf (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_GTP_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_N_PDU_SequenceNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PD_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ContextItem_RANAP_RelocInf_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ContextItemIEs_RANAP_RelocInf_Value                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ContextItemIEs_RANAP_RelocInf_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ContextItemIEs_RANAP_RelocInf_Value *pvalue = (_RAB_ContextItemIEs_RANAP_RelocInf_Value*) pvalue_;

   stat = asn1PD_RAB_ContextItem_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ContextList_RANAP_RelocInf_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ContextList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt,
   RAB_ContextList_RANAP_RelocInf_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItemIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItemIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItemIEs_RANAP_RelocInf_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ContextItemIEs_RANAP_RelocInf[index].ValueSize);
   stat = RAB_ContextItemIEs_RANAP_RelocInf[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_RANAP_RelocInf_element (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ContextList_RANAP_RelocInf_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextList_RANAP_RelocInf_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextList_RANAP_RelocInf_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ContextList_RANAP_RelocInf (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ContextList_RANAP_RelocInf_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ContextList_RANAP_RelocInf_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ContextList_RANAP_RelocInf_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationIEs_Value_1                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RANAP_RelocationInformationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationIEs_Value_1 *pvalue = (_RANAP_RelocationInformationIEs_Value_1*) pvalue_;

   stat = asn1PD_RAB_ContextList_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation_protocolIEs_element (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RANAP_RelocationInformation_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RANAP_RelocationInformation_protocolIEs_element (ASN1CTXT* pctxt,
   RANAP_RelocationInformation_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_RelocationInformationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_RelocationInformationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_RelocationInformationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RANAP_RelocationInformationIEs[index].ValueSize);
   stat = RANAP_RelocationInformationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation_protocolIEs (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RANAP_RelocationInformation_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RANAP_RelocationInformation_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RANAP_RelocationInformation_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationExtensions_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RANAP_RelocationInformationExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationExtensions_Extension *pvalue = (_RANAP_RelocationInformationExtensions_Extension*) pvalue_;

   stat = asn1PD_RRC_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation_protocolExtensions_element (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RANAP_RelocationInformation_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RANAP_RelocationInformation_protocolExtensions_element (ASN1CTXT* pctxt,
   RANAP_RelocationInformation_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_RelocationInformationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_RelocationInformationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_RelocationInformationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RANAP_RelocationInformationExtensions[index].ExtensionSize);
   stat = RANAP_RelocationInformationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation_protocolExtensions (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RANAP_RelocationInformation_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RANAP_RelocationInformation_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RANAP_RelocationInformation_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RANAP_RelocationInformation (ASN1CTXT* pctxt, RANAP_RelocationInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RANAP_RelocationInformation_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RANAP_RelocationInformation_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ModifyItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ModifyItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ModifyItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ModifyItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ModifyItem_ExtIEs[index].ExtensionSize);
   stat = RAB_ModifyItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ModifyItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ModifyItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyItem (ASN1CTXT* pctxt, RAB_ModifyItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode requested_RAB_Parameter_Values */

   stat = asn1PD_Requested_RAB_Parameter_Values (pctxt, &pvalue->requested_RAB_Parameter_Values);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_ModifyItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ModifyItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ModifyItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ModifyItemIEs_Value *pvalue = (_RAB_ModifyItemIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ModifyItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyList_element_element (ASN1CTXT* pctxt, RAB_ModifyList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ModifyList_element_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ModifyList_element_element (ASN1CTXT* pctxt,
   RAB_ModifyList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyItemIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ModifyItemIEs[index].ValueSize);
   stat = RAB_ModifyItemIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyList_element (ASN1CTXT* pctxt, RAB_ModifyList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ModifyList_element_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyList_element_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyList_element_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyList (ASN1CTXT* pctxt, RAB_ModifyList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_ModifyList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ModifyRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_ModifyRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ModifyRequestIEs_Value *pvalue = (_RAB_ModifyRequestIEs_Value*) pvalue_;

   stat = asn1PD_RAB_ModifyList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ModifyRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ModifyRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_ModifyRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, RAB_ModifyRequestIEs[index].ValueSize);
   stat = RAB_ModifyRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest_protocolIEs (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ModifyRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_ModifyRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_ModifyRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_ModifyRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_ModifyRequestExtensions[index].ExtensionSize);
   stat = RAB_ModifyRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_ModifyRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_ModifyRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_ModifyRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ModifyRequest (ASN1CTXT* pctxt, RAB_ModifyRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_RAB_ModifyRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_RAB_ModifyRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataRequestIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataRequestIEs_Value *pvalue = (_LocationRelatedDataRequestIEs_Value*) pvalue_;

   stat = asn1PD_LocationRelatedDataRequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataRequest_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationRelatedDataRequestIEs[index].ValueSize);
   stat = LocationRelatedDataRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataRequestExtensions_Extension           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataRequestExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataRequestExtensions_Extension *pvalue = (_LocationRelatedDataRequestExtensions_Extension*) pvalue_;

   stat = asn1PD_LocationRelatedDataRequestTypeSpecificToGERANIuMode (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationRelatedDataRequestExtensions[index].ExtensionSize);
   stat = LocationRelatedDataRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequest (ASN1CTXT* pctxt, LocationRelatedDataRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationRelatedDataRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationRelatedDataRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataResponseIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataResponseIEs_Value *pvalue = (_LocationRelatedDataResponseIEs_Value*) pvalue_;

   stat = asn1PD_BroadcastAssistanceDataDecipheringKeys (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataResponse_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationRelatedDataResponseIEs[index].ValueSize);
   stat = LocationRelatedDataResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataResponseExtensions_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataResponseExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataResponseExtensions_Extension *pvalue = (_LocationRelatedDataResponseExtensions_Extension*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationRelatedDataResponseExtensions[index].ExtensionSize);
   stat = LocationRelatedDataResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataResponse (ASN1CTXT* pctxt, LocationRelatedDataResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationRelatedDataResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationRelatedDataResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataFailureIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataFailureIEs_Value *pvalue = (_LocationRelatedDataFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataFailure_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, LocationRelatedDataFailureIEs[index].ValueSize);
   stat = LocationRelatedDataFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataFailureExtensions_Extension           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__LocationRelatedDataFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataFailureExtensions_Extension *pvalue = (_LocationRelatedDataFailureExtensions_Extension*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LocationRelatedDataFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LocationRelatedDataFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LocationRelatedDataFailureExtensions[index].ExtensionSize);
   stat = LocationRelatedDataFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LocationRelatedDataFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LocationRelatedDataFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LocationRelatedDataFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataFailure (ASN1CTXT* pctxt, LocationRelatedDataFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_LocationRelatedDataFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_LocationRelatedDataFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value *pvalue = (_InformationTransferIndicationIEs_Value*) pvalue_;

   stat = asn1PD_InformationTransferID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferIndicationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_1 *pvalue = (_InformationTransferIndicationIEs_Value_1*) pvalue_;

   stat = asn1PD_ProvidedData (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_2                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferIndicationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_2 *pvalue = (_InformationTransferIndicationIEs_Value_2*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_3                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferIndicationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_3 *pvalue = (_InformationTransferIndicationIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferIndication_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferIndication_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferIndicationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, InformationTransferIndicationIEs[index].ValueSize);
   stat = InformationTransferIndicationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication_protocolIEs (ASN1CTXT* pctxt, InformationTransferIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferIndication_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferIndication_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferIndication_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InformationTransferIndicationExtensions[index].ExtensionSize);
   stat = InformationTransferIndicationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication_protocolExtensions (ASN1CTXT* pctxt, InformationTransferIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferIndication_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferIndication_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferIndication_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferIndication (ASN1CTXT* pctxt, InformationTransferIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_InformationTransferIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_InformationTransferIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferConfirmationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value *pvalue = (_InformationTransferConfirmationIEs_Value*) pvalue_;

   stat = asn1PD_InformationTransferID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_1               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferConfirmationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_1 *pvalue = (_InformationTransferConfirmationIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_2               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferConfirmationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_2 *pvalue = (_InformationTransferConfirmationIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_3               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferConfirmationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_3 *pvalue = (_InformationTransferConfirmationIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferConfirmation_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferConfirmation_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferConfirmation_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferConfirmationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferConfirmationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferConfirmationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, InformationTransferConfirmationIEs[index].ValueSize);
   stat = InformationTransferConfirmationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation_protocolIEs (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferConfirmation_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferConfirmation_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferConfirmation_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferConfirmation_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferConfirmation_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferConfirmation_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferConfirmationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferConfirmationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferConfirmationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InformationTransferConfirmationExtensions[index].ExtensionSize);
   stat = InformationTransferConfirmationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation_protocolExtensions (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferConfirmation_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferConfirmation_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferConfirmation_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferConfirmation (ASN1CTXT* pctxt, InformationTransferConfirmation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_InformationTransferConfirmation_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_InformationTransferConfirmation_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value *pvalue = (_InformationTransferFailureIEs_Value*) pvalue_;

   stat = asn1PD_InformationTransferID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_1                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_1 *pvalue = (_InformationTransferFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_2                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_2 *pvalue = (_InformationTransferFailureIEs_Value_2*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_3                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_3 *pvalue = (_InformationTransferFailureIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_4                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__InformationTransferFailureIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_4 *pvalue = (_InformationTransferFailureIEs_Value_4*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferFailure_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, InformationTransferFailureIEs[index].ValueSize);
   stat = InformationTransferFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure_protocolIEs (ASN1CTXT* pctxt, InformationTransferFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InformationTransferFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InformationTransferFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InformationTransferFailureExtensions[index].ExtensionSize);
   stat = InformationTransferFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure_protocolExtensions (ASN1CTXT* pctxt, InformationTransferFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InformationTransferFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InformationTransferFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InformationTransferFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferFailure (ASN1CTXT* pctxt, InformationTransferFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_InformationTransferFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_InformationTransferFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UESpecificInformationIndicationIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UESpecificInformationIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UESpecificInformationIndicationIEs_Value *pvalue = (_UESpecificInformationIndicationIEs_Value*) pvalue_;

   stat = asn1PD_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication_protocolIEs_element (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UESpecificInformationIndication_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UESpecificInformationIndication_protocolIEs_element (ASN1CTXT* pctxt,
   UESpecificInformationIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESpecificInformationIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESpecificInformationIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UESpecificInformationIndicationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, UESpecificInformationIndicationIEs[index].ValueSize);
   stat = UESpecificInformationIndicationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication_protocolIEs (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   UESpecificInformationIndication_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UESpecificInformationIndication_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UESpecificInformationIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication_protocolExtensions_element (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UESpecificInformationIndication_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UESpecificInformationIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   UESpecificInformationIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESpecificInformationIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESpecificInformationIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UESpecificInformationIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UESpecificInformationIndicationExtensions[index].ExtensionSize);
   stat = UESpecificInformationIndicationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication_protocolExtensions (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UESpecificInformationIndication_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UESpecificInformationIndication_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UESpecificInformationIndication_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESpecificInformationIndication (ASN1CTXT* pctxt, UESpecificInformationIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_UESpecificInformationIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_UESpecificInformationIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectInformationTransferIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value *pvalue = (_DirectInformationTransferIEs_Value*) pvalue_;

   stat = asn1PD_InterSystemInformationTransferType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectInformationTransferIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_1 *pvalue = (_DirectInformationTransferIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectInformationTransferIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_2 *pvalue = (_DirectInformationTransferIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__DirectInformationTransferIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_3 *pvalue = (_DirectInformationTransferIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer_protocolIEs_element (ASN1CTXT* pctxt, DirectInformationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectInformationTransfer_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectInformationTransfer_protocolIEs_element (ASN1CTXT* pctxt,
   DirectInformationTransfer_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectInformationTransferIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectInformationTransferIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DirectInformationTransferIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, DirectInformationTransferIEs[index].ValueSize);
   stat = DirectInformationTransferIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer_protocolIEs (ASN1CTXT* pctxt, DirectInformationTransfer_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectInformationTransfer_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectInformationTransfer_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectInformationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer_protocolExtensions_element (ASN1CTXT* pctxt, DirectInformationTransfer_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DirectInformationTransfer_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DirectInformationTransfer_protocolExtensions_element (ASN1CTXT* pctxt,
   DirectInformationTransfer_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectInformationTransferExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectInformationTransferExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DirectInformationTransferExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DirectInformationTransferExtensions[index].ExtensionSize);
   stat = DirectInformationTransferExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer_protocolExtensions (ASN1CTXT* pctxt, DirectInformationTransfer_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DirectInformationTransfer_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DirectInformationTransfer_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DirectInformationTransfer_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DirectInformationTransfer (ASN1CTXT* pctxt, DirectInformationTransfer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_DirectInformationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_DirectInformationTransfer_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value *pvalue = (_UplinkInformationExchangeRequestIEs_Value*) pvalue_;

   stat = asn1PD_InformationExchangeID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_1              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_1 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_InformationExchangeType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_2              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_2 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_2*) pvalue_;

   stat = asn1PD_InformationTransferType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_3              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_3 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_3*) pvalue_;

   stat = asn1PD_InformationRequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_4              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_4 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_4*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_5              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeRequestIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_5 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_5*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeRequest_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeRequestIEs[index].ValueSize);
   stat = UplinkInformationExchangeRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeRequestExtensions[index].ExtensionSize);
   stat = UplinkInformationExchangeRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeRequest (ASN1CTXT* pctxt, UplinkInformationExchangeRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_UplinkInformationExchangeRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_UplinkInformationExchangeRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value *pvalue = (_UplinkInformationExchangeResponseIEs_Value*) pvalue_;

   stat = asn1PD_InformationExchangeID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_1             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_1 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_InformationRequested (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_2             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_2 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_3             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_3 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_3*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_4             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeResponseIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_4 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_4*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeResponse_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeResponseIEs[index].ValueSize);
   stat = UplinkInformationExchangeResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeResponseExtensions[index].ExtensionSize);
   stat = UplinkInformationExchangeResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeResponse (ASN1CTXT* pctxt, UplinkInformationExchangeResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_UplinkInformationExchangeResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_UplinkInformationExchangeResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value *pvalue = (_UplinkInformationExchangeFailureIEs_Value*) pvalue_;

   stat = asn1PD_InformationExchangeID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_1              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_1 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_2              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_2 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_2*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_3              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_3 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_3*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_4              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__UplinkInformationExchangeFailureIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_4 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_4*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeFailure_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeFailureIEs[index].ValueSize);
   stat = UplinkInformationExchangeFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UplinkInformationExchangeFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UplinkInformationExchangeFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UplinkInformationExchangeFailureExtensions[index].ExtensionSize);
   stat = UplinkInformationExchangeFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UplinkInformationExchangeFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UplinkInformationExchangeFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UplinkInformationExchangeFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UplinkInformationExchangeFailure (ASN1CTXT* pctxt, UplinkInformationExchangeFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_UplinkInformationExchangeFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_UplinkInformationExchangeFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value *pvalue = (_MBMSSessionStartIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_1 *pvalue = (_MBMSSessionStartIEs_Value_1*) pvalue_;

   stat = asn1PD_MBMSSessionIdentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_2 *pvalue = (_MBMSSessionStartIEs_Value_2*) pvalue_;

   stat = asn1PD_MBMSBearerServiceType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_3                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_3 *pvalue = (_MBMSSessionStartIEs_Value_3*) pvalue_;

   stat = asn1PD_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_4                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_4 *pvalue = (_MBMSSessionStartIEs_Value_4*) pvalue_;

   stat = asn1PD_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_5                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_5 *pvalue = (_MBMSSessionStartIEs_Value_5*) pvalue_;

   stat = asn1PD_PDP_TypeInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_6                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_6 *pvalue = (_MBMSSessionStartIEs_Value_6*) pvalue_;

   stat = asn1PD_MBMSSessionDuration (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_7                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_7 *pvalue = (_MBMSSessionStartIEs_Value_7*) pvalue_;

   stat = asn1PD_MBMSServiceArea (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_8                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_8 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_8 *pvalue = (_MBMSSessionStartIEs_Value_8*) pvalue_;

   stat = asn1PD_FrequenceLayerConvergenceFlag (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_9                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_9 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_9 *pvalue = (_MBMSSessionStartIEs_Value_9*) pvalue_;

   stat = asn1PD_RAListofIdleModeUEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_10                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_10 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_10 *pvalue = (_MBMSSessionStartIEs_Value_10*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_11                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_11 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_11 *pvalue = (_MBMSSessionStartIEs_Value_11*) pvalue_;

   stat = asn1PD_MBMSSessionRepetitionNumber (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_12                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartIEs_Value_12 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_12 *pvalue = (_MBMSSessionStartIEs_Value_12*) pvalue_;

   stat = asn1PD_TimeToMBMSDataTransfer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStart_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStart_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStart_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStart_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStartIEs[index].ValueSize);
   stat = MBMSSessionStartIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStart_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStart_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStart_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStart_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStart_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStart_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStart_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStart_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStartExtensions[index].ExtensionSize);
   stat = MBMSSessionStartExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStart_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStart_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStart_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStart_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStart (ASN1CTXT* pctxt, MBMSSessionStart* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStart_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value *pvalue = (_MBMSSessionStartResponseIEs_Value*) pvalue_;

   stat = asn1PD_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value_1 *pvalue = (_MBMSSessionStartResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value_2 *pvalue = (_MBMSSessionStartResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStartResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStartResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStartResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStartResponseIEs[index].ValueSize);
   stat = MBMSSessionStartResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStartResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStartResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStartResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStartResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStartResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStartResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStartResponseExtensions[index].ExtensionSize);
   stat = MBMSSessionStartResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStartResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStartResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStartResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartResponse (ASN1CTXT* pctxt, MBMSSessionStartResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStartResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStartResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartFailureIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartFailureIEs_Value *pvalue = (_MBMSSessionStartFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartFailureIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStartFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartFailureIEs_Value_1 *pvalue = (_MBMSSessionStartFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStartFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStartFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStartFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStartFailureIEs[index].ValueSize);
   stat = MBMSSessionStartFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStartFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStartFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStartFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStartFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStartFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStartFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStartFailureExtensions[index].ExtensionSize);
   stat = MBMSSessionStartFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStartFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStartFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStartFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStartFailure (ASN1CTXT* pctxt, MBMSSessionStartFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStartFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStartFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateIEs_Value *pvalue = (_MBMSSessionUpdateIEs_Value*) pvalue_;

   stat = asn1PD_SessionUpdateID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateIEs_Value_1 *pvalue = (_MBMSSessionUpdateIEs_Value_1*) pvalue_;

   stat = asn1PD_DeltaRAListofIdleModeUEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdate_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdate_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdate_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateIEs[index].ValueSize);
   stat = MBMSSessionUpdateIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdate_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdate_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdate_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdate_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdate_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdate_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateExtensions[index].ExtensionSize);
   stat = MBMSSessionUpdateExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdate_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdate_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdate_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdate (ASN1CTXT* pctxt, MBMSSessionUpdate* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionUpdate_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value *pvalue = (_MBMSSessionUpdateResponseIEs_Value*) pvalue_;

   stat = asn1PD_SessionUpdateID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_1 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_2 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_3 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdateResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdateResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateResponseIEs[index].ValueSize);
   stat = MBMSSessionUpdateResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdateResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdateResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdateResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdateResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdateResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateResponseExtensions[index].ExtensionSize);
   stat = MBMSSessionUpdateResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdateResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdateResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdateResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateResponse (ASN1CTXT* pctxt, MBMSSessionUpdateResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionUpdateResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionUpdateResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value *pvalue = (_MBMSSessionUpdateFailureIEs_Value*) pvalue_;

   stat = asn1PD_SessionUpdateID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value_1 *pvalue = (_MBMSSessionUpdateFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionUpdateFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value_2 *pvalue = (_MBMSSessionUpdateFailureIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdateFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdateFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateFailureIEs[index].ValueSize);
   stat = MBMSSessionUpdateFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdateFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdateFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdateFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionUpdateFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionUpdateFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionUpdateFailureExtensions[index].ExtensionSize);
   stat = MBMSSessionUpdateFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionUpdateFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionUpdateFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionUpdateFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionUpdateFailure (ASN1CTXT* pctxt, MBMSSessionUpdateFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionUpdateFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStopIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopIEs_Value *pvalue = (_MBMSSessionStopIEs_Value*) pvalue_;

   stat = asn1PD_MBMSCNDe_Registration (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStop_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStop_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStop_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStop_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStopIEs[index].ValueSize);
   stat = MBMSSessionStopIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStop_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStop_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStop_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStop_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStop_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStop_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStop_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStop_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStopExtensions[index].ExtensionSize);
   stat = MBMSSessionStopExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStop_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStop_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStop_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStop_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStop (ASN1CTXT* pctxt, MBMSSessionStop* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStop_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStop_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopResponseIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStopResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopResponseIEs_Value *pvalue = (_MBMSSessionStopResponseIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopResponseIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSSessionStopResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopResponseIEs_Value_1 *pvalue = (_MBMSSessionStopResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStopResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStopResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStopResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSSessionStopResponseIEs[index].ValueSize);
   stat = MBMSSessionStopResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStopResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStopResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStopResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSSessionStopResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSSessionStopResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStopResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSSessionStopResponseExtensions[index].ExtensionSize);
   stat = MBMSSessionStopResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSSessionStopResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSSessionStopResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSSessionStopResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionStopResponse (ASN1CTXT* pctxt, MBMSSessionStopResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSSessionStopResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSSessionStopResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingRequestIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSUELinkingRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingRequestIEs_Value *pvalue = (_MBMSUELinkingRequestIEs_Value*) pvalue_;

   stat = asn1PD_JoinedMBMSBearerService_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LeftMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LeftMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LeftMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   LeftMBMSBearerService_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LeftMBMSBearerService_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LeftMBMSBearerService_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LeftMBMSBearerService_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LeftMBMSBearerService_ExtIEs[index].ExtensionSize);
   stat = LeftMBMSBearerService_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LeftMBMSBearerService_IEs_element_iE_Extensions (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LeftMBMSBearerService_IEs_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LeftMBMSBearerService_IEs_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LeftMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LeftMBMSBearerService_IEs_element (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode tMGI */

   stat = asn1PD_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_LeftMBMSBearerService_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LeftMBMSBearerService_IEs (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   LeftMBMSBearerService_IEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LeftMBMSBearerService_IEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LeftMBMSBearerService_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingRequestIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSUELinkingRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingRequestIEs_Value_1 *pvalue = (_MBMSUELinkingRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_LeftMBMSBearerService_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSUELinkingRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSUELinkingRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSUELinkingRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSUELinkingRequestIEs[index].ValueSize);
   stat = MBMSUELinkingRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest_protocolIEs (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSUELinkingRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSUELinkingRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSUELinkingRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSUELinkingRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSUELinkingRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSUELinkingRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSUELinkingRequestExtensions[index].ExtensionSize);
   stat = MBMSUELinkingRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSUELinkingRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSUELinkingRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSUELinkingRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingRequest (ASN1CTXT* pctxt, MBMSUELinkingRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSUELinkingRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSUELinkingRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulLinking_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UnsuccessfulLinking_IEs_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UnsuccessfulLinking_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   UnsuccessfulLinking_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UnsuccessfulLinking_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UnsuccessfulLinking_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UnsuccessfulLinking_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UnsuccessfulLinking_ExtIEs[index].ExtensionSize);
   stat = UnsuccessfulLinking_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulLinking_IEs_element_iE_Extensions (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UnsuccessfulLinking_IEs_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UnsuccessfulLinking_IEs_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UnsuccessfulLinking_IEs_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulLinking_IEs_element (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode tMGI */

   stat = asn1PD_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cause */

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_UnsuccessfulLinking_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfulLinking_IEs (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   UnsuccessfulLinking_IEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UnsuccessfulLinking_IEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UnsuccessfulLinking_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingResponseIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSUELinkingResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingResponseIEs_Value *pvalue = (_MBMSUELinkingResponseIEs_Value*) pvalue_;

   stat = asn1PD_UnsuccessfulLinking_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingResponseIEs_Value_1                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSUELinkingResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingResponseIEs_Value_1 *pvalue = (_MBMSUELinkingResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSUELinkingResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSUELinkingResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSUELinkingResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSUELinkingResponseIEs[index].ValueSize);
   stat = MBMSUELinkingResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse_protocolIEs (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSUELinkingResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSUELinkingResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSUELinkingResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSUELinkingResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSUELinkingResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSUELinkingResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSUELinkingResponseExtensions[index].ExtensionSize);
   stat = MBMSUELinkingResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSUELinkingResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSUELinkingResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSUELinkingResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSUELinkingResponse (ASN1CTXT* pctxt, MBMSUELinkingResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSUELinkingResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSUELinkingResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value *pvalue = (_MBMSRegistrationRequestIEs_Value*) pvalue_;

   stat = asn1PD_MBMSRegistrationRequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_1 *pvalue = (_MBMSRegistrationRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_2                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_2 *pvalue = (_MBMSRegistrationRequestIEs_Value_2*) pvalue_;

   stat = asn1PD_IPMulticastAddress (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_3                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_3 *pvalue = (_MBMSRegistrationRequestIEs_Value_3*) pvalue_;

   stat = asn1PD_APN (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_4                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_4 *pvalue = (_MBMSRegistrationRequestIEs_Value_4*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRegistrationRequestIEs[index].ValueSize);
   stat = MBMSRegistrationRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRegistrationRequestExtensions[index].ExtensionSize);
   stat = MBMSRegistrationRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequest (ASN1CTXT* pctxt, MBMSRegistrationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRegistrationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRegistrationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value *pvalue = (_MBMSRegistrationResponseIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value_1 *pvalue = (_MBMSRegistrationResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value_2 *pvalue = (_MBMSRegistrationResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRegistrationResponseIEs[index].ValueSize);
   stat = MBMSRegistrationResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRegistrationResponseExtensions[index].ExtensionSize);
   stat = MBMSRegistrationResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationResponse (ASN1CTXT* pctxt, MBMSRegistrationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRegistrationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRegistrationResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value *pvalue = (_MBMSRegistrationFailureIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_1 *pvalue = (_MBMSRegistrationFailureIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_2                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_2 *pvalue = (_MBMSRegistrationFailureIEs_Value_2*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_3                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRegistrationFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_3 *pvalue = (_MBMSRegistrationFailureIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRegistrationFailureIEs[index].ValueSize);
   stat = MBMSRegistrationFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRegistrationFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRegistrationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRegistrationFailureExtensions[index].ExtensionSize);
   stat = MBMSRegistrationFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRegistrationFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRegistrationFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRegistrationFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationFailure (ASN1CTXT* pctxt, MBMSRegistrationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRegistrationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRegistrationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationRequestIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationRequestIEs_Value *pvalue = (_MBMSCNDe_RegistrationRequestIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationRequestIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationRequestIEs_Value_1 *pvalue = (_MBMSCNDe_RegistrationRequestIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSCNDe_RegistrationRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSCNDe_RegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSCNDe_RegistrationRequestIEs[index].ValueSize);
   stat = MBMSCNDe_RegistrationRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest_protocolIEs (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSCNDe_RegistrationRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSCNDe_RegistrationRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSCNDe_RegistrationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSCNDe_RegistrationRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSCNDe_RegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSCNDe_RegistrationRequestExtensions[index].ExtensionSize);
   stat = MBMSCNDe_RegistrationRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSCNDe_RegistrationRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSCNDe_RegistrationRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSCNDe_RegistrationRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationRequest (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSCNDe_RegistrationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSCNDe_RegistrationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value*) pvalue_;

   stat = asn1PD_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_1 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_1*) pvalue_;

   stat = asn1PD_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_2                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_2 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_2*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_3                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSCNDe_RegistrationResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_3 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_3*) pvalue_;

   stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSCNDe_RegistrationResponse_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSCNDe_RegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationResponseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSCNDe_RegistrationResponseIEs[index].ValueSize);
   stat = MBMSCNDe_RegistrationResponseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse_protocolIEs (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSCNDe_RegistrationResponse_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSCNDe_RegistrationResponse_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSCNDe_RegistrationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSCNDe_RegistrationResponse_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSCNDe_RegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSCNDe_RegistrationResponseExtensions[index].ExtensionSize);
   stat = MBMSCNDe_RegistrationResponseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSCNDe_RegistrationResponse_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSCNDe_RegistrationResponse_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSCNDe_RegistrationResponse_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_RegistrationResponse (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSCNDe_RegistrationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSCNDe_RegistrationResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABEstablishmentIndicationIEs_Value                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRABEstablishmentIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABEstablishmentIndicationIEs_Value *pvalue = (_MBMSRABEstablishmentIndicationIEs_Value*) pvalue_;

   stat = asn1PD_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABEstablishmentIndication_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABEstablishmentIndication_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABEstablishmentIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABEstablishmentIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABEstablishmentIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABEstablishmentIndicationIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRABEstablishmentIndicationIEs[index].ValueSize);
   stat = MBMSRABEstablishmentIndicationIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication_protocolIEs (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABEstablishmentIndication_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABEstablishmentIndication_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABEstablishmentIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABEstablishmentIndication_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABEstablishmentIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABEstablishmentIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABEstablishmentIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABEstablishmentIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABEstablishmentIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRABEstablishmentIndicationExtensions[index].ExtensionSize);
   stat = MBMSRABEstablishmentIndicationExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication_protocolExtensions (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABEstablishmentIndication_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABEstablishmentIndication_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABEstablishmentIndication_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABEstablishmentIndication (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRABEstablishmentIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRABEstablishmentIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseRequestIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRABReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseRequestIEs_Value *pvalue = (_MBMSRABReleaseRequestIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABReleaseRequest_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRABReleaseRequestIEs[index].ValueSize);
   stat = MBMSRABReleaseRequestIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest_protocolIEs (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABReleaseRequest_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABReleaseRequest_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABReleaseRequest_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRABReleaseRequestExtensions[index].ExtensionSize);
   stat = MBMSRABReleaseRequestExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABReleaseRequest_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABReleaseRequest_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABReleaseRequest_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseRequest (ASN1CTXT* pctxt, MBMSRABReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRABReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRABReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRABReleaseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseIEs_Value *pvalue = (_MBMSRABReleaseIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABRelease_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABRelease_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABRelease_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABRelease_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRABReleaseIEs[index].ValueSize);
   stat = MBMSRABReleaseIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease_protocolIEs (ASN1CTXT* pctxt, MBMSRABRelease_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABRelease_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABRelease_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABRelease_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABRelease_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABRelease_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABRelease_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABRelease_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRABReleaseExtensions[index].ExtensionSize);
   stat = MBMSRABReleaseExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease_protocolExtensions (ASN1CTXT* pctxt, MBMSRABRelease_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABRelease_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABRelease_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABRelease_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABRelease (ASN1CTXT* pctxt, MBMSRABRelease* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRABRelease_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRABRelease_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseFailureIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__MBMSRABReleaseFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseFailureIEs_Value *pvalue = (_MBMSRABReleaseFailureIEs_Value*) pvalue_;

   stat = asn1PD_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode value */

   stat = pd_OpenType (pctxt, &pvalue->value.encoded.data, &pvalue->value.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABReleaseFailure_protocolIEs_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABReleaseFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABReleaseFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseFailureIEs_Size) return 0;

   /* check value */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->value.encoded.data,
         pvalue->value.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.decoded = rtMemAlloc (pctxt, MBMSRABReleaseFailureIEs[index].ValueSize);
   stat = MBMSRABReleaseFailureIEs[index].decodeValue(pctxt, pvalue->value.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure_protocolIEs (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABReleaseFailure_protocolIEs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABReleaseFailure_protocolIEs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABReleaseFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSRABReleaseFailure_protocolExtensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSRABReleaseFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABReleaseFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSRABReleaseFailureExtensions[index].ExtensionSize);
   stat = MBMSRABReleaseFailureExtensions[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSRABReleaseFailure_protocolExtensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSRABReleaseFailure_protocolExtensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSRABReleaseFailure_protocolExtensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRABReleaseFailure (ASN1CTXT* pctxt, MBMSRABReleaseFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   stat = asn1PD_MBMSRABReleaseFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PD_MBMSRABReleaseFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

