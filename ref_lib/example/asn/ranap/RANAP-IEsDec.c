/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 20-Mar-2007.
 */
#include "asn1intl.h"
#include "RANAP-IEsTable.h"

/**************************************************************/
/*                                                            */
/*  CauseRadioNetwork                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseRadioNetwork (ASN1CTXT* pctxt, CauseRadioNetwork* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(64));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseTransmissionNetwork                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseTransmissionNetwork (ASN1CTXT* pctxt, CauseTransmissionNetwork* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(65), OSUINTCONST(80));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseNAS                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseNAS (ASN1CTXT* pctxt, CauseNAS* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(81), OSUINTCONST(96));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseProtocol                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseProtocol (ASN1CTXT* pctxt, CauseProtocol* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(97), OSUINTCONST(112));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseMisc                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseMisc (ASN1CTXT* pctxt, CauseMisc* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(113), OSUINTCONST(128));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseNon_Standard                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseNon_Standard (ASN1CTXT* pctxt, CauseNon_Standard* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(129), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseRadioNetworkExtension                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseRadioNetworkExtension (ASN1CTXT* pctxt, CauseRadioNetworkExtension* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(257), OSUINTCONST(512));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cause                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cause (ASN1CTXT* pctxt, Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* radioNetwork */
         case 0:
            stat = asn1PD_CauseRadioNetwork (pctxt, &pvalue->u.radioNetwork);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* transmissionNetwork */
         case 1:
            stat = asn1PD_CauseTransmissionNetwork (pctxt, &pvalue->u.transmissionNetwork);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nAS */
         case 2:
            stat = asn1PD_CauseNAS (pctxt, &pvalue->u.nAS);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* protocol */
         case 3:
            stat = asn1PD_CauseProtocol (pctxt, &pvalue->u.protocol);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* misc */
         case 4:
            stat = asn1PD_CauseMisc (pctxt, &pvalue->u.misc);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* non_Standard */
         case 5:
            stat = asn1PD_CauseNon_Standard (pctxt, &pvalue->u.non_Standard);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* radioNetworkExtension */
         case 7:
            stat = asn1PD_CauseRadioNetworkExtension (pctxt, &pvalue->u.radioNetworkExtension);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      rtCopyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_ID (ASN1CTXT* pctxt, RAB_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfullyTransmittedDataVolume                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnsuccessfullyTransmittedDataVolume (ASN1CTXT* pctxt, UnsuccessfullyTransmittedDataVolume* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReference                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReference (ASN1CTXT* pctxt, DataVolumeReference* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_GTP_PDU_SequenceNumber                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_GTP_PDU_SequenceNumber (ASN1CTXT* pctxt, DL_GTP_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_GTP_PDU_SequenceNumber                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_GTP_PDU_SequenceNumber (ASN1CTXT* pctxt, UL_GTP_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber0                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RepetitionNumber0 (ASN1CTXT* pctxt, RepetitionNumber0* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RepetitionNumber1 (ASN1CTXT* pctxt, RepetitionNumber1* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure_element_iE_Extensions_element (ASN1CTXT* pctxt, MessageStructure_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MessageStructure_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MessageStructure_element_iE_Extensions_element (ASN1CTXT* pctxt,
   MessageStructure_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MessageStructure_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MessageStructure_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MessageStructure_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MessageStructure_ExtIEs[index].ExtensionSize);
   stat = MessageStructure_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure_element_iE_Extensions (ASN1CTXT* pctxt, MessageStructure_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MessageStructure_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MessageStructure_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MessageStructure_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure_element (ASN1CTXT* pctxt, MessageStructure_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iE_ID */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      stat = asn1PD_RepetitionNumber1 (pctxt, &pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_MessageStructure_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure (ASN1CTXT* pctxt, MessageStructure* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   MessageStructure_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MessageStructure_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MessageStructure_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CriticalityDiagnostics_IE_List_ExtIEs_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CriticalityDiagnostics_IE_List_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CriticalityDiagnostics_IE_List_ExtIEs_Extension *pvalue = (_CriticalityDiagnostics_IE_List_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_MessageStructure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TypeOfError                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TypeOfError (ASN1CTXT* pctxt, TypeOfError* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = not_understood; break;
         case 1: *pvalue = missing; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CriticalityDiagnostics_IE_List_ExtIEs_Extension_1        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CriticalityDiagnostics_IE_List_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CriticalityDiagnostics_IE_List_ExtIEs_Extension_1 *pvalue = (_CriticalityDiagnostics_IE_List_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_TypeOfError (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (ASN1CTXT* pctxt,
   CriticalityDiagnostics_IE_List_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CriticalityDiagnostics_IE_List_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CriticalityDiagnostics_IE_List_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CriticalityDiagnostics_IE_List_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CriticalityDiagnostics_IE_List_ExtIEs[index].ExtensionSize);
   stat = CriticalityDiagnostics_IE_List_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List_element_iE_Extensions (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CriticalityDiagnostics_IE_List_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List_element (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionNumberPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iECriticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->iECriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_ID */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      stat = asn1PD_RepetitionNumber0 (pctxt, &pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CriticalityDiagnostics_IE_List_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   CriticalityDiagnostics_IE_List_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CriticalityDiagnostics_IE_List_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_iE_Extensions_element (ASN1CTXT* pctxt, CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CriticalityDiagnostics_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CriticalityDiagnostics_iE_Extensions_element (ASN1CTXT* pctxt,
   CriticalityDiagnostics_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CriticalityDiagnostics_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CriticalityDiagnostics_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CriticalityDiagnostics_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CriticalityDiagnostics_ExtIEs[index].ExtensionSize);
   stat = CriticalityDiagnostics_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_iE_Extensions (ASN1CTXT* pctxt, CriticalityDiagnostics_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CriticalityDiagnostics_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CriticalityDiagnostics_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CriticalityDiagnostics_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics (ASN1CTXT* pctxt, CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.procedureCodePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.triggeringMessagePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.procedureCriticalityPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iEsCriticalityDiagnosticsPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode procedureCode */

   if (pvalue->m.procedureCodePresent) {
      stat = asn1PD_ProcedureCode (pctxt, &pvalue->procedureCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      stat = asn1PD_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      stat = asn1PD_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      stat = asn1PD_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CriticalityDiagnostics_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationType (ASN1CTXT* pctxt, RelocationType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ue_not_involved; break;
         case 1: *pvalue = ue_involved; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TBCD_STRING                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TBCD_STRING (ASN1CTXT* pctxt, TBCD_STRING* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNidentity                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNidentity (ASN1CTXT* pctxt, PLMNidentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNC_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNC_ID (ASN1CTXT* pctxt, RNC_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt, SourceRNC_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SourceRNC_ID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SourceRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceRNC_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceRNC_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceRNC_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceRNC_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SourceRNC_ID_ExtIEs[index].ExtensionSize);
   stat = SourceRNC_ID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ID_iE_Extensions (ASN1CTXT* pctxt, SourceRNC_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SourceRNC_ID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SourceRNC_ID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SourceRNC_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ID (ASN1CTXT* pctxt, SourceRNC_ID* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rNC_ID */

   stat = asn1PD_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SourceRNC_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LAC (ASN1CTXT* pctxt, LAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAC (ASN1CTXT* pctxt, SAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAI_iE_Extensions_element (ASN1CTXT* pctxt, SAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SAI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SAI_iE_Extensions_element (ASN1CTXT* pctxt,
   SAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SAI_ExtIEs[index].ExtensionSize);
   stat = SAI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAI_iE_Extensions (ASN1CTXT* pctxt, SAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SAI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SAI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAI (ASN1CTXT* pctxt, SAI* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode lAC */

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode sAC */

   stat = asn1PD_SAC (pctxt, &pvalue->sAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceID (ASN1CTXT* pctxt, SourceID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sourceRNC_ID */
         case 0:
            pvalue->u.sourceRNC_ID = rtMemAllocTypeZ (pctxt, SourceRNC_ID);
            if (pvalue->u.sourceRNC_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SourceRNC_ID (pctxt, pvalue->u.sourceRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* sAI */
         case 1:
            pvalue->u.sAI = rtMemAllocTypeZ (pctxt, SAI);
            if (pvalue->u.sAI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LAI_iE_Extensions_element (ASN1CTXT* pctxt, LAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LAI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LAI_iE_Extensions_element (ASN1CTXT* pctxt,
   LAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LAI_ExtIEs[index].ExtensionSize);
   stat = LAI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LAI_iE_Extensions (ASN1CTXT* pctxt, LAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LAI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LAI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LAI (ASN1CTXT* pctxt, LAI* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode lAC */

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_LAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAC (ASN1CTXT* pctxt, RAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt, TargetRNC_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TargetRNC_ID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TargetRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   TargetRNC_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TargetRNC_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TargetRNC_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TargetRNC_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TargetRNC_ID_ExtIEs[index].ExtensionSize);
   stat = TargetRNC_ID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ID_iE_Extensions (ASN1CTXT* pctxt, TargetRNC_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TargetRNC_ID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TargetRNC_ID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TargetRNC_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ID (ASN1CTXT* pctxt, TargetRNC_ID* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rACPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAI */

   stat = asn1PD_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rAC */

   if (pvalue->m.rACPresent) {
      stat = asn1PD_RAC (pctxt, &pvalue->rAC);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rNC_ID */

   stat = asn1PD_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TargetRNC_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CI                                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CI (ASN1CTXT* pctxt, CI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CGI_ExtIEs_Extension                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__CGI_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CGI_ExtIEs_Extension *pvalue = (_CGI_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CGI_iE_Extensions_element (ASN1CTXT* pctxt, CGI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CGI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CGI_iE_Extensions_element (ASN1CTXT* pctxt,
   CGI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CGI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CGI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CGI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CGI_ExtIEs[index].ExtensionSize);
   stat = CGI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CGI_iE_Extensions (ASN1CTXT* pctxt, CGI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CGI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CGI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CGI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CGI (ASN1CTXT* pctxt, CGI* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode lAC */

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cI */

   stat = asn1PD_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetID (ASN1CTXT* pctxt, TargetID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* targetRNC_ID */
         case 0:
            pvalue->u.targetRNC_ID = rtMemAllocTypeZ (pctxt, TargetRNC_ID);
            if (pvalue->u.targetRNC_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* cGI */
         case 1:
            pvalue->u.cGI = rtMemAllocTypeZ (pctxt, CGI);
            if (pvalue->u.cGI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CGI (pctxt, pvalue->u.cGI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClassmarkInformation2                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ClassmarkInformation2 (ASN1CTXT* pctxt, ClassmarkInformation2* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClassmarkInformation3                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ClassmarkInformation3 (ASN1CTXT* pctxt, ClassmarkInformation3* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RRC_Container                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RRC_Container (ASN1CTXT* pctxt, RRC_Container* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberOfIuInstances                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NumberOfIuInstances (ASN1CTXT* pctxt, NumberOfIuInstances* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionAlgorithm                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionAlgorithm (ASN1CTXT* pctxt, IntegrityProtectionAlgorithm* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ChosenIntegrityProtectionAlgorithm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ChosenIntegrityProtectionAlgorithm (ASN1CTXT* pctxt, ChosenIntegrityProtectionAlgorithm* pvalue)
{
   int stat = 0;

   stat = asn1PD_IntegrityProtectionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionKey                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionKey (ASN1CTXT* pctxt, IntegrityProtectionKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(128), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionAlgorithm                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionAlgorithm (ASN1CTXT* pctxt, EncryptionAlgorithm* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ChosenEncryptionAlgorithm                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ChosenEncryptionAlgorithm (ASN1CTXT* pctxt, ChosenEncryptionAlgorithm* pvalue)
{
   int stat = 0;

   stat = asn1PD_EncryptionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionKey                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionKey (ASN1CTXT* pctxt, EncryptionKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(128), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  D_RNTI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_D_RNTI (ASN1CTXT* pctxt, D_RNTI* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetCellId                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetCellId (ASN1CTXT* pctxt, TargetCellId* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(268435455));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_ID (ASN1CTXT* pctxt, DCH_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_ID (ASN1CTXT* pctxt, DSCH_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_ID (ASN1CTXT* pctxt, USCH_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCH_MAC_d_Flow_ID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCH_MAC_d_Flow_ID (ASN1CTXT* pctxt, HS_DSCH_MAC_d_Flow_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _TrCH_ID_ExtIEs_Extension                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__TrCH_ID_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _TrCH_ID_ExtIEs_Extension *pvalue = (_TrCH_ID_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_HS_DSCH_MAC_d_Flow_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MAC_d_Flow_ID                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MAC_d_Flow_ID (ASN1CTXT* pctxt, E_DCH_MAC_d_Flow_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _TrCH_ID_ExtIEs_Extension_1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__TrCH_ID_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _TrCH_ID_ExtIEs_Extension_1 *pvalue = (_TrCH_ID_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_E_DCH_MAC_d_Flow_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrCH_ID_iE_Extensions_element (ASN1CTXT* pctxt, TrCH_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TrCH_ID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TrCH_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   TrCH_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TrCH_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TrCH_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TrCH_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TrCH_ID_ExtIEs[index].ExtensionSize);
   stat = TrCH_ID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrCH_ID_iE_Extensions (ASN1CTXT* pctxt, TrCH_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TrCH_ID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TrCH_ID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TrCH_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrCH_ID (ASN1CTXT* pctxt, TrCH_ID* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dCH_IDPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dSCH_IDPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uSCH_IDPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode dCH_ID */

   if (pvalue->m.dCH_IDPresent) {
      stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dSCH_ID */

   if (pvalue->m.dSCH_IDPresent) {
      stat = asn1PD_DSCH_ID (pctxt, &pvalue->dSCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uSCH_ID */

   if (pvalue->m.uSCH_IDPresent) {
      stat = asn1PD_USCH_ID (pctxt, &pvalue->uSCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TrCH_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_List                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrCH_ID_List (ASN1CTXT* pctxt, TrCH_ID_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(7), 0 };
   int stat = 0;
   TrCH_ID* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TrCH_ID);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TrCH_ID (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DomainIndicator                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_DomainIndicator (ASN1CTXT* pctxt, CN_DomainIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = cs_domain; break;
      case 1: *pvalue = ps_domain; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_TrCH_MappingItem_ExtIEs_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_TrCH_MappingItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_TrCH_MappingItem_ExtIEs_Extension *pvalue = (_RAB_TrCH_MappingItem_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_CN_DomainIndicator (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_TrCH_MappingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_TrCH_MappingItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_TrCH_MappingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_TrCH_MappingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_TrCH_MappingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_TrCH_MappingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_TrCH_MappingItem_ExtIEs[index].ExtensionSize);
   stat = RAB_TrCH_MappingItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_TrCH_MappingItem_iE_Extensions (ASN1CTXT* pctxt, RAB_TrCH_MappingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_TrCH_MappingItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_TrCH_MappingItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_TrCH_MappingItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_TrCH_MappingItem (ASN1CTXT* pctxt, RAB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAB_ID */

   stat = asn1PD_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode trCH_ID_List */

   stat = asn1PD_TrCH_ID_List (pctxt, &pvalue->trCH_ID_List);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_TrCH_MappingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_Mapping                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_TrCH_Mapping (ASN1CTXT* pctxt, RAB_TrCH_Mapping* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RAB_TrCH_MappingItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_TrCH_MappingItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_TrCH_MappingItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_ID (ASN1CTXT* pctxt, SRB_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt, SRB_TrCH_MappingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SRB_TrCH_MappingItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SRB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   SRB_TrCH_MappingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRB_TrCH_MappingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRB_TrCH_MappingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRB_TrCH_MappingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SRB_TrCH_MappingItem_ExtIEs[index].ExtensionSize);
   stat = SRB_TrCH_MappingItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_TrCH_MappingItem_iE_Extensions (ASN1CTXT* pctxt, SRB_TrCH_MappingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SRB_TrCH_MappingItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRB_TrCH_MappingItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRB_TrCH_MappingItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_TrCH_MappingItem (ASN1CTXT* pctxt, SRB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode sRB_ID */

   stat = asn1PD_SRB_ID (pctxt, &pvalue->sRB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode trCH_ID */

   stat = asn1PD_TrCH_ID (pctxt, &pvalue->trCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SRB_TrCH_MappingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_Mapping                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SRB_TrCH_Mapping (ASN1CTXT* pctxt, SRB_TrCH_Mapping* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   SRB_TrCH_MappingItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SRB_TrCH_MappingItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SRB_TrCH_MappingItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_SRB_TrCH_Mapping (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceUTRANCellID_iE_Extensions_element (ASN1CTXT* pctxt, SourceUTRANCellID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SourceUTRANCellID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SourceUTRANCellID_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceUTRANCellID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceUTRANCellID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceUTRANCellID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceUTRANCellID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SourceUTRANCellID_ExtIEs[index].ExtensionSize);
   stat = SourceUTRANCellID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceUTRANCellID_iE_Extensions (ASN1CTXT* pctxt, SourceUTRANCellID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SourceUTRANCellID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SourceUTRANCellID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SourceUTRANCellID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceUTRANCellID (ASN1CTXT* pctxt, SourceUTRANCellID* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uTRANcellID */

   stat = asn1PD_TargetCellId (pctxt, &pvalue->uTRANcellID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SourceUTRANCellID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceCellID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceCellID (ASN1CTXT* pctxt, SourceCellID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sourceUTRANCellID */
         case 0:
            pvalue->u.sourceUTRANCellID = rtMemAllocTypeZ (pctxt, SourceUTRANCellID);
            if (pvalue->u.sourceUTRANCellID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SourceUTRANCellID (pctxt, pvalue->u.sourceUTRANCellID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* sourceGERANCellID */
         case 1:
            pvalue->u.sourceGERANCellID = rtMemAllocTypeZ (pctxt, CGI);
            if (pvalue->u.sourceGERANCellID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CGI (pctxt, pvalue->u.sourceGERANCellID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_Capacity_Class_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_Capacity_Class_Value (ASN1CTXT* pctxt, Cell_Capacity_Class_Value* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LoadValue                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LoadValue (ASN1CTXT* pctxt, LoadValue* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTLoadValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RTLoadValue (ASN1CTXT* pctxt, RTLoadValue* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NRTLoadInformationValue                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NRTLoadInformationValue (ASN1CTXT* pctxt, NRTLoadInformationValue* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformation_iE_Extensions_element (ASN1CTXT* pctxt, CellLoadInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CellLoadInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CellLoadInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   CellLoadInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CellLoadInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CellLoadInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CellLoadInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CellLoadInformation_ExtIEs[index].ExtensionSize);
   stat = CellLoadInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformation_iE_Extensions (ASN1CTXT* pctxt, CellLoadInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CellLoadInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellLoadInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellLoadInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformation (ASN1CTXT* pctxt, CellLoadInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rTLoadValuePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nRTLoadInformationValuePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode cell_Capacity_Class_Value */

   stat = asn1PD_Cell_Capacity_Class_Value (pctxt, &pvalue->cell_Capacity_Class_Value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode loadValue */

   stat = asn1PD_LoadValue (pctxt, &pvalue->loadValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rTLoadValue */

   if (pvalue->m.rTLoadValuePresent) {
      stat = asn1PD_RTLoadValue (pctxt, &pvalue->rTLoadValue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode nRTLoadInformationValue */

   if (pvalue->m.nRTLoadInformationValuePresent) {
      stat = asn1PD_NRTLoadInformationValue (pctxt, &pvalue->nRTLoadInformationValue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CellLoadInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformationGroup_iE_Extensions_element (ASN1CTXT* pctxt, CellLoadInformationGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_CellLoadInformationGroup_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_CellLoadInformationGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   CellLoadInformationGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CellLoadInformationGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CellLoadInformationGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CellLoadInformationGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, CellLoadInformationGroup_ExtIEs[index].ExtensionSize);
   stat = CellLoadInformationGroup_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformationGroup_iE_Extensions (ASN1CTXT* pctxt, CellLoadInformationGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   CellLoadInformationGroup_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellLoadInformationGroup_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellLoadInformationGroup_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellLoadInformationGroup (ASN1CTXT* pctxt, CellLoadInformationGroup* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uplinkCellLoadInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.downlinkCellLoadInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode sourceCellID */

   stat = asn1PD_SourceCellID (pctxt, &pvalue->sourceCellID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uplinkCellLoadInformation */

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      stat = asn1PD_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode downlinkCellLoadInformation */

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      stat = asn1PD_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_CellLoadInformationGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1*) pvalue_;

   stat = asn1PD_CellLoadInformationGroup (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceReference                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceReference (ASN1CTXT* pctxt, TraceReference* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionReference                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceRecordingSessionReference (ASN1CTXT* pctxt, TraceRecordingSessionReference* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceRecordingSessionInformation_iE_Extensions_element (ASN1CTXT* pctxt, TraceRecordingSessionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TraceRecordingSessionInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TraceRecordingSessionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   TraceRecordingSessionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TraceRecordingSessionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TraceRecordingSessionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TraceRecordingSessionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TraceRecordingSessionInformation_ExtIEs[index].ExtensionSize);
   stat = TraceRecordingSessionInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceRecordingSessionInformation_iE_Extensions (ASN1CTXT* pctxt, TraceRecordingSessionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TraceRecordingSessionInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TraceRecordingSessionInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TraceRecordingSessionInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceRecordingSessionInformation (ASN1CTXT* pctxt, TraceRecordingSessionInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode traceReference */

   stat = asn1PD_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode traceRecordingSessionReference */

   stat = asn1PD_TraceRecordingSessionReference (pctxt, &pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TraceRecordingSessionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2*) pvalue_;

   stat = asn1PD_TraceRecordingSessionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSLinkingInformation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSLinkingInformation (ASN1CTXT* pctxt, MBMSLinkingInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = uE_has_joined_multicast_services; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3*) pvalue_;

   stat = asn1PD_MBMSLinkingInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].ExtensionSize);
   stat = SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceRNC_ToTargetRNC_TransparentContainer (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.chosenIntegrityProtectionAlgorithmPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.integrityProtectionKeyPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.chosenEncryptionAlgorithForSignallingPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cipheringKeyPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.chosenEncryptionAlgorithForCSPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.chosenEncryptionAlgorithForPSPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.d_RNTIPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.targetCellIdPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rAB_TrCH_MappingPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rRC_Container */

   stat = asn1PD_RRC_Container (pctxt, &pvalue->rRC_Container);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode numberOfIuInstances */

   stat = asn1PD_NumberOfIuInstances (pctxt, &pvalue->numberOfIuInstances);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode relocationType */

   stat = asn1PD_RelocationType (pctxt, &pvalue->relocationType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode chosenIntegrityProtectionAlgorithm */

   if (pvalue->m.chosenIntegrityProtectionAlgorithmPresent) {
      stat = asn1PD_ChosenIntegrityProtectionAlgorithm (pctxt, &pvalue->chosenIntegrityProtectionAlgorithm);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode integrityProtectionKey */

   if (pvalue->m.integrityProtectionKeyPresent) {
      stat = asn1PD_IntegrityProtectionKey (pctxt, &pvalue->integrityProtectionKey);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode chosenEncryptionAlgorithForSignalling */

   if (pvalue->m.chosenEncryptionAlgorithForSignallingPresent) {
      stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForSignalling);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode cipheringKey */

   if (pvalue->m.cipheringKeyPresent) {
      stat = asn1PD_EncryptionKey (pctxt, &pvalue->cipheringKey);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode chosenEncryptionAlgorithForCS */

   if (pvalue->m.chosenEncryptionAlgorithForCSPresent) {
      stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode chosenEncryptionAlgorithForPS */

   if (pvalue->m.chosenEncryptionAlgorithForPSPresent) {
      stat = asn1PD_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForPS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode d_RNTI */

   if (pvalue->m.d_RNTIPresent) {
      stat = asn1PD_D_RNTI (pctxt, &pvalue->d_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode targetCellId */

   if (pvalue->m.targetCellIdPresent) {
      stat = asn1PD_TargetCellId (pctxt, &pvalue->targetCellId);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAB_TrCH_Mapping */

   if (pvalue->m.rAB_TrCH_MappingPresent) {
      stat = asn1PD_RAB_TrCH_Mapping (pctxt, &pvalue->rAB_TrCH_Mapping);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OldBSS_ToNewBSS_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_OldBSS_ToNewBSS_Information (ASN1CTXT* pctxt, OldBSS_ToNewBSS_Information* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Classmark                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Classmark (ASN1CTXT* pctxt, GERAN_Classmark* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceBSS_ToTargetBSS_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceBSS_ToTargetBSS_TransparentContainer (ASN1CTXT* pctxt, SourceBSS_ToTargetBSS_TransparentContainer* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].ExtensionSize);
   stat = TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetRNC_ToSourceRNC_TransparentContainer (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.d_RNTIPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rRC_Container */

   stat = asn1PD_RRC_Container (pctxt, &pvalue->rRC_Container);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode d_RNTI */

   if (pvalue->m.d_RNTIPresent) {
      stat = asn1PD_D_RNTI (pctxt, &pvalue->d_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  L3_Information                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_L3_Information (ASN1CTXT* pctxt, L3_Information* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerAddress                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerAddress (ASN1CTXT* pctxt, TransportLayerAddress* pvalue)
{
   static Asn1SizeCnst lsize2 = { 1, OSUINTCONST(0), OSUINT32_MAX, 0 };
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(160), 0 };
   int stat = 0;

   lsize1.next = &lsize2;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_DynBitString (pctxt, (ASN1DynBitStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GTP_TEI                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GTP_TEI (ASN1CTXT* pctxt, GTP_TEI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BindingID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BindingID (ASN1CTXT* pctxt, BindingID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IuTransportAssociation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IuTransportAssociation (ASN1CTXT* pctxt, IuTransportAssociation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* gTP_TEI */
         case 0:
            pvalue->u.gTP_TEI = rtMemAllocTypeZ (pctxt, GTP_TEI);
            if (pvalue->u.gTP_TEI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GTP_TEI (pctxt, pvalue->u.gTP_TEI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* bindingID */
         case 1:
            pvalue->u.bindingID = rtMemAllocTypeZ (pctxt, BindingID);
            if (pvalue->u.bindingID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_BindingID (pctxt, pvalue->u.bindingID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterSystemInformation_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InterSystemInformation_TransparentContainer_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InterSystemInformation_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   InterSystemInformation_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InterSystemInformation_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InterSystemInformation_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InterSystemInformation_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InterSystemInformation_TransparentContainer_ExtIEs[index].ExtensionSize);
   stat = InterSystemInformation_TransparentContainer_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterSystemInformation_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InterSystemInformation_TransparentContainer_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InterSystemInformation_TransparentContainer_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InterSystemInformation_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterSystemInformation_TransparentContainer (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.downlinkCellLoadInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uplinkCellLoadInformationPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode downlinkCellLoadInformation */

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      stat = asn1PD_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uplinkCellLoadInformation */

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      stat = asn1PD_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_InterSystemInformation_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetBSS_ToSourceBSS_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TargetBSS_ToSourceBSS_TransparentContainer (ASN1CTXT* pctxt, TargetBSS_ToSourceBSS_TransparentContainer* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMSI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMSI (ASN1CTXT* pctxt, IMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermanentNAS_UE_ID                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PermanentNAS_UE_ID (ASN1CTXT* pctxt, PermanentNAS_UE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iMSI */
         case 0:
            pvalue->u.iMSI = rtMemAllocTypeZ (pctxt, IMSI);
            if (pvalue->u.iMSI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMSI (pctxt, pvalue->u.iMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_SynchronisationIndicator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NAS_SynchronisationIndicator (ASN1CTXT* pctxt, NAS_SynchronisationIndicator* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrafficClass                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrafficClass (ASN1CTXT* pctxt, TrafficClass* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = conversational; break;
         case 1: *pvalue = streaming; break;
         case 2: *pvalue = interactive; break;
         case 3: *pvalue = background; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AsymmetryIndicator                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_AsymmetryIndicator (ASN1CTXT* pctxt, RAB_AsymmetryIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = symmetric_bidirectional; break;
         case 1: *pvalue = asymmetric_unidirectional_downlink; break;
         case 2: *pvalue = asymmetric_unidirectional_uplink; break;
         case 3: *pvalue = asymmetric_bidirectional; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxBitrate                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaxBitrate (ASN1CTXT* pctxt, MaxBitrate* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(16000000));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameter_MaxBitrateList                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MaxBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GuaranteedBitrate                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GuaranteedBitrate (ASN1CTXT* pctxt, GuaranteedBitrate* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(16000000));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameter_GuaranteedBitrateList                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeliveryOrder                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeliveryOrder (ASN1CTXT* pctxt, DeliveryOrder* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = delivery_order_requested; break;
      case 1: *pvalue = delivery_order_not_requested; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxSDU_Size                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaxSDU_Size (ASN1CTXT* pctxt, MaxSDU_Size* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(32768));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_ErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt, SDU_ErrorRatio_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SDU_ErrorRatio_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SDU_ErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_ErrorRatio_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_ErrorRatio_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_ErrorRatio_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_ErrorRatio_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SDU_ErrorRatio_ExtIEs[index].ExtensionSize);
   stat = SDU_ErrorRatio_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_ErrorRatio_iE_Extensions (ASN1CTXT* pctxt, SDU_ErrorRatio_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SDU_ErrorRatio_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_ErrorRatio_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_ErrorRatio_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_ErrorRatio (ASN1CTXT* pctxt, SDU_ErrorRatio* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode mantissa */

   stat = pd_ConsUInt8 (pctxt, &pvalue->mantissa, OSUINTCONST(1), OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode exponent */

   stat = pd_ConsUInt8 (pctxt, &pvalue->exponent, OSUINTCONST(1), OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SDU_ErrorRatio_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResidualBitErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt, ResidualBitErrorRatio_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_ResidualBitErrorRatio_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_ResidualBitErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt,
   ResidualBitErrorRatio_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResidualBitErrorRatio_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResidualBitErrorRatio_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResidualBitErrorRatio_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, ResidualBitErrorRatio_ExtIEs[index].ExtensionSize);
   stat = ResidualBitErrorRatio_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResidualBitErrorRatio_iE_Extensions (ASN1CTXT* pctxt, ResidualBitErrorRatio_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   ResidualBitErrorRatio_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ResidualBitErrorRatio_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ResidualBitErrorRatio_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResidualBitErrorRatio (ASN1CTXT* pctxt, ResidualBitErrorRatio* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode mantissa */

   stat = pd_ConsUInt8 (pctxt, &pvalue->mantissa, OSUINTCONST(1), OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode exponent */

   stat = pd_ConsUInt8 (pctxt, &pvalue->exponent, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_ResidualBitErrorRatio_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeliveryOfErroneousSDU                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeliveryOfErroneousSDU (ASN1CTXT* pctxt, DeliveryOfErroneousSDU* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = yes; break;
      case 1: *pvalue = no; break;
      case 2: *pvalue = no_error_detection_consideration; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SubflowSDU_Size                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SubflowSDU_Size (ASN1CTXT* pctxt, SubflowSDU_Size* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SubflowCombinationBitRate                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_SubflowCombinationBitRate (ASN1CTXT* pctxt, RAB_SubflowCombinationBitRate* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(16000000));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_FormatInformationParameters_element_iE_Extensions_element (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SDU_FormatInformationParameters_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SDU_FormatInformationParameters_element_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_FormatInformationParameters_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_FormatInformationParameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_FormatInformationParameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_FormatInformationParameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SDU_FormatInformationParameters_ExtIEs[index].ExtensionSize);
   stat = SDU_FormatInformationParameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_FormatInformationParameters_element_iE_Extensions (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SDU_FormatInformationParameters_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_FormatInformationParameters_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_FormatInformationParameters_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_FormatInformationParameters_element (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.subflowSDU_SizePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rAB_SubflowCombinationBitRatePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode subflowSDU_Size */

   if (pvalue->m.subflowSDU_SizePresent) {
      stat = asn1PD_SubflowSDU_Size (pctxt, &pvalue->subflowSDU_Size);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAB_SubflowCombinationBitRate */

   if (pvalue->m.rAB_SubflowCombinationBitRatePresent) {
      stat = asn1PD_RAB_SubflowCombinationBitRate (pctxt, &pvalue->rAB_SubflowCombinationBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SDU_FormatInformationParameters_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_FormatInformationParameters (ASN1CTXT* pctxt, SDU_FormatInformationParameters* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   SDU_FormatInformationParameters_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_FormatInformationParameters_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_FormatInformationParameters_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_Parameters_element_iE_Extensions_element (ASN1CTXT* pctxt, SDU_Parameters_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SDU_Parameters_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SDU_Parameters_element_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_Parameters_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SDU_Parameters_ExtIEs[index].ExtensionSize);
   stat = SDU_Parameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_Parameters_element_iE_Extensions (ASN1CTXT* pctxt, SDU_Parameters_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SDU_Parameters_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_Parameters_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_Parameters_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_Parameters_element (ASN1CTXT* pctxt, SDU_Parameters_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sDU_ErrorRatioPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sDU_FormatInformationParametersPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode sDU_ErrorRatio */

   if (pvalue->m.sDU_ErrorRatioPresent) {
      stat = asn1PD_SDU_ErrorRatio (pctxt, &pvalue->sDU_ErrorRatio);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode residualBitErrorRatio */

   stat = asn1PD_ResidualBitErrorRatio (pctxt, &pvalue->residualBitErrorRatio);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode deliveryOfErroneousSDU */

   stat = asn1PD_DeliveryOfErroneousSDU (pctxt, &pvalue->deliveryOfErroneousSDU);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode sDU_FormatInformationParameters */

   if (pvalue->m.sDU_FormatInformationParametersPresent) {
      stat = asn1PD_SDU_FormatInformationParameters (pctxt, &pvalue->sDU_FormatInformationParameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SDU_Parameters_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SDU_Parameters (ASN1CTXT* pctxt, SDU_Parameters* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(7), 0 };
   int stat = 0;
   SDU_Parameters_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SDU_Parameters_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SDU_Parameters_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransferDelay                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransferDelay (ASN1CTXT* pctxt, TransferDelay* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrafficHandlingPriority                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TrafficHandlingPriority (ASN1CTXT* pctxt, TrafficHandlingPriority* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityLevel                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityLevel (ASN1CTXT* pctxt, PriorityLevel* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionCapability                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Pre_emptionCapability (ASN1CTXT* pctxt, Pre_emptionCapability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = shall_not_trigger_pre_emption; break;
      case 1: *pvalue = may_trigger_pre_emption; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionVulnerability                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Pre_emptionVulnerability (ASN1CTXT* pctxt, Pre_emptionVulnerability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = not_pre_emptable; break;
      case 1: *pvalue = pre_emptable; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QueuingAllowed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_QueuingAllowed (ASN1CTXT* pctxt, QueuingAllowed* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = queueing_not_allowed; break;
      case 1: *pvalue = queueing_allowed; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllocationOrRetentionPriority_iE_Extensions_element (ASN1CTXT* pctxt, AllocationOrRetentionPriority_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_AllocationOrRetentionPriority_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_AllocationOrRetentionPriority_iE_Extensions_element (ASN1CTXT* pctxt,
   AllocationOrRetentionPriority_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < AllocationOrRetentionPriority_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &AllocationOrRetentionPriority_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == AllocationOrRetentionPriority_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, AllocationOrRetentionPriority_ExtIEs[index].ExtensionSize);
   stat = AllocationOrRetentionPriority_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllocationOrRetentionPriority_iE_Extensions (ASN1CTXT* pctxt, AllocationOrRetentionPriority_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   AllocationOrRetentionPriority_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AllocationOrRetentionPriority_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AllocationOrRetentionPriority_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllocationOrRetentionPriority (ASN1CTXT* pctxt, AllocationOrRetentionPriority* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode priorityLevel */

   stat = asn1PD_PriorityLevel (pctxt, &pvalue->priorityLevel);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode pre_emptionCapability */

   stat = asn1PD_Pre_emptionCapability (pctxt, &pvalue->pre_emptionCapability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode pre_emptionVulnerability */

   stat = asn1PD_Pre_emptionVulnerability (pctxt, &pvalue->pre_emptionVulnerability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode queuingAllowed */

   stat = asn1PD_QueuingAllowed (pctxt, &pvalue->queuingAllowed);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_AllocationOrRetentionPriority_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceStatisticsDescriptor                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SourceStatisticsDescriptor (ASN1CTXT* pctxt, SourceStatisticsDescriptor* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = speech; break;
         case 1: *pvalue = unknown; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequirement                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RelocationRequirement (ASN1CTXT* pctxt, RelocationRequirement* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = realtime; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = lossless; break;
         case 1: *pvalue = none; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignallingIndication                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SignallingIndication (ASN1CTXT* pctxt, SignallingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = signalling; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_Parameters_ExtIEs_Extension                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__RAB_Parameters_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_Parameters_ExtIEs_Extension *pvalue = (_RAB_Parameters_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_SignallingIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAB_Parameters_ExtIEs[index].ExtensionSize);
   stat = RAB_Parameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAB_Parameters_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAB_Parameters_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAB_Parameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAB_Parameters (ASN1CTXT* pctxt, RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.guaranteedBitRatePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transferDelayPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.trafficHandlingPriorityPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allocationOrRetentionPriorityPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sourceStatisticsDescriptorPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.relocationRequirementPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode trafficClass */

   stat = asn1PD_TrafficClass (pctxt, &pvalue->trafficClass);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rAB_AsymmetryIndicator */

   stat = asn1PD_RAB_AsymmetryIndicator (pctxt, &pvalue->rAB_AsymmetryIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode maxBitrate */

   stat = asn1PD_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->maxBitrate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode guaranteedBitRate */

   if (pvalue->m.guaranteedBitRatePresent) {
      stat = asn1PD_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->guaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode deliveryOrder */

   stat = asn1PD_DeliveryOrder (pctxt, &pvalue->deliveryOrder);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode maxSDU_Size */

   stat = asn1PD_MaxSDU_Size (pctxt, &pvalue->maxSDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode sDU_Parameters */

   stat = asn1PD_SDU_Parameters (pctxt, &pvalue->sDU_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode transferDelay */

   if (pvalue->m.transferDelayPresent) {
      stat = asn1PD_TransferDelay (pctxt, &pvalue->transferDelay);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode trafficHandlingPriority */

   if (pvalue->m.trafficHandlingPriorityPresent) {
      stat = asn1PD_TrafficHandlingPriority (pctxt, &pvalue->trafficHandlingPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode allocationOrRetentionPriority */

   if (pvalue->m.allocationOrRetentionPriorityPresent) {
      stat = asn1PD_AllocationOrRetentionPriority (pctxt, &pvalue->allocationOrRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode sourceStatisticsDescriptor */

   if (pvalue->m.sourceStatisticsDescriptorPresent) {
      stat = asn1PD_SourceStatisticsDescriptor (pctxt, &pvalue->sourceStatisticsDescriptor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode relocationRequirement */

   if (pvalue->m.relocationRequirementPresent) {
      stat = asn1PD_RelocationRequirement (pctxt, &pvalue->relocationRequirement);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportingIndication                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DataVolumeReportingIndication (ASN1CTXT* pctxt, DataVolumeReportingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = do_report; break;
      case 1: *pvalue = do_not_report; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDP_Type                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDP_Type (ASN1CTXT* pctxt, PDP_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = empty; break;
         case 1: *pvalue = ppp; break;
         case 2: *pvalue = osp_ihoss; break;
         case 3: *pvalue = ipv4; break;
         case 4: *pvalue = ipv6; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDP_TypeInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDP_TypeInformation (ASN1CTXT* pctxt, PDP_TypeInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_PDP_Type (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneMode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UserPlaneMode (ASN1CTXT* pctxt, UserPlaneMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = transparent_mode; break;
         case 1: *pvalue = support_mode_for_predefined_SDU_sizes; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UP_ModeVersions                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UP_ModeVersions (ASN1CTXT* pctxt, UP_ModeVersions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Service_Handover                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Service_Handover (ASN1CTXT* pctxt, Service_Handover* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = handover_to_GSM_should_be_performed; break;
         case 1: *pvalue = handover_to_GSM_should_not_be_performed; break;
         case 2: *pvalue = handover_to_GSM_shall_not_be_performed; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateType                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_MaxBitrateType (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = unspecified_1; break;
         case 1: *pvalue = value_range_1; break;
         case 2: *pvalue = discrete_values_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MaxBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrates                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_MaxBitrates (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Alt_RAB_Parameter_MaxBitrateList* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Alt_RAB_Parameter_MaxBitrateList);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Alt_RAB_Parameter_MaxBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateInf                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_MaxBitrateInf (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.altMaxBitratesPresent = optbit;

   /* decode altMaxBitrateType */

   stat = asn1PD_Alt_RAB_Parameter_MaxBitrateType (pctxt, &pvalue->altMaxBitrateType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altMaxBitrates */

   if (pvalue->m.altMaxBitratesPresent) {
      stat = asn1PD_Alt_RAB_Parameter_MaxBitrates (pctxt, &pvalue->altMaxBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateType                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_GuaranteedBitrateType (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = unspecified; break;
         case 1: *pvalue = value_range; break;
         case 2: *pvalue = discrete_values; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateList                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrates                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_GuaranteedBitrates (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Alt_RAB_Parameter_GuaranteedBitrateList* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Alt_RAB_Parameter_GuaranteedBitrateList);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Alt_RAB_Parameter_GuaranteedBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateInf                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameter_GuaranteedBitrateInf (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.altGuaranteedBitratesPresent = optbit;

   /* decode altGuaranteedBitrateType */

   stat = asn1PD_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, &pvalue->altGuaranteedBitrateType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altGuaranteedBitrates */

   if (pvalue->m.altGuaranteedBitratesPresent) {
      stat = asn1PD_Alt_RAB_Parameter_GuaranteedBitrates (pctxt, &pvalue->altGuaranteedBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Alt_RAB_Parameters_ExtIEs_Extension                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Alt_RAB_Parameters_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Alt_RAB_Parameters_ExtIEs_Extension *pvalue = (_Alt_RAB_Parameters_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, Alt_RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Alt_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Alt_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   Alt_RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Alt_RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Alt_RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Alt_RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Alt_RAB_Parameters_ExtIEs[index].ExtensionSize);
   stat = Alt_RAB_Parameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, Alt_RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Alt_RAB_Parameters_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Alt_RAB_Parameters_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Alt_RAB_Parameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Alt_RAB_Parameters (ASN1CTXT* pctxt, Alt_RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.altMaxBitrateInfPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.altGuaranteedBitRateInfPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode altMaxBitrateInf */

   if (pvalue->m.altMaxBitrateInfPresent) {
      stat = asn1PD_Alt_RAB_Parameter_MaxBitrateInf (pctxt, &pvalue->altMaxBitrateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode altGuaranteedBitRateInf */

   if (pvalue->m.altGuaranteedBitRateInfPresent) {
      stat = asn1PD_Alt_RAB_Parameter_GuaranteedBitrateInf (pctxt, &pvalue->altGuaranteedBitRateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_Alt_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_BSC_Container                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_BSC_Container (ASN1CTXT* pctxt, GERAN_BSC_Container* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermittedIntegrityProtectionAlgorithms                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PermittedIntegrityProtectionAlgorithms (ASN1CTXT* pctxt, PermittedIntegrityProtectionAlgorithms* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (16 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_IntegrityProtectionAlgorithm (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionInformation_iE_Extensions_element (ASN1CTXT* pctxt, IntegrityProtectionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_IntegrityProtectionInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_IntegrityProtectionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   IntegrityProtectionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IntegrityProtectionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IntegrityProtectionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IntegrityProtectionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, IntegrityProtectionInformation_ExtIEs[index].ExtensionSize);
   stat = IntegrityProtectionInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionInformation_iE_Extensions (ASN1CTXT* pctxt, IntegrityProtectionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   IntegrityProtectionInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, IntegrityProtectionInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_IntegrityProtectionInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntegrityProtectionInformation (ASN1CTXT* pctxt, IntegrityProtectionInformation* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode permittedAlgorithms */

   stat = asn1PD_PermittedIntegrityProtectionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode key */

   stat = asn1PD_IntegrityProtectionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_IntegrityProtectionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermittedEncryptionAlgorithms                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PermittedEncryptionAlgorithms (ASN1CTXT* pctxt, PermittedEncryptionAlgorithms* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (16 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_EncryptionAlgorithm (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionInformation_iE_Extensions_element (ASN1CTXT* pctxt, EncryptionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_EncryptionInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_EncryptionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   EncryptionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < EncryptionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &EncryptionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == EncryptionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, EncryptionInformation_ExtIEs[index].ExtensionSize);
   stat = EncryptionInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionInformation_iE_Extensions (ASN1CTXT* pctxt, EncryptionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   EncryptionInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, EncryptionInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_EncryptionInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EncryptionInformation (ASN1CTXT* pctxt, EncryptionInformation* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode permittedAlgorithms */

   stat = asn1PD_PermittedEncryptionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode key */

   stat = asn1PD_EncryptionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_EncryptionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IuSignallingConnectionIdentifier                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IuSignallingConnectionIdentifier (ASN1CTXT* pctxt, IuSignallingConnectionIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_ID                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CN_ID (ASN1CTXT* pctxt, CN_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GlobalCN_ID                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GlobalCN_ID (ASN1CTXT* pctxt, GlobalCN_ID* pvalue)
{
   int stat = 0;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cN_ID */

   stat = asn1PD_CN_ID (pctxt, &pvalue->cN_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNAC                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SNAC (ASN1CTXT* pctxt, SNAC* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedSNAs                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedSNAs (ASN1CTXT* pctxt, AuthorisedSNAs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, SNAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_SNAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedPLMNs_element_iE_Extensions_element (ASN1CTXT* pctxt, AuthorisedPLMNs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_AuthorisedPLMNs_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_AuthorisedPLMNs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   AuthorisedPLMNs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < AuthorisedPLMNs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &AuthorisedPLMNs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == AuthorisedPLMNs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, AuthorisedPLMNs_ExtIEs[index].ExtensionSize);
   stat = AuthorisedPLMNs_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedPLMNs_element_iE_Extensions (ASN1CTXT* pctxt, AuthorisedPLMNs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   AuthorisedPLMNs_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AuthorisedPLMNs_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AuthorisedPLMNs_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedPLMNs_element (ASN1CTXT* pctxt, AuthorisedPLMNs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.authorisedSNAsListPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode authorisedSNAsList */

   if (pvalue->m.authorisedSNAsListPresent) {
      stat = asn1PD_AuthorisedSNAs (pctxt, &pvalue->authorisedSNAsList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_AuthorisedPLMNs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuthorisedPLMNs (ASN1CTXT* pctxt, AuthorisedPLMNs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   AuthorisedPLMNs_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AuthorisedPLMNs_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AuthorisedPLMNs_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SNA_Access_Information_iE_Extensions_element (ASN1CTXT* pctxt, SNA_Access_Information_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_SNA_Access_Information_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_SNA_Access_Information_iE_Extensions_element (ASN1CTXT* pctxt,
   SNA_Access_Information_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SNA_Access_Information_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SNA_Access_Information_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SNA_Access_Information_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, SNA_Access_Information_ExtIEs[index].ExtensionSize);
   stat = SNA_Access_Information_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SNA_Access_Information_iE_Extensions (ASN1CTXT* pctxt, SNA_Access_Information_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   SNA_Access_Information_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SNA_Access_Information_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SNA_Access_Information_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SNA_Access_Information (ASN1CTXT* pctxt, SNA_Access_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode authorisedPLMNs */

   stat = asn1PD_AuthorisedPLMNs (pctxt, &pvalue->authorisedPLMNs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_SNA_Access_Information_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_IuA                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_IuA (ASN1CTXT* pctxt, UESBI_IuA* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_IuB                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_IuB (ASN1CTXT* pctxt, UESBI_IuB* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_Iu_iE_Extensions_element (ASN1CTXT* pctxt, UESBI_Iu_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_UESBI_Iu_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_UESBI_Iu_iE_Extensions_element (ASN1CTXT* pctxt,
   UESBI_Iu_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESBI_Iu_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESBI_Iu_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UESBI_Iu_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, UESBI_Iu_ExtIEs[index].ExtensionSize);
   stat = UESBI_Iu_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_Iu_iE_Extensions (ASN1CTXT* pctxt, UESBI_Iu_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   UESBI_Iu_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UESBI_Iu_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UESBI_Iu_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UESBI_Iu (ASN1CTXT* pctxt, UESBI_Iu* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uESBI_IuAPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uESBI_IuBPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode uESBI_IuA */

   if (pvalue->m.uESBI_IuAPresent) {
      stat = asn1PD_UESBI_IuA (pctxt, &pvalue->uESBI_IuA);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uESBI_IuB */

   if (pvalue->m.uESBI_IuBPresent) {
      stat = asn1PD_UESBI_IuB (pctxt, &pvalue->uESBI_IuB);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_UESBI_Iu_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_serviceID                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMGI_serviceID (ASN1CTXT* pctxt, TMGI_serviceID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMGI_iE_Extensions_element (ASN1CTXT* pctxt, TMGI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TMGI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TMGI_iE_Extensions_element (ASN1CTXT* pctxt,
   TMGI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TMGI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TMGI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TMGI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TMGI_ExtIEs[index].ExtensionSize);
   stat = TMGI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMGI_iE_Extensions (ASN1CTXT* pctxt, TMGI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TMGI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TMGI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TMGI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMGI (ASN1CTXT* pctxt, TMGI* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode serviceID */

   stat = asn1PD_TMGI_serviceID (pctxt, &pvalue->serviceID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TMGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMS_PTP_RAB_ID                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMS_PTP_RAB_ID (ASN1CTXT* pctxt, MBMS_PTP_RAB_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameter_MaxBitrateList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Ass_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MaxBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameter_GuaranteedBitrateList                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Ass_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, Ass_RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Ass_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Ass_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   Ass_RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Ass_RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Ass_RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Ass_RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Ass_RAB_Parameters_ExtIEs[index].ExtensionSize);
   stat = Ass_RAB_Parameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, Ass_RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Ass_RAB_Parameters_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Ass_RAB_Parameters_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Ass_RAB_Parameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ass_RAB_Parameters (ASN1CTXT* pctxt, Ass_RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.assMaxBitrateInfPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.assGuaranteedBitRateInfPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode assMaxBitrateInf */

   if (pvalue->m.assMaxBitrateInfPresent) {
      stat = asn1PD_Ass_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->assMaxBitrateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode assGuaranteedBitRateInf */

   if (pvalue->m.assGuaranteedBitRateInfPresent) {
      stat = asn1PD_Ass_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->assGuaranteedBitRateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_Ass_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewBSS_To_OldBSS_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NewBSS_To_OldBSS_Information (ASN1CTXT* pctxt, NewBSS_To_OldBSS_Information* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_N_PDU_SequenceNumber                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_N_PDU_SequenceNumber (ASN1CTXT* pctxt, DL_N_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_N_PDU_SequenceNumber                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_N_PDU_SequenceNumber (ASN1CTXT* pctxt, UL_N_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyStatus                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_KeyStatus (ASN1CTXT* pctxt, KeyStatus* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = old; break;
         case 1: *pvalue = new_; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GlobalRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GlobalRNC_ID (ASN1CTXT* pctxt, GlobalRNC_ID* pvalue)
{
   int stat = 0;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rNC_ID */

   stat = asn1PD_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMSI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TMSI (ASN1CTXT* pctxt, TMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_TMSI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_P_TMSI (ASN1CTXT* pctxt, P_TMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TemporaryUE_ID                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TemporaryUE_ID (ASN1CTXT* pctxt, TemporaryUE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* tMSI */
         case 0:
            pvalue->u.tMSI = rtMemAllocTypeZ (pctxt, TMSI);
            if (pvalue->u.tMSI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_TMSI (pctxt, pvalue->u.tMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* p_TMSI */
         case 1:
            pvalue->u.p_TMSI = rtMemAllocTypeZ (pctxt, P_TMSI);
            if (pvalue->u.p_TMSI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_P_TMSI (pctxt, pvalue->u.p_TMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAI_iE_Extensions_element (ASN1CTXT* pctxt, RAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RAI_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RAI_iE_Extensions_element (ASN1CTXT* pctxt,
   RAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RAI_ExtIEs[index].ExtensionSize);
   stat = RAI_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAI_iE_Extensions (ASN1CTXT* pctxt, RAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RAI_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RAI_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAI (ASN1CTXT* pctxt, RAI* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAI */

   stat = asn1PD_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rAC */

   stat = asn1PD_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PagingAreaID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PagingAreaID (ASN1CTXT* pctxt, PagingAreaID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* lAI */
         case 0:
            pvalue->u.lAI = rtMemAllocTypeZ (pctxt, LAI);
            if (pvalue->u.lAI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_LAI (pctxt, pvalue->u.lAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* rAI */
         case 1:
            pvalue->u.rAI = rtMemAllocTypeZ (pctxt, RAI);
            if (pvalue->u.rAI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RAI (pctxt, pvalue->u.rAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PagingCause                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PagingCause (ASN1CTXT* pctxt, PagingCause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = terminating_high_priority_signalling; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = terminating_conversational_call; break;
         case 1: *pvalue = terminating_streaming_call; break;
         case 2: *pvalue = terminating_interactive_call; break;
         case 3: *pvalue = terminating_background_call; break;
         case 4: *pvalue = terminating_low_priority_signalling; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonSearchingIndication                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NonSearchingIndication (ASN1CTXT* pctxt, NonSearchingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = non_searching; break;
      case 1: *pvalue = searching; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DRX_CycleLengthCoefficient                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DRX_CycleLengthCoefficient (ASN1CTXT* pctxt, DRX_CycleLengthCoefficient* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(6), OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceType (ASN1CTXT* pctxt, TraceType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TriggerID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TriggerID (ASN1CTXT* pctxt, TriggerID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(22), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEI (ASN1CTXT* pctxt, IMEI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISV                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISV (ASN1CTXT* pctxt, IMEISV* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UE_ID                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UE_ID (ASN1CTXT* pctxt, UE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* imsi */
         case 0:
            pvalue->u.imsi = rtMemAllocTypeZ (pctxt, IMSI);
            if (pvalue->u.imsi == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMSI (pctxt, pvalue->u.imsi);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* imei */
         case 1:
            pvalue->u.imei = rtMemAllocTypeZ (pctxt, IMEI);
            if (pvalue->u.imei == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEI (pctxt, pvalue->u.imei);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* imeisv */
         case 3:
            pvalue->u.imeisv = rtMemAllocTypeZ (pctxt, IMEISV);
            if (pvalue->u.imeisv == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEISV (pctxt, pvalue->u.imeisv);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      rtCopyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OMC_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_OMC_ID (ASN1CTXT* pctxt, OMC_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(22), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceDepth                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TraceDepth (ASN1CTXT* pctxt, TraceDepth* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = minimum; break;
         case 1: *pvalue = medium; break;
         case 2: *pvalue = maximum; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_interface_                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterfacesToTraceItem_interface_ (ASN1CTXT* pctxt, InterfacesToTraceItem_interface_* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = iu_cs; break;
         case 1: *pvalue = iu_ps; break;
         case 2: *pvalue = iur; break;
         case 3: *pvalue = iub; break;
         case 4: *pvalue = uu; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterfacesToTraceItem_iE_Extensions_element (ASN1CTXT* pctxt, InterfacesToTraceItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_InterfacesToTraceItem_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_InterfacesToTraceItem_iE_Extensions_element (ASN1CTXT* pctxt,
   InterfacesToTraceItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InterfacesToTraceItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InterfacesToTraceItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InterfacesToTraceItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, InterfacesToTraceItem_ExtIEs[index].ExtensionSize);
   stat = InterfacesToTraceItem_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterfacesToTraceItem_iE_Extensions (ASN1CTXT* pctxt, InterfacesToTraceItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   InterfacesToTraceItem_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InterfacesToTraceItem_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InterfacesToTraceItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterfacesToTraceItem (ASN1CTXT* pctxt, InterfacesToTraceItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode interface_ */

   stat = asn1PD_InterfacesToTraceItem_interface_ (pctxt, &pvalue->interface_);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_InterfacesToTraceItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ListOfInterfacesToTrace                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ListOfInterfacesToTrace (ASN1CTXT* pctxt, ListOfInterfacesToTrace* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   InterfacesToTraceItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, InterfacesToTraceItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_InterfacesToTraceItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TracePropagationParameters_iE_Extensions_element (ASN1CTXT* pctxt, TracePropagationParameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_TracePropagationParameters_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_TracePropagationParameters_iE_Extensions_element (ASN1CTXT* pctxt,
   TracePropagationParameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TracePropagationParameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TracePropagationParameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TracePropagationParameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, TracePropagationParameters_ExtIEs[index].ExtensionSize);
   stat = TracePropagationParameters_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TracePropagationParameters_iE_Extensions (ASN1CTXT* pctxt, TracePropagationParameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   TracePropagationParameters_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TracePropagationParameters_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TracePropagationParameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TracePropagationParameters (ASN1CTXT* pctxt, TracePropagationParameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.listOfInterfacesToTracePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode traceRecordingSessionReference */

   stat = asn1PD_TraceRecordingSessionReference (pctxt, &pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode traceDepth */

   stat = asn1PD_TraceDepth (pctxt, &pvalue->traceDepth);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode listOfInterfacesToTrace */

   if (pvalue->m.listOfInterfacesToTracePresent) {
      stat = asn1PD_ListOfInterfacesToTrace (pctxt, &pvalue->listOfInterfacesToTrace);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_TracePropagationParameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Event                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Event (ASN1CTXT* pctxt, Event* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = stop_direct; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = stop_change_of_service_area; break;
         case 1: *pvalue = direct; break;
         case 2: *pvalue = change_of_servicearea; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportArea                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportArea (ASN1CTXT* pctxt, ReportArea* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = service_area; break;
         case 1: *pvalue = geographical_area; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestType (ASN1CTXT* pctxt, RequestType* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.accuracyCodePresent = optbit;

   /* decode event */

   stat = asn1PD_Event (pctxt, &pvalue->event);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode reportArea */

   stat = asn1PD_ReportArea (pctxt, &pvalue->reportArea);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode accuracyCode */

   if (pvalue->m.accuracyCodePresent) {
      stat = pd_ConsUInt8 (pctxt, &pvalue->accuracyCode, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VerticalAccuracyCode                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_VerticalAccuracyCode (ASN1CTXT* pctxt, VerticalAccuracyCode* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResponseTime                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResponseTime (ASN1CTXT* pctxt, ResponseTime* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = lowdelay; break;
         case 1: *pvalue = delaytolerant; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningPriority                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositioningPriority (ASN1CTXT* pctxt, PositioningPriority* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = high_Priority; break;
         case 1: *pvalue = normal_Priority; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClientType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ClientType (ASN1CTXT* pctxt, ClientType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = emergency_Services; break;
         case 1: *pvalue = value_Added_Services; break;
         case 2: *pvalue = pLMN_Operator_Services; break;
         case 3: *pvalue = lawful_Intercept_Services; break;
         case 4: *pvalue = pLMN_Operator_Broadcast_Services; break;
         case 5: *pvalue = pLMN_Operator_O_et_M; break;
         case 6: *pvalue = pLMN_Operator_Anonymous_Statistics; break;
         case 7: *pvalue = pLMN_Operator_Target_MS_Service_Support; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_latitudeSign                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalCoordinates_latitudeSign (ASN1CTXT* pctxt, GeographicalCoordinates_latitudeSign* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = north; break;
      case 1: *pvalue = south; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalCoordinates_iE_Extensions_element (ASN1CTXT* pctxt, GeographicalCoordinates_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GeographicalCoordinates_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GeographicalCoordinates_iE_Extensions_element (ASN1CTXT* pctxt,
   GeographicalCoordinates_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GeographicalCoordinates_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GeographicalCoordinates_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GeographicalCoordinates_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GeographicalCoordinates_ExtIEs[index].ExtensionSize);
   stat = GeographicalCoordinates_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalCoordinates_iE_Extensions (ASN1CTXT* pctxt, GeographicalCoordinates_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GeographicalCoordinates_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GeographicalCoordinates_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GeographicalCoordinates_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalCoordinates (ASN1CTXT* pctxt, GeographicalCoordinates* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode latitudeSign */

   stat = asn1PD_GeographicalCoordinates_latitudeSign (pctxt, &pvalue->latitudeSign);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode latitude */

   stat = pd_ConsUnsigned (pctxt, &pvalue->latitude, OSUINTCONST(0), OSUINTCONST(8388607));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode longitude */

   stat = pd_ConsInteger (pctxt, &pvalue->longitude, OSINTCONST(-8388608), OSINTCONST(8388607));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GeographicalCoordinates_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Point_iE_Extensions_element (ASN1CTXT* pctxt, GA_Point_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_Point_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_Point_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_Point_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_Point_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_Point_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_Point_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_Point_ExtIEs[index].ExtensionSize);
   stat = GA_Point_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Point_iE_Extensions (ASN1CTXT* pctxt, GA_Point_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_Point_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_Point_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_Point_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Point (ASN1CTXT* pctxt, GA_Point* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_Point_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertainty_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithUnCertainty_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_PointWithUnCertainty_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_PointWithUnCertainty_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithUnCertainty_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithUnCertainty_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithUnCertainty_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithUnCertainty_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_PointWithUnCertainty_ExtIEs[index].ExtensionSize);
   stat = GA_PointWithUnCertainty_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertainty_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithUnCertainty_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_PointWithUnCertainty_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_PointWithUnCertainty_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_PointWithUnCertainty_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertainty (ASN1CTXT* pctxt, GA_PointWithUnCertainty* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_PointWithUnCertainty_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode uncertaintyCode */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyCode, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Polygon_element_iE_Extensions_element (ASN1CTXT* pctxt, GA_Polygon_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_Polygon_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_Polygon_element_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_Polygon_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_Polygon_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_Polygon_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_Polygon_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_Polygon_ExtIEs[index].ExtensionSize);
   stat = GA_Polygon_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Polygon_element_iE_Extensions (ASN1CTXT* pctxt, GA_Polygon_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_Polygon_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_Polygon_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_Polygon_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Polygon_element (ASN1CTXT* pctxt, GA_Polygon_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_Polygon_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_Polygon (ASN1CTXT* pctxt, GA_Polygon* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   GA_Polygon_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_Polygon_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_Polygon_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_UncertaintyEllipse                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_UncertaintyEllipse (ASN1CTXT* pctxt, GA_UncertaintyEllipse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   rtDListInit (&pvalue->extElem1);

   /* decode uncertaintySemi_major */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySemi_major, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintySemi_minor */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySemi_minor, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode orientationOfMajorAxis */

   stat = pd_ConsUInt8 (pctxt, &pvalue->orientationOfMajorAxis, OSUINTCONST(0), OSUINTCONST(179));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithUnCertaintyEllipse_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithUnCertaintyEllipse_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithUnCertaintyEllipse_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithUnCertaintyEllipse_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_PointWithUnCertaintyEllipse_ExtIEs[index].ExtensionSize);
   stat = GA_PointWithUnCertaintyEllipse_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertaintyEllipse_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_PointWithUnCertaintyEllipse_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_PointWithUnCertaintyEllipse_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithUnCertaintyEllipse (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintyEllipse */

   stat = asn1PD_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode confidence */

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_PointWithUnCertaintyEllipse_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_AltitudeAndDirection_directionOfAltitude               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_AltitudeAndDirection_directionOfAltitude (ASN1CTXT* pctxt, GA_AltitudeAndDirection_directionOfAltitude* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = height; break;
      case 1: *pvalue = depth; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_AltitudeAndDirection                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_AltitudeAndDirection (ASN1CTXT* pctxt, GA_AltitudeAndDirection* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   rtDListInit (&pvalue->extElem1);

   /* decode directionOfAltitude */

   stat = asn1PD_GA_AltitudeAndDirection_directionOfAltitude (pctxt, &pvalue->directionOfAltitude);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altitude */

   stat = pd_ConsUInt16 (pctxt, &pvalue->altitude, OSUINTCONST(0), OSUINTCONST(32767));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitude_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithAltitude_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_PointWithAltitude_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_PointWithAltitude_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithAltitude_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithAltitude_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithAltitude_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithAltitude_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_PointWithAltitude_ExtIEs[index].ExtensionSize);
   stat = GA_PointWithAltitude_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitude_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithAltitude_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_PointWithAltitude_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_PointWithAltitude_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_PointWithAltitude_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitude (ASN1CTXT* pctxt, GA_PointWithAltitude* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altitudeAndDirection */

   stat = asn1PD_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_PointWithAltitude_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].ExtensionSize);
   stat = GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode altitudeAndDirection */

   stat = asn1PD_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintyEllipse */

   stat = asn1PD_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintyAltitude */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyAltitude, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode confidence */

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_EllipsoidArc_iE_Extensions_element (ASN1CTXT* pctxt, GA_EllipsoidArc_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GA_EllipsoidArc_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GA_EllipsoidArc_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_EllipsoidArc_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_EllipsoidArc_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_EllipsoidArc_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_EllipsoidArc_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GA_EllipsoidArc_ExtIEs[index].ExtensionSize);
   stat = GA_EllipsoidArc_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_EllipsoidArc_iE_Extensions (ASN1CTXT* pctxt, GA_EllipsoidArc_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GA_EllipsoidArc_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GA_EllipsoidArc_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GA_EllipsoidArc_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GA_EllipsoidArc (ASN1CTXT* pctxt, GA_EllipsoidArc* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode innerRadius */

   stat = pd_ConsUInt16 (pctxt, &pvalue->innerRadius, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode uncertaintyRadius */

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyRadius, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode offsetAngle */

   stat = pd_ConsUInt8 (pctxt, &pvalue->offsetAngle, OSUINTCONST(0), OSUINTCONST(179));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode includedAngle */

   stat = pd_ConsUInt8 (pctxt, &pvalue->includedAngle, OSUINTCONST(0), OSUINTCONST(179));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode confidence */

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GA_EllipsoidArc_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalArea                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeographicalArea (ASN1CTXT* pctxt, GeographicalArea* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* point */
         case 0:
            pvalue->u.point = rtMemAllocTypeZ (pctxt, GA_Point);
            if (pvalue->u.point == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_Point (pctxt, pvalue->u.point);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* pointWithUnCertainty */
         case 1:
            pvalue->u.pointWithUnCertainty = rtMemAllocTypeZ (pctxt, GA_PointWithUnCertainty);
            if (pvalue->u.pointWithUnCertainty == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_PointWithUnCertainty (pctxt, pvalue->u.pointWithUnCertainty);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* polygon */
         case 2:
            pvalue->u.polygon = rtMemAllocTypeZ (pctxt, GA_Polygon);
            if (pvalue->u.polygon == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_Polygon (pctxt, pvalue->u.polygon);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* pointWithUncertaintyEllipse */
         case 4:
            pvalue->u.pointWithUncertaintyEllipse = rtMemAllocTypeZ (pctxt, GA_PointWithUnCertaintyEllipse);
            if (pvalue->u.pointWithUncertaintyEllipse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_PointWithUnCertaintyEllipse (pctxt, pvalue->u.pointWithUncertaintyEllipse);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* pointWithAltitude */
         case 5:
            pvalue->u.pointWithAltitude = rtMemAllocTypeZ (pctxt, GA_PointWithAltitude);
            if (pvalue->u.pointWithAltitude == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_PointWithAltitude (pctxt, pvalue->u.pointWithAltitude);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* pointWithAltitudeAndUncertaintyEllipsoid */
         case 6:
            pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid = rtMemAllocTypeZ (pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid);
            if (pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_PointWithAltitudeAndUncertaintyEllipsoid (pctxt, pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* ellipsoidArc */
         case 7:
            pvalue->u.ellipsoidArc = rtMemAllocTypeZ (pctxt, GA_EllipsoidArc);
            if (pvalue->u.ellipsoidArc == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GA_EllipsoidArc (pctxt, pvalue->u.ellipsoidArc);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      rtCopyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AreaIdentity                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AreaIdentity (ASN1CTXT* pctxt, AreaIdentity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sAI */
         case 0:
            pvalue->u.sAI = rtMemAllocTypeZ (pctxt, SAI);
            if (pvalue->u.sAI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* geographicalArea */
         case 1:
            pvalue->u.geographicalArea = rtMemAllocTypeZ (pctxt, GeographicalArea);
            if (pvalue->u.geographicalArea == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeographicalArea (pctxt, pvalue->u.geographicalArea);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LastKnownServiceArea_iE_Extensions_element (ASN1CTXT* pctxt, LastKnownServiceArea_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LastKnownServiceArea_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LastKnownServiceArea_iE_Extensions_element (ASN1CTXT* pctxt,
   LastKnownServiceArea_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LastKnownServiceArea_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LastKnownServiceArea_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LastKnownServiceArea_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LastKnownServiceArea_ExtIEs[index].ExtensionSize);
   stat = LastKnownServiceArea_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LastKnownServiceArea_iE_Extensions (ASN1CTXT* pctxt, LastKnownServiceArea_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LastKnownServiceArea_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LastKnownServiceArea_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LastKnownServiceArea_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LastKnownServiceArea (ASN1CTXT* pctxt, LastKnownServiceArea* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode sAI */

   stat = asn1PD_SAI (pctxt, &pvalue->sAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode ageOfSAI */

   stat = pd_ConsUInt16 (pctxt, &pvalue->ageOfSAI, OSUINTCONST(0), OSUINTCONST(32767));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_LastKnownServiceArea_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningDataDiscriminator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositioningDataDiscriminator (ASN1CTXT* pctxt, PositioningDataDiscriminator* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningMethodAndUsage                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositioningMethodAndUsage (ASN1CTXT* pctxt, PositioningMethodAndUsage* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningDataSet                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositioningDataSet (ASN1CTXT* pctxt, PositioningDataSet* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(9), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (9 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositionData_iE_Extensions_element (ASN1CTXT* pctxt, PositionData_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_PositionData_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_PositionData_iE_Extensions_element (ASN1CTXT* pctxt,
   PositionData_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PositionData_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PositionData_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PositionData_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, PositionData_ExtIEs[index].ExtensionSize);
   stat = PositionData_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositionData_iE_Extensions (ASN1CTXT* pctxt, PositionData_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   PositionData_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PositionData_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PositionData_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositionData (ASN1CTXT* pctxt, PositionData* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.positioningDataSetPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode positioningDataDiscriminator */

   stat = asn1PD_PositioningDataDiscriminator (pctxt, &pvalue->positioningDataDiscriminator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode positioningDataSet */

   if (pvalue->m.positioningDataSetPresent) {
      stat = asn1PD_PositioningDataSet (pctxt, &pvalue->positioningDataSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_PositionData_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionDataSpecificToGERANIuMode                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PositionDataSpecificToGERANIuMode (ASN1CTXT* pctxt, PositionDataSpecificToGERANIuMode* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccuracyFulfilmentIndicator                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AccuracyFulfilmentIndicator (ASN1CTXT* pctxt, AccuracyFulfilmentIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = requested_Accuracy_Fulfilled; break;
         case 1: *pvalue = requested_Accuracy_Not_Fulfilled; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_PDU                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NAS_PDU (ASN1CTXT* pctxt, NAS_PDU* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_SequenceNumber                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NAS_SequenceNumber (ASN1CTXT* pctxt, NAS_SequenceNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAPI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAPI (ASN1CTXT* pctxt, SAPI* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = sapi_0; break;
         case 1: *pvalue = sapi_3; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RejectCauseValue                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RejectCauseValue (ASN1CTXT* pctxt, RejectCauseValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = pLMN_Not_Allowed; break;
         case 1: *pvalue = location_Area_Not_Allowed; break;
         case 2: *pvalue = roaming_Not_Allowed_In_This_Location_Area; break;
         case 3: *pvalue = no_Suitable_Cell_In_Location_Area; break;
         case 4: *pvalue = gPRS_Services_Not_Allowed_In_This_PLMN; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionCompleted                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RedirectionCompleted (ASN1CTXT* pctxt, RedirectionCompleted* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = redirection_completed; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberOfSteps                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NumberOfSteps (ASN1CTXT* pctxt, NumberOfSteps* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_MaxBitrateList                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Requested_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MaxBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_GuaranteedBitrateList             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Requested_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (2 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AlternativeRABConfigurationRequest                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AlternativeRABConfigurationRequest (ASN1CTXT* pctxt, AlternativeRABConfigurationRequest* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = alternative_RAB_configuration_Requested; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Requested_RAB_Parameter_Values_ExtIEs_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD__Requested_RAB_Parameter_Values_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Requested_RAB_Parameter_Values_ExtIEs_Extension *pvalue = (_Requested_RAB_Parameter_Values_ExtIEs_Extension*) pvalue_;

   stat = asn1PD_AlternativeRABConfigurationRequest (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_Values_iE_Extensions_element (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Requested_RAB_Parameter_Values_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Requested_RAB_Parameter_Values_iE_Extensions_element (ASN1CTXT* pctxt,
   Requested_RAB_Parameter_Values_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Requested_RAB_Parameter_Values_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Requested_RAB_Parameter_Values_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Requested_RAB_Parameter_Values_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Requested_RAB_Parameter_Values_ExtIEs[index].ExtensionSize);
   stat = Requested_RAB_Parameter_Values_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_Values_iE_Extensions (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Requested_RAB_Parameter_Values_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Requested_RAB_Parameter_Values_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Requested_RAB_Parameter_Values_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Requested_RAB_Parameter_Values (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.requestedMaxBitratesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.requestedGuaranteedBitratesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode requestedMaxBitrates */

   if (pvalue->m.requestedMaxBitratesPresent) {
      stat = asn1PD_Requested_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->requestedMaxBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode requestedGuaranteedBitrates */

   if (pvalue->m.requestedGuaranteedBitratesPresent) {
      stat = asn1PD_Requested_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->requestedGuaranteedBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_Requested_RAB_Parameter_Values_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedLocationRelatedDataType                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedLocationRelatedDataType (ASN1CTXT* pctxt, RequestedLocationRelatedDataType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = decipheringKeysUEBasedOTDOA; break;
         case 1: *pvalue = decipheringKeysAssistedGPS; break;
         case 2: *pvalue = dedicatedAssistanceDataUEBasedOTDOA; break;
         case 3: *pvalue = dedicatedAssistanceDataAssistedGPS; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedGPSAssistanceData                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedGPSAssistanceData (ASN1CTXT* pctxt, RequestedGPSAssistanceData* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(38), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestType                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequestType (ASN1CTXT* pctxt, LocationRelatedDataRequestType* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.requestedGPSAssistanceDataPresent = optbit;

   /* decode requestedLocationRelatedDataType */

   stat = asn1PD_RequestedLocationRelatedDataType (pctxt, &pvalue->requestedLocationRelatedDataType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode requestedGPSAssistanceData */

   if (pvalue->m.requestedGPSAssistanceDataPresent) {
      stat = asn1PD_RequestedGPSAssistanceData (pctxt, &pvalue->requestedGPSAssistanceData);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestTypeSpecificToGERANIuMode       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LocationRelatedDataRequestTypeSpecificToGERANIuMode (ASN1CTXT* pctxt, LocationRelatedDataRequestTypeSpecificToGERANIuMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = decipheringKeysEOTD; break;
         case 1: *pvalue = dedicatedMobileAssistedEOTDAssistanceData; break;
         case 2: *pvalue = dedicatedMobileBasedEOTDAssistanceData; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_currentDecipherin  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(56), OSUINTCONST(56), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_nextDecipheringKe  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(56), OSUINTCONST(56), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BroadcastAssistanceDataDecipheringKeys (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   rtDListInit (&pvalue->extElem1);

   /* decode cipheringKeyFlag */

   stat = asn1PD_BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag (pctxt, &pvalue->cipheringKeyFlag);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode currentDecipheringKey */

   stat = asn1PD_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (pctxt, &pvalue->currentDecipheringKey);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode nextDecipheringKey */

   stat = asn1PD_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (pctxt, &pvalue->nextDecipheringKey);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferID (ASN1CTXT* pctxt, InformationTransferID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ListOF_SNAs                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ListOF_SNAs (ASN1CTXT* pctxt, ListOF_SNAs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, SNAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_SNAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LA_LIST_element_iE_Extensions_element (ASN1CTXT* pctxt, LA_LIST_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_LA_LIST_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_LA_LIST_element_iE_Extensions_element (ASN1CTXT* pctxt,
   LA_LIST_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LA_LIST_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LA_LIST_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LA_LIST_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, LA_LIST_ExtIEs[index].ExtensionSize);
   stat = LA_LIST_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LA_LIST_element_iE_Extensions (ASN1CTXT* pctxt, LA_LIST_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   LA_LIST_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, LA_LIST_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_LA_LIST_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LA_LIST_element (ASN1CTXT* pctxt, LA_LIST_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAC */

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode listOF_SNAs */

   stat = asn1PD_ListOF_SNAs (pctxt, &pvalue->listOF_SNAs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_LA_LIST_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LA_LIST (ASN1CTXT* pctxt, LA_LIST* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   LA_LIST_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;
   int lstat;

   rtDListInit (pvalue);

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, LA_LIST_element);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_LA_LIST_element (pctxt, pdata);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         rtDListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == 0) break;
   }
   stat = pu_checkSizeConstraint (pctxt, pvalue->count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNs_in_shared_network_element_iE_Extensions_element (ASN1CTXT* pctxt, PLMNs_in_shared_network_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_PLMNs_in_shared_network_element_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_PLMNs_in_shared_network_element_iE_Extensions_element (ASN1CTXT* pctxt,
   PLMNs_in_shared_network_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PLMNs_in_shared_network_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PLMNs_in_shared_network_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PLMNs_in_shared_network_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, PLMNs_in_shared_network_ExtIEs[index].ExtensionSize);
   stat = PLMNs_in_shared_network_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNs_in_shared_network_element_iE_Extensions (ASN1CTXT* pctxt, PLMNs_in_shared_network_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   PLMNs_in_shared_network_element_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PLMNs_in_shared_network_element_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PLMNs_in_shared_network_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNs_in_shared_network_element (ASN1CTXT* pctxt, PLMNs_in_shared_network_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode lA_LIST */

   stat = asn1PD_LA_LIST (pctxt, &pvalue->lA_LIST);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_PLMNs_in_shared_network_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PLMNs_in_shared_network (ASN1CTXT* pctxt, PLMNs_in_shared_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   PLMNs_in_shared_network_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PLMNs_in_shared_network_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PLMNs_in_shared_network_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Shared_Network_Information_iE_Extensions_element (ASN1CTXT* pctxt, Shared_Network_Information_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_Shared_Network_Information_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_Shared_Network_Information_iE_Extensions_element (ASN1CTXT* pctxt,
   Shared_Network_Information_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Shared_Network_Information_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Shared_Network_Information_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Shared_Network_Information_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, Shared_Network_Information_ExtIEs[index].ExtensionSize);
   stat = Shared_Network_Information_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Shared_Network_Information_iE_Extensions (ASN1CTXT* pctxt, Shared_Network_Information_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Shared_Network_Information_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Shared_Network_Information_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Shared_Network_Information_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Shared_Network_Information (ASN1CTXT* pctxt, Shared_Network_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNs_in_shared_network */

   stat = asn1PD_PLMNs_in_shared_network (pctxt, &pvalue->pLMNs_in_shared_network);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_Shared_Network_Information_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProvidedData                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ProvidedData (ASN1CTXT* pctxt, ProvidedData* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* shared_network_information */
         case 0:
            pvalue->u.shared_network_information = rtMemAllocTypeZ (pctxt, Shared_Network_Information);
            if (pvalue->u.shared_network_information == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Shared_Network_Information (pctxt, pvalue->u.shared_network_information);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIMInformation                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIMInformation (ASN1CTXT* pctxt, RIMInformation* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Cell_ID_iE_Extensions_element (ASN1CTXT* pctxt, GERAN_Cell_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_GERAN_Cell_ID_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_GERAN_Cell_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   GERAN_Cell_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Cell_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Cell_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Cell_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, GERAN_Cell_ID_ExtIEs[index].ExtensionSize);
   stat = GERAN_Cell_ID_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Cell_ID_iE_Extensions (ASN1CTXT* pctxt, GERAN_Cell_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   GERAN_Cell_ID_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GERAN_Cell_ID_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GERAN_Cell_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GERAN_Cell_ID (ASN1CTXT* pctxt, GERAN_Cell_ID* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAI */

   stat = asn1PD_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rAC */

   stat = asn1PD_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode cI */

   stat = asn1PD_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_GERAN_Cell_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIMRoutingAddress                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIMRoutingAddress (ASN1CTXT* pctxt, RIMRoutingAddress* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* globalRNC_ID */
         case 0:
            pvalue->u.globalRNC_ID = rtMemAllocTypeZ (pctxt, GlobalRNC_ID);
            if (pvalue->u.globalRNC_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GlobalRNC_ID (pctxt, pvalue->u.globalRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* gERAN_Cell_ID */
         case 1:
            pvalue->u.gERAN_Cell_ID = rtMemAllocTypeZ (pctxt, GERAN_Cell_ID);
            if (pvalue->u.gERAN_Cell_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GERAN_Cell_ID (pctxt, pvalue->u.gERAN_Cell_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIM_Transfer_iE_Extensions_element (ASN1CTXT* pctxt, RIM_Transfer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RIM_Transfer_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RIM_Transfer_iE_Extensions_element (ASN1CTXT* pctxt,
   RIM_Transfer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RIM_Transfer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RIM_Transfer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RIM_Transfer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RIM_Transfer_ExtIEs[index].ExtensionSize);
   stat = RIM_Transfer_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIM_Transfer_iE_Extensions (ASN1CTXT* pctxt, RIM_Transfer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RIM_Transfer_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RIM_Transfer_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RIM_Transfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RIM_Transfer (ASN1CTXT* pctxt, RIM_Transfer* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rIMRoutingAddressPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rIMInformation */

   stat = asn1PD_RIMInformation (pctxt, &pvalue->rIMInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode rIMRoutingAddress */

   if (pvalue->m.rIMRoutingAddressPresent) {
      stat = asn1PD_RIMRoutingAddress (pctxt, &pvalue->rIMRoutingAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RIM_Transfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformationTransferType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InterSystemInformationTransferType (ASN1CTXT* pctxt, InterSystemInformationTransferType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rIM_Transfer */
         case 0:
            pvalue->u.rIM_Transfer = rtMemAllocTypeZ (pctxt, RIM_Transfer);
            if (pvalue->u.rIM_Transfer == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RIM_Transfer (pctxt, pvalue->u.rIM_Transfer);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeID (ASN1CTXT* pctxt, InformationExchangeID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeType (ASN1CTXT* pctxt, InformationExchangeType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = transfer; break;
         case 1: *pvalue = request; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_traceActivationIndicator              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNCTraceInformation_traceActivationIndicator (ASN1CTXT* pctxt, RNCTraceInformation_traceActivationIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = activated; break;
      case 1: *pvalue = deactivated; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIList                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIList (ASN1CTXT* pctxt, IMEIList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (64 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_IMEI (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVList                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVList (ASN1CTXT* pctxt, IMEISVList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   if (64 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_IMEISV (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iMEIMask                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIGroup_iMEIMask (ASN1CTXT* pctxt, IMEIGroup_iMEIMask* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(7), OSUINTCONST(7), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIGroup_iE_Extensions_element (ASN1CTXT* pctxt, IMEIGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_IMEIGroup_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_IMEIGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   IMEIGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IMEIGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IMEIGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IMEIGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, IMEIGroup_ExtIEs[index].ExtensionSize);
   stat = IMEIGroup_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIGroup_iE_Extensions (ASN1CTXT* pctxt, IMEIGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   IMEIGroup_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, IMEIGroup_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_IMEIGroup_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEIGroup (ASN1CTXT* pctxt, IMEIGroup* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iMEI */

   stat = asn1PD_IMEI (pctxt, &pvalue->iMEI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iMEIMask */

   stat = asn1PD_IMEIGroup_iMEIMask (pctxt, &pvalue->iMEIMask);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_IMEIGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iMEISVMask                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVGroup_iMEISVMask (ASN1CTXT* pctxt, IMEISVGroup_iMEISVMask* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(7), OSUINTCONST(7), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVGroup_iE_Extensions_element (ASN1CTXT* pctxt, IMEISVGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_IMEISVGroup_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_IMEISVGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   IMEISVGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IMEISVGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IMEISVGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IMEISVGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, IMEISVGroup_ExtIEs[index].ExtensionSize);
   stat = IMEISVGroup_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVGroup_iE_Extensions (ASN1CTXT* pctxt, IMEISVGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   IMEISVGroup_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, IMEISVGroup_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_IMEISVGroup_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IMEISVGroup (ASN1CTXT* pctxt, IMEISVGroup* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iMEISV */

   stat = asn1PD_IMEISV (pctxt, &pvalue->iMEISV);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iMEISVMask */

   stat = asn1PD_IMEISVGroup_iMEISVMask (pctxt, &pvalue->iMEISVMask);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_IMEISVGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquipmentsToBeTraced                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EquipmentsToBeTraced (ASN1CTXT* pctxt, EquipmentsToBeTraced* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iMEIlist */
         case 0:
            pvalue->u.iMEIlist = rtMemAllocTypeZ (pctxt, IMEIList);
            if (pvalue->u.iMEIlist == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEIList (pctxt, pvalue->u.iMEIlist);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* iMEISVlist */
         case 1:
            pvalue->u.iMEISVlist = rtMemAllocTypeZ (pctxt, IMEISVList);
            if (pvalue->u.iMEISVlist == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEISVList (pctxt, pvalue->u.iMEISVlist);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* iMEIgroup */
         case 2:
            pvalue->u.iMEIgroup = rtMemAllocTypeZ (pctxt, IMEIGroup);
            if (pvalue->u.iMEIgroup == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEIGroup (pctxt, pvalue->u.iMEIgroup);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* iMEISVgroup */
         case 3:
            pvalue->u.iMEISVgroup = rtMemAllocTypeZ (pctxt, IMEISVGroup);
            if (pvalue->u.iMEISVgroup == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IMEISVGroup (pctxt, pvalue->u.iMEISVgroup);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNCTraceInformation_iE_Extensions_element (ASN1CTXT* pctxt, RNCTraceInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_RNCTraceInformation_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_RNCTraceInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   RNCTraceInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RNCTraceInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RNCTraceInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RNCTraceInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, RNCTraceInformation_ExtIEs[index].ExtensionSize);
   stat = RNCTraceInformation_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNCTraceInformation_iE_Extensions (ASN1CTXT* pctxt, RNCTraceInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   RNCTraceInformation_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RNCTraceInformation_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RNCTraceInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNCTraceInformation (ASN1CTXT* pctxt, RNCTraceInformation* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.equipmentsToBeTracedPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode traceReference */

   stat = asn1PD_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode traceActivationIndicator */

   stat = asn1PD_RNCTraceInformation_traceActivationIndicator (pctxt, &pvalue->traceActivationIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode equipmentsToBeTraced */

   if (pvalue->m.equipmentsToBeTracedPresent) {
      stat = asn1PD_EquipmentsToBeTraced (pctxt, &pvalue->equipmentsToBeTraced);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_RNCTraceInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationTransferType (ASN1CTXT* pctxt, InformationTransferType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rNCTraceInformation */
         case 0:
            pvalue->u.rNCTraceInformation = rtMemAllocTypeZ (pctxt, RNCTraceInformation);
            if (pvalue->u.rNCTraceInformation == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RNCTraceInformation (pctxt, pvalue->u.rNCTraceInformation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNRequest                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSIPMulticastAddressandAPNRequest (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(512), 0 };
   int stat = 0;
   TMGI* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TMGI);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TMGI (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationRequestType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationRequestType (ASN1CTXT* pctxt, InformationRequestType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* mBMSIPMulticastAddressandAPNRequest */
         case 0:
            pvalue->u.mBMSIPMulticastAddressandAPNRequest = rtMemAllocTypeZ (pctxt, MBMSIPMulticastAddressandAPNRequest);
            if (pvalue->u.mBMSIPMulticastAddressandAPNRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_MBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.mBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* permanentNAS_UE_ID */
         case 1:
            pvalue->u.permanentNAS_UE_ID = rtMemAllocTypeZ (pctxt, PermanentNAS_UE_ID);
            if (pvalue->u.permanentNAS_UE_ID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_PermanentNAS_UE_ID (pctxt, pvalue->u.permanentNAS_UE_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPMulticastAddress                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPMulticastAddress (ASN1CTXT* pctxt, IPMulticastAddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(16), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  APN                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_APN (ASN1CTXT* pctxt, APN* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(255), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (ASN1CTXT* pctxt,
   MBMSIPMulticastAddressandAPNlist_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSIPMulticastAddressandAPNlist_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSIPMulticastAddressandAPNlist_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSIPMulticastAddressandAPNlist_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, MBMSIPMulticastAddressandAPNlist_ExtIEs[index].ExtensionSize);
   stat = MBMSIPMulticastAddressandAPNlist_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSIPMulticastAddressandAPNlist_iE_Extensions (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   MBMSIPMulticastAddressandAPNlist_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSIPMulticastAddressandAPNlist_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSIPMulticastAddressandAPNlist (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode tMGI */

   stat = asn1PD_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iPMulticastAddress */

   stat = asn1PD_IPMulticastAddress (pctxt, &pvalue->iPMulticastAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode aPN */

   stat = asn1PD_APN (pctxt, &pvalue->aPN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_MBMSIPMulticastAddressandAPNlist_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedMBMSIPMulticastAddressandAPNRequest              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedMBMSIPMulticastAddressandAPNRequest (ASN1CTXT* pctxt, RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(512), 0 };
   int stat = 0;
   MBMSIPMulticastAddressandAPNlist* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MBMSIPMulticastAddressandAPNlist);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MBMSIPMulticastAddressandAPNlist (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedMulticastServiceList                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedMulticastServiceList (ASN1CTXT* pctxt, RequestedMulticastServiceList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   TMGI* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TMGI);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TMGI (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationRequested                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationRequested (ASN1CTXT* pctxt, InformationRequested* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* requestedMBMSIPMulticastAddressandAPNRequest */
         case 0:
            pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest = rtMemAllocTypeZ (pctxt, RequestedMBMSIPMulticastAddressandAPNRequest);
            if (pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RequestedMBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* requestedMulticastServiceList */
         case 1:
            pvalue->u.requestedMulticastServiceList = rtMemAllocTypeZ (pctxt, RequestedMulticastServiceList);
            if (pvalue->u.requestedMulticastServiceList == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RequestedMulticastServiceList (pctxt, pvalue->u.requestedMulticastServiceList);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionIdentity                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionIdentity (ASN1CTXT* pctxt, MBMSSessionIdentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSBearerServiceType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSBearerServiceType (ASN1CTXT* pctxt, MBMSBearerServiceType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = multicast; break;
         case 1: *pvalue = broadcast; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionDuration                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionDuration (ASN1CTXT* pctxt, MBMSSessionDuration* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSServiceArea                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSServiceArea (ASN1CTXT* pctxt, MBMSServiceArea* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrequenceLayerConvergenceFlag                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FrequenceLayerConvergenceFlag (ASN1CTXT* pctxt, FrequenceLayerConvergenceFlag* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = no_FLC_flag; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAofIdleModeUEs                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAofIdleModeUEs (ASN1CTXT* pctxt, RAofIdleModeUEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, RAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt,
   NotEmptyRAListofIdleModeUEs_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < NotEmptyRAListofIdleModeUEs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &NotEmptyRAListofIdleModeUEs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == NotEmptyRAListofIdleModeUEs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, NotEmptyRAListofIdleModeUEs_ExtIEs[index].ExtensionSize);
   stat = NotEmptyRAListofIdleModeUEs_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NotEmptyRAListofIdleModeUEs_iE_Extensions (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   NotEmptyRAListofIdleModeUEs_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, NotEmptyRAListofIdleModeUEs_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NotEmptyRAListofIdleModeUEs (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode rAofIdleModeUEs */

   stat = asn1PD_RAofIdleModeUEs (pctxt, &pvalue->rAofIdleModeUEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_NotEmptyRAListofIdleModeUEs_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (ASN1CTXT* pctxt, RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = emptylist; break;
         case 1: *pvalue = fulllist; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListofIdleModeUEs                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAListofIdleModeUEs (ASN1CTXT* pctxt, RAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* notEmptyRAListofIdleModeUEs */
         case 0:
            pvalue->u.notEmptyRAListofIdleModeUEs = rtMemAllocTypeZ (pctxt, NotEmptyRAListofIdleModeUEs);
            if (pvalue->u.notEmptyRAListofIdleModeUEs == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_NotEmptyRAListofIdleModeUEs (pctxt, pvalue->u.notEmptyRAListofIdleModeUEs);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* emptyFullRAListofIdleModeUEs */
         case 1:
            stat = asn1PD_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (pctxt, &pvalue->u.emptyFullRAListofIdleModeUEs);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionRepetitionNumber                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSSessionRepetitionNumber (ASN1CTXT* pctxt, MBMSSessionRepetitionNumber* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeToMBMSDataTransfer                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeToMBMSDataTransfer (ASN1CTXT* pctxt, TimeToMBMSDataTransfer* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SessionUpdateID                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SessionUpdateID (ASN1CTXT* pctxt, SessionUpdateID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewRAListofIdleModeUEs                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NewRAListofIdleModeUEs (ASN1CTXT* pctxt, NewRAListofIdleModeUEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, RAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListwithNoIdleModeUEsAnyMore                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RAListwithNoIdleModeUEsAnyMore (ASN1CTXT* pctxt, RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, RAC);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeltaRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* decode id */

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode criticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode extensionValue */

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.encoded.data, &pvalue->extensionValue.encoded.numocts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

    /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PDTC_DeltaRAListofIdleModeUEs_iE_Extensions_element (pctxt, pvalue);

   rtCopyContext (pctxt, &lctxt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PDTC_DeltaRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt,
   DeltaRAListofIdleModeUEs_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DeltaRAListofIdleModeUEs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DeltaRAListofIdleModeUEs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DeltaRAListofIdleModeUEs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = pd_setp (pctxt,
         (OSOCTET*)pvalue->extensionValue.encoded.data,
         pvalue->extensionValue.encoded.numocts,
         pctxt->buffer.aligned);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.decoded = rtMemAlloc (pctxt, DeltaRAListofIdleModeUEs_ExtIEs[index].ExtensionSize);
   stat = DeltaRAListofIdleModeUEs_ExtIEs[index].decodeExtension(pctxt, pvalue->extensionValue.decoded );
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeltaRAListofIdleModeUEs_iE_Extensions (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   DeltaRAListofIdleModeUEs_iE_Extensions_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DeltaRAListofIdleModeUEs_iE_Extensions_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DeltaRAListofIdleModeUEs_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeltaRAListofIdleModeUEs (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSBOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.newRAListofIdleModeUEsPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode newRAListofIdleModeUEs */

   if (pvalue->m.newRAListofIdleModeUEsPresent) {
      stat = asn1PD_NewRAListofIdleModeUEs (pctxt, &pvalue->newRAListofIdleModeUEs);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode rAListwithNoIdleModeUEsAnyMore */

   if (pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent) {
      stat = asn1PD_RAListwithNoIdleModeUEsAnyMore (pctxt, &pvalue->rAListwithNoIdleModeUEsAnyMore);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PD_DeltaRAListofIdleModeUEs_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_Registration                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSCNDe_Registration (ASN1CTXT* pctxt, MBMSCNDe_Registration* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = normalsessionstop; break;
         case 1: *pvalue = deregister; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequestType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSRegistrationRequestType (ASN1CTXT* pctxt, MBMSRegistrationRequestType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = register_; break;
         case 1: *pvalue = deregister_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateControlAllowed                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RateControlAllowed (ASN1CTXT* pctxt, RateControlAllowed* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = not_allowed; break;
      case 1: *pvalue = allowed; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   return (stat);
}

