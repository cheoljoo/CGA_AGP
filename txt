Example : MEM_CPU_LOG
- Draw the chart to check the memory and cpu usage
- It will check every day what is the problem.:q

 - Documents [NEXT]
	. Comments as doxygen for each function
	. ASPICE traceability
	. SDD/LLD with flow chart / state diagram / progress
 - Unit test (gtest & vectorCast) 
 - Study : Design Pattern , C++ , perlre(ING)

 ------------------------


[Parser Done] : parser.c

make the stc file for html and header file
-header file includes structures autogenerated.
-html file includes the stc format to show the final table.

compiler processes
DONE : front end  (define the syntax and parsing) -> a.pl
DONE : optimizer ( make the added variables) -> m.pl
DONE : back end for STC    -> r.pl

Action Items : input for back end with stc file format
 - structure  (Done)
 - html table  (Done)
 - add + (max_keys) in ITERATE (Done)
 - add array in ITERATE (Done)
 - Optimizer (Done) **
 - Parser (Done) : result - parser.c
	. m.pl will be changed to make parser
			$gCol{0}{0}{"Define"}="START_BYTES"
			$gCol{0}{0}{"Description"}="(Header - Start Bytes)"
			$gCol{0}{0}{"Span"}="10"
			$gCol{0}{0}{"Len"}="1"
			$gCol{0}{0}{"Comments"}=""
			$gCol{0}{0}{"Value"}="0xAA"
		$gCol{1}{0}{"ParserSiblingX"}="prior X index of satisfying the following condition (span > 0)"
		$gCol{1}{0}{"ParserSiblingY"}="prior Y index of satisfying the following condition (len > 0)"
		$gCol{1}{0}{"ParserParentX"}="Parent X Index of Y-1";
		$gCol{1}{0}{"ParserParentY"}="Parent X Index of Y-1";
		$gCol{2}{2}{"LongDefine"}="longname..."
		logname will be defined with special value!
		$ParserCol{2}{1}{"Parent"} = 0 (index of X-structure)
		$ParserRow{1}{2}{"Parent"} = 0 (index of X-structure)
	. Next will have Next code
		funciton for tracing backward of Y ( input : Current LongDefine # ,  Value )
			function name :
			inner call :
			case  
				elsif before status(parent status) + current value;
				elsif 
		bytes [Len:Span:ParserParentX:ParserParentY]
		Byte[_____ 0____] [_____ 1____] [_____ 2____] [_____ 3____] [_____ 4____] [_____ 5____] [_____ 6____] [_____ 7____] [_____ 8____] [_____ 9____] [_____10____] 
		0 [ 1:11: 0: 0] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		0       0xAA                                                                                                                                                
		1 [ 1: 3: 0: 0] [__:__:__:__] [__:__:__:__] [ 1: 3: 0: 0] [__:__:__:__] [__:__:__:__] [ 1: 1: 0: 0] [ 1: 1: 0: 0] [ 1: 1: 0: 0] [ 1: 1: 0: 0] [ 1: 1: 0: 0] 
		1       0x84                                      0x88                                      0x81          0x82          0x85          0x86          0x87    
		if else :
			parent status(0)+0x84 => LongDefine      parent status(0)+0x88 => LongDefine  ..........
		call :
			call_level_3(LongDefine of 1 , next pointer);
		2 [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		2                                                                                                                                                           
		3 [ 2: 1: 0: 1] [ 2: 1: 0: 1] [ 2: 1: 0: 1] [ 2: 1: 3: 1] [ 2: 1: 3: 1] [ 2: 1: 3: 1] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		3     0x0A03        0x0F02        0x01EE        0x0A03        0x0F02        0x01EE                                                                          
										if OK => return Final Structure #
		4 [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		4                                                                                                                                                           
		5 [ 2: 1: 0: 3] [ 2: 1: 1: 3] [__:__:__:__] [ 2: 1: 3: 3] [ 2: 1: 4: 3] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		5       0x03        0x3303                        0x03        0x3303                                                                                        

(Done)
- Add function : various hash type (+V%  : hash value ascending sort)
ITERATE  [+-]?[KV]?[%@&+]
 K : key sort , V : value sort (only hash %)
 [KV] : K is default
 [+-] : + is default
 % : hash
 @ : array
 & : reverse array
 + : 0 ~ max key 
	default : K(key sort) , +(ascending order)
	%&@+
	K or V or nothing : default K   (K :key , V : value)
	+ or - or nothing : default +
	

 - Documents (NEXT)
	. Comments as doxygen for each function
	. ASPICE traceability
	. SDD/LLD with flow chart / state diagram / progress
 - Unit test (gtest & vectorCast)
 - Study : Design Pattern , C++ , perlre(ING)

ADD EXAMPLES for the following test
	$iterate_lines =~ m/([\t ]*)IFEQUAL\s*([^\n#\/]*)\s*\/\#/;       IFEQUAL|IFNOTEQUAL ( () && ||  ) /#
	$iterate_lines =~ m/((?:\/\#(?:[^#]|(?:\#+[^#\/]))*\#+\/))/;     /#   #/
	my @pp = $a =~ s/((?:\/\*(?:[^*]|(?:\*+[^*\/]))*\*+\/)|(?:\/\/.*))//g;    /*   */
	if($a =~ /(\{([^\{\}]|(?R))*\})/)            { {} {} }

	(?=pattern)
		is a positive look-ahead assertion
	(?!pattern)
		is a negative look-ahead assertion
	(?<=pattern)
		is a positive look-behind assertion
	(?<!pattern)
		is a negative look-behind assertion

	https://docstore.mik.ua/orelly/perl3/lperl/ch09_05.htm
	$.    : matched line
	$`
	$&
	$'
	($`)($&)($') : This is location for each variables.


Caller
		#  0         1          2      3            4
		my ($package, $filename, $line, $subroutine, $hasargs,
		    #  5          6          7            8       9         10
		    $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
		  = caller($i);

