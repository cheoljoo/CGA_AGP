/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 19-Mar-2007.
 */
#include "asn1intl.h"
#include "NBAP-PDU-Contents.h"
#include "NBAP-Constants.h"

/**************************************************************/
/*                                                            */
/*  FACH_ParametersList_CTCH_SetupRqstFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersList_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, FACH_ParametersList_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersList_CTCH_SetupRqstFDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersList_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_Parameters_CTCH_SetupRqstFDD                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_Parameters_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, PCH_Parameters_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Parameters_CTCH_SetupRqstFDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Parameters_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_Parameters_CTCH_SetupRqstFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_Parameters_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, RACH_Parameters_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_Parameters_CTCH_SetupRqstFDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_Parameters_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_parameterList_CTCH_SetupRqstTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_parameterList_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_parameterList_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterList_CTCH_SetupRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterList_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersList_CTCH_SetupRqstTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersList_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, FACH_ParametersList_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersList_CTCH_SetupRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersList_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_Parameters_CTCH_SetupRqstTDD                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PCH_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Parameters_CTCH_SetupRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Parameters_CTCH_SetupRqstTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PICH_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Parameters_CTCH_SetupRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_Parameters_CTCH_SetupRqstTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PRACH_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_Parameters_CTCH_SetupRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_Parameter_CTCH_SetupRqstTDD                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_Parameter_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, RACH_Parameter_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_Parameter_CTCH_SetupRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_Parameter_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersList_CTCH_ReconfRqstFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersList_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, FACH_ParametersList_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersList_CTCH_ReconfRqstFDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersList_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_Parameters_CTCH_ReconfRqstFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_Parameters_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, PCH_Parameters_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Parameters_CTCH_ReconfRqstFDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Parameters_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Parameters_CTCH_ReconfRqstFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_Parameters_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, PICH_Parameters_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Parameters_CTCH_ReconfRqstFDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Parameters_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_ParametersList_CTCH_ReconfRqstFDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_ParametersList_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, PRACH_ParametersList_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_ParametersList_CTCH_ReconfRqstFDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_ParametersList_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_ParametersList_CTCH_ReconfRqstFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AICH_ParametersList_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, AICH_ParametersList_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_ParametersList_CTCH_ReconfRqstFDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_ParametersList_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCHList_CTCH_ReconfRqstTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCHList_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCHList_CTCH_ReconfRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCHList_CTCH_ReconfRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCHList_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_SCH_Information_AuditRsp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_P_SCH_Information_AuditRsp (ASN1CTXT* pctxt, P_SCH_Information_AuditRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_P_SCH_Information_AuditRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_P_SCH_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_SCH_Information_AuditRsp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_SCH_Information_AuditRsp (ASN1CTXT* pctxt, S_SCH_Information_AuditRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_SCH_Information_AuditRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_S_SCH_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_CPICH_Information_AuditRsp                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_P_CPICH_Information_AuditRsp (ASN1CTXT* pctxt, P_CPICH_Information_AuditRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_P_CPICH_Information_AuditRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_P_CPICH_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_CCPCH_Information_AuditRsp                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_P_CCPCH_Information_AuditRsp (ASN1CTXT* pctxt, P_CCPCH_Information_AuditRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_P_CCPCH_Information_AuditRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_P_CCPCH_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BCH_Information_AuditRsp                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BCH_Information_AuditRsp (ASN1CTXT* pctxt, BCH_Information_AuditRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BCH_Information_AuditRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_BCH_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_Information_AuditRsp                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_Information_AuditRsp (ASN1CTXT* pctxt, PCH_Information_AuditRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Information_AuditRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Information_AuditRsp                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_Information_AuditRsp (ASN1CTXT* pctxt, PICH_Information_AuditRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Information_AuditRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SCH_Information_AuditRsp                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SCH_Information_AuditRsp (ASN1CTXT* pctxt, SCH_Information_AuditRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_Information_AuditRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_CommonMeasurementObjectType_CM_Rqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_CommonMeasurementObjectType_CM_Rqst (ASN1CTXT* pctxt, Extension_CommonMeasurementObjectType_CM_Rqst* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_CommonMeasurementObjectType_CM_Rqst: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_CommonMeasurementObjectType_CM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_CommonMeasurementObjectType_CM_Rsp              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_CommonMeasurementObjectType_CM_Rsp (ASN1CTXT* pctxt, Extension_CommonMeasurementObjectType_CM_Rsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_CommonMeasurementObjectType_CM_Rsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_CommonMeasurementObjectType_CM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_CommonMeasurementObjectType_CM_Rprt             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_CommonMeasurementObjectType_CM_Rprt (ASN1CTXT* pctxt, Extension_CommonMeasurementObjectType_CM_Rprt* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_CommonMeasurementObjectType_CM_Rprt: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_CommonMeasurementObjectType_CM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncCaseIndicator_Cell_SetupRqstTDD_PSCH                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncCaseIndicator_Cell_SetupRqstTDD_PSCH (ASN1CTXT* pctxt, SyncCaseIndicator_Cell_SetupRqstTDD_PSCH* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncCaseIndicator_Cell_SetupRqstTDD_PSCH: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncCaseIndicator_Cell_SetupRqstTDD_PSCH: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_SCH_Information_ResourceStatusInd                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_P_SCH_Information_ResourceStatusInd (ASN1CTXT* pctxt, P_SCH_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_P_SCH_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_P_SCH_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_SCH_Information_ResourceStatusInd                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_SCH_Information_ResourceStatusInd (ASN1CTXT* pctxt, S_SCH_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_SCH_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_S_SCH_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_CPICH_Information_ResourceStatusInd                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_P_CPICH_Information_ResourceStatusInd (ASN1CTXT* pctxt, P_CPICH_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_P_CPICH_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_P_CPICH_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_CCPCH_Information_ResourceStatusInd                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_P_CCPCH_Information_ResourceStatusInd (ASN1CTXT* pctxt, P_CCPCH_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_P_CCPCH_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_P_CCPCH_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BCH_Information_ResourceStatusInd                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BCH_Information_ResourceStatusInd (ASN1CTXT* pctxt, BCH_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BCH_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_BCH_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_Information_ResourceStatusInd                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_Information_ResourceStatusInd (ASN1CTXT* pctxt, PCH_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Information_ResourceStatusInd                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_Information_ResourceStatusInd (ASN1CTXT* pctxt, PICH_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SCH_Information_ResourceStatusInd                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SCH_Information_ResourceStatusInd (ASN1CTXT* pctxt, SCH_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DwPCH_LCR_Information_ResourceStatusInd                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DwPCH_LCR_Information_ResourceStatusInd (ASN1CTXT* pctxt, DwPCH_LCR_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DwPCH_LCR_Information_ResourceStatusInd: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DwPCH_LCR_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SegmentInformationList_SystemInfoUpdate                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SegmentInformationList_SystemInfoUpdate (ASN1CTXT* pctxt, SegmentInformationList_SystemInfoUpdate* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentInformationList_SystemInfoUpdate: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentInformationList_SystemInfoUpdate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_Information_RL_SetupRqstTDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_Information_RL_SetupRqstTDD (ASN1CTXT* pctxt, UL_DPCH_Information_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_Information_RL_SetupRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_Information_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_Information_RL_SetupRqstTDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_Information_RL_SetupRqstTDD (ASN1CTXT* pctxt, DL_DPCH_Information_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Information_RL_SetupRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Information_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_InformationResponseList_RL_SetupRspTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_InformationResponseList_RL_SetupRspTDD (ASN1CTXT* pctxt, DCH_InformationResponseList_RL_SetupRspTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponseList_RL_SetupRspTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponseList_RL_SetupRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_InformationResponseList_RL_SetupRspTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_InformationResponseList_RL_SetupRspTDD (ASN1CTXT* pctxt, DSCH_InformationResponseList_RL_SetupRspTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponseList_RL_SetupRspTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponseList_RL_SetupRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationResponseList_RL_SetupRspTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_InformationResponseList_RL_SetupRspTDD (ASN1CTXT* pctxt, USCH_InformationResponseList_RL_SetupRspTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponseList_RL_SetupRspTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponseList_RL_SetupRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD (ASN1CTXT* pctxt, Unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationList_RL_AdditionRqstTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationList_RL_AdditionRqstTDD (ASN1CTXT* pctxt, UL_DPCH_InformationList_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationList_RL_AdditionRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationList_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationList_RL_AdditionRqstTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationList_RL_AdditionRqstTDD (ASN1CTXT* pctxt, DL_DPCH_InformationList_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationList_RL_AdditionRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationList_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_InformationResponseList_RL_AdditionRspTDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_InformationResponseList_RL_AdditionRspTDD (ASN1CTXT* pctxt, DSCH_InformationResponseList_RL_AdditionRspTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponseList_RL_AdditionRspTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponseList_RL_AdditionRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationResponseList_RL_AdditionRspTDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_InformationResponseList_RL_AdditionRspTDD (ASN1CTXT* pctxt, USCH_InformationResponseList_RL_AdditionRspTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponseList_RL_AdditionRspTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponseList_RL_AdditionRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_RL_InformationRespItem_RL_AdditionFailureTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_RL_InformationRespItem_RL_AdditionFailureTDD (ASN1CTXT* pctxt, Unsuccessful_RL_InformationRespItem_RL_AdditionFailureTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespItem_RL_AdditionFailureTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespItem_RL_AdditionFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationAddList_RL_ReconfPrepTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationAddList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationAddList_RL_ReconfPrepTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationAddList_RL_ReconfPrepTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationAddList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationAddList_RL_ReconfPrepTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_InformationResponseList_RL_ReconfReady                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_InformationResponseList_RL_ReconfReady (ASN1CTXT* pctxt, DCH_InformationResponseList_RL_ReconfReady* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponseList_RL_ReconfReady: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponseList_RL_ReconfReady: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_InformationResponseList_RL_ReconfReady               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_InformationResponseList_RL_ReconfReady (ASN1CTXT* pctxt, DSCH_InformationResponseList_RL_ReconfReady* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponseList_RL_ReconfReady: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponseList_RL_ReconfReady: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationResponseList_RL_ReconfReady               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_InformationResponseList_RL_ReconfReady (ASN1CTXT* pctxt, USCH_InformationResponseList_RL_ReconfReady* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponseList_RL_ReconfReady: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponseList_RL_ReconfReady: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_InformationResponseList_RL_ReconfRsp                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_InformationResponseList_RL_ReconfRsp (ASN1CTXT* pctxt, DCH_InformationResponseList_RL_ReconfRsp* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponseList_RL_ReconfRsp: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponseList_RL_ReconfRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllRL_DM_Rqst                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllRL_DM_Rqst_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllRL_DM_Rqst: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt,"asn1PD_AllRL_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllRL_Set_DM_Rqst                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllRL_Set_DM_Rqst_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllRL_Set_DM_Rqst: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt,"asn1PD_AllRL_Set_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCH_Information_AddList_PSCH_ReconfRqst                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCH_Information_AddList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCH_Information_AddList_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_Information_AddList_PSCH_ReconfRqst: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_Information_AddList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCH_Information_ModifyList_PSCH_ReconfRqst              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCH_Information_ModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCH_Information_ModifyList_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_Information_ModifyList_PSCH_ReconfRqst: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_Information_ModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_Information_AddList_PSCH_ReconfRqst                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_Information_AddList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCH_Information_AddList_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Information_AddList_PSCH_ReconfRqst: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Information_AddList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_Information_ModifyList_PSCH_ReconfRqst              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_Information_ModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCH_Information_ModifyList_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Information_ModifyList_PSCH_ReconfRqst: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Information_ModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstMeasInfoList_CellSyncReconfRqstTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstMeasInfoList_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, CellSyncBurstMeasInfoList_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoList_CellSyncReconfRqstTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoList_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportTypeIE                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportTypeIE (ASN1CTXT* pctxt, SynchronisationReportTypeIE* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportTypeIE: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportTypeIE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharacteristicsIE                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportCharacteristicsIE (ASN1CTXT* pctxt, SynchronisationReportCharacteristicsIE* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharacteristicsIE: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharacteristicsIE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  C_ID_IE_CellSyncReprtTDD                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_C_ID_IE_CellSyncReprtTDD (ASN1CTXT* pctxt, C_ID_IE_CellSyncReprtTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_C_ID_IE_CellSyncReprtTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_C_ID_IE_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncReportTypeIE_CellSyncReprtTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncReportTypeIE_CellSyncReprtTDD (ASN1CTXT* pctxt, SyncReportTypeIE_CellSyncReprtTDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncReportTypeIE_CellSyncReprtTDD: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncReportTypeIE_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelSetupRequestFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelSetupRequestFDD (ASN1CTXT* pctxt, CommonTransportChannelSetupRequestFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelSetupRequestFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelSetupRequestFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerOffsetInformation_CTCH_SetupRqstFDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerOffsetInformation_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, PowerOffsetInformation_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pO1_ForTFCI_Bits */

   PU_PUSHNAME (pctxt, "pO1_ForTFCI_Bits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO1_ForTFCI_Bits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pO3_ForPilotBits */

   PU_PUSHNAME (pctxt, "pO3_ForPilotBits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO3_ForPilotBits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_CTCH_SetupRqstFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, Secondary_CCPCH_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dl_ScramblingCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_ScramblingCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "fACH_ParametersPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.fACH_ParametersPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pCH_ParametersPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pCH_ParametersPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_S_CCPCH_Offset */

   PU_PUSHNAME (pctxt, "fdd_S_CCPCH_Offset");

   stat = asn1PD_FDD_S_CCPCH_Offset (pctxt, &pvalue->fdd_S_CCPCH_Offset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_ScramblingCode */

   if (pvalue->m.dl_ScramblingCodePresent) {
      PU_PUSHNAME (pctxt, "dl_ScramblingCode");

      stat = asn1PD_DL_ScramblingCode (pctxt, &pvalue->dl_ScramblingCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode fdd_DL_ChannelisationCodeNumber */

   PU_PUSHNAME (pctxt, "fdd_DL_ChannelisationCodeNumber");

   stat = asn1PD_FDD_DL_ChannelisationCodeNumber (pctxt, &pvalue->fdd_DL_ChannelisationCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode secondary_CCPCH_SlotFormat */

   PU_PUSHNAME (pctxt, "secondary_CCPCH_SlotFormat");

   stat = asn1PD_SecondaryCCPCH_SlotFormat (pctxt, &pvalue->secondary_CCPCH_SlotFormat);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode multiplexingPosition */

   PU_PUSHNAME (pctxt, "multiplexingPosition");

   stat = asn1PD_MultiplexingPosition (pctxt, &pvalue->multiplexingPosition);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode powerOffsetInformation */

   PU_PUSHNAME (pctxt, "powerOffsetInformation");

   stat = asn1PD_PowerOffsetInformation_CTCH_SetupRqstFDD (pctxt, &pvalue->powerOffsetInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sTTD_Indicator */

   PU_PUSHNAME (pctxt, "sTTD_Indicator");

   stat = asn1PD_STTD_Indicator (pctxt, &pvalue->sTTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fACH_Parameters */

   if (pvalue->m.fACH_ParametersPresent) {
      PU_PUSHNAME (pctxt, "fACH_Parameters");

      stat = asn1PD_FACH_ParametersList_CTCH_SetupRqstFDD (pctxt, &pvalue->fACH_Parameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pCH_Parameters */

   if (pvalue->m.pCH_ParametersPresent) {
      PU_PUSHNAME (pctxt, "pCH_Parameters");

      stat = asn1PD_PCH_Parameters_CTCH_SetupRqstFDD (pctxt, &pvalue->pCH_Parameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllowedSlotFormatInformationItem_CTCH_SetupRqstFDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllowedSlotFormatInformationItem_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, AllowedSlotFormatInformationItem_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedSlotFormatInformationItem_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rACHSlotFormat */

   PU_PUSHNAME (pctxt, "rACHSlotFormat");

   stat = asn1PD_RACH_SlotFormat (pctxt, &pvalue->rACHSlotFormat);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedSlotFormatInformationItem_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllowedSlotFormatInformationList_CTCH_SetupRqstFDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllowedSlotFormatInformationList_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, AllowedSlotFormatInformationList_CTCH_SetupRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   AllowedSlotFormatInformationItem_CTCH_SetupRqstFDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedSlotFormatInformationList_CTCH_SetupRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AllowedSlotFormatInformationItem_CTCH_SetupRqstFDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AllowedSlotFormatInformationItem_CTCH_SetupRqstFDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedSlotFormatInformationList_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_Parameters_CTCH_SetupRqstFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AICH_Parameters_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, AICH_Parameters_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_Parameters_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode aICH_TransmissionTiming */

   PU_PUSHNAME (pctxt, "aICH_TransmissionTiming");

   stat = asn1PD_AICH_TransmissionTiming (pctxt, &pvalue->aICH_TransmissionTiming);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_dl_ChannelisationCodeNumber */

   PU_PUSHNAME (pctxt, "fdd_dl_ChannelisationCodeNumber");

   stat = asn1PD_FDD_DL_ChannelisationCodeNumber (pctxt, &pvalue->fdd_dl_ChannelisationCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode aICH_Power */

   PU_PUSHNAME (pctxt, "aICH_Power");

   stat = asn1PD_AICH_Power (pctxt, &pvalue->aICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sTTD_Indicator */

   PU_PUSHNAME (pctxt, "sTTD_Indicator");

   stat = asn1PD_STTD_Indicator (pctxt, &pvalue->sTTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_Parameters_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_CTCH_SetupRqstFDD                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, PRACH_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode scramblingCodeNumber */

   PU_PUSHNAME (pctxt, "scramblingCodeNumber");

   stat = asn1PD_ScramblingCodeNumber (pctxt, &pvalue->scramblingCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode preambleSignatures */

   PU_PUSHNAME (pctxt, "preambleSignatures");

   stat = asn1PD_PreambleSignatures (pctxt, &pvalue->preambleSignatures);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode allowedSlotFormatInformation */

   PU_PUSHNAME (pctxt, "allowedSlotFormatInformation");

   stat = asn1PD_AllowedSlotFormatInformationList_CTCH_SetupRqstFDD (pctxt, &pvalue->allowedSlotFormatInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rACH_SubChannelNumbers */

   PU_PUSHNAME (pctxt, "rACH_SubChannelNumbers");

   stat = asn1PD_RACH_SubChannelNumbers (pctxt, &pvalue->rACH_SubChannelNumbers);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_punctureLimit */

   PU_PUSHNAME (pctxt, "ul_punctureLimit");

   stat = asn1PD_PunctureLimit (pctxt, &pvalue->ul_punctureLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode preambleThreshold */

   PU_PUSHNAME (pctxt, "preambleThreshold");

   stat = asn1PD_PreambleThreshold (pctxt, &pvalue->preambleThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rACH_Parameters */

   PU_PUSHNAME (pctxt, "rACH_Parameters");

   stat = asn1PD_RACH_Parameters_CTCH_SetupRqstFDD (pctxt, &pvalue->rACH_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode aICH_Parameters */

   PU_PUSHNAME (pctxt, "aICH_Parameters");

   stat = asn1PD_AICH_Parameters_CTCH_SetupRqstFDD (pctxt, &pvalue->aICH_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonPhysicalChannelType_CTCH_SetupRqstFDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonPhysicalChannelType_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, CommonPhysicalChannelType_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonPhysicalChannelType_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* secondary_CCPCH_parameters */
         case 0:
            PU_PUSHNAME (pctxt, "u.secondary_CCPCH_parameters");

            pvalue->u.secondary_CCPCH_parameters = rtMemAllocTypeZ (pctxt, Secondary_CCPCH_CTCH_SetupRqstFDD);
            if (pvalue->u.secondary_CCPCH_parameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Secondary_CCPCH_CTCH_SetupRqstFDD (pctxt, pvalue->u.secondary_CCPCH_parameters);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* pRACH_parameters */
         case 1:
            PU_PUSHNAME (pctxt, "u.pRACH_parameters");

            pvalue->u.pRACH_parameters = rtMemAllocTypeZ (pctxt, PRACH_CTCH_SetupRqstFDD);
            if (pvalue->u.pRACH_parameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_PRACH_CTCH_SetupRqstFDD (pctxt, pvalue->u.pRACH_parameters);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notUsed_pCPCHes_parameters */
         case 2:
            PU_PUSHNAME (pctxt, "u.notUsed_pCPCHes_parameters");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonPhysicalChannelType_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersItem_CTCH_SetupRqstFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersItem_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, FACH_ParametersItem_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersItem_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transportFormatSet */

   PU_PUSHNAME (pctxt, "transportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxFACH_Power */

   PU_PUSHNAME (pctxt, "maxFACH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->maxFACH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersItem_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersListIE_CTCH_SetupRqstFDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersListIE_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, FACH_ParametersListIE_CTCH_SetupRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   FACH_ParametersItem_CTCH_SetupRqstFDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersListIE_CTCH_SetupRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, FACH_ParametersItem_CTCH_SetupRqstFDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_FACH_ParametersItem_CTCH_SetupRqstFDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersListIE_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Parameters_CTCH_SetupRqstFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_Parameters_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, PICH_Parameters_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Parameters_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_dl_ChannelisationCodeNumber */

   PU_PUSHNAME (pctxt, "fdd_dl_ChannelisationCodeNumber");

   stat = asn1PD_FDD_DL_ChannelisationCodeNumber (pctxt, &pvalue->fdd_dl_ChannelisationCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pICH_Power */

   PU_PUSHNAME (pctxt, "pICH_Power");

   stat = asn1PD_PICH_Power (pctxt, &pvalue->pICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pICH_Mode */

   PU_PUSHNAME (pctxt, "pICH_Mode");

   stat = asn1PD_PICH_Mode (pctxt, &pvalue->pICH_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sTTD_Indicator */

   PU_PUSHNAME (pctxt, "sTTD_Indicator");

   stat = asn1PD_STTD_Indicator (pctxt, &pvalue->sTTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Parameters_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_ParametersItem_CTCH_SetupRqstFDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_ParametersItem_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, PCH_ParametersItem_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_ParametersItem_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transportFormatSet */

   PU_PUSHNAME (pctxt, "transportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pCH_Power */

   PU_PUSHNAME (pctxt, "pCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->pCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pICH_Parameters */

   PU_PUSHNAME (pctxt, "pICH_Parameters");

   stat = asn1PD_PICH_Parameters_CTCH_SetupRqstFDD (pctxt, &pvalue->pICH_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_ParametersItem_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_Parameters_CTCH_SetupRqstFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_Parameters_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, MICH_Parameters_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Parameters_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_dl_ChannelisationCodeNumber */

   PU_PUSHNAME (pctxt, "fdd_dl_ChannelisationCodeNumber");

   stat = asn1PD_FDD_DL_ChannelisationCodeNumber (pctxt, &pvalue->fdd_dl_ChannelisationCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mICH_Power */

   PU_PUSHNAME (pctxt, "mICH_Power");

   stat = asn1PD_PICH_Power (pctxt, &pvalue->mICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mICH_Mode */

   PU_PUSHNAME (pctxt, "mICH_Mode");

   stat = asn1PD_MICH_Mode (pctxt, &pvalue->mICH_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sTTD_Indicator */

   PU_PUSHNAME (pctxt, "sTTD_Indicator");

   stat = asn1PD_STTD_Indicator (pctxt, &pvalue->sTTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Parameters_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_ParametersItem_CTCH_SetupRqstFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_ParametersItem_CTCH_SetupRqstFDD (ASN1CTXT* pctxt, RACH_ParametersItem_CTCH_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_ParametersItem_CTCH_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transportFormatSet */

   PU_PUSHNAME (pctxt, "transportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_ParametersItem_CTCH_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelSetupRequestTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelSetupRequestTDD (ASN1CTXT* pctxt, CommonTransportChannelSetupRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelSetupRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelSetupRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_CTCH_SetupRqstTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "fACH_ParametersListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.fACH_ParametersListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pCH_ParametersPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pCH_ParametersPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sCCPCH_CCTrCH_ID */

   PU_PUSHNAME (pctxt, "sCCPCH_CCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->sCCPCH_CCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Coding */

   PU_PUSHNAME (pctxt, "tFCI_Coding");

   stat = asn1PD_TFCI_Coding (pctxt, &pvalue->tFCI_Coding);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode punctureLimit */

   PU_PUSHNAME (pctxt, "punctureLimit");

   stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode secondaryCCPCH_parameterList */

   PU_PUSHNAME (pctxt, "secondaryCCPCH_parameterList");

   stat = asn1PD_Secondary_CCPCH_parameterList_CTCH_SetupRqstTDD (pctxt, &pvalue->secondaryCCPCH_parameterList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fACH_ParametersList */

   if (pvalue->m.fACH_ParametersListPresent) {
      PU_PUSHNAME (pctxt, "fACH_ParametersList");

      stat = asn1PD_FACH_ParametersList_CTCH_SetupRqstTDD (pctxt, &pvalue->fACH_ParametersList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pCH_Parameters */

   if (pvalue->m.pCH_ParametersPresent) {
      PU_PUSHNAME (pctxt, "pCH_Parameters");

      stat = asn1PD_PCH_Parameters_CTCH_SetupRqstTDD (pctxt, &pvalue->pCH_Parameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_CTCH_SetupRqstTDD                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PRACH_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pRACH_Parameters_CTCH_SetupRqstTDD */

   PU_PUSHNAME (pctxt, "pRACH_Parameters_CTCH_SetupRqstTDD");

   stat = asn1PD_PRACH_Parameters_CTCH_SetupRqstTDD (pctxt, &pvalue->pRACH_Parameters_CTCH_SetupRqstTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonPhysicalChannelType_CTCH_SetupRqstTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonPhysicalChannelType_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, CommonPhysicalChannelType_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonPhysicalChannelType_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* secondary_CCPCH_parameters */
         case 0:
            PU_PUSHNAME (pctxt, "u.secondary_CCPCH_parameters");

            pvalue->u.secondary_CCPCH_parameters = rtMemAllocTypeZ (pctxt, Secondary_CCPCH_CTCH_SetupRqstTDD);
            if (pvalue->u.secondary_CCPCH_parameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Secondary_CCPCH_CTCH_SetupRqstTDD (pctxt, pvalue->u.secondary_CCPCH_parameters);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* pRACH_parameters */
         case 1:
            PU_PUSHNAME (pctxt, "u.pRACH_parameters");

            pvalue->u.pRACH_parameters = rtMemAllocTypeZ (pctxt, PRACH_CTCH_SetupRqstTDD);
            if (pvalue->u.pRACH_parameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_PRACH_CTCH_SetupRqstTDD (pctxt, pvalue->u.pRACH_parameters);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonPhysicalChannelType_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeslot */

   PU_PUSHNAME (pctxt, "timeslot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftandBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftandBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftandBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode s_CCPCH_Power */

   PU_PUSHNAME (pctxt, "s_CCPCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->s_CCPCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_parameterListIE_CTCH_SetupRqstTDD         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_parameterListIE_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_parameterListIE_CTCH_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterListIE_CTCH_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterListIE_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersItem_CTCH_SetupRqstTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersItem_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, FACH_ParametersItem_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersItem_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fACH_CCTrCH_ID */

   PU_PUSHNAME (pctxt, "fACH_CCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->fACH_CCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_TransportFormatSet */

   PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersItem_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersListIE_CTCH_SetupRqstTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersListIE_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, FACH_ParametersListIE_CTCH_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   FACH_ParametersItem_CTCH_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersListIE_CTCH_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, FACH_ParametersItem_CTCH_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_FACH_ParametersItem_CTCH_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersListIE_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_ParametersItem_CTCH_SetupRqstTDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_ParametersItem_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PCH_ParametersItem_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_ParametersItem_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pCH_CCTrCH_ID */

   PU_PUSHNAME (pctxt, "pCH_CCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->pCH_CCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_TransportFormatSet */

   PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pICH_Parameters */

   PU_PUSHNAME (pctxt, "pICH_Parameters");

   stat = asn1PD_PICH_Parameters_CTCH_SetupRqstTDD (pctxt, &pvalue->pICH_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_ParametersItem_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_ParametersItem_CTCH_SetupRqstTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_ParametersItem_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PICH_ParametersItem_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_ParametersItem_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleshiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleshiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleshiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pagingIndicatorLength */

   PU_PUSHNAME (pctxt, "pagingIndicatorLength");

   stat = asn1PD_PagingIndicatorLength (pctxt, &pvalue->pagingIndicatorLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pICH_Power */

   PU_PUSHNAME (pctxt, "pICH_Power");

   stat = asn1PD_PICH_Power (pctxt, &pvalue->pICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_ParametersItem_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_LCR_Parameters_CTCH_SetupRqstTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_LCR_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PICH_LCR_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_LCR_Parameters_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pagingIndicatorLength */

   PU_PUSHNAME (pctxt, "pagingIndicatorLength");

   stat = asn1PD_PagingIndicatorLength (pctxt, &pvalue->pagingIndicatorLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pICH_Power */

   PU_PUSHNAME (pctxt, "pICH_Power");

   stat = asn1PD_PICH_Power (pctxt, &pvalue->pICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode second_TDD_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "second_TDD_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->second_TDD_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_LCR_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeslotLCR */

   PU_PUSHNAME (pctxt, "timeslotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeslotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode s_CCPCH_Power */

   PU_PUSHNAME (pctxt, "s_CCPCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->s_CCPCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode s_CCPCH_TimeSlotFormat_LCR */

   PU_PUSHNAME (pctxt, "s_CCPCH_TimeSlotFormat_LCR");

   stat = asn1PD_TDD_DL_DPCH_TimeSlotFormat_LCR (pctxt, &pvalue->s_CCPCH_TimeSlotFormat_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_LCR_parameterList_CTCH_SetupRqstTDD       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_LCR_parameterList_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_LCR_parameterList_CTCH_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_LCR_parameterList_CTCH_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_LCR_parameterList_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_HCR_Parameters_CTCH_SetupRqstTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_HCR_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, MICH_HCR_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_HCR_Parameters_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleshiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleshiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleshiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_HCR_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_LCR_Parameters_CTCH_SetupRqstTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_LCR_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, MICH_LCR_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_LCR_Parameters_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode second_TDD_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "second_TDD_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->second_TDD_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tSTD_Indicator */

   PU_PUSHNAME (pctxt, "tSTD_Indicator");

   stat = asn1PD_TSTD_Indicator (pctxt, &pvalue->tSTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_LCR_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_TDDOption_Specific_Parameters_CTCH_SetupRqstTDD      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_TDDOption_Specific_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, MICH_TDDOption_Specific_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_TDDOption_Specific_Parameters_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* hCR_TDD */
         case 0:
            PU_PUSHNAME (pctxt, "u.hCR_TDD");

            pvalue->u.hCR_TDD = rtMemAllocTypeZ (pctxt, MICH_HCR_Parameters_CTCH_SetupRqstTDD);
            if (pvalue->u.hCR_TDD == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_MICH_HCR_Parameters_CTCH_SetupRqstTDD (pctxt, pvalue->u.hCR_TDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* lCR_TDD */
         case 1:
            PU_PUSHNAME (pctxt, "u.lCR_TDD");

            pvalue->u.lCR_TDD = rtMemAllocTypeZ (pctxt, MICH_LCR_Parameters_CTCH_SetupRqstTDD);
            if (pvalue->u.lCR_TDD == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_MICH_LCR_Parameters_CTCH_SetupRqstTDD (pctxt, pvalue->u.lCR_TDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_TDDOption_Specific_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_Parameters_CTCH_SetupRqstTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, MICH_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Parameters_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode notificationIndicatorLength */

   PU_PUSHNAME (pctxt, "notificationIndicatorLength");

   stat = asn1PD_NotificationIndicatorLength (pctxt, &pvalue->notificationIndicatorLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mICH_Power */

   PU_PUSHNAME (pctxt, "mICH_Power");

   stat = asn1PD_PICH_Power (pctxt, &pvalue->mICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mICH_TDDOption_Specific_Parameters */

   PU_PUSHNAME (pctxt, "mICH_TDDOption_Specific_Parameters");

   stat = asn1PD_MICH_TDDOption_Specific_Parameters_CTCH_SetupRqstTDD (pctxt, &pvalue->mICH_TDDOption_Specific_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_parameterExtendedList_CTCH_SetupRqstTDD   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_parameterExtendedList_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_parameterExtendedList_CTCH_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(232), 0 };
   int stat = 0;
   Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterExtendedList_CTCH_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Secondary_CCPCH_parameterItem_CTCH_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterExtendedList_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_LCR_parameterExtendedList_CTCH_SetupRqst  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_LCR_parameterExtendedList_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_LCR_parameterExtendedList_CTCH_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(88), 0 };
   int stat = 0;
   Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_LCR_parameterExtendedList_CTCH_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Secondary_CCPCH_LCR_parameterItem_CTCH_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_LCR_parameterExtendedList_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_ParametersItem_CTCH_SetupRqstTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_ParametersItem_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PRACH_ParametersItem_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_ParametersItem_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeslot */

   PU_PUSHNAME (pctxt, "timeslot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxPRACH_MidambleShifts */

   PU_PUSHNAME (pctxt, "maxPRACH_MidambleShifts");

   stat = asn1PD_MaxPRACH_MidambleShifts (pctxt, &pvalue->maxPRACH_MidambleShifts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pRACH_Midamble */

   PU_PUSHNAME (pctxt, "pRACH_Midamble");

   stat = asn1PD_PRACH_Midamble (pctxt, &pvalue->pRACH_Midamble);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rACH */

   PU_PUSHNAME (pctxt, "rACH");

   stat = asn1PD_RACH_Parameter_CTCH_SetupRqstTDD (pctxt, &pvalue->rACH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_ParametersItem_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_ParameterItem_CTCH_SetupRqstTDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_ParameterItem_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, RACH_ParameterItem_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_ParameterItem_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_TransportFormatSet */

   PU_PUSHNAME (pctxt, "uL_TransportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->uL_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_ParameterItem_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_LCR_ParametersItem_CTCH_SetupRqstTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_LCR_ParametersItem_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PRACH_LCR_ParametersItem_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_LCR_ParametersItem_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeslotLCR */

   PU_PUSHNAME (pctxt, "timeslotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeslotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rACH */

   PU_PUSHNAME (pctxt, "rACH");

   stat = asn1PD_RACH_Parameter_CTCH_SetupRqstTDD (pctxt, &pvalue->rACH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_LCR_ParametersItem_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_LCR_ParametersList_CTCH_SetupRqstTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_LCR_ParametersList_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, PRACH_LCR_ParametersList_CTCH_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   PRACH_LCR_ParametersItem_CTCH_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_LCR_ParametersList_CTCH_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PRACH_LCR_ParametersItem_CTCH_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PRACH_LCR_ParametersItem_CTCH_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_LCR_ParametersList_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FPACH_LCR_Parameters_CTCH_SetupRqstTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FPACH_LCR_Parameters_CTCH_SetupRqstTDD (ASN1CTXT* pctxt, FPACH_LCR_Parameters_CTCH_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_LCR_Parameters_CTCH_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeslotLCR */

   PU_PUSHNAME (pctxt, "timeslotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeslotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fPACH_Power */

   PU_PUSHNAME (pctxt, "fPACH_Power");

   stat = asn1PD_FPACH_Power (pctxt, &pvalue->fPACH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_LCR_Parameters_CTCH_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelSetupResponse                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelSetupResponse (ASN1CTXT* pctxt, CommonTransportChannelSetupResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelSetupResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_CommonTransportChannel_InformationResponse           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_CommonTransportChannel_InformationResponse (ASN1CTXT* pctxt, FACH_CommonTransportChannel_InformationResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   CommonTransportChannel_InformationResponse* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_CommonTransportChannel_InformationResponse: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CommonTransportChannel_InformationResponse);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CommonTransportChannel_InformationResponse (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_CommonTransportChannel_InformationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelSetupFailure                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelSetupFailure (ASN1CTXT* pctxt, CommonTransportChannelSetupFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelSetupFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelSetupFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelReconfigurationRequestFDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelReconfigurationRequestFDD (ASN1CTXT* pctxt, CommonTransportChannelReconfigurationRequestFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelReconfigurationRequestFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelReconfigurationRequestFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCHList_CTCH_ReconfRqstFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCHList_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, Secondary_CCPCHList_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCHList_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "fACH_ParametersList_CTCH_ReconfRqstFDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.fACH_ParametersList_CTCH_ReconfRqstFDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pCH_Parameters_CTCH_ReconfRqstFDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pCH_Parameters_CTCH_ReconfRqstFDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pICH_Parameters_CTCH_ReconfRqstFDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pICH_Parameters_CTCH_ReconfRqstFDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode fACH_ParametersList_CTCH_ReconfRqstFDD */

   if (pvalue->m.fACH_ParametersList_CTCH_ReconfRqstFDDPresent) {
      PU_PUSHNAME (pctxt, "fACH_ParametersList_CTCH_ReconfRqstFDD");

      stat = asn1PD_FACH_ParametersList_CTCH_ReconfRqstFDD (pctxt, &pvalue->fACH_ParametersList_CTCH_ReconfRqstFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pCH_Parameters_CTCH_ReconfRqstFDD */

   if (pvalue->m.pCH_Parameters_CTCH_ReconfRqstFDDPresent) {
      PU_PUSHNAME (pctxt, "pCH_Parameters_CTCH_ReconfRqstFDD");

      stat = asn1PD_PCH_Parameters_CTCH_ReconfRqstFDD (pctxt, &pvalue->pCH_Parameters_CTCH_ReconfRqstFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pICH_Parameters_CTCH_ReconfRqstFDD */

   if (pvalue->m.pICH_Parameters_CTCH_ReconfRqstFDDPresent) {
      PU_PUSHNAME (pctxt, "pICH_Parameters_CTCH_ReconfRqstFDD");

      stat = asn1PD_PICH_Parameters_CTCH_ReconfRqstFDD (pctxt, &pvalue->pICH_Parameters_CTCH_ReconfRqstFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCHList_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACHList_CTCH_ReconfRqstFDD                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACHList_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, PRACHList_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACHList_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "pRACH_ParametersList_CTCH_ReconfRqstFDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pRACH_ParametersList_CTCH_ReconfRqstFDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "aICH_ParametersList_CTCH_ReconfRqstFDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.aICH_ParametersList_CTCH_ReconfRqstFDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pRACH_ParametersList_CTCH_ReconfRqstFDD */

   if (pvalue->m.pRACH_ParametersList_CTCH_ReconfRqstFDDPresent) {
      PU_PUSHNAME (pctxt, "pRACH_ParametersList_CTCH_ReconfRqstFDD");

      stat = asn1PD_PRACH_ParametersList_CTCH_ReconfRqstFDD (pctxt, &pvalue->pRACH_ParametersList_CTCH_ReconfRqstFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode aICH_ParametersList_CTCH_ReconfRqstFDD */

   if (pvalue->m.aICH_ParametersList_CTCH_ReconfRqstFDDPresent) {
      PU_PUSHNAME (pctxt, "aICH_ParametersList_CTCH_ReconfRqstFDD");

      stat = asn1PD_AICH_ParametersList_CTCH_ReconfRqstFDD (pctxt, &pvalue->aICH_ParametersList_CTCH_ReconfRqstFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACHList_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonPhysicalChannelType_CTCH_ReconfRqstFDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonPhysicalChannelType_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, CommonPhysicalChannelType_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonPhysicalChannelType_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* secondary_CCPCH_parameters */
         case 0:
            PU_PUSHNAME (pctxt, "u.secondary_CCPCH_parameters");

            pvalue->u.secondary_CCPCH_parameters = rtMemAllocTypeZ (pctxt, Secondary_CCPCHList_CTCH_ReconfRqstFDD);
            if (pvalue->u.secondary_CCPCH_parameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Secondary_CCPCHList_CTCH_ReconfRqstFDD (pctxt, pvalue->u.secondary_CCPCH_parameters);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* pRACH_parameters */
         case 1:
            PU_PUSHNAME (pctxt, "u.pRACH_parameters");

            pvalue->u.pRACH_parameters = rtMemAllocTypeZ (pctxt, PRACHList_CTCH_ReconfRqstFDD);
            if (pvalue->u.pRACH_parameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_PRACHList_CTCH_ReconfRqstFDD (pctxt, pvalue->u.pRACH_parameters);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notUsed_cPCH_parameters */
         case 2:
            PU_PUSHNAME (pctxt, "u.notUsed_cPCH_parameters");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonPhysicalChannelType_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersItem_CTCH_ReconfRqstFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersItem_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, FACH_ParametersItem_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersItem_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxFACH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxFACH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWEPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxFACH_Power */

   if (pvalue->m.maxFACH_PowerPresent) {
      PU_PUSHNAME (pctxt, "maxFACH_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->maxFACH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersItem_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersListIE_CTCH_ReconfRqstFDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersListIE_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, FACH_ParametersListIE_CTCH_ReconfRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   FACH_ParametersItem_CTCH_ReconfRqstFDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersListIE_CTCH_ReconfRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, FACH_ParametersItem_CTCH_ReconfRqstFDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_FACH_ParametersItem_CTCH_ReconfRqstFDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersListIE_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_ParametersItem_CTCH_ReconfRqstFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_ParametersItem_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, PCH_ParametersItem_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_ParametersItem_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "pCH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pCH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWEPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pCH_Power */

   if (pvalue->m.pCH_PowerPresent) {
      PU_PUSHNAME (pctxt, "pCH_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->pCH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_ParametersItem_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_ParametersItem_CTCH_ReconfRqstFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_ParametersItem_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, PICH_ParametersItem_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_ParametersItem_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "pICH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pICH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pICH_Power */

   if (pvalue->m.pICH_PowerPresent) {
      PU_PUSHNAME (pctxt, "pICH_Power");

      stat = asn1PD_PICH_Power (pctxt, &pvalue->pICH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_ParametersItem_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_Parameters_CTCH_ReconfRqstFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_Parameters_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, MICH_Parameters_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Parameters_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "mICH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mICH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mICH_Power */

   if (pvalue->m.mICH_PowerPresent) {
      PU_PUSHNAME (pctxt, "mICH_Power");

      stat = asn1PD_PICH_Power (pctxt, &pvalue->mICH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Parameters_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllowedSlotFormatInformationItem_CTCH_ReconfRqstFDD       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllowedSlotFormatInformationItem_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, AllowedSlotFormatInformationItem_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedSlotFormatInformationItem_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rACH_SlotFormat */

   PU_PUSHNAME (pctxt, "rACH_SlotFormat");

   stat = asn1PD_RACH_SlotFormat (pctxt, &pvalue->rACH_SlotFormat);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedSlotFormatInformationItem_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllowedSlotFormatInformationList_CTCH_ReconfRqstFDD       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllowedSlotFormatInformationList_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, AllowedSlotFormatInformationList_CTCH_ReconfRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   AllowedSlotFormatInformationItem_CTCH_ReconfRqstFDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedSlotFormatInformationList_CTCH_ReconfRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AllowedSlotFormatInformationItem_CTCH_ReconfRqstFDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AllowedSlotFormatInformationItem_CTCH_ReconfRqstFDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedSlotFormatInformationList_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_ParametersItem_CTCH_ReconfRqstFDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_ParametersItem_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, PRACH_ParametersItem_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_ParametersItem_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "preambleSignaturesPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.preambleSignaturesPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allowedSlotFormatInformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allowedSlotFormatInformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rACH_SubChannelNumbersPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rACH_SubChannelNumbersPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode preambleSignatures */

   if (pvalue->m.preambleSignaturesPresent) {
      PU_PUSHNAME (pctxt, "preambleSignatures");

      stat = asn1PD_PreambleSignatures (pctxt, &pvalue->preambleSignatures);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode allowedSlotFormatInformation */

   if (pvalue->m.allowedSlotFormatInformationPresent) {
      PU_PUSHNAME (pctxt, "allowedSlotFormatInformation");

      stat = asn1PD_AllowedSlotFormatInformationList_CTCH_ReconfRqstFDD (pctxt, &pvalue->allowedSlotFormatInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode rACH_SubChannelNumbers */

   if (pvalue->m.rACH_SubChannelNumbersPresent) {
      PU_PUSHNAME (pctxt, "rACH_SubChannelNumbers");

      stat = asn1PD_RACH_SubChannelNumbers (pctxt, &pvalue->rACH_SubChannelNumbers);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_ParametersItem_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_ParametersListIE_CTCH_ReconfRqstFDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_ParametersListIE_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, PRACH_ParametersListIE_CTCH_ReconfRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   PRACH_ParametersItem_CTCH_ReconfRqstFDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_ParametersListIE_CTCH_ReconfRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PRACH_ParametersItem_CTCH_ReconfRqstFDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PRACH_ParametersItem_CTCH_ReconfRqstFDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_ParametersListIE_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_ParametersItem_CTCH_ReconfRqstFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AICH_ParametersItem_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, AICH_ParametersItem_CTCH_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_ParametersItem_CTCH_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "aICH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.aICH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode aICH_Power */

   if (pvalue->m.aICH_PowerPresent) {
      PU_PUSHNAME (pctxt, "aICH_Power");

      stat = asn1PD_AICH_Power (pctxt, &pvalue->aICH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_ParametersItem_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_ParametersListIE_CTCH_ReconfRqstFDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AICH_ParametersListIE_CTCH_ReconfRqstFDD (ASN1CTXT* pctxt, AICH_ParametersListIE_CTCH_ReconfRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   AICH_ParametersItem_CTCH_ReconfRqstFDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_ParametersListIE_CTCH_ReconfRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AICH_ParametersItem_CTCH_ReconfRqstFDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_AICH_ParametersItem_CTCH_ReconfRqstFDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_ParametersListIE_CTCH_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelReconfigurationRequestTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelReconfigurationRequestTDD (ASN1CTXT* pctxt, CommonTransportChannelReconfigurationRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelReconfigurationRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelReconfigurationRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_Parameters_CTCH_ReconfRqstTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_Parameters_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_Parameters_CTCH_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_Parameters_CTCH_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "secondaryCCPCHListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondaryCCPCHListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode secondaryCCPCHList */

   if (pvalue->m.secondaryCCPCHListPresent) {
      PU_PUSHNAME (pctxt, "secondaryCCPCHList");

      stat = asn1PD_Secondary_CCPCHList_CTCH_ReconfRqstTDD (pctxt, &pvalue->secondaryCCPCHList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_Parameters_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCHItem_CTCH_ReconfRqstTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCHItem_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCHItem_CTCH_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCHItem_CTCH_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "sCCPCH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sCCPCH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sCCPCH_Power */

   if (pvalue->m.sCCPCH_PowerPresent) {
      PU_PUSHNAME (pctxt, "sCCPCH_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->sCCPCH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCHItem_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCHListIE_CTCH_ReconfRqstTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCHListIE_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCHListIE_CTCH_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Secondary_CCPCHItem_CTCH_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCHListIE_CTCH_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Secondary_CCPCHItem_CTCH_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Secondary_CCPCHItem_CTCH_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCHListIE_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Parameters_CTCH_ReconfRqstTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_Parameters_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, PICH_Parameters_CTCH_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Parameters_CTCH_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "pICH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pICH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pICH_Power */

   if (pvalue->m.pICH_PowerPresent) {
      PU_PUSHNAME (pctxt, "pICH_Power");

      stat = asn1PD_PICH_Power (pctxt, &pvalue->pICH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Parameters_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersItem_CTCH_ReconfRqstTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersItem_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, FACH_ParametersItem_CTCH_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersItem_CTCH_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWEPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersItem_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_ParametersList_CTCH_ReconfRqstTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_ParametersList_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, FACH_ParametersList_CTCH_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(8), 0 };
   int stat = 0;
   FACH_ParametersItem_CTCH_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersList_CTCH_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, FACH_ParametersItem_CTCH_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_FACH_ParametersItem_CTCH_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_ParametersList_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCH_Parameters_CTCH_ReconfRqstTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCH_Parameters_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, PCH_Parameters_CTCH_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Parameters_CTCH_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWEPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PCH_Parameters_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FPACH_LCR_Parameters_CTCH_ReconfRqstTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FPACH_LCR_Parameters_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, FPACH_LCR_Parameters_CTCH_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_LCR_Parameters_CTCH_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "fPACHPowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.fPACHPowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelId */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelId");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fPACHPower */

   if (pvalue->m.fPACHPowerPresent) {
      PU_PUSHNAME (pctxt, "fPACHPower");

      stat = asn1PD_FPACH_Power (pctxt, &pvalue->fPACHPower);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_LCR_Parameters_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_Parameters_CTCH_ReconfRqstTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_Parameters_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, MICH_Parameters_CTCH_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Parameters_CTCH_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "mICH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mICH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mICH_Power */

   if (pvalue->m.mICH_PowerPresent) {
      PU_PUSHNAME (pctxt, "mICH_Power");

      stat = asn1PD_PICH_Power (pctxt, &pvalue->mICH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Parameters_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_parameterExtendedList_CTCH_ReconfRqstTDD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_parameterExtendedList_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_parameterExtendedList_CTCH_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(232), 0 };
   int stat = 0;
   Secondary_CCPCHItem_CTCH_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterExtendedList_CTCH_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Secondary_CCPCHItem_CTCH_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Secondary_CCPCHItem_CTCH_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_parameterExtendedList_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CCPCH_LCR_parameterExtendedList_CTCH_ReconfRqs  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CCPCH_LCR_parameterExtendedList_CTCH_ReconfRqstTDD (ASN1CTXT* pctxt, Secondary_CCPCH_LCR_parameterExtendedList_CTCH_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(88), 0 };
   int stat = 0;
   Secondary_CCPCHItem_CTCH_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_LCR_parameterExtendedList_CTCH_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Secondary_CCPCHItem_CTCH_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Secondary_CCPCHItem_CTCH_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CCPCH_LCR_parameterExtendedList_CTCH_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelReconfigurationResponse             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelReconfigurationResponse (ASN1CTXT* pctxt, CommonTransportChannelReconfigurationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelReconfigurationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelReconfigurationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelReconfigurationFailure              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelReconfigurationFailure (ASN1CTXT* pctxt, CommonTransportChannelReconfigurationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelReconfigurationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelReconfigurationFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelDeletionRequest                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelDeletionRequest (ASN1CTXT* pctxt, CommonTransportChannelDeletionRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelDeletionRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelDeletionRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelDeletionResponse                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelDeletionResponse (ASN1CTXT* pctxt, CommonTransportChannelDeletionResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelDeletionResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelDeletionResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BlockResourceRequest                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BlockResourceRequest (ASN1CTXT* pctxt, BlockResourceRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_BlockResourceRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BlockResourceRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BlockResourceResponse                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BlockResourceResponse (ASN1CTXT* pctxt, BlockResourceResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_BlockResourceResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BlockResourceResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BlockResourceFailure                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BlockResourceFailure (ASN1CTXT* pctxt, BlockResourceFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_BlockResourceFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BlockResourceFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnblockResourceIndication                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UnblockResourceIndication (ASN1CTXT* pctxt, UnblockResourceIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UnblockResourceIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UnblockResourceIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditRequiredIndication                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuditRequiredIndication (ASN1CTXT* pctxt, AuditRequiredIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AuditRequiredIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AuditRequiredIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditRequest                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuditRequest (ASN1CTXT* pctxt, AuditRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AuditRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AuditRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditResponse                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuditResponse (ASN1CTXT* pctxt, AuditResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AuditResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AuditResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_InformationList_AuditRsp                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_InformationList_AuditRsp (ASN1CTXT* pctxt, Cell_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_CPICH_InformationList_AuditRsp                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_CPICH_InformationList_AuditRsp (ASN1CTXT* pctxt, S_CPICH_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CPICH_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CPICH_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_CCPCH_InformationList_AuditRsp                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_CCPCH_InformationList_AuditRsp (ASN1CTXT* pctxt, S_CCPCH_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_InformationList_AuditRsp                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_InformationList_AuditRsp (ASN1CTXT* pctxt, FACH_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_InformationList_AuditRsp                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_InformationList_AuditRsp (ASN1CTXT* pctxt, PRACH_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_InformationList_AuditRsp                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_InformationList_AuditRsp (ASN1CTXT* pctxt, RACH_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_InformationList_AuditRsp                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AICH_InformationList_AuditRsp (ASN1CTXT* pctxt, AICH_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_InformationItem_AuditRsp                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_InformationItem_AuditRsp (ASN1CTXT* pctxt, Cell_InformationItem_AuditRsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InformationItem_AuditRsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "primary_SCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.primary_SCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondary_SCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondary_SCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "primary_CPICH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.primary_CPICH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondary_CPICH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondary_CPICH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "primary_CCPCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.primary_CCPCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondary_CCPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondary_CCPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pICH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pICH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "fACH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.fACH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pRACH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pRACH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rACH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rACH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "aICH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.aICH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "notUsed_1_pCPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.notUsed_1_pCPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "notUsed_2_cPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.notUsed_2_cPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "notUsed_3_aP_AICH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.notUsed_3_aP_AICH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "notUsed_4_cDCA_ICH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.notUsed_4_cDCA_ICH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode configurationGenerationID */

   PU_PUSHNAME (pctxt, "configurationGenerationID");

   stat = asn1PD_ConfigurationGenerationID (pctxt, &pvalue->configurationGenerationID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode local_Cell_ID */

   PU_PUSHNAME (pctxt, "local_Cell_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_Cell_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode primary_SCH_Information */

   if (pvalue->m.primary_SCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "primary_SCH_Information");

      stat = asn1PD_P_SCH_Information_AuditRsp (pctxt, &pvalue->primary_SCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode secondary_SCH_Information */

   if (pvalue->m.secondary_SCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "secondary_SCH_Information");

      stat = asn1PD_S_SCH_Information_AuditRsp (pctxt, &pvalue->secondary_SCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode primary_CPICH_Information */

   if (pvalue->m.primary_CPICH_InformationPresent) {
      PU_PUSHNAME (pctxt, "primary_CPICH_Information");

      stat = asn1PD_P_CPICH_Information_AuditRsp (pctxt, &pvalue->primary_CPICH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode secondary_CPICH_InformationList */

   if (pvalue->m.secondary_CPICH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "secondary_CPICH_InformationList");

      stat = asn1PD_S_CPICH_InformationList_AuditRsp (pctxt, &pvalue->secondary_CPICH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode primary_CCPCH_Information */

   if (pvalue->m.primary_CCPCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "primary_CCPCH_Information");

      stat = asn1PD_P_CCPCH_Information_AuditRsp (pctxt, &pvalue->primary_CCPCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode bCH_Information */

   if (pvalue->m.bCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "bCH_Information");

      stat = asn1PD_BCH_Information_AuditRsp (pctxt, &pvalue->bCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode secondary_CCPCH_InformationList */

   if (pvalue->m.secondary_CCPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "secondary_CCPCH_InformationList");

      stat = asn1PD_S_CCPCH_InformationList_AuditRsp (pctxt, &pvalue->secondary_CCPCH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pCH_Information */

   if (pvalue->m.pCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "pCH_Information");

      stat = asn1PD_PCH_Information_AuditRsp (pctxt, &pvalue->pCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pICH_Information */

   if (pvalue->m.pICH_InformationPresent) {
      PU_PUSHNAME (pctxt, "pICH_Information");

      stat = asn1PD_PICH_Information_AuditRsp (pctxt, &pvalue->pICH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode fACH_InformationList */

   if (pvalue->m.fACH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "fACH_InformationList");

      stat = asn1PD_FACH_InformationList_AuditRsp (pctxt, &pvalue->fACH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pRACH_InformationList */

   if (pvalue->m.pRACH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "pRACH_InformationList");

      stat = asn1PD_PRACH_InformationList_AuditRsp (pctxt, &pvalue->pRACH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode rACH_InformationList */

   if (pvalue->m.rACH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "rACH_InformationList");

      stat = asn1PD_RACH_InformationList_AuditRsp (pctxt, &pvalue->rACH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode aICH_InformationList */

   if (pvalue->m.aICH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "aICH_InformationList");

      stat = asn1PD_AICH_InformationList_AuditRsp (pctxt, &pvalue->aICH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode notUsed_1_pCPCH_InformationList */

   if (pvalue->m.notUsed_1_pCPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "notUsed_1_pCPCH_InformationList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode notUsed_2_cPCH_InformationList */

   if (pvalue->m.notUsed_2_cPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "notUsed_2_cPCH_InformationList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode notUsed_3_aP_AICH_InformationList */

   if (pvalue->m.notUsed_3_aP_AICH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "notUsed_3_aP_AICH_InformationList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode notUsed_4_cDCA_ICH_InformationList */

   if (pvalue->m.notUsed_4_cDCA_ICH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "notUsed_4_cDCA_ICH_InformationList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode sCH_Information */

   if (pvalue->m.sCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "sCH_Information");

      stat = asn1PD_SCH_Information_AuditRsp (pctxt, &pvalue->sCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InformationItem_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCP_InformationList_AuditRsp                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCP_InformationList_AuditRsp (ASN1CTXT* pctxt, CCP_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCP_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCP_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCP_InformationItem_AuditRsp                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCP_InformationItem_AuditRsp (ASN1CTXT* pctxt, CCP_InformationItem_AuditRsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCP_InformationItem_AuditRsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode communicationControlPortID */

   PU_PUSHNAME (pctxt, "communicationControlPortID");

   stat = asn1PD_CommunicationControlPortID (pctxt, &pvalue->communicationControlPortID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCP_InformationItem_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FPACH_LCR_InformationList_AuditRsp                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FPACH_LCR_InformationList_AuditRsp (ASN1CTXT* pctxt, FPACH_LCR_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_LCR_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_LCR_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCH_Resources_Information_AuditRsp                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCH_Resources_Information_AuditRsp (ASN1CTXT* pctxt, HS_DSCH_Resources_Information_AuditRsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCH_Resources_Information_AuditRsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCH_Resources_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_CCPCH_InformationListExt_AuditRsp                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_CCPCH_InformationListExt_AuditRsp (ASN1CTXT* pctxt, S_CCPCH_InformationListExt_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(208), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_InformationListExt_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_InformationListExt_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_CCPCH_LCR_InformationListExt_AuditRsp                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_CCPCH_LCR_InformationListExt_AuditRsp (ASN1CTXT* pctxt, S_CCPCH_LCR_InformationListExt_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_LCR_InformationListExt_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_LCR_InformationListExt_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_Resources_Information_AuditRsp                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_Resources_Information_AuditRsp (ASN1CTXT* pctxt, E_DCH_Resources_Information_AuditRsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Resources_Information_AuditRsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Resources_Information_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_InformationList_AuditRsp                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_InformationList_AuditRsp (ASN1CTXT* pctxt, Local_Cell_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_InformationItem_AuditRsp                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_InformationItem_AuditRsp (ASN1CTXT* pctxt, Local_Cell_InformationItem_AuditRsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationItem_AuditRsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maximumDL_PowerCapabilityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maximumDL_PowerCapabilityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minSpreadingFactorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minSpreadingFactorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minimumDL_PowerCapabilityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minimumDL_PowerCapabilityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "local_Cell_Group_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.local_Cell_Group_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode local_Cell_ID */

   PU_PUSHNAME (pctxt, "local_Cell_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_Cell_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_or_global_capacityCredit */

   PU_PUSHNAME (pctxt, "dl_or_global_capacityCredit");

   stat = asn1PD_DL_or_Global_CapacityCredit (pctxt, &pvalue->dl_or_global_capacityCredit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_capacityCredit */

   if (pvalue->m.ul_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "ul_capacityCredit");

      stat = asn1PD_UL_CapacityCredit (pctxt, &pvalue->ul_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode commonChannelsCapacityConsumptionLaw */

   PU_PUSHNAME (pctxt, "commonChannelsCapacityConsumptionLaw");

   stat = asn1PD_CommonChannelsCapacityConsumptionLaw (pctxt, &pvalue->commonChannelsCapacityConsumptionLaw);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dedicatedChannelsCapacityConsumptionLaw */

   PU_PUSHNAME (pctxt, "dedicatedChannelsCapacityConsumptionLaw");

   stat = asn1PD_DedicatedChannelsCapacityConsumptionLaw (pctxt, &pvalue->dedicatedChannelsCapacityConsumptionLaw);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maximumDL_PowerCapability */

   if (pvalue->m.maximumDL_PowerCapabilityPresent) {
      PU_PUSHNAME (pctxt, "maximumDL_PowerCapability");

      stat = asn1PD_MaximumDL_PowerCapability (pctxt, &pvalue->maximumDL_PowerCapability);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minSpreadingFactor */

   if (pvalue->m.minSpreadingFactorPresent) {
      PU_PUSHNAME (pctxt, "minSpreadingFactor");

      stat = asn1PD_MinSpreadingFactor (pctxt, &pvalue->minSpreadingFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minimumDL_PowerCapability */

   if (pvalue->m.minimumDL_PowerCapabilityPresent) {
      PU_PUSHNAME (pctxt, "minimumDL_PowerCapability");

      stat = asn1PD_MinimumDL_PowerCapability (pctxt, &pvalue->minimumDL_PowerCapability);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode local_Cell_Group_ID */

   if (pvalue->m.local_Cell_Group_IDPresent) {
      PU_PUSHNAME (pctxt, "local_Cell_Group_ID");

      stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_Cell_Group_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationItem_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_Group_InformationList_AuditRsp                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_Group_InformationList_AuditRsp (ASN1CTXT* pctxt, Local_Cell_Group_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_Group_InformationItem_AuditRsp                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_Group_InformationItem_AuditRsp (ASN1CTXT* pctxt, Local_Cell_Group_InformationItem_AuditRsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationItem_AuditRsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode local_Cell_Group_ID */

   PU_PUSHNAME (pctxt, "local_Cell_Group_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_Cell_Group_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_or_global_capacityCredit */

   PU_PUSHNAME (pctxt, "dl_or_global_capacityCredit");

   stat = asn1PD_DL_or_Global_CapacityCredit (pctxt, &pvalue->dl_or_global_capacityCredit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_capacityCredit */

   if (pvalue->m.ul_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "ul_capacityCredit");

      stat = asn1PD_UL_CapacityCredit (pctxt, &pvalue->ul_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode commonChannelsCapacityConsumptionLaw */

   PU_PUSHNAME (pctxt, "commonChannelsCapacityConsumptionLaw");

   stat = asn1PD_CommonChannelsCapacityConsumptionLaw (pctxt, &pvalue->commonChannelsCapacityConsumptionLaw);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dedicatedChannelsCapacityConsumptionLaw */

   PU_PUSHNAME (pctxt, "dedicatedChannelsCapacityConsumptionLaw");

   stat = asn1PD_DedicatedChannelsCapacityConsumptionLaw (pctxt, &pvalue->dedicatedChannelsCapacityConsumptionLaw);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationItem_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Power_Local_Cell_Group_InformationList_AuditRsp           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Power_Local_Cell_Group_InformationList_AuditRsp (ASN1CTXT* pctxt, Power_Local_Cell_Group_InformationList_AuditRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationList_AuditRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationList_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Power_Local_Cell_Group_InformationItem_AuditRsp           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Power_Local_Cell_Group_InformationItem_AuditRsp (ASN1CTXT* pctxt, Power_Local_Cell_Group_InformationItem_AuditRsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationItem_AuditRsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode power_Local_Cell_Group_ID */

   PU_PUSHNAME (pctxt, "power_Local_Cell_Group_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->power_Local_Cell_Group_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maximumDL_PowerCapability */

   PU_PUSHNAME (pctxt, "maximumDL_PowerCapability");

   stat = asn1PD_MaximumDL_PowerCapability (pctxt, &pvalue->maximumDL_PowerCapability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationItem_AuditRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditFailure                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AuditFailure (ASN1CTXT* pctxt, AuditFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AuditFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AuditFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementInitiationRequest                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementInitiationRequest (ASN1CTXT* pctxt, CommonMeasurementInitiationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementInitiationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementInitiationRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_CM_Rqst                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_CM_Rqst (ASN1CTXT* pctxt, Cell_CM_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_CM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "timeSlotPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timeSlotPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   if (pvalue->m.timeSlotPresent) {
      PU_PUSHNAME (pctxt, "timeSlot");

      stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_CM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_CM_Rqst                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_CM_Rqst (ASN1CTXT* pctxt, RACH_CM_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_CM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_CM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementObjectType_CM_Rqst                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementObjectType_CM_Rqst (ASN1CTXT* pctxt, CommonMeasurementObjectType_CM_Rqst* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementObjectType_CM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* cell */
         case 0:
            PU_PUSHNAME (pctxt, "u.cell");

            pvalue->u.cell = rtMemAllocTypeZ (pctxt, Cell_CM_Rqst);
            if (pvalue->u.cell == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Cell_CM_Rqst (pctxt, pvalue->u.cell);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rACH */
         case 1:
            PU_PUSHNAME (pctxt, "u.rACH");

            pvalue->u.rACH = rtMemAllocTypeZ (pctxt, RACH_CM_Rqst);
            if (pvalue->u.rACH == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RACH_CM_Rqst (pctxt, pvalue->u.rACH);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notUsed_cPCH */
         case 2:
            PU_PUSHNAME (pctxt, "u.notUsed_cPCH");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_CommonMeasurementObjectType_CM_Rqst */
         case 4:
            PU_PUSHNAME (pctxt, "u.extension_CommonMeasurementObjectType_CM_Rqst");

            pvalue->u.extension_CommonMeasurementObjectType_CM_Rqst = rtMemAllocTypeZ (pctxt, Extension_CommonMeasurementObjectType_CM_Rqst);
            if (pvalue->u.extension_CommonMeasurementObjectType_CM_Rqst == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_CommonMeasurementObjectType_CM_Rqst (pctxt, pvalue->u.extension_CommonMeasurementObjectType_CM_Rqst);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementObjectType_CM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerLocalCellGroup_CM_Rqst                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerLocalCellGroup_CM_Rqst (ASN1CTXT* pctxt, PowerLocalCellGroup_CM_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerLocalCellGroup_CM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode powerLocalCellGroupID */

   PU_PUSHNAME (pctxt, "powerLocalCellGroupID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->powerLocalCellGroupID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerLocalCellGroup_CM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementInitiationResponse                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementInitiationResponse (ASN1CTXT* pctxt, CommonMeasurementInitiationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementInitiationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementInitiationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_CM_Rsp                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_CM_Rsp (ASN1CTXT* pctxt, Cell_CM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_CM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonMeasurementValue */

   PU_PUSHNAME (pctxt, "commonMeasurementValue");

   stat = asn1PD_CommonMeasurementValue (pctxt, &pvalue->commonMeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_CM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_CM_Rsp                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_CM_Rsp (ASN1CTXT* pctxt, RACH_CM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_CM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonMeasurementValue */

   PU_PUSHNAME (pctxt, "commonMeasurementValue");

   stat = asn1PD_CommonMeasurementValue (pctxt, &pvalue->commonMeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_CM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementObjectType_CM_Rsp                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementObjectType_CM_Rsp (ASN1CTXT* pctxt, CommonMeasurementObjectType_CM_Rsp* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementObjectType_CM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* cell */
         case 0:
            PU_PUSHNAME (pctxt, "u.cell");

            pvalue->u.cell = rtMemAllocTypeZ (pctxt, Cell_CM_Rsp);
            if (pvalue->u.cell == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Cell_CM_Rsp (pctxt, pvalue->u.cell);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rACH */
         case 1:
            PU_PUSHNAME (pctxt, "u.rACH");

            pvalue->u.rACH = rtMemAllocTypeZ (pctxt, RACH_CM_Rsp);
            if (pvalue->u.rACH == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RACH_CM_Rsp (pctxt, pvalue->u.rACH);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notUsed_cPCH */
         case 2:
            PU_PUSHNAME (pctxt, "u.notUsed_cPCH");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_CommonMeasurementObjectType_CM_Rsp */
         case 4:
            PU_PUSHNAME (pctxt, "u.extension_CommonMeasurementObjectType_CM_Rsp");

            pvalue->u.extension_CommonMeasurementObjectType_CM_Rsp = rtMemAllocTypeZ (pctxt, Extension_CommonMeasurementObjectType_CM_Rsp);
            if (pvalue->u.extension_CommonMeasurementObjectType_CM_Rsp == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_CommonMeasurementObjectType_CM_Rsp (pctxt, pvalue->u.extension_CommonMeasurementObjectType_CM_Rsp);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementObjectType_CM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerLocalCellGroup_CM_Rsp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerLocalCellGroup_CM_Rsp (ASN1CTXT* pctxt, PowerLocalCellGroup_CM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerLocalCellGroup_CM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonMeasurementValue */

   PU_PUSHNAME (pctxt, "commonMeasurementValue");

   stat = asn1PD_CommonMeasurementValue (pctxt, &pvalue->commonMeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerLocalCellGroup_CM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementInitiationFailure                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementInitiationFailure (ASN1CTXT* pctxt, CommonMeasurementInitiationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementInitiationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementInitiationFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementReport                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementReport (ASN1CTXT* pctxt, CommonMeasurementReport* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementReport: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_CM_Rprt                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_CM_Rprt (ASN1CTXT* pctxt, Cell_CM_Rprt* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_CM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonMeasurementValueInformation */

   PU_PUSHNAME (pctxt, "commonMeasurementValueInformation");

   stat = asn1PD_CommonMeasurementValueInformation (pctxt, &pvalue->commonMeasurementValueInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_CM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_CM_Rprt                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_CM_Rprt (ASN1CTXT* pctxt, RACH_CM_Rprt* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_CM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonMeasurementValueInformation */

   PU_PUSHNAME (pctxt, "commonMeasurementValueInformation");

   stat = asn1PD_CommonMeasurementValueInformation (pctxt, &pvalue->commonMeasurementValueInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_CM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementObjectType_CM_Rprt                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementObjectType_CM_Rprt (ASN1CTXT* pctxt, CommonMeasurementObjectType_CM_Rprt* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementObjectType_CM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* cell */
         case 0:
            PU_PUSHNAME (pctxt, "u.cell");

            pvalue->u.cell = rtMemAllocTypeZ (pctxt, Cell_CM_Rprt);
            if (pvalue->u.cell == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Cell_CM_Rprt (pctxt, pvalue->u.cell);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rACH */
         case 1:
            PU_PUSHNAME (pctxt, "u.rACH");

            pvalue->u.rACH = rtMemAllocTypeZ (pctxt, RACH_CM_Rprt);
            if (pvalue->u.rACH == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RACH_CM_Rprt (pctxt, pvalue->u.rACH);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notUsed_cPCH */
         case 2:
            PU_PUSHNAME (pctxt, "u.notUsed_cPCH");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_CommonMeasurementObjectType_CM_Rprt */
         case 4:
            PU_PUSHNAME (pctxt, "u.extension_CommonMeasurementObjectType_CM_Rprt");

            pvalue->u.extension_CommonMeasurementObjectType_CM_Rprt = rtMemAllocTypeZ (pctxt, Extension_CommonMeasurementObjectType_CM_Rprt);
            if (pvalue->u.extension_CommonMeasurementObjectType_CM_Rprt == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_CommonMeasurementObjectType_CM_Rprt (pctxt, pvalue->u.extension_CommonMeasurementObjectType_CM_Rprt);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementObjectType_CM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerLocalCellGroup_CM_Rprt                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerLocalCellGroup_CM_Rprt (ASN1CTXT* pctxt, PowerLocalCellGroup_CM_Rprt* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerLocalCellGroup_CM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonMeasurementValueInformation */

   PU_PUSHNAME (pctxt, "commonMeasurementValueInformation");

   stat = asn1PD_CommonMeasurementValueInformation (pctxt, &pvalue->commonMeasurementValueInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerLocalCellGroup_CM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementTerminationRequest                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementTerminationRequest (ASN1CTXT* pctxt, CommonMeasurementTerminationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementTerminationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementTerminationRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementFailureIndication                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementFailureIndication (ASN1CTXT* pctxt, CommonMeasurementFailureIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementFailureIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSetupRequestFDD                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSetupRequestFDD (ASN1CTXT* pctxt, CellSetupRequestFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSetupRequestFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSetupRequestFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Synchronisation_Configuration_Cell_SetupRqst              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Synchronisation_Configuration_Cell_SetupRqst (ASN1CTXT* pctxt, Synchronisation_Configuration_Cell_SetupRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Synchronisation_Configuration_Cell_SetupRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode n_INSYNC_IND */

   PU_PUSHNAME (pctxt, "n_INSYNC_IND");

   stat = asn1PD_N_INSYNC_IND (pctxt, &pvalue->n_INSYNC_IND);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode n_OUTSYNC_IND */

   PU_PUSHNAME (pctxt, "n_OUTSYNC_IND");

   stat = asn1PD_N_OUTSYNC_IND (pctxt, &pvalue->n_OUTSYNC_IND);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode t_RLFAILURE */

   PU_PUSHNAME (pctxt, "t_RLFAILURE");

   stat = asn1PD_T_RLFAILURE (pctxt, &pvalue->t_RLFAILURE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Synchronisation_Configuration_Cell_SetupRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimarySCH_Information_Cell_SetupRqstFDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimarySCH_Information_Cell_SetupRqstFDD (ASN1CTXT* pctxt, PrimarySCH_Information_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimarySCH_Information_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode primarySCH_Power */

   PU_PUSHNAME (pctxt, "primarySCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->primarySCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tSTD_Indicator */

   PU_PUSHNAME (pctxt, "tSTD_Indicator");

   stat = asn1PD_TSTD_Indicator (pctxt, &pvalue->tSTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimarySCH_Information_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondarySCH_Information_Cell_SetupRqstFDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecondarySCH_Information_Cell_SetupRqstFDD (ASN1CTXT* pctxt, SecondarySCH_Information_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondarySCH_Information_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode secondarySCH_Power */

   PU_PUSHNAME (pctxt, "secondarySCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->secondarySCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tSTD_Indicator */

   PU_PUSHNAME (pctxt, "tSTD_Indicator");

   stat = asn1PD_TSTD_Indicator (pctxt, &pvalue->tSTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondarySCH_Information_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCPICH_Information_Cell_SetupRqstFDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimaryCPICH_Information_Cell_SetupRqstFDD (ASN1CTXT* pctxt, PrimaryCPICH_Information_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCPICH_Information_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode primaryCPICH_Power */

   PU_PUSHNAME (pctxt, "primaryCPICH_Power");

   stat = asn1PD_PrimaryCPICH_Power (pctxt, &pvalue->primaryCPICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transmitDiversityIndicator */

   PU_PUSHNAME (pctxt, "transmitDiversityIndicator");

   stat = asn1PD_TransmitDiversityIndicator (pctxt, &pvalue->transmitDiversityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCPICH_Information_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondaryCPICH_InformationList_Cell_SetupRqstFDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecondaryCPICH_InformationList_Cell_SetupRqstFDD (ASN1CTXT* pctxt, SecondaryCPICH_InformationList_Cell_SetupRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCPICH_InformationList_Cell_SetupRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCPICH_InformationList_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondaryCPICH_InformationItem_Cell_SetupRqstFDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecondaryCPICH_InformationItem_Cell_SetupRqstFDD (ASN1CTXT* pctxt, SecondaryCPICH_InformationItem_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCPICH_InformationItem_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_ScramblingCode */

   PU_PUSHNAME (pctxt, "dl_ScramblingCode");

   stat = asn1PD_DL_ScramblingCode (pctxt, &pvalue->dl_ScramblingCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fDD_DL_ChannelisationCodeNumber */

   PU_PUSHNAME (pctxt, "fDD_DL_ChannelisationCodeNumber");

   stat = asn1PD_FDD_DL_ChannelisationCodeNumber (pctxt, &pvalue->fDD_DL_ChannelisationCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode secondaryCPICH_Power */

   PU_PUSHNAME (pctxt, "secondaryCPICH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->secondaryCPICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transmitDiversityIndicator */

   PU_PUSHNAME (pctxt, "transmitDiversityIndicator");

   stat = asn1PD_TransmitDiversityIndicator (pctxt, &pvalue->transmitDiversityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCPICH_InformationItem_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BCH_Information_Cell_SetupRqstFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BCH_Information_Cell_SetupRqstFDD (ASN1CTXT* pctxt, BCH_Information_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_BCH_Information_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bCH_Power */

   PU_PUSHNAME (pctxt, "bCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->bCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BCH_Information_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCCPCH_Information_Cell_SetupRqstFDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimaryCCPCH_Information_Cell_SetupRqstFDD (ASN1CTXT* pctxt, PrimaryCCPCH_Information_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCCPCH_Information_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bCH_information */

   PU_PUSHNAME (pctxt, "bCH_information");

   stat = asn1PD_BCH_Information_Cell_SetupRqstFDD (pctxt, &pvalue->bCH_information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sTTD_Indicator */

   PU_PUSHNAME (pctxt, "sTTD_Indicator");

   stat = asn1PD_STTD_Indicator (pctxt, &pvalue->sTTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCCPCH_Information_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Limited_power_increase_information_Cell_SetupRqstFDD      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Limited_power_increase_information_Cell_SetupRqstFDD (ASN1CTXT* pctxt, Limited_power_increase_information_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Limited_power_increase_information_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode powerRaiseLimit */

   PU_PUSHNAME (pctxt, "powerRaiseLimit");

   stat = asn1PD_PowerRaiseLimit (pctxt, &pvalue->powerRaiseLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dLPowerAveragingWindowSize */

   PU_PUSHNAME (pctxt, "dLPowerAveragingWindowSize");

   stat = asn1PD_DLPowerAveragingWindowSize (pctxt, &pvalue->dLPowerAveragingWindowSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Limited_power_increase_information_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDLParameter_Information_Cell_SetupRqstFDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDLParameter_Information_Cell_SetupRqstFDD (ASN1CTXT* pctxt, IPDLParameter_Information_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iPDL_FDD_Parameters */

   PU_PUSHNAME (pctxt, "iPDL_FDD_Parameters");

   stat = asn1PD_IPDL_FDD_Parameters (pctxt, &pvalue->iPDL_FDD_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iPDL_Indicator */

   PU_PUSHNAME (pctxt, "iPDL_Indicator");

   stat = asn1PD_IPDL_Indicator (pctxt, &pvalue->iPDL_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellPortion_InformationList_Cell_SetupRqstFDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellPortion_InformationList_Cell_SetupRqstFDD (ASN1CTXT* pctxt, CellPortion_InformationList_Cell_SetupRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellPortion_InformationList_Cell_SetupRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellPortion_InformationList_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellPortion_InformationItem_Cell_SetupRqstFDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellPortion_InformationItem_Cell_SetupRqstFDD (ASN1CTXT* pctxt, CellPortion_InformationItem_Cell_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellPortion_InformationItem_Cell_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PD_CellPortionID (pctxt, &pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode associatedSecondaryCPICH */

   PU_PUSHNAME (pctxt, "associatedSecondaryCPICH");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->associatedSecondaryCPICH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellPortion_InformationItem_Cell_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSetupRequestTDD                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSetupRequestTDD (ASN1CTXT* pctxt, CellSetupRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSetupRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSetupRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SCH_Information_Cell_SetupRqstTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SCH_Information_Cell_SetupRqstTDD (ASN1CTXT* pctxt, SCH_Information_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_Information_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncCaseIndicator */

   PU_PUSHNAME (pctxt, "syncCaseIndicator");

   stat = asn1PD_SyncCaseIndicator_Cell_SetupRqstTDD_PSCH (pctxt, &pvalue->syncCaseIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sCH_Power */

   PU_PUSHNAME (pctxt, "sCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->sCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tSTD_Indicator */

   PU_PUSHNAME (pctxt, "tSTD_Indicator");

   stat = asn1PD_TSTD_Indicator (pctxt, &pvalue->tSTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_Information_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Case1_Cell_SetupRqstTDD                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Case1_Cell_SetupRqstTDD (ASN1CTXT* pctxt, Case1_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Case1_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Case1_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Case2_Cell_SetupRqstTDD                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Case2_Cell_SetupRqstTDD (ASN1CTXT* pctxt, Case2_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Case2_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sCH_TimeSlot */

   PU_PUSHNAME (pctxt, "sCH_TimeSlot");

   stat = asn1PD_SCH_TimeSlot (pctxt, &pvalue->sCH_TimeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Case2_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncCaseIndicatorItem_Cell_SetupRqstTDD_PSCH              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncCaseIndicatorItem_Cell_SetupRqstTDD_PSCH (ASN1CTXT* pctxt, SyncCaseIndicatorItem_Cell_SetupRqstTDD_PSCH* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncCaseIndicatorItem_Cell_SetupRqstTDD_PSCH: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* case1 */
         case 0:
            PU_PUSHNAME (pctxt, "u.case1");

            pvalue->u.case1 = rtMemAllocTypeZ (pctxt, Case1_Cell_SetupRqstTDD);
            if (pvalue->u.case1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Case1_Cell_SetupRqstTDD (pctxt, pvalue->u.case1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* case2 */
         case 1:
            PU_PUSHNAME (pctxt, "u.case2");

            pvalue->u.case2 = rtMemAllocTypeZ (pctxt, Case2_Cell_SetupRqstTDD);
            if (pvalue->u.case2 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Case2_Cell_SetupRqstTDD (pctxt, pvalue->u.case2);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncCaseIndicatorItem_Cell_SetupRqstTDD_PSCH: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCCPCH_Information_Cell_SetupRqstTDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCCPCH_Information_Cell_SetupRqstTDD (ASN1CTXT* pctxt, PCCPCH_Information_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCCPCH_Information_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pCCPCH_Power */

   PU_PUSHNAME (pctxt, "pCCPCH_Power");

   stat = asn1PD_PCCPCH_Power (pctxt, &pvalue->pCCPCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sCTD_Indicator */

   PU_PUSHNAME (pctxt, "sCTD_Indicator");

   stat = asn1PD_SCTD_Indicator (pctxt, &pvalue->sCTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PCCPCH_Information_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotConfigurationItem_Cell_SetupRqstTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotConfigurationItem_Cell_SetupRqstTDD (ASN1CTXT* pctxt, TimeSlotConfigurationItem_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationItem_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotStatus */

   PU_PUSHNAME (pctxt, "timeSlotStatus");

   stat = asn1PD_TimeSlotStatus (pctxt, &pvalue->timeSlotStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotDirection */

   PU_PUSHNAME (pctxt, "timeSlotDirection");

   stat = asn1PD_TimeSlotDirection (pctxt, &pvalue->timeSlotDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationItem_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotConfigurationList_Cell_SetupRqstTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotConfigurationList_Cell_SetupRqstTDD (ASN1CTXT* pctxt, TimeSlotConfigurationList_Cell_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   TimeSlotConfigurationItem_Cell_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationList_Cell_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TimeSlotConfigurationItem_Cell_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TimeSlotConfigurationItem_Cell_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationList_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotConfigurationItem_LCR_Cell_SetupRqstTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotConfigurationItem_LCR_Cell_SetupRqstTDD (ASN1CTXT* pctxt, TimeSlotConfigurationItem_LCR_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationItem_LCR_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotStatus */

   PU_PUSHNAME (pctxt, "timeSlotStatus");

   stat = asn1PD_TimeSlotStatus (pctxt, &pvalue->timeSlotStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotDirection */

   PU_PUSHNAME (pctxt, "timeSlotDirection");

   stat = asn1PD_TimeSlotDirection (pctxt, &pvalue->timeSlotDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationItem_LCR_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotConfigurationList_LCR_Cell_SetupRqstTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotConfigurationList_LCR_Cell_SetupRqstTDD (ASN1CTXT* pctxt, TimeSlotConfigurationList_LCR_Cell_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(7), 0 };
   int stat = 0;
   TimeSlotConfigurationItem_LCR_Cell_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationList_LCR_Cell_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TimeSlotConfigurationItem_LCR_Cell_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TimeSlotConfigurationItem_LCR_Cell_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationList_LCR_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCCPCH_LCR_Information_Cell_SetupRqstTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCCPCH_LCR_Information_Cell_SetupRqstTDD (ASN1CTXT* pctxt, PCCPCH_LCR_Information_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCCPCH_LCR_Information_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pCCPCH_Power */

   PU_PUSHNAME (pctxt, "pCCPCH_Power");

   stat = asn1PD_PCCPCH_Power (pctxt, &pvalue->pCCPCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sCTD_Indicator */

   PU_PUSHNAME (pctxt, "sCTD_Indicator");

   stat = asn1PD_SCTD_Indicator (pctxt, &pvalue->sCTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tSTD_Indicator */

   PU_PUSHNAME (pctxt, "tSTD_Indicator");

   stat = asn1PD_TSTD_Indicator (pctxt, &pvalue->tSTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PCCPCH_LCR_Information_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DwPCH_LCR_Information_Cell_SetupRqstTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DwPCH_LCR_Information_Cell_SetupRqstTDD (ASN1CTXT* pctxt, DwPCH_LCR_Information_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DwPCH_LCR_Information_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelId */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelId");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tSTD_Indicator */

   PU_PUSHNAME (pctxt, "tSTD_Indicator");

   stat = asn1PD_TSTD_Indicator (pctxt, &pvalue->tSTD_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dwPCH_Power */

   PU_PUSHNAME (pctxt, "dwPCH_Power");

   stat = asn1PD_DwPCH_Power (pctxt, &pvalue->dwPCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DwPCH_LCR_Information_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDLParameter_Information_Cell_SetupRqstTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDLParameter_Information_Cell_SetupRqstTDD (ASN1CTXT* pctxt, IPDLParameter_Information_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iPDL_TDD_Parameters */

   PU_PUSHNAME (pctxt, "iPDL_TDD_Parameters");

   stat = asn1PD_IPDL_TDD_Parameters (pctxt, &pvalue->iPDL_TDD_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iPDL_Indicator */

   PU_PUSHNAME (pctxt, "iPDL_Indicator");

   stat = asn1PD_IPDL_Indicator (pctxt, &pvalue->iPDL_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDLParameter_Information_LCR_Cell_SetupRqstTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDLParameter_Information_LCR_Cell_SetupRqstTDD (ASN1CTXT* pctxt, IPDLParameter_Information_LCR_Cell_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_LCR_Cell_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iPDL_TDD_Parameters_LCR */

   PU_PUSHNAME (pctxt, "iPDL_TDD_Parameters_LCR");

   stat = asn1PD_IPDL_TDD_Parameters_LCR (pctxt, &pvalue->iPDL_TDD_Parameters_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iPDL_Indicator */

   PU_PUSHNAME (pctxt, "iPDL_Indicator");

   stat = asn1PD_IPDL_Indicator (pctxt, &pvalue->iPDL_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_LCR_Cell_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSetupResponse                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSetupResponse (ASN1CTXT* pctxt, CellSetupResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSetupResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSetupFailure                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSetupFailure (ASN1CTXT* pctxt, CellSetupFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSetupFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSetupFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellReconfigurationRequestFDD                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellReconfigurationRequestFDD (ASN1CTXT* pctxt, CellReconfigurationRequestFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellReconfigurationRequestFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellReconfigurationRequestFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Synchronisation_Configuration_Cell_ReconfRqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Synchronisation_Configuration_Cell_ReconfRqst (ASN1CTXT* pctxt, Synchronisation_Configuration_Cell_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Synchronisation_Configuration_Cell_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode n_INSYNC_IND */

   PU_PUSHNAME (pctxt, "n_INSYNC_IND");

   stat = asn1PD_N_INSYNC_IND (pctxt, &pvalue->n_INSYNC_IND);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode n_OUTSYNC_IND */

   PU_PUSHNAME (pctxt, "n_OUTSYNC_IND");

   stat = asn1PD_N_OUTSYNC_IND (pctxt, &pvalue->n_OUTSYNC_IND);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode t_RLFAILURE */

   PU_PUSHNAME (pctxt, "t_RLFAILURE");

   stat = asn1PD_T_RLFAILURE (pctxt, &pvalue->t_RLFAILURE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Synchronisation_Configuration_Cell_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimarySCH_Information_Cell_ReconfRqstFDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimarySCH_Information_Cell_ReconfRqstFDD (ASN1CTXT* pctxt, PrimarySCH_Information_Cell_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimarySCH_Information_Cell_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode primarySCH_Power */

   PU_PUSHNAME (pctxt, "primarySCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->primarySCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimarySCH_Information_Cell_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondarySCH_Information_Cell_ReconfRqstFDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecondarySCH_Information_Cell_ReconfRqstFDD (ASN1CTXT* pctxt, SecondarySCH_Information_Cell_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondarySCH_Information_Cell_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode secondarySCH_Power */

   PU_PUSHNAME (pctxt, "secondarySCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->secondarySCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondarySCH_Information_Cell_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCPICH_Information_Cell_ReconfRqstFDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimaryCPICH_Information_Cell_ReconfRqstFDD (ASN1CTXT* pctxt, PrimaryCPICH_Information_Cell_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCPICH_Information_Cell_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode primaryCPICH_Power */

   PU_PUSHNAME (pctxt, "primaryCPICH_Power");

   stat = asn1PD_PrimaryCPICH_Power (pctxt, &pvalue->primaryCPICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCPICH_Information_Cell_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondaryCPICH_InformationList_Cell_ReconfRqstFDD         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecondaryCPICH_InformationList_Cell_ReconfRqstFDD (ASN1CTXT* pctxt, SecondaryCPICH_InformationList_Cell_ReconfRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCPICH_InformationList_Cell_ReconfRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCPICH_InformationList_Cell_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondaryCPICH_InformationItem_Cell_ReconfRqstFDD         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecondaryCPICH_InformationItem_Cell_ReconfRqstFDD (ASN1CTXT* pctxt, SecondaryCPICH_InformationItem_Cell_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCPICH_InformationItem_Cell_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode secondaryCPICH_Power */

   PU_PUSHNAME (pctxt, "secondaryCPICH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->secondaryCPICH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCPICH_InformationItem_Cell_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BCH_information_Cell_ReconfRqstFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BCH_information_Cell_ReconfRqstFDD (ASN1CTXT* pctxt, BCH_information_Cell_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_BCH_information_Cell_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bCH_Power */

   PU_PUSHNAME (pctxt, "bCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->bCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BCH_information_Cell_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCCPCH_Information_Cell_ReconfRqstFDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimaryCCPCH_Information_Cell_ReconfRqstFDD (ASN1CTXT* pctxt, PrimaryCCPCH_Information_Cell_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCCPCH_Information_Cell_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode bCH_information */

   PU_PUSHNAME (pctxt, "bCH_information");

   stat = asn1PD_BCH_information_Cell_ReconfRqstFDD (pctxt, &pvalue->bCH_information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCCPCH_Information_Cell_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDLParameter_Information_Cell_ReconfRqstFDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDLParameter_Information_Cell_ReconfRqstFDD (ASN1CTXT* pctxt, IPDLParameter_Information_Cell_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_Cell_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iPDL_FDD_ParametersPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iPDL_FDD_ParametersPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iPDL_FDD_Parameters */

   if (pvalue->m.iPDL_FDD_ParametersPresent) {
      PU_PUSHNAME (pctxt, "iPDL_FDD_Parameters");

      stat = asn1PD_IPDL_FDD_Parameters (pctxt, &pvalue->iPDL_FDD_Parameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iPDL_Indicator */

   PU_PUSHNAME (pctxt, "iPDL_Indicator");

   stat = asn1PD_IPDL_Indicator (pctxt, &pvalue->iPDL_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_Cell_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellReconfigurationRequestTDD                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellReconfigurationRequestTDD (ASN1CTXT* pctxt, CellReconfigurationRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellReconfigurationRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellReconfigurationRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SCH_Information_Cell_ReconfRqstTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SCH_Information_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, SCH_Information_Cell_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_Information_Cell_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sCH_Power */

   PU_PUSHNAME (pctxt, "sCH_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->sCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_Information_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCCPCH_Information_Cell_ReconfRqstTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCCPCH_Information_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, PCCPCH_Information_Cell_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCCPCH_Information_Cell_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pCCPCH_Power */

   PU_PUSHNAME (pctxt, "pCCPCH_Power");

   stat = asn1PD_PCCPCH_Power (pctxt, &pvalue->pCCPCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PCCPCH_Information_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotConfigurationItem_Cell_ReconfRqstTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotConfigurationItem_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, TimeSlotConfigurationItem_Cell_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationItem_Cell_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotStatus */

   PU_PUSHNAME (pctxt, "timeSlotStatus");

   stat = asn1PD_TimeSlotStatus (pctxt, &pvalue->timeSlotStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotDirection */

   PU_PUSHNAME (pctxt, "timeSlotDirection");

   stat = asn1PD_TimeSlotDirection (pctxt, &pvalue->timeSlotDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationItem_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotConfigurationList_Cell_ReconfRqstTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotConfigurationList_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, TimeSlotConfigurationList_Cell_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   TimeSlotConfigurationItem_Cell_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationList_Cell_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TimeSlotConfigurationItem_Cell_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TimeSlotConfigurationItem_Cell_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationList_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotConfigurationItem_LCR_Cell_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotConfigurationItem_LCR_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, TimeSlotConfigurationItem_LCR_Cell_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationItem_LCR_Cell_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotStatus */

   PU_PUSHNAME (pctxt, "timeSlotStatus");

   stat = asn1PD_TimeSlotStatus (pctxt, &pvalue->timeSlotStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotDirection */

   PU_PUSHNAME (pctxt, "timeSlotDirection");

   stat = asn1PD_TimeSlotDirection (pctxt, &pvalue->timeSlotDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationItem_LCR_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotConfigurationList_LCR_Cell_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotConfigurationList_LCR_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, TimeSlotConfigurationList_LCR_Cell_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(7), 0 };
   int stat = 0;
   TimeSlotConfigurationItem_LCR_Cell_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationList_LCR_Cell_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TimeSlotConfigurationItem_LCR_Cell_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TimeSlotConfigurationItem_LCR_Cell_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotConfigurationList_LCR_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DwPCH_LCR_Information_Cell_ReconfRqstTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DwPCH_LCR_Information_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, DwPCH_LCR_Information_Cell_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DwPCH_LCR_Information_Cell_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelId */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelId");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dwPCH_Power */

   PU_PUSHNAME (pctxt, "dwPCH_Power");

   stat = asn1PD_DwPCH_Power (pctxt, &pvalue->dwPCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DwPCH_LCR_Information_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDLParameter_Information_Cell_ReconfRqstTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDLParameter_Information_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, IPDLParameter_Information_Cell_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_Cell_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iPDL_TDD_ParametersPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iPDL_TDD_ParametersPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iPDL_TDD_Parameters */

   if (pvalue->m.iPDL_TDD_ParametersPresent) {
      PU_PUSHNAME (pctxt, "iPDL_TDD_Parameters");

      stat = asn1PD_IPDL_TDD_Parameters (pctxt, &pvalue->iPDL_TDD_Parameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iPDL_Indicator */

   PU_PUSHNAME (pctxt, "iPDL_Indicator");

   stat = asn1PD_IPDL_Indicator (pctxt, &pvalue->iPDL_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDLParameter_Information_LCR_Cell_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDLParameter_Information_LCR_Cell_ReconfRqstTDD (ASN1CTXT* pctxt, IPDLParameter_Information_LCR_Cell_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_LCR_Cell_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iPDL_TDD_Parameters_LCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iPDL_TDD_Parameters_LCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iPDL_TDD_Parameters_LCR */

   if (pvalue->m.iPDL_TDD_Parameters_LCRPresent) {
      PU_PUSHNAME (pctxt, "iPDL_TDD_Parameters_LCR");

      stat = asn1PD_IPDL_TDD_Parameters_LCR (pctxt, &pvalue->iPDL_TDD_Parameters_LCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iPDL_Indicator */

   PU_PUSHNAME (pctxt, "iPDL_Indicator");

   stat = asn1PD_IPDL_Indicator (pctxt, &pvalue->iPDL_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDLParameter_Information_LCR_Cell_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellReconfigurationResponse                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellReconfigurationResponse (ASN1CTXT* pctxt, CellReconfigurationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellReconfigurationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellReconfigurationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellReconfigurationFailure                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellReconfigurationFailure (ASN1CTXT* pctxt, CellReconfigurationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellReconfigurationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellReconfigurationFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellDeletionRequest                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellDeletionRequest (ASN1CTXT* pctxt, CellDeletionRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellDeletionRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellDeletionRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellDeletionResponse                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellDeletionResponse (ASN1CTXT* pctxt, CellDeletionResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellDeletionResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellDeletionResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResourceStatusIndication                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResourceStatusIndication (ASN1CTXT* pctxt, ResourceStatusIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ResourceStatusIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ResourceStatusIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_InformationList_ResourceStatusInd              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, Local_Cell_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_Group_InformationList_ResourceStatusInd        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_Group_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, Local_Cell_Group_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  No_Failure_ResourceStatusInd                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_No_Failure_ResourceStatusInd (ASN1CTXT* pctxt, No_Failure_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_No_Failure_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "local_Cell_Group_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.local_Cell_Group_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode local_Cell_InformationList */

   PU_PUSHNAME (pctxt, "local_Cell_InformationList");

   stat = asn1PD_Local_Cell_InformationList_ResourceStatusInd (pctxt, &pvalue->local_Cell_InformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode local_Cell_Group_InformationList */

   if (pvalue->m.local_Cell_Group_InformationListPresent) {
      PU_PUSHNAME (pctxt, "local_Cell_Group_InformationList");

      stat = asn1PD_Local_Cell_Group_InformationList_ResourceStatusInd (pctxt, &pvalue->local_Cell_Group_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_No_Failure_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_InformationList2_ResourceStatusInd             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_InformationList2_ResourceStatusInd (ASN1CTXT* pctxt, Local_Cell_InformationList2_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationList2_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationList2_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_Group_InformationList2_ResourceStatusInd       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_Group_InformationList2_ResourceStatusInd (ASN1CTXT* pctxt, Local_Cell_Group_InformationList2_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationList2_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationList2_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCP_InformationList_ResourceStatusInd                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCP_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, CCP_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCP_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCP_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_InformationList_ResourceStatusInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, Cell_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceImpacting_ResourceStatusInd                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ServiceImpacting_ResourceStatusInd (ASN1CTXT* pctxt, ServiceImpacting_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceImpacting_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "local_Cell_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.local_Cell_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "local_Cell_Group_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.local_Cell_Group_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cCP_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCP_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cell_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cell_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode local_Cell_InformationList */

   if (pvalue->m.local_Cell_InformationListPresent) {
      PU_PUSHNAME (pctxt, "local_Cell_InformationList");

      stat = asn1PD_Local_Cell_InformationList2_ResourceStatusInd (pctxt, &pvalue->local_Cell_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode local_Cell_Group_InformationList */

   if (pvalue->m.local_Cell_Group_InformationListPresent) {
      PU_PUSHNAME (pctxt, "local_Cell_Group_InformationList");

      stat = asn1PD_Local_Cell_Group_InformationList2_ResourceStatusInd (pctxt, &pvalue->local_Cell_Group_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cCP_InformationList */

   if (pvalue->m.cCP_InformationListPresent) {
      PU_PUSHNAME (pctxt, "cCP_InformationList");

      stat = asn1PD_CCP_InformationList_ResourceStatusInd (pctxt, &pvalue->cCP_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cell_InformationList */

   if (pvalue->m.cell_InformationListPresent) {
      PU_PUSHNAME (pctxt, "cell_InformationList");

      stat = asn1PD_Cell_InformationList_ResourceStatusInd (pctxt, &pvalue->cell_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceImpacting_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IndicationType_ResourceStatusInd                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IndicationType_ResourceStatusInd (ASN1CTXT* pctxt, IndicationType_ResourceStatusInd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IndicationType_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* no_Failure */
         case 0:
            PU_PUSHNAME (pctxt, "u.no_Failure");

            pvalue->u.no_Failure = rtMemAllocTypeZ (pctxt, No_Failure_ResourceStatusInd);
            if (pvalue->u.no_Failure == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_No_Failure_ResourceStatusInd (pctxt, pvalue->u.no_Failure);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* serviceImpacting */
         case 1:
            PU_PUSHNAME (pctxt, "u.serviceImpacting");

            pvalue->u.serviceImpacting = rtMemAllocTypeZ (pctxt, ServiceImpacting_ResourceStatusInd);
            if (pvalue->u.serviceImpacting == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_ServiceImpacting_ResourceStatusInd (pctxt, pvalue->u.serviceImpacting);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IndicationType_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_InformationItem_ResourceStatusInd              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_InformationItem_ResourceStatusInd (ASN1CTXT* pctxt, Local_Cell_InformationItem_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationItem_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dl_or_global_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_or_global_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "commonChannelsCapacityConsumptionLawPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.commonChannelsCapacityConsumptionLawPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dedicatedChannelsCapacityConsumptionLawPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dedicatedChannelsCapacityConsumptionLawPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maximumDL_PowerCapabilityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maximumDL_PowerCapabilityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minSpreadingFactorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minSpreadingFactorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minimumDL_PowerCapabilityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minimumDL_PowerCapabilityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "local_Cell_Group_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.local_Cell_Group_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode local_CellID */

   PU_PUSHNAME (pctxt, "local_CellID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_CellID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode addorDeleteIndicator */

   PU_PUSHNAME (pctxt, "addorDeleteIndicator");

   stat = asn1PD_AddorDeleteIndicator (pctxt, &pvalue->addorDeleteIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_or_global_capacityCredit */

   if (pvalue->m.dl_or_global_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "dl_or_global_capacityCredit");

      stat = asn1PD_DL_or_Global_CapacityCredit (pctxt, &pvalue->dl_or_global_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_capacityCredit */

   if (pvalue->m.ul_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "ul_capacityCredit");

      stat = asn1PD_UL_CapacityCredit (pctxt, &pvalue->ul_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode commonChannelsCapacityConsumptionLaw */

   if (pvalue->m.commonChannelsCapacityConsumptionLawPresent) {
      PU_PUSHNAME (pctxt, "commonChannelsCapacityConsumptionLaw");

      stat = asn1PD_CommonChannelsCapacityConsumptionLaw (pctxt, &pvalue->commonChannelsCapacityConsumptionLaw);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dedicatedChannelsCapacityConsumptionLaw */

   if (pvalue->m.dedicatedChannelsCapacityConsumptionLawPresent) {
      PU_PUSHNAME (pctxt, "dedicatedChannelsCapacityConsumptionLaw");

      stat = asn1PD_DedicatedChannelsCapacityConsumptionLaw (pctxt, &pvalue->dedicatedChannelsCapacityConsumptionLaw);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode maximumDL_PowerCapability */

   if (pvalue->m.maximumDL_PowerCapabilityPresent) {
      PU_PUSHNAME (pctxt, "maximumDL_PowerCapability");

      stat = asn1PD_MaximumDL_PowerCapability (pctxt, &pvalue->maximumDL_PowerCapability);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minSpreadingFactor */

   if (pvalue->m.minSpreadingFactorPresent) {
      PU_PUSHNAME (pctxt, "minSpreadingFactor");

      stat = asn1PD_MinSpreadingFactor (pctxt, &pvalue->minSpreadingFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minimumDL_PowerCapability */

   if (pvalue->m.minimumDL_PowerCapabilityPresent) {
      PU_PUSHNAME (pctxt, "minimumDL_PowerCapability");

      stat = asn1PD_MinimumDL_PowerCapability (pctxt, &pvalue->minimumDL_PowerCapability);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode local_Cell_Group_ID */

   if (pvalue->m.local_Cell_Group_IDPresent) {
      PU_PUSHNAME (pctxt, "local_Cell_Group_ID");

      stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_Cell_Group_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationItem_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_Group_InformationItem_ResourceStatusInd        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_Group_InformationItem_ResourceStatusInd (ASN1CTXT* pctxt, Local_Cell_Group_InformationItem_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationItem_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode local_Cell_Group_ID */

   PU_PUSHNAME (pctxt, "local_Cell_Group_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_Cell_Group_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_or_global_capacityCredit */

   PU_PUSHNAME (pctxt, "dl_or_global_capacityCredit");

   stat = asn1PD_DL_or_Global_CapacityCredit (pctxt, &pvalue->dl_or_global_capacityCredit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_capacityCredit */

   if (pvalue->m.ul_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "ul_capacityCredit");

      stat = asn1PD_UL_CapacityCredit (pctxt, &pvalue->ul_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode commonChannelsCapacityConsumptionLaw */

   PU_PUSHNAME (pctxt, "commonChannelsCapacityConsumptionLaw");

   stat = asn1PD_CommonChannelsCapacityConsumptionLaw (pctxt, &pvalue->commonChannelsCapacityConsumptionLaw);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dedicatedChannelsCapacityConsumptionLaw */

   PU_PUSHNAME (pctxt, "dedicatedChannelsCapacityConsumptionLaw");

   stat = asn1PD_DedicatedChannelsCapacityConsumptionLaw (pctxt, &pvalue->dedicatedChannelsCapacityConsumptionLaw);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationItem_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Power_Local_Cell_Group_InformationList_ResourceStatusInd  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Power_Local_Cell_Group_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, Power_Local_Cell_Group_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Power_Local_Cell_Group_InformationItem_ResourceStatusInd  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Power_Local_Cell_Group_InformationItem_ResourceStatusInd (ASN1CTXT* pctxt, Power_Local_Cell_Group_InformationItem_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationItem_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode power_Local_Cell_Group_ID */

   PU_PUSHNAME (pctxt, "power_Local_Cell_Group_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->power_Local_Cell_Group_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maximumDL_PowerCapability */

   PU_PUSHNAME (pctxt, "maximumDL_PowerCapability");

   stat = asn1PD_MaximumDL_PowerCapability (pctxt, &pvalue->maximumDL_PowerCapability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationItem_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_InformationItem2_ResourceStatusInd             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_InformationItem2_ResourceStatusInd (ASN1CTXT* pctxt, Local_Cell_InformationItem2_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationItem2_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dl_or_global_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_or_global_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "commonChannelsCapacityConsumptionLawPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.commonChannelsCapacityConsumptionLawPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dedicatedChannelsCapacityConsumptionLawPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dedicatedChannelsCapacityConsumptionLawPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maximum_DL_PowerCapabilityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maximum_DL_PowerCapabilityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minSpreadingFactorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minSpreadingFactorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minimumDL_PowerCapabilityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minimumDL_PowerCapabilityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode local_Cell_ID */

   PU_PUSHNAME (pctxt, "local_Cell_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_Cell_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_or_global_capacityCredit */

   if (pvalue->m.dl_or_global_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "dl_or_global_capacityCredit");

      stat = asn1PD_DL_or_Global_CapacityCredit (pctxt, &pvalue->dl_or_global_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_capacityCredit */

   if (pvalue->m.ul_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "ul_capacityCredit");

      stat = asn1PD_UL_CapacityCredit (pctxt, &pvalue->ul_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode commonChannelsCapacityConsumptionLaw */

   if (pvalue->m.commonChannelsCapacityConsumptionLawPresent) {
      PU_PUSHNAME (pctxt, "commonChannelsCapacityConsumptionLaw");

      stat = asn1PD_CommonChannelsCapacityConsumptionLaw (pctxt, &pvalue->commonChannelsCapacityConsumptionLaw);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dedicatedChannelsCapacityConsumptionLaw */

   if (pvalue->m.dedicatedChannelsCapacityConsumptionLawPresent) {
      PU_PUSHNAME (pctxt, "dedicatedChannelsCapacityConsumptionLaw");

      stat = asn1PD_DedicatedChannelsCapacityConsumptionLaw (pctxt, &pvalue->dedicatedChannelsCapacityConsumptionLaw);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode maximum_DL_PowerCapability */

   if (pvalue->m.maximum_DL_PowerCapabilityPresent) {
      PU_PUSHNAME (pctxt, "maximum_DL_PowerCapability");

      stat = asn1PD_MaximumDL_PowerCapability (pctxt, &pvalue->maximum_DL_PowerCapability);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minSpreadingFactor */

   if (pvalue->m.minSpreadingFactorPresent) {
      PU_PUSHNAME (pctxt, "minSpreadingFactor");

      stat = asn1PD_MinSpreadingFactor (pctxt, &pvalue->minSpreadingFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minimumDL_PowerCapability */

   if (pvalue->m.minimumDL_PowerCapabilityPresent) {
      PU_PUSHNAME (pctxt, "minimumDL_PowerCapability");

      stat = asn1PD_MinimumDL_PowerCapability (pctxt, &pvalue->minimumDL_PowerCapability);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_InformationItem2_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_Group_InformationItem2_ResourceStatusInd       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_Group_InformationItem2_ResourceStatusInd (ASN1CTXT* pctxt, Local_Cell_Group_InformationItem2_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationItem2_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dl_or_global_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_or_global_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_capacityCreditPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_capacityCreditPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "commonChannelsCapacityConsumptionLawPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.commonChannelsCapacityConsumptionLawPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dedicatedChannelsCapacityConsumptionLawPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dedicatedChannelsCapacityConsumptionLawPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode local_Cell_Group_ID */

   PU_PUSHNAME (pctxt, "local_Cell_Group_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->local_Cell_Group_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_or_global_capacityCredit */

   if (pvalue->m.dl_or_global_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "dl_or_global_capacityCredit");

      stat = asn1PD_DL_or_Global_CapacityCredit (pctxt, &pvalue->dl_or_global_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_capacityCredit */

   if (pvalue->m.ul_capacityCreditPresent) {
      PU_PUSHNAME (pctxt, "ul_capacityCredit");

      stat = asn1PD_UL_CapacityCredit (pctxt, &pvalue->ul_capacityCredit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode commonChannelsCapacityConsumptionLaw */

   if (pvalue->m.commonChannelsCapacityConsumptionLawPresent) {
      PU_PUSHNAME (pctxt, "commonChannelsCapacityConsumptionLaw");

      stat = asn1PD_CommonChannelsCapacityConsumptionLaw (pctxt, &pvalue->commonChannelsCapacityConsumptionLaw);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dedicatedChannelsCapacityConsumptionLaw */

   if (pvalue->m.dedicatedChannelsCapacityConsumptionLawPresent) {
      PU_PUSHNAME (pctxt, "dedicatedChannelsCapacityConsumptionLaw");

      stat = asn1PD_DedicatedChannelsCapacityConsumptionLaw (pctxt, &pvalue->dedicatedChannelsCapacityConsumptionLaw);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_Group_InformationItem2_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Power_Local_Cell_Group_InformationList2_ResourceStatusIn  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Power_Local_Cell_Group_InformationList2_ResourceStatusInd (ASN1CTXT* pctxt, Power_Local_Cell_Group_InformationList2_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationList2_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationList2_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Power_Local_Cell_Group_InformationItem2_ResourceStatusIn  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Power_Local_Cell_Group_InformationItem2_ResourceStatusInd (ASN1CTXT* pctxt, Power_Local_Cell_Group_InformationItem2_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationItem2_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode power_Local_Cell_Group_ID */

   PU_PUSHNAME (pctxt, "power_Local_Cell_Group_ID");

   stat = asn1PD_Local_Cell_ID (pctxt, &pvalue->power_Local_Cell_Group_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maximumDL_PowerCapability */

   PU_PUSHNAME (pctxt, "maximumDL_PowerCapability");

   stat = asn1PD_MaximumDL_PowerCapability (pctxt, &pvalue->maximumDL_PowerCapability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Power_Local_Cell_Group_InformationItem2_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCP_InformationItem_ResourceStatusInd                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCP_InformationItem_ResourceStatusInd (ASN1CTXT* pctxt, CCP_InformationItem_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCP_InformationItem_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode communicationControlPortID */

   PU_PUSHNAME (pctxt, "communicationControlPortID");

   stat = asn1PD_CommunicationControlPortID (pctxt, &pvalue->communicationControlPortID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCP_InformationItem_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_CPICH_InformationList_ResourceStatusInd                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_CPICH_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, S_CPICH_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CPICH_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CPICH_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_CCPCH_InformationList_ResourceStatusInd                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_CCPCH_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, S_CCPCH_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FACH_InformationList_ResourceStatusInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FACH_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, FACH_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FACH_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_InformationList_ResourceStatusInd                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, PRACH_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_InformationList_ResourceStatusInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, RACH_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_InformationList_ResourceStatusInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AICH_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, AICH_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_InformationItem_ResourceStatusInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_InformationItem_ResourceStatusInd (ASN1CTXT* pctxt, Cell_InformationItem_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InformationItem_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "resourceOperationalStatePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.resourceOperationalStatePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "availabilityStatusPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.availabilityStatusPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "primary_SCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.primary_SCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondary_SCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondary_SCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "primary_CPICH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.primary_CPICH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondary_CPICH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondary_CPICH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "primary_CCPCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.primary_CCPCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondary_CCPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondary_CCPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pICH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pICH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "fACH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.fACH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pRACH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pRACH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rACH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rACH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "aICH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.aICH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "notUsed_1_pCPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.notUsed_1_pCPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "notUsed_2_cPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.notUsed_2_cPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "notUsed_3_aP_AICH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.notUsed_3_aP_AICH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "notUsed_4_cDCA_ICH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.notUsed_4_cDCA_ICH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode resourceOperationalState */

   if (pvalue->m.resourceOperationalStatePresent) {
      PU_PUSHNAME (pctxt, "resourceOperationalState");

      stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode availabilityStatus */

   if (pvalue->m.availabilityStatusPresent) {
      PU_PUSHNAME (pctxt, "availabilityStatus");

      stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode primary_SCH_Information */

   if (pvalue->m.primary_SCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "primary_SCH_Information");

      stat = asn1PD_P_SCH_Information_ResourceStatusInd (pctxt, &pvalue->primary_SCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode secondary_SCH_Information */

   if (pvalue->m.secondary_SCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "secondary_SCH_Information");

      stat = asn1PD_S_SCH_Information_ResourceStatusInd (pctxt, &pvalue->secondary_SCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode primary_CPICH_Information */

   if (pvalue->m.primary_CPICH_InformationPresent) {
      PU_PUSHNAME (pctxt, "primary_CPICH_Information");

      stat = asn1PD_P_CPICH_Information_ResourceStatusInd (pctxt, &pvalue->primary_CPICH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode secondary_CPICH_Information */

   if (pvalue->m.secondary_CPICH_InformationPresent) {
      PU_PUSHNAME (pctxt, "secondary_CPICH_Information");

      stat = asn1PD_S_CPICH_InformationList_ResourceStatusInd (pctxt, &pvalue->secondary_CPICH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode primary_CCPCH_Information */

   if (pvalue->m.primary_CCPCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "primary_CCPCH_Information");

      stat = asn1PD_P_CCPCH_Information_ResourceStatusInd (pctxt, &pvalue->primary_CCPCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode bCH_Information */

   if (pvalue->m.bCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "bCH_Information");

      stat = asn1PD_BCH_Information_ResourceStatusInd (pctxt, &pvalue->bCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode secondary_CCPCH_InformationList */

   if (pvalue->m.secondary_CCPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "secondary_CCPCH_InformationList");

      stat = asn1PD_S_CCPCH_InformationList_ResourceStatusInd (pctxt, &pvalue->secondary_CCPCH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pCH_Information */

   if (pvalue->m.pCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "pCH_Information");

      stat = asn1PD_PCH_Information_ResourceStatusInd (pctxt, &pvalue->pCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pICH_Information */

   if (pvalue->m.pICH_InformationPresent) {
      PU_PUSHNAME (pctxt, "pICH_Information");

      stat = asn1PD_PICH_Information_ResourceStatusInd (pctxt, &pvalue->pICH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode fACH_InformationList */

   if (pvalue->m.fACH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "fACH_InformationList");

      stat = asn1PD_FACH_InformationList_ResourceStatusInd (pctxt, &pvalue->fACH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode pRACH_InformationList */

   if (pvalue->m.pRACH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "pRACH_InformationList");

      stat = asn1PD_PRACH_InformationList_ResourceStatusInd (pctxt, &pvalue->pRACH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode rACH_InformationList */

   if (pvalue->m.rACH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "rACH_InformationList");

      stat = asn1PD_RACH_InformationList_ResourceStatusInd (pctxt, &pvalue->rACH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode aICH_InformationList */

   if (pvalue->m.aICH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "aICH_InformationList");

      stat = asn1PD_AICH_InformationList_ResourceStatusInd (pctxt, &pvalue->aICH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode notUsed_1_pCPCH_InformationList */

   if (pvalue->m.notUsed_1_pCPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "notUsed_1_pCPCH_InformationList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode notUsed_2_cPCH_InformationList */

   if (pvalue->m.notUsed_2_cPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "notUsed_2_cPCH_InformationList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode notUsed_3_aP_AICH_InformationList */

   if (pvalue->m.notUsed_3_aP_AICH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "notUsed_3_aP_AICH_InformationList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode notUsed_4_cDCA_ICH_InformationList */

   if (pvalue->m.notUsed_4_cDCA_ICH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "notUsed_4_cDCA_ICH_InformationList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode sCH_Information */

   if (pvalue->m.sCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "sCH_Information");

      stat = asn1PD_SCH_Information_ResourceStatusInd (pctxt, &pvalue->sCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InformationItem_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FPACH_LCR_InformationList_ResourceStatusInd               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FPACH_LCR_InformationList_ResourceStatusInd (ASN1CTXT* pctxt, FPACH_LCR_InformationList_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_LCR_InformationList_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_LCR_InformationList_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCH_Resources_Information_ResourceStatusInd           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCH_Resources_Information_ResourceStatusInd (ASN1CTXT* pctxt, HS_DSCH_Resources_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCH_Resources_Information_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCH_Resources_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_CCPCH_InformationListExt_ResourceStatusInd              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_CCPCH_InformationListExt_ResourceStatusInd (ASN1CTXT* pctxt, S_CCPCH_InformationListExt_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(208), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_InformationListExt_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_InformationListExt_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S_CCPCH_LCR_InformationListExt_ResourceStatusInd          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_S_CCPCH_LCR_InformationListExt_ResourceStatusInd (ASN1CTXT* pctxt, S_CCPCH_LCR_InformationListExt_ResourceStatusInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_LCR_InformationListExt_ResourceStatusInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_CCPCH_LCR_InformationListExt_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_Resources_Information_ResourceStatusInd             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_Resources_Information_ResourceStatusInd (ASN1CTXT* pctxt, E_DCH_Resources_Information_ResourceStatusInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Resources_Information_ResourceStatusInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Resources_Information_ResourceStatusInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SystemInformationUpdateRequest                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SystemInformationUpdateRequest (ASN1CTXT* pctxt, SystemInformationUpdateRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SystemInformationUpdateRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SystemInformationUpdateRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  No_Deletion_SystemInfoUpdate                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_No_Deletion_SystemInfoUpdate (ASN1CTXT* pctxt, No_Deletion_SystemInfoUpdate* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_No_Deletion_SystemInfoUpdate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "sIB_OriginatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sIB_OriginatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iB_SG_REPPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iB_SG_REPPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sIB_Originator */

   if (pvalue->m.sIB_OriginatorPresent) {
      PU_PUSHNAME (pctxt, "sIB_Originator");

      stat = asn1PD_SIB_Originator (pctxt, &pvalue->sIB_Originator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iB_SG_REP */

   if (pvalue->m.iB_SG_REPPresent) {
      PU_PUSHNAME (pctxt, "iB_SG_REP");

      stat = asn1PD_IB_SG_REP (pctxt, &pvalue->iB_SG_REP);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode segmentInformationList */

   PU_PUSHNAME (pctxt, "segmentInformationList");

   stat = asn1PD_SegmentInformationList_SystemInfoUpdate (pctxt, &pvalue->segmentInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_No_Deletion_SystemInfoUpdate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeletionIndicator_SystemInfoUpdate                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeletionIndicator_SystemInfoUpdate (ASN1CTXT* pctxt, DeletionIndicator_SystemInfoUpdate* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DeletionIndicator_SystemInfoUpdate: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* no_Deletion */
      case 0:
         PU_PUSHNAME (pctxt, "u.no_Deletion");

         pvalue->u.no_Deletion = rtMemAllocTypeZ (pctxt, No_Deletion_SystemInfoUpdate);
         if (pvalue->u.no_Deletion == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_No_Deletion_SystemInfoUpdate (pctxt, pvalue->u.no_Deletion);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* yes_Deletion */
      case 1:
         PU_PUSHNAME (pctxt, "u.yes_Deletion");

         /* NULL */

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DeletionIndicator_SystemInfoUpdate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MIB_SB_SIB_InformationItem_SystemInfoUpdateRqst           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MIB_SB_SIB_InformationItem_SystemInfoUpdateRqst (ASN1CTXT* pctxt, MIB_SB_SIB_InformationItem_SystemInfoUpdateRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MIB_SB_SIB_InformationItem_SystemInfoUpdateRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iB_Type */

   PU_PUSHNAME (pctxt, "iB_Type");

   stat = asn1PD_IB_Type (pctxt, &pvalue->iB_Type);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iB_OC_ID */

   PU_PUSHNAME (pctxt, "iB_OC_ID");

   stat = asn1PD_IB_OC_ID (pctxt, &pvalue->iB_OC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode deletionIndicator */

   PU_PUSHNAME (pctxt, "deletionIndicator");

   stat = asn1PD_DeletionIndicator_SystemInfoUpdate (pctxt, &pvalue->deletionIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MIB_SB_SIB_InformationItem_SystemInfoUpdateRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MIB_SB_SIB_InformationList_SystemInfoUpdateRqst           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MIB_SB_SIB_InformationList_SystemInfoUpdateRqst (ASN1CTXT* pctxt, MIB_SB_SIB_InformationList_SystemInfoUpdateRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   MIB_SB_SIB_InformationItem_SystemInfoUpdateRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MIB_SB_SIB_InformationList_SystemInfoUpdateRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MIB_SB_SIB_InformationItem_SystemInfoUpdateRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MIB_SB_SIB_InformationItem_SystemInfoUpdateRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MIB_SB_SIB_InformationList_SystemInfoUpdateRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SegmentInformationItem_SystemInfoUpdate                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SegmentInformationItem_SystemInfoUpdate (ASN1CTXT* pctxt, SegmentInformationItem_SystemInfoUpdate* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentInformationItem_SystemInfoUpdate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iB_SG_POSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iB_SG_POSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "segment_TypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.segment_TypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iB_SG_DATAPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iB_SG_DATAPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iB_SG_POS */

   if (pvalue->m.iB_SG_POSPresent) {
      PU_PUSHNAME (pctxt, "iB_SG_POS");

      stat = asn1PD_IB_SG_POS (pctxt, &pvalue->iB_SG_POS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode segment_Type */

   if (pvalue->m.segment_TypePresent) {
      PU_PUSHNAME (pctxt, "segment_Type");

      stat = asn1PD_Segment_Type (pctxt, &pvalue->segment_Type);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iB_SG_DATA */

   if (pvalue->m.iB_SG_DATAPresent) {
      PU_PUSHNAME (pctxt, "iB_SG_DATA");

      stat = asn1PD_IB_SG_DATA (pctxt, &pvalue->iB_SG_DATA);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentInformationItem_SystemInfoUpdate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SegmentInformationListIE_SystemInfoUpdate                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SegmentInformationListIE_SystemInfoUpdate (ASN1CTXT* pctxt, SegmentInformationListIE_SystemInfoUpdate* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   SegmentInformationItem_SystemInfoUpdate* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentInformationListIE_SystemInfoUpdate: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SegmentInformationItem_SystemInfoUpdate);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SegmentInformationItem_SystemInfoUpdate (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentInformationListIE_SystemInfoUpdate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SystemInformationUpdateResponse                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SystemInformationUpdateResponse (ASN1CTXT* pctxt, SystemInformationUpdateResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SystemInformationUpdateResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SystemInformationUpdateResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SystemInformationUpdateFailure                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SystemInformationUpdateFailure (ASN1CTXT* pctxt, SystemInformationUpdateFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SystemInformationUpdateFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SystemInformationUpdateFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkSetupRequestFDD                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkSetupRequestFDD (ASN1CTXT* pctxt, RadioLinkSetupRequestFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupRequestFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupRequestFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_Information_RL_SetupRqstFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_Information_RL_SetupRqstFDD (ASN1CTXT* pctxt, UL_DPCH_Information_RL_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_Information_RL_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxNrOfUL_DPDCHsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxNrOfUL_DPDCHsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_sSDT_CellID_LengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_sSDT_CellID_LengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_s_FieldLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_s_FieldLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode ul_ScramblingCode */

   PU_PUSHNAME (pctxt, "ul_ScramblingCode");

   stat = asn1PD_UL_ScramblingCode (pctxt, &pvalue->ul_ScramblingCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode minUL_ChannelisationCodeLength */

   PU_PUSHNAME (pctxt, "minUL_ChannelisationCodeLength");

   stat = asn1PD_MinUL_ChannelisationCodeLength (pctxt, &pvalue->minUL_ChannelisationCodeLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxNrOfUL_DPDCHs */

   if (pvalue->m.maxNrOfUL_DPDCHsPresent) {
      PU_PUSHNAME (pctxt, "maxNrOfUL_DPDCHs");

      stat = asn1PD_MaxNrOfUL_DPDCHs (pctxt, &pvalue->maxNrOfUL_DPDCHs);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_PunctureLimit */

   PU_PUSHNAME (pctxt, "ul_PunctureLimit");

   stat = asn1PD_PunctureLimit (pctxt, &pvalue->ul_PunctureLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_DPCCH_SlotFormat */

   PU_PUSHNAME (pctxt, "ul_DPCCH_SlotFormat");

   stat = asn1PD_UL_DPCCH_SlotFormat (pctxt, &pvalue->ul_DPCCH_SlotFormat);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_SIR_Target */

   PU_PUSHNAME (pctxt, "ul_SIR_Target");

   stat = asn1PD_UL_SIR (pctxt, &pvalue->ul_SIR_Target);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode diversityMode */

   PU_PUSHNAME (pctxt, "diversityMode");

   stat = asn1PD_DiversityMode (pctxt, &pvalue->diversityMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode not_Used_sSDT_CellID_Length */

   if (pvalue->m.not_Used_sSDT_CellID_LengthPresent) {
      PU_PUSHNAME (pctxt, "not_Used_sSDT_CellID_Length");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_s_FieldLength */

   if (pvalue->m.not_Used_s_FieldLengthPresent) {
      PU_PUSHNAME (pctxt, "not_Used_s_FieldLength");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_Information_RL_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerOffsetInformation_RL_SetupRqstFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerOffsetInformation_RL_SetupRqstFDD (ASN1CTXT* pctxt, PowerOffsetInformation_RL_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_RL_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pO1_ForTFCI_Bits */

   PU_PUSHNAME (pctxt, "pO1_ForTFCI_Bits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO1_ForTFCI_Bits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pO2_ForTPC_Bits */

   PU_PUSHNAME (pctxt, "pO2_ForTPC_Bits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO2_ForTPC_Bits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pO3_ForPilotBits */

   PU_PUSHNAME (pctxt, "pO3_ForPilotBits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO3_ForPilotBits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_RL_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_Information_RL_SetupRqstFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_Information_RL_SetupRqstFDD (ASN1CTXT* pctxt, DL_DPCH_Information_RL_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Information_RL_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_pDSCH_RL_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_pDSCH_RL_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_pDSCH_CodeMappingPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_pDSCH_CodeMappingPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_DPCH_SlotFormat */

   PU_PUSHNAME (pctxt, "dl_DPCH_SlotFormat");

   stat = asn1PD_DL_DPCH_SlotFormat (pctxt, &pvalue->dl_DPCH_SlotFormat);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_SignallingMode */

   PU_PUSHNAME (pctxt, "tFCI_SignallingMode");

   stat = asn1PD_TFCI_SignallingMode (pctxt, &pvalue->tFCI_SignallingMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode multiplexingPosition */

   PU_PUSHNAME (pctxt, "multiplexingPosition");

   stat = asn1PD_MultiplexingPosition (pctxt, &pvalue->multiplexingPosition);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode not_Used_pDSCH_RL_ID */

   if (pvalue->m.not_Used_pDSCH_RL_IDPresent) {
      PU_PUSHNAME (pctxt, "not_Used_pDSCH_RL_ID");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_pDSCH_CodeMapping */

   if (pvalue->m.not_Used_pDSCH_CodeMappingPresent) {
      PU_PUSHNAME (pctxt, "not_Used_pDSCH_CodeMapping");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode powerOffsetInformation */

   PU_PUSHNAME (pctxt, "powerOffsetInformation");

   stat = asn1PD_PowerOffsetInformation_RL_SetupRqstFDD (pctxt, &pvalue->powerOffsetInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_TPC_DownlinkStepSize */

   PU_PUSHNAME (pctxt, "fdd_TPC_DownlinkStepSize");

   stat = asn1PD_FDD_TPC_DownlinkStepSize (pctxt, &pvalue->fdd_TPC_DownlinkStepSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode limitedPowerIncrease */

   PU_PUSHNAME (pctxt, "limitedPowerIncrease");

   stat = asn1PD_LimitedPowerIncrease (pctxt, &pvalue->limitedPowerIncrease);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode innerLoopDLPCStatus */

   PU_PUSHNAME (pctxt, "innerLoopDLPCStatus");

   stat = asn1PD_InnerLoopDLPCStatus (pctxt, &pvalue->innerLoopDLPCStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Information_RL_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_RL_SetupRqstFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_RL_SetupRqstFDD (ASN1CTXT* pctxt, RL_InformationList_RL_SetupRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_SetupRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_RL_SetupRqstFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_RL_SetupRqstFDD (ASN1CTXT* pctxt, RL_InformationItem_RL_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "propagationDelayPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.propagationDelayPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "diversityControlFieldPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.diversityControlFieldPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_sSDT_Cell_IdentityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_sSDT_Cell_IdentityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transmitDiversityIndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transmitDiversityIndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode firstRLS_indicator */

   PU_PUSHNAME (pctxt, "firstRLS_indicator");

   stat = asn1PD_FirstRLS_Indicator (pctxt, &pvalue->firstRLS_indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode frameOffset */

   PU_PUSHNAME (pctxt, "frameOffset");

   stat = asn1PD_FrameOffset (pctxt, &pvalue->frameOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode chipOffset */

   PU_PUSHNAME (pctxt, "chipOffset");

   stat = asn1PD_ChipOffset (pctxt, &pvalue->chipOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode propagationDelay */

   if (pvalue->m.propagationDelayPresent) {
      PU_PUSHNAME (pctxt, "propagationDelay");

      stat = asn1PD_PropagationDelay (pctxt, &pvalue->propagationDelay);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode diversityControlField */

   if (pvalue->m.diversityControlFieldPresent) {
      PU_PUSHNAME (pctxt, "diversityControlField");

      stat = asn1PD_DiversityControlField (pctxt, &pvalue->diversityControlField);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_CodeInformation */

   PU_PUSHNAME (pctxt, "dl_CodeInformation");

   stat = asn1PD_FDD_DL_CodeInformation (pctxt, &pvalue->dl_CodeInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode initialDL_transmissionPower */

   PU_PUSHNAME (pctxt, "initialDL_transmissionPower");

   stat = asn1PD_DL_Power (pctxt, &pvalue->initialDL_transmissionPower);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maximumDL_power */

   PU_PUSHNAME (pctxt, "maximumDL_power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->maximumDL_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode minimumDL_power */

   PU_PUSHNAME (pctxt, "minimumDL_power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->minimumDL_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode not_Used_sSDT_Cell_Identity */

   if (pvalue->m.not_Used_sSDT_Cell_IdentityPresent) {
      PU_PUSHNAME (pctxt, "not_Used_sSDT_Cell_Identity");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode transmitDiversityIndicator */

   if (pvalue->m.transmitDiversityIndicatorPresent) {
      PU_PUSHNAME (pctxt, "transmitDiversityIndicator");

      stat = asn1PD_TransmitDiversityIndicator (pctxt, &pvalue->transmitDiversityIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DPCH_Information_RL_SetupRqstFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DPCH_Information_RL_SetupRqstFDD (ASN1CTXT* pctxt, E_DPCH_Information_RL_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DPCH_Information_RL_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode maxSet_E_DPDCHs */

   PU_PUSHNAME (pctxt, "maxSet_E_DPDCHs");

   stat = asn1PD_Max_Set_E_DPDCHs (pctxt, &pvalue->maxSet_E_DPDCHs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_PunctureLimit */

   PU_PUSHNAME (pctxt, "ul_PunctureLimit");

   stat = asn1PD_PunctureLimit (pctxt, &pvalue->ul_PunctureLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode e_TFCS_Information */

   PU_PUSHNAME (pctxt, "e_TFCS_Information");

   stat = asn1PD_E_TFCS_Information (pctxt, &pvalue->e_TFCS_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode e_TTI */

   PU_PUSHNAME (pctxt, "e_TTI");

   stat = asn1PD_E_TTI (pctxt, &pvalue->e_TTI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode e_DPCCH_PO */

   PU_PUSHNAME (pctxt, "e_DPCCH_PO");

   stat = asn1PD_E_DPCCH_PO (pctxt, &pvalue->e_DPCCH_PO);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DPCH_Information_RL_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerOffsetInformation_F_DPCH_RL_SetupRqstFDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerOffsetInformation_F_DPCH_RL_SetupRqstFDD (ASN1CTXT* pctxt, PowerOffsetInformation_F_DPCH_RL_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_F_DPCH_RL_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pO2_ForTPC_Bits */

   PU_PUSHNAME (pctxt, "pO2_ForTPC_Bits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO2_ForTPC_Bits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_F_DPCH_RL_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  F_DPCH_Information_RL_SetupRqstFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_F_DPCH_Information_RL_SetupRqstFDD (ASN1CTXT* pctxt, F_DPCH_Information_RL_SetupRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_F_DPCH_Information_RL_SetupRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode powerOffsetInformation */

   PU_PUSHNAME (pctxt, "powerOffsetInformation");

   stat = asn1PD_PowerOffsetInformation_F_DPCH_RL_SetupRqstFDD (pctxt, &pvalue->powerOffsetInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_TPC_DownlinkStepSize */

   PU_PUSHNAME (pctxt, "fdd_TPC_DownlinkStepSize");

   stat = asn1PD_FDD_TPC_DownlinkStepSize (pctxt, &pvalue->fdd_TPC_DownlinkStepSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode limitedPowerIncrease */

   PU_PUSHNAME (pctxt, "limitedPowerIncrease");

   stat = asn1PD_LimitedPowerIncrease (pctxt, &pvalue->limitedPowerIncrease);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode innerLoopDLPCStatus */

   PU_PUSHNAME (pctxt, "innerLoopDLPCStatus");

   stat = asn1PD_InnerLoopDLPCStatus (pctxt, &pvalue->innerLoopDLPCStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_F_DPCH_Information_RL_SetupRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkSetupRequestTDD                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkSetupRequestTDD (ASN1CTXT* pctxt, RadioLinkSetupRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationList_RL_SetupRqstTDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationList_RL_SetupRqstTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationList_RL_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationList_RL_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationList_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationItem_RL_SetupRqstTDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationItem_RL_SetupRqstTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationItem_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationItem_RL_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "uL_DPCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_DPCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Coding */

   PU_PUSHNAME (pctxt, "tFCI_Coding");

   stat = asn1PD_TFCI_Coding (pctxt, &pvalue->tFCI_Coding);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode punctureLimit */

   PU_PUSHNAME (pctxt, "punctureLimit");

   stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_DPCH_Information */

   if (pvalue->m.uL_DPCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "uL_DPCH_Information");

      stat = asn1PD_UL_DPCH_Information_RL_SetupRqstTDD (pctxt, &pvalue->uL_DPCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationItem_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationItem_RL_SetupRqstTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationItem_RL_SetupRqstTDD (ASN1CTXT* pctxt, UL_DPCH_InformationItem_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationItem_RL_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Timeslot_Information */

   PU_PUSHNAME (pctxt, "uL_Timeslot_Information");

   stat = asn1PD_UL_Timeslot_Information (pctxt, &pvalue->uL_Timeslot_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationItem_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_LCR_Information_RL_SetupRqstTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_LCR_Information_RL_SetupRqstTDD (ASN1CTXT* pctxt, UL_DPCH_LCR_Information_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_LCR_Information_RL_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_TimeslotLCR_Information */

   PU_PUSHNAME (pctxt, "uL_TimeslotLCR_Information");

   stat = asn1PD_UL_TimeslotLCR_Information (pctxt, &pvalue->uL_TimeslotLCR_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_LCR_Information_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationList_RL_SetupRqstTDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationList_RL_SetupRqstTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationList_RL_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationList_RL_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationList_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_TPCItem_RL_SetupRqstTDD                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_TPCItem_RL_SetupRqstTDD (ASN1CTXT* pctxt, CCTrCH_TPCItem_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCItem_RL_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCItem_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_TPCList_RL_SetupRqstTDD                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_TPCList_RL_SetupRqstTDD (ASN1CTXT* pctxt, CCTrCH_TPCList_RL_SetupRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   CCTrCH_TPCItem_RL_SetupRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCList_RL_SetupRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CCTrCH_TPCItem_RL_SetupRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CCTrCH_TPCItem_RL_SetupRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCList_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationItem_RL_SetupRqstTDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationItem_RL_SetupRqstTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationItem_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationItem_RL_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "cCTrCH_TPCListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_TPCListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_DPCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_DPCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Coding */

   PU_PUSHNAME (pctxt, "tFCI_Coding");

   stat = asn1PD_TFCI_Coding (pctxt, &pvalue->tFCI_Coding);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode punctureLimit */

   PU_PUSHNAME (pctxt, "punctureLimit");

   stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_TPC_DownlinkStepSize */

   PU_PUSHNAME (pctxt, "tdd_TPC_DownlinkStepSize");

   stat = asn1PD_TDD_TPC_DownlinkStepSize (pctxt, &pvalue->tdd_TPC_DownlinkStepSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cCTrCH_TPCList */

   if (pvalue->m.cCTrCH_TPCListPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_TPCList");

      stat = asn1PD_CCTrCH_TPCList_RL_SetupRqstTDD (pctxt, &pvalue->cCTrCH_TPCList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_DPCH_Information */

   if (pvalue->m.dL_DPCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "dL_DPCH_Information");

      stat = asn1PD_DL_DPCH_Information_RL_SetupRqstTDD (pctxt, &pvalue->dL_DPCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationItem_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationItem_RL_SetupRqstTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationItem_RL_SetupRqstTDD (ASN1CTXT* pctxt, DL_DPCH_InformationItem_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationItem_RL_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Timeslot_Information */

   PU_PUSHNAME (pctxt, "dL_Timeslot_Information");

   stat = asn1PD_DL_Timeslot_Information (pctxt, &pvalue->dL_Timeslot_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationItem_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_LCR_Information_RL_SetupRqstTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_LCR_Information_RL_SetupRqstTDD (ASN1CTXT* pctxt, DL_DPCH_LCR_Information_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_LCR_Information_RL_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_TimeslotLCR_Information */

   PU_PUSHNAME (pctxt, "dL_TimeslotLCR_Information");

   stat = asn1PD_DL_TimeslotLCR_Information (pctxt, &pvalue->dL_TimeslotLCR_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tstdIndicator */

   PU_PUSHNAME (pctxt, "tstdIndicator");

   stat = asn1PD_TSTD_Indicator (pctxt, &pvalue->tstdIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_LCR_Information_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Information_RL_SetupRqstTDD                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Information_RL_SetupRqstTDD (ASN1CTXT* pctxt, RL_Information_RL_SetupRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Information_RL_SetupRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dL_TimeSlotISCPInfoPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_TimeSlotISCPInfoPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode frameOffset */

   PU_PUSHNAME (pctxt, "frameOffset");

   stat = asn1PD_FrameOffset (pctxt, &pvalue->frameOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode specialBurstScheduling */

   PU_PUSHNAME (pctxt, "specialBurstScheduling");

   stat = asn1PD_SpecialBurstScheduling (pctxt, &pvalue->specialBurstScheduling);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode initialDL_transmissionPower */

   PU_PUSHNAME (pctxt, "initialDL_transmissionPower");

   stat = asn1PD_DL_Power (pctxt, &pvalue->initialDL_transmissionPower);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maximumDL_power */

   PU_PUSHNAME (pctxt, "maximumDL_power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->maximumDL_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode minimumDL_power */

   PU_PUSHNAME (pctxt, "minimumDL_power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->minimumDL_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_TimeSlotISCPInfo */

   if (pvalue->m.dL_TimeSlotISCPInfoPresent) {
      PU_PUSHNAME (pctxt, "dL_TimeSlotISCPInfo");

      stat = asn1PD_DL_TimeslotISCPInfo (pctxt, &pvalue->dL_TimeSlotISCPInfo);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Information_RL_SetupRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkSetupResponseFDD                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkSetupResponseFDD (ASN1CTXT* pctxt, RadioLinkSetupResponseFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupResponseFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupResponseFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponseList_RL_SetupRspFDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponseList_RL_SetupRspFDD (ASN1CTXT* pctxt, RL_InformationResponseList_RL_SetupRspFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseList_RL_SetupRspFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseList_RL_SetupRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combining_RL_SetupRspFDD                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Combining_RL_SetupRspFDD (ASN1CTXT* pctxt, Combining_RL_SetupRspFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_SetupRspFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_SetupRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonCombiningOrFirstRL_RL_SetupRspFDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NonCombiningOrFirstRL_RL_SetupRspFDD (ASN1CTXT* pctxt, NonCombiningOrFirstRL_RL_SetupRspFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NonCombiningOrFirstRL_RL_SetupRspFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_InformationResponse */

   PU_PUSHNAME (pctxt, "dCH_InformationResponse");

   stat = asn1PD_DCH_InformationResponse (pctxt, &pvalue->dCH_InformationResponse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NonCombiningOrFirstRL_RL_SetupRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityIndication_RL_SetupRspFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DiversityIndication_RL_SetupRspFDD (ASN1CTXT* pctxt, DiversityIndication_RL_SetupRspFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_SetupRspFDD: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* combining */
      case 0:
         PU_PUSHNAME (pctxt, "u.combining");

         pvalue->u.combining = rtMemAllocTypeZ (pctxt, Combining_RL_SetupRspFDD);
         if (pvalue->u.combining == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Combining_RL_SetupRspFDD (pctxt, pvalue->u.combining);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* nonCombiningOrFirstRL */
      case 1:
         PU_PUSHNAME (pctxt, "u.nonCombiningOrFirstRL");

         pvalue->u.nonCombiningOrFirstRL = rtMemAllocTypeZ (pctxt, NonCombiningOrFirstRL_RL_SetupRspFDD);
         if (pvalue->u.nonCombiningOrFirstRL == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_NonCombiningOrFirstRL_RL_SetupRspFDD (pctxt, pvalue->u.nonCombiningOrFirstRL);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_SetupRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponseItem_RL_SetupRspFDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponseItem_RL_SetupRspFDD (ASN1CTXT* pctxt, RL_InformationResponseItem_RL_SetupRspFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseItem_RL_SetupRspFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "not_Used_dSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_dSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode received_total_wide_band_power */

   PU_PUSHNAME (pctxt, "received_total_wide_band_power");

   stat = asn1PD_Received_total_wide_band_power_Value (pctxt, &pvalue->received_total_wide_band_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode diversityIndication */

   PU_PUSHNAME (pctxt, "diversityIndication");

   stat = asn1PD_DiversityIndication_RL_SetupRspFDD (pctxt, &pvalue->diversityIndication);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode not_Used_dSCH_InformationResponseList */

   if (pvalue->m.not_Used_dSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "not_Used_dSCH_InformationResponseList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode sSDT_SupportIndicator */

   PU_PUSHNAME (pctxt, "sSDT_SupportIndicator");

   stat = asn1PD_SSDT_SupportIndicator (pctxt, &pvalue->sSDT_SupportIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseItem_RL_SetupRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkSetupResponseTDD                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkSetupResponseTDD (ASN1CTXT* pctxt, RadioLinkSetupResponseTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupResponseTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupResponseTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponse_RL_SetupRspTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponse_RL_SetupRspTDD (ASN1CTXT* pctxt, RL_InformationResponse_RL_SetupRspTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponse_RL_SetupRspTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_TimeSlot_ISCP_Info */

   PU_PUSHNAME (pctxt, "uL_TimeSlot_ISCP_Info");

   stat = asn1PD_UL_TimeSlot_ISCP_Info (pctxt, &pvalue->uL_TimeSlot_ISCP_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_PhysCH_SF_Variation */

   PU_PUSHNAME (pctxt, "ul_PhysCH_SF_Variation");

   stat = asn1PD_UL_PhysCH_SF_Variation (pctxt, &pvalue->ul_PhysCH_SF_Variation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_InformationResponseList */

   if (pvalue->m.dCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "dCH_InformationResponseList");

      stat = asn1PD_DCH_InformationResponseList_RL_SetupRspTDD (pctxt, &pvalue->dCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dSCH_InformationResponseList */

   if (pvalue->m.dSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "dSCH_InformationResponseList");

      stat = asn1PD_DSCH_InformationResponseList_RL_SetupRspTDD (pctxt, &pvalue->dSCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uSCH_InformationResponseList */

   if (pvalue->m.uSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "uSCH_InformationResponseList");

      stat = asn1PD_USCH_InformationResponseList_RL_SetupRspTDD (pctxt, &pvalue->uSCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponse_RL_SetupRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponse_LCR_RL_SetupRspTDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponse_LCR_RL_SetupRspTDD (ASN1CTXT* pctxt, RL_InformationResponse_LCR_RL_SetupRspTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponse_LCR_RL_SetupRspTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_TimeSlot_ISCP_LCR_Info */

   PU_PUSHNAME (pctxt, "uL_TimeSlot_ISCP_LCR_Info");

   stat = asn1PD_UL_TimeSlot_ISCP_LCR_Info (pctxt, &pvalue->uL_TimeSlot_ISCP_LCR_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_PhysCH_SF_Variation */

   PU_PUSHNAME (pctxt, "ul_PhysCH_SF_Variation");

   stat = asn1PD_UL_PhysCH_SF_Variation (pctxt, &pvalue->ul_PhysCH_SF_Variation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_InformationResponseList */

   if (pvalue->m.dCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "dCH_InformationResponseList");

      stat = asn1PD_DCH_InformationResponseList_RL_SetupRspTDD (pctxt, &pvalue->dCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dSCH_InformationResponseList */

   if (pvalue->m.dSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "dSCH_InformationResponseList");

      stat = asn1PD_DSCH_InformationResponseList_RL_SetupRspTDD (pctxt, &pvalue->dSCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uSCH_InformationResponseList */

   if (pvalue->m.uSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "uSCH_InformationResponseList");

      stat = asn1PD_USCH_InformationResponseList_RL_SetupRspTDD (pctxt, &pvalue->uSCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponse_LCR_RL_SetupRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkSetupFailureFDD                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkSetupFailureFDD (ASN1CTXT* pctxt, RadioLinkSetupFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeneralCauseList_RL_SetupFailureFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeneralCauseList_RL_SetupFailureFDD (ASN1CTXT* pctxt, GeneralCauseList_RL_SetupFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_SetupFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_RL_InformationRespList_RL_SetupFailureFDD    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_RL_InformationRespList_RL_SetupFailureFDD (ASN1CTXT* pctxt, Unsuccessful_RL_InformationRespList_RL_SetupFailureFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespList_RL_SetupFailureFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespList_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Successful_RL_InformationRespList_RL_SetupFailureFDD      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Successful_RL_InformationRespList_RL_SetupFailureFDD (ASN1CTXT* pctxt, Successful_RL_InformationRespList_RL_SetupFailureFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Successful_RL_InformationRespList_RL_SetupFailureFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Successful_RL_InformationRespList_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RLSpecificCauseList_RL_SetupFailureFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RLSpecificCauseList_RL_SetupFailureFDD (ASN1CTXT* pctxt, RLSpecificCauseList_RL_SetupFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_SetupFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "successful_RL_InformationRespList_RL_SetupFailureFDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.successful_RL_InformationRespList_RL_SetupFailureFDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode unsuccessful_RL_InformationRespList_RL_SetupFailureFDD */

   PU_PUSHNAME (pctxt, "unsuccessful_RL_InformationRespList_RL_SetupFailureFDD");

   stat = asn1PD_Unsuccessful_RL_InformationRespList_RL_SetupFailureFDD (pctxt, &pvalue->unsuccessful_RL_InformationRespList_RL_SetupFailureFDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode successful_RL_InformationRespList_RL_SetupFailureFDD */

   if (pvalue->m.successful_RL_InformationRespList_RL_SetupFailureFDDPresent) {
      PU_PUSHNAME (pctxt, "successful_RL_InformationRespList_RL_SetupFailureFDD");

      stat = asn1PD_Successful_RL_InformationRespList_RL_SetupFailureFDD (pctxt, &pvalue->successful_RL_InformationRespList_RL_SetupFailureFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseLevel_RL_SetupFailureFDD                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseLevel_RL_SetupFailureFDD (ASN1CTXT* pctxt, CauseLevel_RL_SetupFailureFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_SetupFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* generalCause */
         case 0:
            PU_PUSHNAME (pctxt, "u.generalCause");

            pvalue->u.generalCause = rtMemAllocTypeZ (pctxt, GeneralCauseList_RL_SetupFailureFDD);
            if (pvalue->u.generalCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeneralCauseList_RL_SetupFailureFDD (pctxt, pvalue->u.generalCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rLSpecificCause */
         case 1:
            PU_PUSHNAME (pctxt, "u.rLSpecificCause");

            pvalue->u.rLSpecificCause = rtMemAllocTypeZ (pctxt, RLSpecificCauseList_RL_SetupFailureFDD);
            if (pvalue->u.rLSpecificCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RLSpecificCauseList_RL_SetupFailureFDD (pctxt, pvalue->u.rLSpecificCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_RL_InformationRespItem_RL_SetupFailureFDD    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_RL_InformationRespItem_RL_SetupFailureFDD (ASN1CTXT* pctxt, Unsuccessful_RL_InformationRespItem_RL_SetupFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespItem_RL_SetupFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespItem_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combining_RL_SetupFailureFDD                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Combining_RL_SetupFailureFDD (ASN1CTXT* pctxt, Combining_RL_SetupFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_SetupFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonCombiningOrFirstRL_RL_SetupFailureFDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NonCombiningOrFirstRL_RL_SetupFailureFDD (ASN1CTXT* pctxt, NonCombiningOrFirstRL_RL_SetupFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NonCombiningOrFirstRL_RL_SetupFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_InformationResponse */

   PU_PUSHNAME (pctxt, "dCH_InformationResponse");

   stat = asn1PD_DCH_InformationResponse (pctxt, &pvalue->dCH_InformationResponse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NonCombiningOrFirstRL_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityIndication_RL_SetupFailureFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DiversityIndication_RL_SetupFailureFDD (ASN1CTXT* pctxt, DiversityIndication_RL_SetupFailureFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_SetupFailureFDD: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* combining */
      case 0:
         PU_PUSHNAME (pctxt, "u.combining");

         pvalue->u.combining = rtMemAllocTypeZ (pctxt, Combining_RL_SetupFailureFDD);
         if (pvalue->u.combining == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Combining_RL_SetupFailureFDD (pctxt, pvalue->u.combining);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* nonCombiningOrFirstRL */
      case 1:
         PU_PUSHNAME (pctxt, "u.nonCombiningOrFirstRL");

         pvalue->u.nonCombiningOrFirstRL = rtMemAllocTypeZ (pctxt, NonCombiningOrFirstRL_RL_SetupFailureFDD);
         if (pvalue->u.nonCombiningOrFirstRL == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_NonCombiningOrFirstRL_RL_SetupFailureFDD (pctxt, pvalue->u.nonCombiningOrFirstRL);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Successful_RL_InformationRespItem_RL_SetupFailureFDD      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Successful_RL_InformationRespItem_RL_SetupFailureFDD (ASN1CTXT* pctxt, Successful_RL_InformationRespItem_RL_SetupFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Successful_RL_InformationRespItem_RL_SetupFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "not_Used_dSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_dSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_tFCI2_BearerInformationResponsePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_tFCI2_BearerInformationResponsePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode received_total_wide_band_power */

   PU_PUSHNAME (pctxt, "received_total_wide_band_power");

   stat = asn1PD_Received_total_wide_band_power_Value (pctxt, &pvalue->received_total_wide_band_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode diversityIndication */

   PU_PUSHNAME (pctxt, "diversityIndication");

   stat = asn1PD_DiversityIndication_RL_SetupFailureFDD (pctxt, &pvalue->diversityIndication);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode not_Used_dSCH_InformationResponseList */

   if (pvalue->m.not_Used_dSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "not_Used_dSCH_InformationResponseList");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_tFCI2_BearerInformationResponse */

   if (pvalue->m.not_Used_tFCI2_BearerInformationResponsePresent) {
      PU_PUSHNAME (pctxt, "not_Used_tFCI2_BearerInformationResponse");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode sSDT_SupportIndicator */

   PU_PUSHNAME (pctxt, "sSDT_SupportIndicator");

   stat = asn1PD_SSDT_SupportIndicator (pctxt, &pvalue->sSDT_SupportIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Successful_RL_InformationRespItem_RL_SetupFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkSetupFailureTDD                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkSetupFailureTDD (ASN1CTXT* pctxt, RadioLinkSetupFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkSetupFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeneralCauseList_RL_SetupFailureTDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeneralCauseList_RL_SetupFailureTDD (ASN1CTXT* pctxt, GeneralCauseList_RL_SetupFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_SetupFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_SetupFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RLSpecificCauseList_RL_SetupFailureTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RLSpecificCauseList_RL_SetupFailureTDD (ASN1CTXT* pctxt, RLSpecificCauseList_RL_SetupFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_SetupFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD */

   PU_PUSHNAME (pctxt, "unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD");

   stat = asn1PD_Unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD (pctxt, &pvalue->unsuccessful_RL_InformationRespItem_RL_SetupFailureTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_SetupFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseLevel_RL_SetupFailureTDD                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseLevel_RL_SetupFailureTDD (ASN1CTXT* pctxt, CauseLevel_RL_SetupFailureTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_SetupFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* generalCause */
         case 0:
            PU_PUSHNAME (pctxt, "u.generalCause");

            pvalue->u.generalCause = rtMemAllocTypeZ (pctxt, GeneralCauseList_RL_SetupFailureTDD);
            if (pvalue->u.generalCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeneralCauseList_RL_SetupFailureTDD (pctxt, pvalue->u.generalCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rLSpecificCause */
         case 1:
            PU_PUSHNAME (pctxt, "u.rLSpecificCause");

            pvalue->u.rLSpecificCause = rtMemAllocTypeZ (pctxt, RLSpecificCauseList_RL_SetupFailureTDD);
            if (pvalue->u.rLSpecificCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RLSpecificCauseList_RL_SetupFailureTDD (pctxt, pvalue->u.rLSpecificCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_SetupFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_RL_InformationResp_RL_SetupFailureTDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_RL_InformationResp_RL_SetupFailureTDD (ASN1CTXT* pctxt, Unsuccessful_RL_InformationResp_RL_SetupFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationResp_RL_SetupFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationResp_RL_SetupFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkAdditionRequestFDD                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkAdditionRequestFDD (ASN1CTXT* pctxt, RadioLinkAdditionRequestFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionRequestFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionRequestFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_RL_AdditionRqstFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_RL_AdditionRqstFDD (ASN1CTXT* pctxt, RL_InformationList_RL_AdditionRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_AdditionRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_AdditionRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_RL_AdditionRqstFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_RL_AdditionRqstFDD (ASN1CTXT* pctxt, RL_InformationItem_RL_AdditionRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_AdditionRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "initialDL_TransmissionPowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.initialDL_TransmissionPowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maximumDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maximumDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minimumDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minimumDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_sSDT_CellIdentityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_sSDT_CellIdentityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transmitDiversityIndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transmitDiversityIndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode frameOffset */

   PU_PUSHNAME (pctxt, "frameOffset");

   stat = asn1PD_FrameOffset (pctxt, &pvalue->frameOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode chipOffset */

   PU_PUSHNAME (pctxt, "chipOffset");

   stat = asn1PD_ChipOffset (pctxt, &pvalue->chipOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode diversityControlField */

   PU_PUSHNAME (pctxt, "diversityControlField");

   stat = asn1PD_DiversityControlField (pctxt, &pvalue->diversityControlField);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_CodeInformation */

   PU_PUSHNAME (pctxt, "dl_CodeInformation");

   stat = asn1PD_FDD_DL_CodeInformation (pctxt, &pvalue->dl_CodeInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode initialDL_TransmissionPower */

   if (pvalue->m.initialDL_TransmissionPowerPresent) {
      PU_PUSHNAME (pctxt, "initialDL_TransmissionPower");

      stat = asn1PD_DL_Power (pctxt, &pvalue->initialDL_TransmissionPower);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode maximumDL_Power */

   if (pvalue->m.maximumDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "maximumDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->maximumDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minimumDL_Power */

   if (pvalue->m.minimumDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "minimumDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->minimumDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_sSDT_CellIdentity */

   if (pvalue->m.not_Used_sSDT_CellIdentityPresent) {
      PU_PUSHNAME (pctxt, "not_Used_sSDT_CellIdentity");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode transmitDiversityIndicator */

   if (pvalue->m.transmitDiversityIndicatorPresent) {
      PU_PUSHNAME (pctxt, "transmitDiversityIndicator");

      stat = asn1PD_TransmitDiversityIndicator (pctxt, &pvalue->transmitDiversityIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_AdditionRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkAdditionRequestTDD                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkAdditionRequestTDD (ASN1CTXT* pctxt, RadioLinkAdditionRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationItem_RL_AdditionRqstTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationItem_RL_AdditionRqstTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationItem_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationItem_RL_AdditionRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "uL_DPCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_DPCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_DPCH_Information */

   if (pvalue->m.uL_DPCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "uL_DPCH_Information");

      stat = asn1PD_UL_DPCH_InformationList_RL_AdditionRqstTDD (pctxt, &pvalue->uL_DPCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationItem_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationList_RL_AdditionRqstTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationList_RL_AdditionRqstTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationList_RL_AdditionRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   UL_CCTrCH_InformationItem_RL_AdditionRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationList_RL_AdditionRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_CCTrCH_InformationItem_RL_AdditionRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_CCTrCH_InformationItem_RL_AdditionRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationList_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationItem_RL_AdditionRqstTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationItem_RL_AdditionRqstTDD (ASN1CTXT* pctxt, UL_DPCH_InformationItem_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationItem_RL_AdditionRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Timeslot_Information */

   PU_PUSHNAME (pctxt, "uL_Timeslot_Information");

   stat = asn1PD_UL_Timeslot_Information (pctxt, &pvalue->uL_Timeslot_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationItem_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationItem_RL_AdditionRqstTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationItem_RL_AdditionRqstTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationItem_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationItem_RL_AdditionRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dL_DPCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_DPCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_DPCH_Information */

   if (pvalue->m.dL_DPCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "dL_DPCH_Information");

      stat = asn1PD_DL_DPCH_InformationList_RL_AdditionRqstTDD (pctxt, &pvalue->dL_DPCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationItem_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationList_RL_AdditionRqstTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationList_RL_AdditionRqstTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationList_RL_AdditionRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   DL_CCTrCH_InformationItem_RL_AdditionRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationList_RL_AdditionRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_CCTrCH_InformationItem_RL_AdditionRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_CCTrCH_InformationItem_RL_AdditionRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationList_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationItem_RL_AdditionRqstTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationItem_RL_AdditionRqstTDD (ASN1CTXT* pctxt, DL_DPCH_InformationItem_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationItem_RL_AdditionRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Timeslot_Information */

   PU_PUSHNAME (pctxt, "dL_Timeslot_Information");

   stat = asn1PD_DL_Timeslot_Information (pctxt, &pvalue->dL_Timeslot_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationItem_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Information_RL_AdditionRqstTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Information_RL_AdditionRqstTDD (ASN1CTXT* pctxt, RL_Information_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Information_RL_AdditionRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "initial_DL_Transmission_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.initial_DL_Transmission_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maximumDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maximumDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minimumDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minimumDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_TimeSlotISCPInfoPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_TimeSlotISCPInfoPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode frameOffset */

   PU_PUSHNAME (pctxt, "frameOffset");

   stat = asn1PD_FrameOffset (pctxt, &pvalue->frameOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode diversityControlField */

   PU_PUSHNAME (pctxt, "diversityControlField");

   stat = asn1PD_DiversityControlField (pctxt, &pvalue->diversityControlField);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode initial_DL_Transmission_Power */

   if (pvalue->m.initial_DL_Transmission_PowerPresent) {
      PU_PUSHNAME (pctxt, "initial_DL_Transmission_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->initial_DL_Transmission_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode maximumDL_Power */

   if (pvalue->m.maximumDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "maximumDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->maximumDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minimumDL_Power */

   if (pvalue->m.minimumDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "minimumDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->minimumDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_TimeSlotISCPInfo */

   if (pvalue->m.dL_TimeSlotISCPInfoPresent) {
      PU_PUSHNAME (pctxt, "dL_TimeSlotISCPInfo");

      stat = asn1PD_DL_TimeslotISCPInfo (pctxt, &pvalue->dL_TimeSlotISCPInfo);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Information_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD (ASN1CTXT* pctxt, UL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_TimeslotLCR_Information */

   PU_PUSHNAME (pctxt, "uL_TimeslotLCR_Information");

   stat = asn1PD_UL_TimeslotLCR_Information (pctxt, &pvalue->uL_TimeslotLCR_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD (ASN1CTXT* pctxt, DL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_TimeslotLCR_Information */

   PU_PUSHNAME (pctxt, "dL_TimeslotLCR_Information");

   stat = asn1PD_DL_TimeslotLCR_Information (pctxt, &pvalue->dL_TimeslotLCR_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationItem_LCR_RL_AdditionRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkAdditionResponseFDD                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkAdditionResponseFDD (ASN1CTXT* pctxt, RadioLinkAdditionResponseFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionResponseFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionResponseFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponseList_RL_AdditionRspFDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponseList_RL_AdditionRspFDD (ASN1CTXT* pctxt, RL_InformationResponseList_RL_AdditionRspFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseList_RL_AdditionRspFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseList_RL_AdditionRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combining_RL_AdditionRspFDD                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Combining_RL_AdditionRspFDD (ASN1CTXT* pctxt, Combining_RL_AdditionRspFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_AdditionRspFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_AdditionRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Non_Combining_RL_AdditionRspFDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Non_Combining_RL_AdditionRspFDD (ASN1CTXT* pctxt, Non_Combining_RL_AdditionRspFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Non_Combining_RL_AdditionRspFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_InformationResponse */

   PU_PUSHNAME (pctxt, "dCH_InformationResponse");

   stat = asn1PD_DCH_InformationResponse (pctxt, &pvalue->dCH_InformationResponse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Non_Combining_RL_AdditionRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityIndication_RL_AdditionRspFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DiversityIndication_RL_AdditionRspFDD (ASN1CTXT* pctxt, DiversityIndication_RL_AdditionRspFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_AdditionRspFDD: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* combining */
      case 0:
         PU_PUSHNAME (pctxt, "u.combining");

         pvalue->u.combining = rtMemAllocTypeZ (pctxt, Combining_RL_AdditionRspFDD);
         if (pvalue->u.combining == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Combining_RL_AdditionRspFDD (pctxt, pvalue->u.combining);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* non_combining */
      case 1:
         PU_PUSHNAME (pctxt, "u.non_combining");

         pvalue->u.non_combining = rtMemAllocTypeZ (pctxt, Non_Combining_RL_AdditionRspFDD);
         if (pvalue->u.non_combining == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Non_Combining_RL_AdditionRspFDD (pctxt, pvalue->u.non_combining);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_AdditionRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponseItem_RL_AdditionRspFDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponseItem_RL_AdditionRspFDD (ASN1CTXT* pctxt, RL_InformationResponseItem_RL_AdditionRspFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseItem_RL_AdditionRspFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode received_total_wide_band_power */

   PU_PUSHNAME (pctxt, "received_total_wide_band_power");

   stat = asn1PD_Received_total_wide_band_power_Value (pctxt, &pvalue->received_total_wide_band_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode diversityIndication */

   PU_PUSHNAME (pctxt, "diversityIndication");

   stat = asn1PD_DiversityIndication_RL_AdditionRspFDD (pctxt, &pvalue->diversityIndication);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sSDT_SupportIndicator */

   PU_PUSHNAME (pctxt, "sSDT_SupportIndicator");

   stat = asn1PD_SSDT_SupportIndicator (pctxt, &pvalue->sSDT_SupportIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseItem_RL_AdditionRspFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkAdditionResponseTDD                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkAdditionResponseTDD (ASN1CTXT* pctxt, RadioLinkAdditionResponseTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionResponseTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionResponseTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combining_RL_AdditionRspTDD                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Combining_RL_AdditionRspTDD (ASN1CTXT* pctxt, Combining_RL_AdditionRspTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_AdditionRspTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_AdditionRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Non_Combining_RL_AdditionRspTDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Non_Combining_RL_AdditionRspTDD (ASN1CTXT* pctxt, Non_Combining_RL_AdditionRspTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Non_Combining_RL_AdditionRspTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_InformationResponse */

   PU_PUSHNAME (pctxt, "dCH_InformationResponse");

   stat = asn1PD_DCH_InformationResponse (pctxt, &pvalue->dCH_InformationResponse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Non_Combining_RL_AdditionRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityIndication_RL_AdditionRspTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DiversityIndication_RL_AdditionRspTDD (ASN1CTXT* pctxt, DiversityIndication_RL_AdditionRspTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_AdditionRspTDD: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* combining */
      case 0:
         PU_PUSHNAME (pctxt, "u.combining");

         pvalue->u.combining = rtMemAllocTypeZ (pctxt, Combining_RL_AdditionRspTDD);
         if (pvalue->u.combining == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Combining_RL_AdditionRspTDD (pctxt, pvalue->u.combining);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* non_Combining */
      case 1:
         PU_PUSHNAME (pctxt, "u.non_Combining");

         pvalue->u.non_Combining = rtMemAllocTypeZ (pctxt, Non_Combining_RL_AdditionRspTDD);
         if (pvalue->u.non_Combining == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Non_Combining_RL_AdditionRspTDD (pctxt, pvalue->u.non_Combining);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_AdditionRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Information_RL_AdditionRspTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_Information_RL_AdditionRspTDD (ASN1CTXT* pctxt, DCH_Information_RL_AdditionRspTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Information_RL_AdditionRspTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode diversityIndication */

   PU_PUSHNAME (pctxt, "diversityIndication");

   stat = asn1PD_DiversityIndication_RL_AdditionRspTDD (pctxt, &pvalue->diversityIndication);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Information_RL_AdditionRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponse_RL_AdditionRspTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponse_RL_AdditionRspTDD (ASN1CTXT* pctxt, RL_InformationResponse_RL_AdditionRspTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponse_RL_AdditionRspTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_TimeSlot_ISCP_Info */

   PU_PUSHNAME (pctxt, "uL_TimeSlot_ISCP_Info");

   stat = asn1PD_UL_TimeSlot_ISCP_Info (pctxt, &pvalue->uL_TimeSlot_ISCP_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_PhysCH_SF_Variation */

   PU_PUSHNAME (pctxt, "ul_PhysCH_SF_Variation");

   stat = asn1PD_UL_PhysCH_SF_Variation (pctxt, &pvalue->ul_PhysCH_SF_Variation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_Information */

   if (pvalue->m.dCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "dCH_Information");

      stat = asn1PD_DCH_Information_RL_AdditionRspTDD (pctxt, &pvalue->dCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dSCH_InformationResponseList */

   if (pvalue->m.dSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "dSCH_InformationResponseList");

      stat = asn1PD_DSCH_InformationResponseList_RL_AdditionRspTDD (pctxt, &pvalue->dSCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uSCH_InformationResponseList */

   if (pvalue->m.uSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "uSCH_InformationResponseList");

      stat = asn1PD_USCH_InformationResponseList_RL_AdditionRspTDD (pctxt, &pvalue->uSCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponse_RL_AdditionRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponse_LCR_RL_AdditionRspTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponse_LCR_RL_AdditionRspTDD (ASN1CTXT* pctxt, RL_InformationResponse_LCR_RL_AdditionRspTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponse_LCR_RL_AdditionRspTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dCH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dCH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uSCH_InformationResponseListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uSCH_InformationResponseListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_TimeSlot_ISCP_InfoLCR */

   PU_PUSHNAME (pctxt, "uL_TimeSlot_ISCP_InfoLCR");

   stat = asn1PD_UL_TimeSlot_ISCP_LCR_Info (pctxt, &pvalue->uL_TimeSlot_ISCP_InfoLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_PhysCH_SF_Variation */

   PU_PUSHNAME (pctxt, "ul_PhysCH_SF_Variation");

   stat = asn1PD_UL_PhysCH_SF_Variation (pctxt, &pvalue->ul_PhysCH_SF_Variation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_Information */

   if (pvalue->m.dCH_InformationPresent) {
      PU_PUSHNAME (pctxt, "dCH_Information");

      stat = asn1PD_DCH_Information_RL_AdditionRspTDD (pctxt, &pvalue->dCH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dSCH_InformationResponseList */

   if (pvalue->m.dSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "dSCH_InformationResponseList");

      stat = asn1PD_DSCH_InformationResponseList_RL_AdditionRspTDD (pctxt, &pvalue->dSCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uSCH_InformationResponseList */

   if (pvalue->m.uSCH_InformationResponseListPresent) {
      PU_PUSHNAME (pctxt, "uSCH_InformationResponseList");

      stat = asn1PD_USCH_InformationResponseList_RL_AdditionRspTDD (pctxt, &pvalue->uSCH_InformationResponseList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponse_LCR_RL_AdditionRspTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkAdditionFailureFDD                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkAdditionFailureFDD (ASN1CTXT* pctxt, RadioLinkAdditionFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeneralCauseList_RL_AdditionFailureFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeneralCauseList_RL_AdditionFailureFDD (ASN1CTXT* pctxt, GeneralCauseList_RL_AdditionFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_AdditionFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_RL_InformationRespList_RL_AdditionFailureFD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_RL_InformationRespList_RL_AdditionFailureFDD (ASN1CTXT* pctxt, Unsuccessful_RL_InformationRespList_RL_AdditionFailureFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespList_RL_AdditionFailureFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespList_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Successful_RL_InformationRespList_RL_AdditionFailureFDD   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Successful_RL_InformationRespList_RL_AdditionFailureFDD (ASN1CTXT* pctxt, Successful_RL_InformationRespList_RL_AdditionFailureFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(14), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Successful_RL_InformationRespList_RL_AdditionFailureFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Successful_RL_InformationRespList_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RLSpecificCauseList_RL_AdditionFailureFDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RLSpecificCauseList_RL_AdditionFailureFDD (ASN1CTXT* pctxt, RLSpecificCauseList_RL_AdditionFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_AdditionFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "successful_RL_InformationRespList_RL_AdditionFailureFDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.successful_RL_InformationRespList_RL_AdditionFailureFDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode unsuccessful_RL_InformationRespList_RL_AdditionFailureFDD */

   PU_PUSHNAME (pctxt, "unsuccessful_RL_InformationRespList_RL_AdditionFailureFDD");

   stat = asn1PD_Unsuccessful_RL_InformationRespList_RL_AdditionFailureFDD (pctxt, &pvalue->unsuccessful_RL_InformationRespList_RL_AdditionFailureFDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode successful_RL_InformationRespList_RL_AdditionFailureFDD */

   if (pvalue->m.successful_RL_InformationRespList_RL_AdditionFailureFDDPresent) {
      PU_PUSHNAME (pctxt, "successful_RL_InformationRespList_RL_AdditionFailureFDD");

      stat = asn1PD_Successful_RL_InformationRespList_RL_AdditionFailureFDD (pctxt, &pvalue->successful_RL_InformationRespList_RL_AdditionFailureFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseLevel_RL_AdditionFailureFDD                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseLevel_RL_AdditionFailureFDD (ASN1CTXT* pctxt, CauseLevel_RL_AdditionFailureFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_AdditionFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* generalCause */
         case 0:
            PU_PUSHNAME (pctxt, "u.generalCause");

            pvalue->u.generalCause = rtMemAllocTypeZ (pctxt, GeneralCauseList_RL_AdditionFailureFDD);
            if (pvalue->u.generalCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeneralCauseList_RL_AdditionFailureFDD (pctxt, pvalue->u.generalCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rLSpecificCause */
         case 1:
            PU_PUSHNAME (pctxt, "u.rLSpecificCause");

            pvalue->u.rLSpecificCause = rtMemAllocTypeZ (pctxt, RLSpecificCauseList_RL_AdditionFailureFDD);
            if (pvalue->u.rLSpecificCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RLSpecificCauseList_RL_AdditionFailureFDD (pctxt, pvalue->u.rLSpecificCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_RL_InformationRespItem_RL_AdditionFailureFD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_RL_InformationRespItem_RL_AdditionFailureFDD (ASN1CTXT* pctxt, Unsuccessful_RL_InformationRespItem_RL_AdditionFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespItem_RL_AdditionFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationRespItem_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combining_RL_AdditionFailureFDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Combining_RL_AdditionFailureFDD (ASN1CTXT* pctxt, Combining_RL_AdditionFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_AdditionFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Combining_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Non_Combining_RL_AdditionFailureFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Non_Combining_RL_AdditionFailureFDD (ASN1CTXT* pctxt, Non_Combining_RL_AdditionFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Non_Combining_RL_AdditionFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_InformationResponse */

   PU_PUSHNAME (pctxt, "dCH_InformationResponse");

   stat = asn1PD_DCH_InformationResponse (pctxt, &pvalue->dCH_InformationResponse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Non_Combining_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityIndication_RL_AdditionFailureFDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DiversityIndication_RL_AdditionFailureFDD (ASN1CTXT* pctxt, DiversityIndication_RL_AdditionFailureFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_AdditionFailureFDD: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* combining */
      case 0:
         PU_PUSHNAME (pctxt, "u.combining");

         pvalue->u.combining = rtMemAllocTypeZ (pctxt, Combining_RL_AdditionFailureFDD);
         if (pvalue->u.combining == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Combining_RL_AdditionFailureFDD (pctxt, pvalue->u.combining);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* non_Combining */
      case 1:
         PU_PUSHNAME (pctxt, "u.non_Combining");

         pvalue->u.non_Combining = rtMemAllocTypeZ (pctxt, Non_Combining_RL_AdditionFailureFDD);
         if (pvalue->u.non_Combining == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Non_Combining_RL_AdditionFailureFDD (pctxt, pvalue->u.non_Combining);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityIndication_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Successful_RL_InformationRespItem_RL_AdditionFailureFDD   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Successful_RL_InformationRespItem_RL_AdditionFailureFDD (ASN1CTXT* pctxt, Successful_RL_InformationRespItem_RL_AdditionFailureFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Successful_RL_InformationRespItem_RL_AdditionFailureFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode received_total_wide_band_power */

   PU_PUSHNAME (pctxt, "received_total_wide_band_power");

   stat = asn1PD_Received_total_wide_band_power_Value (pctxt, &pvalue->received_total_wide_band_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode diversityIndication */

   PU_PUSHNAME (pctxt, "diversityIndication");

   stat = asn1PD_DiversityIndication_RL_AdditionFailureFDD (pctxt, &pvalue->diversityIndication);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sSDT_SupportIndicator */

   PU_PUSHNAME (pctxt, "sSDT_SupportIndicator");

   stat = asn1PD_SSDT_SupportIndicator (pctxt, &pvalue->sSDT_SupportIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Successful_RL_InformationRespItem_RL_AdditionFailureFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkAdditionFailureTDD                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkAdditionFailureTDD (ASN1CTXT* pctxt, RadioLinkAdditionFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkAdditionFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeneralCauseList_RL_AdditionFailureTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeneralCauseList_RL_AdditionFailureTDD (ASN1CTXT* pctxt, GeneralCauseList_RL_AdditionFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_AdditionFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_AdditionFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RLSpecificCauseList_RL_AdditionFailureTDD                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RLSpecificCauseList_RL_AdditionFailureTDD (ASN1CTXT* pctxt, RLSpecificCauseList_RL_AdditionFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_AdditionFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode unsuccessful_RL_InformationRespItem_RL_AdditionFailureTDD */

   PU_PUSHNAME (pctxt, "unsuccessful_RL_InformationRespItem_RL_AdditionFailureTDD");

   stat = asn1PD_Unsuccessful_RL_InformationRespItem_RL_AdditionFailureTDD (pctxt, &pvalue->unsuccessful_RL_InformationRespItem_RL_AdditionFailureTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_AdditionFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseLevel_RL_AdditionFailureTDD                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseLevel_RL_AdditionFailureTDD (ASN1CTXT* pctxt, CauseLevel_RL_AdditionFailureTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_AdditionFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* generalCause */
         case 0:
            PU_PUSHNAME (pctxt, "u.generalCause");

            pvalue->u.generalCause = rtMemAllocTypeZ (pctxt, GeneralCauseList_RL_AdditionFailureTDD);
            if (pvalue->u.generalCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeneralCauseList_RL_AdditionFailureTDD (pctxt, pvalue->u.generalCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rLSpecificCause */
         case 1:
            PU_PUSHNAME (pctxt, "u.rLSpecificCause");

            pvalue->u.rLSpecificCause = rtMemAllocTypeZ (pctxt, RLSpecificCauseList_RL_AdditionFailureTDD);
            if (pvalue->u.rLSpecificCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RLSpecificCauseList_RL_AdditionFailureTDD (pctxt, pvalue->u.rLSpecificCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_AdditionFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_RL_InformationResp_RL_AdditionFailureTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_RL_InformationResp_RL_AdditionFailureTDD (ASN1CTXT* pctxt, Unsuccessful_RL_InformationResp_RL_AdditionFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationResp_RL_AdditionFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_RL_InformationResp_RL_AdditionFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationPrepareFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationPrepareFDD (ASN1CTXT* pctxt, RadioLinkReconfigurationPrepareFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationPrepareFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationPrepareFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_Information_RL_ReconfPrepFDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_Information_RL_ReconfPrepFDD (ASN1CTXT* pctxt, UL_DPCH_Information_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_Information_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_ScramblingCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_ScramblingCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_SIR_TargetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_SIR_TargetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minUL_ChannelisationCodeLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minUL_ChannelisationCodeLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maxNrOfUL_DPDCHsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxNrOfUL_DPDCHsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_PunctureLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_PunctureLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_DPCCH_SlotFormatPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCCH_SlotFormatPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "diversityModePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.diversityModePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_sSDT_CellIDLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_sSDT_CellIDLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_s_FieldLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_s_FieldLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode ul_ScramblingCode */

   if (pvalue->m.ul_ScramblingCodePresent) {
      PU_PUSHNAME (pctxt, "ul_ScramblingCode");

      stat = asn1PD_UL_ScramblingCode (pctxt, &pvalue->ul_ScramblingCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_SIR_Target */

   if (pvalue->m.ul_SIR_TargetPresent) {
      PU_PUSHNAME (pctxt, "ul_SIR_Target");

      stat = asn1PD_UL_SIR (pctxt, &pvalue->ul_SIR_Target);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minUL_ChannelisationCodeLength */

   if (pvalue->m.minUL_ChannelisationCodeLengthPresent) {
      PU_PUSHNAME (pctxt, "minUL_ChannelisationCodeLength");

      stat = asn1PD_MinUL_ChannelisationCodeLength (pctxt, &pvalue->minUL_ChannelisationCodeLength);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode maxNrOfUL_DPDCHs */

   if (pvalue->m.maxNrOfUL_DPDCHsPresent) {
      PU_PUSHNAME (pctxt, "maxNrOfUL_DPDCHs");

      stat = asn1PD_MaxNrOfUL_DPDCHs (pctxt, &pvalue->maxNrOfUL_DPDCHs);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_PunctureLimit */

   if (pvalue->m.ul_PunctureLimitPresent) {
      PU_PUSHNAME (pctxt, "ul_PunctureLimit");

      stat = asn1PD_PunctureLimit (pctxt, &pvalue->ul_PunctureLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCS */

   if (pvalue->m.tFCSPresent) {
      PU_PUSHNAME (pctxt, "tFCS");

      stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_DPCCH_SlotFormat */

   if (pvalue->m.ul_DPCCH_SlotFormatPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCCH_SlotFormat");

      stat = asn1PD_UL_DPCCH_SlotFormat (pctxt, &pvalue->ul_DPCCH_SlotFormat);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode diversityMode */

   if (pvalue->m.diversityModePresent) {
      PU_PUSHNAME (pctxt, "diversityMode");

      stat = asn1PD_DiversityMode (pctxt, &pvalue->diversityMode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_sSDT_CellIDLength */

   if (pvalue->m.not_Used_sSDT_CellIDLengthPresent) {
      PU_PUSHNAME (pctxt, "not_Used_sSDT_CellIDLength");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_s_FieldLength */

   if (pvalue->m.not_Used_s_FieldLengthPresent) {
      PU_PUSHNAME (pctxt, "not_Used_s_FieldLength");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_Information_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_Information_RL_ReconfPrepFDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_Information_RL_ReconfPrepFDD (ASN1CTXT* pctxt, DL_DPCH_Information_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Information_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tFCSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_SlotFormatPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_SlotFormatPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_SignallingModePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_SignallingModePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "multiplexingPositionPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.multiplexingPositionPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_pDSCH_CodeMappingPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_pDSCH_CodeMappingPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_pDSCH_RL_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_pDSCH_RL_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "limitedPowerIncreasePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.limitedPowerIncreasePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tFCS */

   if (pvalue->m.tFCSPresent) {
      PU_PUSHNAME (pctxt, "tFCS");

      stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_SlotFormat */

   if (pvalue->m.dl_DPCH_SlotFormatPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_SlotFormat");

      stat = asn1PD_DL_DPCH_SlotFormat (pctxt, &pvalue->dl_DPCH_SlotFormat);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_SignallingMode */

   if (pvalue->m.tFCI_SignallingModePresent) {
      PU_PUSHNAME (pctxt, "tFCI_SignallingMode");

      stat = asn1PD_TFCI_SignallingMode (pctxt, &pvalue->tFCI_SignallingMode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode multiplexingPosition */

   if (pvalue->m.multiplexingPositionPresent) {
      PU_PUSHNAME (pctxt, "multiplexingPosition");

      stat = asn1PD_MultiplexingPosition (pctxt, &pvalue->multiplexingPosition);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_pDSCH_CodeMapping */

   if (pvalue->m.not_Used_pDSCH_CodeMappingPresent) {
      PU_PUSHNAME (pctxt, "not_Used_pDSCH_CodeMapping");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_pDSCH_RL_ID */

   if (pvalue->m.not_Used_pDSCH_RL_IDPresent) {
      PU_PUSHNAME (pctxt, "not_Used_pDSCH_RL_ID");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode limitedPowerIncrease */

   if (pvalue->m.limitedPowerIncreasePresent) {
      PU_PUSHNAME (pctxt, "limitedPowerIncrease");

      stat = asn1PD_LimitedPowerIncrease (pctxt, &pvalue->limitedPowerIncrease);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Information_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerOffsetInformation_RL_ReconfPrepFDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerOffsetInformation_RL_ReconfPrepFDD (ASN1CTXT* pctxt, PowerOffsetInformation_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pO1_ForTFCI_Bits */

   PU_PUSHNAME (pctxt, "pO1_ForTFCI_Bits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO1_ForTFCI_Bits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pO2_ForTPC_Bits */

   PU_PUSHNAME (pctxt, "pO2_ForTPC_Bits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO2_ForTPC_Bits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pO3_ForPilotBits */

   PU_PUSHNAME (pctxt, "pO3_ForPilotBits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO3_ForPilotBits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_Power_Information_RL_ReconfPrepFDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_Power_Information_RL_ReconfPrepFDD (ASN1CTXT* pctxt, DL_DPCH_Power_Information_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Power_Information_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode powerOffsetInformation */

   PU_PUSHNAME (pctxt, "powerOffsetInformation");

   stat = asn1PD_PowerOffsetInformation_RL_ReconfPrepFDD (pctxt, &pvalue->powerOffsetInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_TPC_DownlinkStepSize */

   PU_PUSHNAME (pctxt, "fdd_TPC_DownlinkStepSize");

   stat = asn1PD_FDD_TPC_DownlinkStepSize (pctxt, &pvalue->fdd_TPC_DownlinkStepSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode innerLoopDLPCStatus */

   PU_PUSHNAME (pctxt, "innerLoopDLPCStatus");

   stat = asn1PD_InnerLoopDLPCStatus (pctxt, &pvalue->innerLoopDLPCStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Power_Information_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_DeleteItem_RL_ReconfPrepFDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_DeleteItem_RL_ReconfPrepFDD (ASN1CTXT* pctxt, DCH_DeleteItem_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteItem_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteItem_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_DeleteList_RL_ReconfPrepFDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_DeleteList_RL_ReconfPrepFDD (ASN1CTXT* pctxt, DCH_DeleteList_RL_ReconfPrepFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_DeleteItem_RL_ReconfPrepFDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteList_RL_ReconfPrepFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_DeleteItem_RL_ReconfPrepFDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_DeleteItem_RL_ReconfPrepFDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteList_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_RL_ReconfPrepFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_RL_ReconfPrepFDD (ASN1CTXT* pctxt, RL_InformationList_RL_ReconfPrepFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_ReconfPrepFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_RL_ReconfPrepFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_RL_ReconfPrepFDD (ASN1CTXT* pctxt, RL_InformationItem_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dl_CodeInformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_CodeInformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maxDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_sSDT_IndicationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_sSDT_IndicationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_sSDT_Cell_IdentityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_sSDT_Cell_IdentityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transmitDiversityIndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transmitDiversityIndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_CodeInformation */

   if (pvalue->m.dl_CodeInformationPresent) {
      PU_PUSHNAME (pctxt, "dl_CodeInformation");

      stat = asn1PD_FDD_DL_CodeInformation (pctxt, &pvalue->dl_CodeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode maxDL_Power */

   if (pvalue->m.maxDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "maxDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->maxDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minDL_Power */

   if (pvalue->m.minDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "minDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->minDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_sSDT_Indication */

   if (pvalue->m.not_Used_sSDT_IndicationPresent) {
      PU_PUSHNAME (pctxt, "not_Used_sSDT_Indication");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_sSDT_Cell_Identity */

   if (pvalue->m.not_Used_sSDT_Cell_IdentityPresent) {
      PU_PUSHNAME (pctxt, "not_Used_sSDT_Cell_Identity");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode transmitDiversityIndicator */

   if (pvalue->m.transmitDiversityIndicatorPresent) {
      PU_PUSHNAME (pctxt, "transmitDiversityIndicator");

      stat = asn1PD_TransmitDiversityIndicator (pctxt, &pvalue->transmitDiversityIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DPCH_Information_RL_ReconfPrepFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DPCH_Information_RL_ReconfPrepFDD (ASN1CTXT* pctxt, E_DPCH_Information_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DPCH_Information_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxSet_E_DPDCHsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxSet_E_DPDCHsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_PunctureLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_PunctureLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_TFCS_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_TFCS_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_TTIPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_TTIPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_DPCCH_POPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_DPCCH_POPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode maxSet_E_DPDCHs */

   if (pvalue->m.maxSet_E_DPDCHsPresent) {
      PU_PUSHNAME (pctxt, "maxSet_E_DPDCHs");

      stat = asn1PD_Max_Set_E_DPDCHs (pctxt, &pvalue->maxSet_E_DPDCHs);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_PunctureLimit */

   if (pvalue->m.ul_PunctureLimitPresent) {
      PU_PUSHNAME (pctxt, "ul_PunctureLimit");

      stat = asn1PD_PunctureLimit (pctxt, &pvalue->ul_PunctureLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode e_TFCS_Information */

   if (pvalue->m.e_TFCS_InformationPresent) {
      PU_PUSHNAME (pctxt, "e_TFCS_Information");

      stat = asn1PD_E_TFCS_Information (pctxt, &pvalue->e_TFCS_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode e_TTI */

   if (pvalue->m.e_TTIPresent) {
      PU_PUSHNAME (pctxt, "e_TTI");

      stat = asn1PD_E_TTI (pctxt, &pvalue->e_TTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode e_DPCCH_PO */

   if (pvalue->m.e_DPCCH_POPresent) {
      PU_PUSHNAME (pctxt, "e_DPCCH_PO");

      stat = asn1PD_E_DPCCH_PO (pctxt, &pvalue->e_DPCCH_PO);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DPCH_Information_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerOffsetInformation_F_DPCH_RL_ReconfPrepFDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerOffsetInformation_F_DPCH_RL_ReconfPrepFDD (ASN1CTXT* pctxt, PowerOffsetInformation_F_DPCH_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_F_DPCH_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pO2_ForTPC_Bits */

   PU_PUSHNAME (pctxt, "pO2_ForTPC_Bits");

   stat = asn1PD_PowerOffset (pctxt, &pvalue->pO2_ForTPC_Bits);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffsetInformation_F_DPCH_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  F_DPCH_Information_RL_ReconfPrepFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_F_DPCH_Information_RL_ReconfPrepFDD (ASN1CTXT* pctxt, F_DPCH_Information_RL_ReconfPrepFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_F_DPCH_Information_RL_ReconfPrepFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode powerOffsetInformation */

   PU_PUSHNAME (pctxt, "powerOffsetInformation");

   stat = asn1PD_PowerOffsetInformation_F_DPCH_RL_ReconfPrepFDD (pctxt, &pvalue->powerOffsetInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_TPC_DownlinkStepSize */

   PU_PUSHNAME (pctxt, "fdd_TPC_DownlinkStepSize");

   stat = asn1PD_FDD_TPC_DownlinkStepSize (pctxt, &pvalue->fdd_TPC_DownlinkStepSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode limitedPowerIncrease */

   PU_PUSHNAME (pctxt, "limitedPowerIncrease");

   stat = asn1PD_LimitedPowerIncrease (pctxt, &pvalue->limitedPowerIncrease);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode innerLoopDLPCStatus */

   PU_PUSHNAME (pctxt, "innerLoopDLPCStatus");

   stat = asn1PD_InnerLoopDLPCStatus (pctxt, &pvalue->innerLoopDLPCStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_F_DPCH_Information_RL_ReconfPrepFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationPrepareTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationPrepareTDD (ASN1CTXT* pctxt, RadioLinkReconfigurationPrepareTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationPrepareTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationPrepareTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Coding */

   PU_PUSHNAME (pctxt, "tFCI_Coding");

   stat = asn1PD_TFCI_Coding (pctxt, &pvalue->tFCI_Coding);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode punctureLimit */

   PU_PUSHNAME (pctxt, "punctureLimit");

   stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_DPCH_InformationList */

   if (pvalue->m.ul_DPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationList");

      stat = asn1PD_UL_DPCH_InformationAddList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationAddList_RL_ReconfPrepTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationAddList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   UL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationAddList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Timeslot_InformationLCR */

   PU_PUSHNAME (pctxt, "uL_Timeslot_InformationLCR");

   stat = asn1PD_UL_TimeslotLCR_Information (pctxt, &pvalue->uL_Timeslot_InformationLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_UL_DPCH_InformationAddListIE_RL_ReconfPrepTDD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_UL_DPCH_InformationAddListIE_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_UL_DPCH_InformationAddListIE_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_UL_DPCH_InformationAddListIE_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationListLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationListLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_sir_targetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_sir_targetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDD_TPC_UplinkStepSize_LCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tDD_TPC_UplinkStepSize_LCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rL_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rL_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode ul_DPCH_InformationList */

   if (pvalue->m.ul_DPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationList");

      stat = asn1PD_UL_DPCH_InformationAddList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_DPCH_InformationListLCR */

   if (pvalue->m.ul_DPCH_InformationListLCRPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationListLCR");

      stat = asn1PD_UL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationListLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_sir_target */

   if (pvalue->m.ul_sir_targetPresent) {
      PU_PUSHNAME (pctxt, "ul_sir_target");

      stat = asn1PD_UL_SIR (pctxt, &pvalue->ul_sir_target);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tDD_TPC_UplinkStepSize_LCR */

   if (pvalue->m.tDD_TPC_UplinkStepSize_LCRPresent) {
      PU_PUSHNAME (pctxt, "tDD_TPC_UplinkStepSize_LCR");

      stat = asn1PD_TDD_TPC_UplinkStepSize_LCR (pctxt, &pvalue->tDD_TPC_UplinkStepSize_LCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode rL_ID */

   if (pvalue->m.rL_IDPresent) {
      PU_PUSHNAME (pctxt, "rL_ID");

      stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_UL_DPCH_InformationAddListIE_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_UL_DPCH_InformationAddList_RL_ReconfPrepTDD    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_UL_DPCH_InformationAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_UL_DPCH_InformationAddList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   MultipleRL_UL_DPCH_InformationAddListIE_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_UL_DPCH_InformationAddList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MultipleRL_UL_DPCH_InformationAddListIE_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MultipleRL_UL_DPCH_InformationAddListIE_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_UL_DPCH_InformationAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationAddItem_RL_ReconfPrepTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationAddItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationAddItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationAddItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Timeslot_Information */

   PU_PUSHNAME (pctxt, "uL_Timeslot_Information");

   stat = asn1PD_UL_Timeslot_Information (pctxt, &pvalue->uL_Timeslot_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationAddItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tFCSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_CodingPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_CodingPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "punctureLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.punctureLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationAddListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationAddListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationModifyListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationModifyListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationDeleteListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationDeleteListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   if (pvalue->m.tFCSPresent) {
      PU_PUSHNAME (pctxt, "tFCS");

      stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Coding */

   if (pvalue->m.tFCI_CodingPresent) {
      PU_PUSHNAME (pctxt, "tFCI_Coding");

      stat = asn1PD_TFCI_Coding (pctxt, &pvalue->tFCI_Coding);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode punctureLimit */

   if (pvalue->m.punctureLimitPresent) {
      PU_PUSHNAME (pctxt, "punctureLimit");

      stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_DPCH_InformationAddList */

   if (pvalue->m.ul_DPCH_InformationAddListPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationAddList");

      stat = asn1PD_UL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationAddList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_DPCH_InformationModifyList */

   if (pvalue->m.ul_DPCH_InformationModifyListPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationModifyList");

      stat = asn1PD_UL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationModifyList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_DPCH_InformationDeleteList */

   if (pvalue->m.ul_DPCH_InformationDeleteListPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationDeleteList");

      stat = asn1PD_UL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationDeleteList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   UL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Timeslot_InformationLCR */

   PU_PUSHNAME (pctxt, "uL_Timeslot_InformationLCR");

   stat = asn1PD_UL_TimeslotLCR_Information (pctxt, &pvalue->uL_Timeslot_InformationLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_UL_DPCH_InformationModifyListIE_RL_ReconfPrep  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_UL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_UL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_UL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationAddListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationAddListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationModifyListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationModifyListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationDeleteListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationDeleteListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_DPCH_InformationAddListLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_DPCH_InformationAddListLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_sir_targetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_sir_targetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDD_TPC_UplinkStepSize_LCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tDD_TPC_UplinkStepSize_LCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rL_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rL_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode ul_DPCH_InformationAddList */

   if (pvalue->m.ul_DPCH_InformationAddListPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationAddList");

      stat = asn1PD_UL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationAddList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_DPCH_InformationModifyList */

   if (pvalue->m.ul_DPCH_InformationModifyListPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationModifyList");

      stat = asn1PD_UL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationModifyList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_DPCH_InformationDeleteList */

   if (pvalue->m.ul_DPCH_InformationDeleteListPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationDeleteList");

      stat = asn1PD_UL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationDeleteList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_DPCH_InformationAddListLCR */

   if (pvalue->m.ul_DPCH_InformationAddListLCRPresent) {
      PU_PUSHNAME (pctxt, "ul_DPCH_InformationAddListLCR");

      stat = asn1PD_UL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD (pctxt, &pvalue->ul_DPCH_InformationAddListLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_sir_target */

   if (pvalue->m.ul_sir_targetPresent) {
      PU_PUSHNAME (pctxt, "ul_sir_target");

      stat = asn1PD_UL_SIR (pctxt, &pvalue->ul_sir_target);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tDD_TPC_UplinkStepSize_LCR */

   if (pvalue->m.tDD_TPC_UplinkStepSize_LCRPresent) {
      PU_PUSHNAME (pctxt, "tDD_TPC_UplinkStepSize_LCR");

      stat = asn1PD_TDD_TPC_UplinkStepSize_LCR (pctxt, &pvalue->tDD_TPC_UplinkStepSize_LCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode rL_ID */

   if (pvalue->m.rL_IDPresent) {
      PU_PUSHNAME (pctxt, "rL_ID");

      stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_UL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_UL_DPCH_InformationModifyList_RL_ReconfPrepTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_UL_DPCH_InformationModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_UL_DPCH_InformationModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   MultipleRL_UL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_UL_DPCH_InformationModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MultipleRL_UL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MultipleRL_UL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_UL_DPCH_InformationModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Timeslot_Information */

   PU_PUSHNAME (pctxt, "uL_Timeslot_Information");

   stat = asn1PD_UL_Timeslot_Information (pctxt, &pvalue->uL_Timeslot_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tdd_ChannelisationCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_ChannelisationCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   if (pvalue->m.tdd_ChannelisationCodePresent) {
      PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftAndBurstTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftAndBurstTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   if (pvalue->m.midambleShiftAndBurstTypePresent) {
      PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

      stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD */

   if (pvalue->m.uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD");

      stat = asn1PD_UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   UL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "repetitionPeriodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionPeriodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "repetitionLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_DPCHOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_DPCHOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   if (pvalue->m.repetitionPeriodPresent) {
      PU_PUSHNAME (pctxt, "repetitionPeriod");

      stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode repetitionLength */

   if (pvalue->m.repetitionLengthPresent) {
      PU_PUSHNAME (pctxt, "repetitionLength");

      stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_DPCHOffset */

   if (pvalue->m.tdd_DPCHOffsetPresent) {
      PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

      stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD */

   if (pvalue->m.uL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "uL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD");

      stat = asn1PD_UL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->uL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDDLCR  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDDLCR (ASN1CTXT* pctxt, UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDDLCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDDLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tdd_ChannelisationCodeLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_ChannelisationCodeLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   if (pvalue->m.tdd_ChannelisationCodeLCRPresent) {
      PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

      stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDDLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR (ASN1CTXT* pctxt, UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDDLCR* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDDLCR);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDDLCR (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPr  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   if (pvalue->m.midambleShiftLCRPresent) {
      PU_PUSHNAME (pctxt, "midambleShiftLCR");

      stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR */

   if (pvalue->m.uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCRPresent) {
      PU_PUSHNAME (pctxt, "uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR");

      stat = asn1PD_UL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR (pctxt, &pvalue->uL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotLCR_InformationModify_ModifyList_RL_ReconfPre  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeslotLCR_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_TimeslotLCR_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   UL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotLCR_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotLCR_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   UL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   UL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_TPCAddItem_RL_ReconfPrepTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_TPCAddItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, CCTrCH_TPCAddItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCAddItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCAddItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_TPCAddList_RL_ReconfPrepTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_TPCAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, CCTrCH_TPCAddList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   CCTrCH_TPCAddItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCAddList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CCTrCH_TPCAddItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CCTrCH_TPCAddItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "cCTrCH_TPCListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_TPCListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   PU_PUSHNAME (pctxt, "tFCS");

   stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Coding */

   PU_PUSHNAME (pctxt, "tFCI_Coding");

   stat = asn1PD_TFCI_Coding (pctxt, &pvalue->tFCI_Coding);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode punctureLimit */

   PU_PUSHNAME (pctxt, "punctureLimit");

   stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cCTrCH_TPCList */

   if (pvalue->m.cCTrCH_TPCListPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_TPCList");

      stat = asn1PD_CCTrCH_TPCAddList_RL_ReconfPrepTDD (pctxt, &pvalue->cCTrCH_TPCList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_InformationList */

   if (pvalue->m.dl_DPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationList");

      stat = asn1PD_DL_DPCH_InformationAddList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationAddList_RL_ReconfPrepTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationAddList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   DL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationAddList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_CCTrCH_InformationAddItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Timeslot_InformationLCR */

   PU_PUSHNAME (pctxt, "dL_Timeslot_InformationLCR");

   stat = asn1PD_DL_TimeslotLCR_Information (pctxt, &pvalue->dL_Timeslot_InformationLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_DL_DPCH_InformationAddListIE_RL_ReconfPrepTDD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_DL_DPCH_InformationAddListIE_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_DL_DPCH_InformationAddListIE_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_DL_DPCH_InformationAddListIE_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationListLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationListLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cCTrCH_Initial_DL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_Initial_DL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDD_TPC_DownlinkStepSizePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tDD_TPC_DownlinkStepSizePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cCTrCH_Maximum_DL_Power_InformationAdd_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_Maximum_DL_Power_InformationAdd_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cCTrCH_Minimum_DL_Power_InformationAdd_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_Minimum_DL_Power_InformationAdd_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rL_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rL_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dl_DPCH_InformationList */

   if (pvalue->m.dl_DPCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationList");

      stat = asn1PD_DL_DPCH_InformationAddList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_InformationListLCR */

   if (pvalue->m.dl_DPCH_InformationListLCRPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationListLCR");

      stat = asn1PD_DL_DPCH_LCR_InformationAddList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationListLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cCTrCH_Initial_DL_Power */

   if (pvalue->m.cCTrCH_Initial_DL_PowerPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_Initial_DL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->cCTrCH_Initial_DL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tDD_TPC_DownlinkStepSize */

   if (pvalue->m.tDD_TPC_DownlinkStepSizePresent) {
      PU_PUSHNAME (pctxt, "tDD_TPC_DownlinkStepSize");

      stat = asn1PD_TDD_TPC_DownlinkStepSize (pctxt, &pvalue->tDD_TPC_DownlinkStepSize);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cCTrCH_Maximum_DL_Power_InformationAdd_RL_ReconfPrepTDD */

   if (pvalue->m.cCTrCH_Maximum_DL_Power_InformationAdd_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_Maximum_DL_Power_InformationAdd_RL_ReconfPrepTDD");

      stat = asn1PD_DL_Power (pctxt, &pvalue->cCTrCH_Maximum_DL_Power_InformationAdd_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cCTrCH_Minimum_DL_Power_InformationAdd_RL_ReconfPrepTDD */

   if (pvalue->m.cCTrCH_Minimum_DL_Power_InformationAdd_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_Minimum_DL_Power_InformationAdd_RL_ReconfPrepTDD");

      stat = asn1PD_DL_Power (pctxt, &pvalue->cCTrCH_Minimum_DL_Power_InformationAdd_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode rL_ID */

   if (pvalue->m.rL_IDPresent) {
      PU_PUSHNAME (pctxt, "rL_ID");

      stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_DL_DPCH_InformationAddListIE_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_DL_DPCH_InformationAddList_RL_ReconfPrepTDD    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_DL_DPCH_InformationAddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_DL_DPCH_InformationAddList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   MultipleRL_DL_DPCH_InformationAddListIE_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_DL_DPCH_InformationAddList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MultipleRL_DL_DPCH_InformationAddListIE_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MultipleRL_DL_DPCH_InformationAddListIE_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_DL_DPCH_InformationAddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationAddItem_RL_ReconfPrepTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationAddItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationAddItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationAddItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Timeslot_Information */

   PU_PUSHNAME (pctxt, "dL_Timeslot_Information");

   stat = asn1PD_DL_Timeslot_Information (pctxt, &pvalue->dL_Timeslot_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationAddItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_TPCModifyItem_RL_ReconfPrepTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_TPCModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, CCTrCH_TPCModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_TPCModifyList_RL_ReconfPrepTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_TPCModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, CCTrCH_TPCModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   CCTrCH_TPCModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CCTrCH_TPCModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CCTrCH_TPCModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_TPCModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tFCSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_CodingPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_CodingPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "punctureLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.punctureLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cCTrCH_TPCListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_TPCListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationAddListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationAddListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationModifyListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationModifyListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationDeleteListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationDeleteListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   if (pvalue->m.tFCSPresent) {
      PU_PUSHNAME (pctxt, "tFCS");

      stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Coding */

   if (pvalue->m.tFCI_CodingPresent) {
      PU_PUSHNAME (pctxt, "tFCI_Coding");

      stat = asn1PD_TFCI_Coding (pctxt, &pvalue->tFCI_Coding);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode punctureLimit */

   if (pvalue->m.punctureLimitPresent) {
      PU_PUSHNAME (pctxt, "punctureLimit");

      stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cCTrCH_TPCList */

   if (pvalue->m.cCTrCH_TPCListPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_TPCList");

      stat = asn1PD_CCTrCH_TPCModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->cCTrCH_TPCList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_InformationAddList */

   if (pvalue->m.dl_DPCH_InformationAddListPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationAddList");

      stat = asn1PD_DL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationAddList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_InformationModifyList */

   if (pvalue->m.dl_DPCH_InformationModifyListPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationModifyList");

      stat = asn1PD_DL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationModifyList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_InformationDeleteList */

   if (pvalue->m.dl_DPCH_InformationDeleteListPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationDeleteList");

      stat = asn1PD_DL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationDeleteList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   DL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_CCTrCH_InformationModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Timeslot_InformationLCR */

   PU_PUSHNAME (pctxt, "dL_Timeslot_InformationLCR");

   stat = asn1PD_DL_TimeslotLCR_Information (pctxt, &pvalue->dL_Timeslot_InformationLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_DL_DPCH_InformationModifyListIE_RL_ReconfPrep  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_DL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_DL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_DL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationAddListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationAddListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationModifyListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationModifyListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationDeleteListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationDeleteListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_DPCH_InformationAddListLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_DPCH_InformationAddListLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDD_TPC_DownlinkStepSize_InformationModify_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tDD_TPC_DownlinkStepSize_InformationModify_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cCTrCH_Maximum_DL_Power_InformationModify_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_Maximum_DL_Power_InformationModify_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cCTrCH_Minimum_DL_Power_InformationModify_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_Minimum_DL_Power_InformationModify_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rL_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rL_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dl_DPCH_InformationAddList */

   if (pvalue->m.dl_DPCH_InformationAddListPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationAddList");

      stat = asn1PD_DL_DPCH_InformationModify_AddList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationAddList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_InformationModifyList */

   if (pvalue->m.dl_DPCH_InformationModifyListPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationModifyList");

      stat = asn1PD_DL_DPCH_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationModifyList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_InformationDeleteList */

   if (pvalue->m.dl_DPCH_InformationDeleteListPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationDeleteList");

      stat = asn1PD_DL_DPCH_InformationModify_DeleteList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationDeleteList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_DPCH_InformationAddListLCR */

   if (pvalue->m.dl_DPCH_InformationAddListLCRPresent) {
      PU_PUSHNAME (pctxt, "dl_DPCH_InformationAddListLCR");

      stat = asn1PD_DL_DPCH_LCR_InformationModify_AddList_RL_ReconfPrepTDD (pctxt, &pvalue->dl_DPCH_InformationAddListLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tDD_TPC_DownlinkStepSize_InformationModify_RL_ReconfPrepTDD */

   if (pvalue->m.tDD_TPC_DownlinkStepSize_InformationModify_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "tDD_TPC_DownlinkStepSize_InformationModify_RL_ReconfPrepTDD");

      stat = asn1PD_TDD_TPC_DownlinkStepSize (pctxt, &pvalue->tDD_TPC_DownlinkStepSize_InformationModify_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cCTrCH_Maximum_DL_Power_InformationModify_RL_ReconfPrepTDD */

   if (pvalue->m.cCTrCH_Maximum_DL_Power_InformationModify_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_Maximum_DL_Power_InformationModify_RL_ReconfPrepTDD");

      stat = asn1PD_DL_Power (pctxt, &pvalue->cCTrCH_Maximum_DL_Power_InformationModify_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cCTrCH_Minimum_DL_Power_InformationModify_RL_ReconfPrepTDD */

   if (pvalue->m.cCTrCH_Minimum_DL_Power_InformationModify_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_Minimum_DL_Power_InformationModify_RL_ReconfPrepTDD");

      stat = asn1PD_DL_Power (pctxt, &pvalue->cCTrCH_Minimum_DL_Power_InformationModify_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode rL_ID */

   if (pvalue->m.rL_IDPresent) {
      PU_PUSHNAME (pctxt, "rL_ID");

      stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_DL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_DL_DPCH_InformationModifyList_RL_ReconfPrepTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_DL_DPCH_InformationModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_DL_DPCH_InformationModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   MultipleRL_DL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_DL_DPCH_InformationModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MultipleRL_DL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MultipleRL_DL_DPCH_InformationModifyListIE_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_DL_DPCH_InformationModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DPCHOffset */

   PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

   stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Timeslot_Information */

   PU_PUSHNAME (pctxt, "dL_Timeslot_Information");

   stat = asn1PD_DL_Timeslot_Information (pctxt, &pvalue->dL_Timeslot_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_AddItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tdd_ChannelisationCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_ChannelisationCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   if (pvalue->m.tdd_ChannelisationCodePresent) {
      PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(240), 0 };
   int stat = 0;
   DL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Code_InformationModify_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftAndBurstTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftAndBurstTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   if (pvalue->m.midambleShiftAndBurstTypePresent) {
      PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

      stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD */

   if (pvalue->m.dL_Code_InformationModify_ModifyList_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "dL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD");

      stat = asn1PD_DL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->dL_Code_InformationModify_ModifyList_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   DL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Timeslot_InformationModify_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "repetitionPeriodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionPeriodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "repetitionLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_DPCHOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_DPCHOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_Timeslot_InformationAddModify_ModifyList_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_Timeslot_InformationAddModify_ModifyList_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   if (pvalue->m.repetitionPeriodPresent) {
      PU_PUSHNAME (pctxt, "repetitionPeriod");

      stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode repetitionLength */

   if (pvalue->m.repetitionLengthPresent) {
      PU_PUSHNAME (pctxt, "repetitionLength");

      stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_DPCHOffset */

   if (pvalue->m.tdd_DPCHOffsetPresent) {
      PU_PUSHNAME (pctxt, "tdd_DPCHOffset");

      stat = asn1PD_TDD_DPCHOffset (pctxt, &pvalue->tdd_DPCHOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_Timeslot_InformationAddModify_ModifyList_RL_ReconfPrepTDD */

   if (pvalue->m.dL_Timeslot_InformationAddModify_ModifyList_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "dL_Timeslot_InformationAddModify_ModifyList_RL_ReconfPrepTDD");

      stat = asn1PD_DL_Timeslot_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->dL_Timeslot_InformationAddModify_ModifyList_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_LCR_InformationModify_ModifyItem_RL_ReconfPrepTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_Code_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tdd_ChannelisationCodeLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_ChannelisationCodeLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   if (pvalue->m.tdd_ChannelisationCodeLCRPresent) {
      PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

      stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   DL_Code_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Code_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Code_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPr  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   if (pvalue->m.midambleShiftLCRPresent) {
      PU_PUSHNAME (pctxt, "midambleShiftLCR");

      stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD */

   if (pvalue->m.dL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDDPresent) {
      PU_PUSHNAME (pctxt, "dL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD");

      stat = asn1PD_DL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD (pctxt, &pvalue->dL_Code_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfPr  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   DL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_DPCH_InformationModify_DeleteItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_InformationModify_DeleteListIE_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   DL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_CCTrCH_InformationDeleteItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationDeleteList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_DeleteItem_RL_ReconfPrepTDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_DeleteItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DCH_DeleteItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_DeleteList_RL_ReconfPrepTDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_DeleteList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DCH_DeleteList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_DeleteItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_DeleteItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_DeleteItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_Information_ModifyItem_RL_ReconfPrepTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_Information_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DSCH_Information_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_Information_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "cCTrCH_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportFormatSetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportFormatSetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allocationRetentionPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "frameHandlingPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.frameHandlingPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWEPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dSCH_ID */

   PU_PUSHNAME (pctxt, "dSCH_ID");

   stat = asn1PD_DSCH_ID (pctxt, &pvalue->dSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cCTrCH_ID */

   if (pvalue->m.cCTrCH_IDPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_ID");

      stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportFormatSet */

   if (pvalue->m.transportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "transportFormatSet");

      stat = asn1PD_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode frameHandlingPriority */

   if (pvalue->m.frameHandlingPriorityPresent) {
      PU_PUSHNAME (pctxt, "frameHandlingPriority");

      stat = asn1PD_FrameHandlingPriority (pctxt, &pvalue->frameHandlingPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PD_TransportBearerRequestIndicator (pctxt, &pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_Information_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_Information_ModifyList_RL_ReconfPrepTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_Information_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DSCH_Information_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   DSCH_Information_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_Information_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DSCH_Information_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DSCH_Information_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_Information_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_Information_DeleteItem_RL_ReconfPrepTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_Information_DeleteItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DSCH_Information_DeleteItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_Information_DeleteItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dSCH_ID */

   PU_PUSHNAME (pctxt, "dSCH_ID");

   stat = asn1PD_DSCH_ID (pctxt, &pvalue->dSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_Information_DeleteItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_Information_DeleteList_RL_ReconfPrepTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_Information_DeleteList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, DSCH_Information_DeleteList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   DSCH_Information_DeleteItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_Information_DeleteList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DSCH_Information_DeleteItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DSCH_Information_DeleteItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_Information_DeleteList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_Information_ModifyItem_RL_ReconfPrepTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_Information_ModifyItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, USCH_Information_ModifyItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information_ModifyItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "transportFormatSetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportFormatSetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allocationRetentionPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cCTrCH_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cCTrCH_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uSCH_ID */

   PU_PUSHNAME (pctxt, "uSCH_ID");

   stat = asn1PD_USCH_ID (pctxt, &pvalue->uSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transportFormatSet */

   if (pvalue->m.transportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "transportFormatSet");

      stat = asn1PD_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cCTrCH_ID */

   if (pvalue->m.cCTrCH_IDPresent) {
      PU_PUSHNAME (pctxt, "cCTrCH_ID");

      stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PD_TransportBearerRequestIndicator (pctxt, &pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information_ModifyItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_Information_ModifyList_RL_ReconfPrepTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_Information_ModifyList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, USCH_Information_ModifyList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   USCH_Information_ModifyItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information_ModifyList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, USCH_Information_ModifyItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_USCH_Information_ModifyItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information_ModifyList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_Information_DeleteItem_RL_ReconfPrepTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_Information_DeleteItem_RL_ReconfPrepTDD (ASN1CTXT* pctxt, USCH_Information_DeleteItem_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information_DeleteItem_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uSCH_ID */

   PU_PUSHNAME (pctxt, "uSCH_ID");

   stat = asn1PD_USCH_ID (pctxt, &pvalue->uSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information_DeleteItem_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_Information_DeleteList_RL_ReconfPrepTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_Information_DeleteList_RL_ReconfPrepTDD (ASN1CTXT* pctxt, USCH_Information_DeleteList_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   USCH_Information_DeleteItem_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information_DeleteList_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, USCH_Information_DeleteItem_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_USCH_Information_DeleteItem_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information_DeleteList_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Information_RL_ReconfPrepTDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Information_RL_ReconfPrepTDD (ASN1CTXT* pctxt, RL_Information_RL_ReconfPrepTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Information_RL_ReconfPrepTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxDL_Power */

   if (pvalue->m.maxDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "maxDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->maxDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minDL_Power */

   if (pvalue->m.minDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "minDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->minDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Information_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleRL_Information_RL_ReconfPrepTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultipleRL_Information_RL_ReconfPrepTDD (ASN1CTXT* pctxt, MultipleRL_Information_RL_ReconfPrepTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   RL_Information_RL_ReconfPrepTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_Information_RL_ReconfPrepTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RL_Information_RL_ReconfPrepTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RL_Information_RL_ReconfPrepTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultipleRL_Information_RL_ReconfPrepTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationReady                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationReady (ASN1CTXT* pctxt, RadioLinkReconfigurationReady* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationReady: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationReady: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponseList_RL_ReconfReady                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponseList_RL_ReconfReady (ASN1CTXT* pctxt, RL_InformationResponseList_RL_ReconfReady* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseList_RL_ReconfReady: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseList_RL_ReconfReady: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponseItem_RL_ReconfReady                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponseItem_RL_ReconfReady (ASN1CTXT* pctxt, RL_InformationResponseItem_RL_ReconfReady* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseItem_RL_ReconfReady: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dCH_InformationResponseList_RL_ReconfReadyPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dCH_InformationResponseList_RL_ReconfReadyPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dSCH_InformationResponseList_RL_ReconfReadyPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dSCH_InformationResponseList_RL_ReconfReadyPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uSCH_InformationResponseList_RL_ReconfReadyPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uSCH_InformationResponseList_RL_ReconfReadyPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_tFCI2_BearerInformationResponsePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_tFCI2_BearerInformationResponsePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_InformationResponseList_RL_ReconfReady */

   if (pvalue->m.dCH_InformationResponseList_RL_ReconfReadyPresent) {
      PU_PUSHNAME (pctxt, "dCH_InformationResponseList_RL_ReconfReady");

      stat = asn1PD_DCH_InformationResponseList_RL_ReconfReady (pctxt, &pvalue->dCH_InformationResponseList_RL_ReconfReady);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dSCH_InformationResponseList_RL_ReconfReady */

   if (pvalue->m.dSCH_InformationResponseList_RL_ReconfReadyPresent) {
      PU_PUSHNAME (pctxt, "dSCH_InformationResponseList_RL_ReconfReady");

      stat = asn1PD_DSCH_InformationResponseList_RL_ReconfReady (pctxt, &pvalue->dSCH_InformationResponseList_RL_ReconfReady);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uSCH_InformationResponseList_RL_ReconfReady */

   if (pvalue->m.uSCH_InformationResponseList_RL_ReconfReadyPresent) {
      PU_PUSHNAME (pctxt, "uSCH_InformationResponseList_RL_ReconfReady");

      stat = asn1PD_USCH_InformationResponseList_RL_ReconfReady (pctxt, &pvalue->uSCH_InformationResponseList_RL_ReconfReady);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_tFCI2_BearerInformationResponse */

   if (pvalue->m.not_Used_tFCI2_BearerInformationResponsePresent) {
      PU_PUSHNAME (pctxt, "not_Used_tFCI2_BearerInformationResponse");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseItem_RL_ReconfReady: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationFailure                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationFailure (ASN1CTXT* pctxt, RadioLinkReconfigurationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeneralCauseList_RL_ReconfFailure                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeneralCauseList_RL_ReconfFailure (ASN1CTXT* pctxt, GeneralCauseList_RL_ReconfFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_ReconfFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_RL_ReconfFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_ReconfigurationFailureList_RL_ReconfFailure            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_ReconfigurationFailureList_RL_ReconfFailure (ASN1CTXT* pctxt, RL_ReconfigurationFailureList_RL_ReconfFailure* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_ReconfigurationFailureList_RL_ReconfFailure: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_ReconfigurationFailureList_RL_ReconfFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RLSpecificCauseList_RL_ReconfFailure                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RLSpecificCauseList_RL_ReconfFailure (ASN1CTXT* pctxt, RLSpecificCauseList_RL_ReconfFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_ReconfFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "rL_ReconfigurationFailureList_RL_ReconfFailurePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rL_ReconfigurationFailureList_RL_ReconfFailurePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ReconfigurationFailureList_RL_ReconfFailure */

   if (pvalue->m.rL_ReconfigurationFailureList_RL_ReconfFailurePresent) {
      PU_PUSHNAME (pctxt, "rL_ReconfigurationFailureList_RL_ReconfFailure");

      stat = asn1PD_RL_ReconfigurationFailureList_RL_ReconfFailure (pctxt, &pvalue->rL_ReconfigurationFailureList_RL_ReconfFailure);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RLSpecificCauseList_RL_ReconfFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseLevel_RL_ReconfFailure                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseLevel_RL_ReconfFailure (ASN1CTXT* pctxt, CauseLevel_RL_ReconfFailure* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_ReconfFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* generalCause */
         case 0:
            PU_PUSHNAME (pctxt, "u.generalCause");

            pvalue->u.generalCause = rtMemAllocTypeZ (pctxt, GeneralCauseList_RL_ReconfFailure);
            if (pvalue->u.generalCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeneralCauseList_RL_ReconfFailure (pctxt, pvalue->u.generalCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rLSpecificCause */
         case 1:
            PU_PUSHNAME (pctxt, "u.rLSpecificCause");

            pvalue->u.rLSpecificCause = rtMemAllocTypeZ (pctxt, RLSpecificCauseList_RL_ReconfFailure);
            if (pvalue->u.rLSpecificCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RLSpecificCauseList_RL_ReconfFailure (pctxt, pvalue->u.rLSpecificCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_RL_ReconfFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_ReconfigurationFailureItem_RL_ReconfFailure            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_ReconfigurationFailureItem_RL_ReconfFailure (ASN1CTXT* pctxt, RL_ReconfigurationFailureItem_RL_ReconfFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_ReconfigurationFailureItem_RL_ReconfFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_ReconfigurationFailureItem_RL_ReconfFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationCommit                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationCommit (ASN1CTXT* pctxt, RadioLinkReconfigurationCommit* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationCommit: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationCommit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationCancel                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationCancel (ASN1CTXT* pctxt, RadioLinkReconfigurationCancel* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationCancel: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationCancel: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationRequestFDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationRequestFDD (ASN1CTXT* pctxt, RadioLinkReconfigurationRequestFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationRequestFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationRequestFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCH_Information_RL_ReconfRqstFDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCH_Information_RL_ReconfRqstFDD (ASN1CTXT* pctxt, UL_DPCH_Information_RL_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_Information_RL_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_TFCSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_TFCSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode ul_TFCS */

   if (pvalue->m.ul_TFCSPresent) {
      PU_PUSHNAME (pctxt, "ul_TFCS");

      stat = asn1PD_TFCS (pctxt, &pvalue->ul_TFCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCH_Information_RL_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_Information_RL_ReconfRqstFDD                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_Information_RL_ReconfRqstFDD (ASN1CTXT* pctxt, DL_DPCH_Information_RL_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Information_RL_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dl_TFCSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_TFCSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_SignallingModePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_SignallingModePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "limitedPowerIncreasePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.limitedPowerIncreasePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dl_TFCS */

   if (pvalue->m.dl_TFCSPresent) {
      PU_PUSHNAME (pctxt, "dl_TFCS");

      stat = asn1PD_TFCS (pctxt, &pvalue->dl_TFCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_SignallingMode */

   if (pvalue->m.tFCI_SignallingModePresent) {
      PU_PUSHNAME (pctxt, "tFCI_SignallingMode");

      stat = asn1PD_TFCI_SignallingMode (pctxt, &pvalue->tFCI_SignallingMode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode limitedPowerIncrease */

   if (pvalue->m.limitedPowerIncreasePresent) {
      PU_PUSHNAME (pctxt, "limitedPowerIncrease");

      stat = asn1PD_LimitedPowerIncrease (pctxt, &pvalue->limitedPowerIncrease);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_Information_RL_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_DeleteItem_RL_ReconfRqstFDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_DeleteItem_RL_ReconfRqstFDD (ASN1CTXT* pctxt, DCH_DeleteItem_RL_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteItem_RL_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteItem_RL_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_DeleteList_RL_ReconfRqstFDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_DeleteList_RL_ReconfRqstFDD (ASN1CTXT* pctxt, DCH_DeleteList_RL_ReconfRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_DeleteItem_RL_ReconfRqstFDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteList_RL_ReconfRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_DeleteItem_RL_ReconfRqstFDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_DeleteItem_RL_ReconfRqstFDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteList_RL_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_RL_ReconfRqstFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_RL_ReconfRqstFDD (ASN1CTXT* pctxt, RL_InformationList_RL_ReconfRqstFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_ReconfRqstFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_RL_ReconfRqstFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_RL_ReconfRqstFDD (ASN1CTXT* pctxt, RL_InformationItem_RL_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_CodeInformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_CodeInformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxDL_Power */

   if (pvalue->m.maxDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "maxDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->maxDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minDL_Power */

   if (pvalue->m.minDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "minDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->minDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_CodeInformation */

   if (pvalue->m.dl_CodeInformationPresent) {
      PU_PUSHNAME (pctxt, "dl_CodeInformation");

      stat = asn1PD_FDD_DL_CodeInformation (pctxt, &pvalue->dl_CodeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DPCH_Information_RL_ReconfRqstFDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DPCH_Information_RL_ReconfRqstFDD (ASN1CTXT* pctxt, E_DPCH_Information_RL_ReconfRqstFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DPCH_Information_RL_ReconfRqstFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "e_TFCS_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_TFCS_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_DPCCH_POPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_DPCCH_POPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_TFCS_Information */

   if (pvalue->m.e_TFCS_InformationPresent) {
      PU_PUSHNAME (pctxt, "e_TFCS_Information");

      stat = asn1PD_E_TFCS_Information (pctxt, &pvalue->e_TFCS_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode e_DPCCH_PO */

   if (pvalue->m.e_DPCCH_POPresent) {
      PU_PUSHNAME (pctxt, "e_DPCCH_PO");

      stat = asn1PD_E_DPCCH_PO (pctxt, &pvalue->e_DPCCH_PO);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DPCH_Information_RL_ReconfRqstFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationRequestTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationRequestTDD (ASN1CTXT* pctxt, RadioLinkReconfigurationRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tFCSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "punctureLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.punctureLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   if (pvalue->m.tFCSPresent) {
      PU_PUSHNAME (pctxt, "tFCS");

      stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode punctureLimit */

   if (pvalue->m.punctureLimitPresent) {
      PU_PUSHNAME (pctxt, "punctureLimit");

      stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD (ASN1CTXT* pctxt, UL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationModifyList_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tFCSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "punctureLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.punctureLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCS */

   if (pvalue->m.tFCSPresent) {
      PU_PUSHNAME (pctxt, "tFCS");

      stat = asn1PD_TFCS (pctxt, &pvalue->tFCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode punctureLimit */

   if (pvalue->m.punctureLimitPresent) {
      PU_PUSHNAME (pctxt, "punctureLimit");

      stat = asn1PD_PunctureLimit (pctxt, &pvalue->punctureLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationModifyItem_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfRq  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxPowerLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxPowerLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minPowerLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minPowerLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxPowerLCR */

   if (pvalue->m.maxPowerLCRPresent) {
      PU_PUSHNAME (pctxt, "maxPowerLCR");

      stat = asn1PD_DL_Power (pctxt, &pvalue->maxPowerLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minPowerLCR */

   if (pvalue->m.minPowerLCRPresent) {
      PU_PUSHNAME (pctxt, "minPowerLCR");

      stat = asn1PD_DL_Power (pctxt, &pvalue->minPowerLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRq  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Timeslot_LCR_InformationModify_ModifyItem_RL_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_LCR_InformationModify_ModifyList_RL_ReconfRqstTD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DL_DPCH_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD */

   if (pvalue->m.dL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDDPresent) {
      PU_PUSHNAME (pctxt, "dL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD");

      stat = asn1PD_DL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD (pctxt, &pvalue->dL_Timeslot_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_LCR_InformationModify_ModifyList_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationDeleteList_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_CCTrCH_InformationDeleteItem_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_DeleteItem_RL_ReconfRqstTDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_DeleteItem_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DCH_DeleteItem_RL_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteItem_RL_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteItem_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_DeleteList_RL_ReconfRqstTDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_DeleteList_RL_ReconfRqstTDD (ASN1CTXT* pctxt, DCH_DeleteList_RL_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_DeleteItem_RL_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteList_RL_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_DeleteItem_RL_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_DeleteItem_RL_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_DeleteList_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Information_RL_ReconfRqstTDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Information_RL_ReconfRqstTDD (ASN1CTXT* pctxt, RL_Information_RL_ReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Information_RL_ReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minDL_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minDL_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxDL_Power */

   if (pvalue->m.maxDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "maxDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->maxDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode minDL_Power */

   if (pvalue->m.minDL_PowerPresent) {
      PU_PUSHNAME (pctxt, "minDL_Power");

      stat = asn1PD_DL_Power (pctxt, &pvalue->minDL_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Information_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Multiple_RL_Information_RL_ReconfRqstTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Multiple_RL_Information_RL_ReconfRqstTDD (ASN1CTXT* pctxt, Multiple_RL_Information_RL_ReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   RL_Information_RL_ReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_RL_Information_RL_ReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RL_Information_RL_ReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RL_Information_RL_ReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_RL_Information_RL_ReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkReconfigurationResponse                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkReconfigurationResponse (ASN1CTXT* pctxt, RadioLinkReconfigurationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkReconfigurationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponseList_RL_ReconfRsp                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponseList_RL_ReconfRsp (ASN1CTXT* pctxt, RL_InformationResponseList_RL_ReconfRsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseList_RL_ReconfRsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseList_RL_ReconfRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationResponseItem_RL_ReconfRsp                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationResponseItem_RL_ReconfRsp (ASN1CTXT* pctxt, RL_InformationResponseItem_RL_ReconfRsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseItem_RL_ReconfRsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dCH_InformationResponseList_RL_ReconfRspPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dCH_InformationResponseList_RL_ReconfRspPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_InformationResponseList_RL_ReconfRsp */

   if (pvalue->m.dCH_InformationResponseList_RL_ReconfRspPresent) {
      PU_PUSHNAME (pctxt, "dCH_InformationResponseList_RL_ReconfRsp");

      stat = asn1PD_DCH_InformationResponseList_RL_ReconfRsp (pctxt, &pvalue->dCH_InformationResponseList_RL_ReconfRsp);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationResponseItem_RL_ReconfRsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkDeletionRequest                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkDeletionRequest (ASN1CTXT* pctxt, RadioLinkDeletionRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkDeletionRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkDeletionRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_informationList_RL_DeletionRqst                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_informationList_RL_DeletionRqst (ASN1CTXT* pctxt, RL_informationList_RL_DeletionRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_informationList_RL_DeletionRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_informationList_RL_DeletionRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_informationItem_RL_DeletionRqst                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_informationItem_RL_DeletionRqst (ASN1CTXT* pctxt, RL_informationItem_RL_DeletionRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_informationItem_RL_DeletionRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_informationItem_RL_DeletionRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkDeletionResponse                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkDeletionResponse (ASN1CTXT* pctxt, RadioLinkDeletionResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkDeletionResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkDeletionResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_PowerControlRequest                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_PowerControlRequest (ASN1CTXT* pctxt, DL_PowerControlRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerControlRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerControlRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_ReferencePowerInformationList_DL_PC_Rqst               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_ReferencePowerInformationList_DL_PC_Rqst (ASN1CTXT* pctxt, DL_ReferencePowerInformationList_DL_PC_Rqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ReferencePowerInformationList_DL_PC_Rqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ReferencePowerInformationList_DL_PC_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_ReferencePowerInformationItem_DL_PC_Rqst               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_ReferencePowerInformationItem_DL_PC_Rqst (ASN1CTXT* pctxt, DL_ReferencePowerInformationItem_DL_PC_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ReferencePowerInformationItem_DL_PC_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_ReferencePower */

   PU_PUSHNAME (pctxt, "dl_ReferencePower");

   stat = asn1PD_DL_Power (pctxt, &pvalue->dl_ReferencePower);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ReferencePowerInformationItem_DL_PC_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_PowerTimeslotControlRequest                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_PowerTimeslotControlRequest (ASN1CTXT* pctxt, DL_PowerTimeslotControlRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerTimeslotControlRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerTimeslotControlRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementInitiationRequest                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementInitiationRequest (ASN1CTXT* pctxt, DedicatedMeasurementInitiationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementInitiationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementInitiationRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_DM_Rqst                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_DM_Rqst (ASN1CTXT* pctxt, RL_InformationList_DM_Rqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_DM_Rqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_DM_Rqst                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_DM_Rqst (ASN1CTXT* pctxt, RL_DM_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_DM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_InformationList */

   PU_PUSHNAME (pctxt, "rL_InformationList");

   stat = asn1PD_RL_InformationList_DM_Rqst (pctxt, &pvalue->rL_InformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationItem_DM_Rqst                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationItem_DM_Rqst (ASN1CTXT* pctxt, RL_Set_InformationItem_DM_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_DM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationList_DM_Rqst                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationList_DM_Rqst (ASN1CTXT* pctxt, RL_Set_InformationList_DM_Rqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   RL_Set_InformationItem_DM_Rqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_DM_Rqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RL_Set_InformationItem_DM_Rqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RL_Set_InformationItem_DM_Rqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_DM_Rqst                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_DM_Rqst (ASN1CTXT* pctxt, RL_Set_DM_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_DM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_InformationList_DM_Rqst */

   PU_PUSHNAME (pctxt, "rL_Set_InformationList_DM_Rqst");

   stat = asn1PD_RL_Set_InformationList_DM_Rqst (pctxt, &pvalue->rL_Set_InformationList_DM_Rqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementObjectType_DM_Rqst                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementObjectType_DM_Rqst (ASN1CTXT* pctxt, DedicatedMeasurementObjectType_DM_Rqst* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementObjectType_DM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* rL */
         case 0:
            PU_PUSHNAME (pctxt, "u.rL");

            pvalue->u.rL = rtMemAllocTypeZ (pctxt, RL_DM_Rqst);
            if (pvalue->u.rL == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_DM_Rqst (pctxt, pvalue->u.rL);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rLS */
         case 1:
            PU_PUSHNAME (pctxt, "u.rLS");

            pvalue->u.rLS = rtMemAllocTypeZ (pctxt, RL_Set_DM_Rqst);
            if (pvalue->u.rLS == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_Set_DM_Rqst (pctxt, pvalue->u.rLS);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* all_RL */
         case 2:
            PU_PUSHNAME (pctxt, "u.all_RL");

            stat = asn1PD_AllRL_DM_Rqst (pctxt);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* all_RLS */
         case 3:
            PU_PUSHNAME (pctxt, "u.all_RLS");

            stat = asn1PD_AllRL_Set_DM_Rqst (pctxt);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementObjectType_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_DM_Rqst                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_DM_Rqst (ASN1CTXT* pctxt, RL_InformationItem_DM_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_DM_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dPCH_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dPCH_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dPCH_ID */

   if (pvalue->m.dPCH_IDPresent) {
      PU_PUSHNAME (pctxt, "dPCH_ID");

      stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_Info_DM_Rqst                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_Info_DM_Rqst (ASN1CTXT* pctxt, PUSCH_Info_DM_Rqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Info_DM_Rqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (256 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_PUSCH_ID (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Info_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSICH_Info_DM_Rqst                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSICH_Info_DM_Rqst (ASN1CTXT* pctxt, HSSICH_Info_DM_Rqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSICH_Info_DM_Rqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (4 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_HS_SICH_ID (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSICH_Info_DM_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementInitiationResponse                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementInitiationResponse (ASN1CTXT* pctxt, DedicatedMeasurementInitiationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementInitiationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementInitiationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_DM_Rsp                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_DM_Rsp (ASN1CTXT* pctxt, RL_InformationList_DM_Rsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_DM_Rsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_DM_Rsp                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_DM_Rsp (ASN1CTXT* pctxt, RL_DM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_DM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_InformationList_DM_Rsp */

   PU_PUSHNAME (pctxt, "rL_InformationList_DM_Rsp");

   stat = asn1PD_RL_InformationList_DM_Rsp (pctxt, &pvalue->rL_InformationList_DM_Rsp);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationList_DM_Rsp                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationList_DM_Rsp (ASN1CTXT* pctxt, RL_Set_InformationList_DM_Rsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_DM_Rsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_DM_Rsp                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_DM_Rsp (ASN1CTXT* pctxt, RL_Set_DM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_DM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_InformationList_DM_Rsp */

   PU_PUSHNAME (pctxt, "rL_Set_InformationList_DM_Rsp");

   stat = asn1PD_RL_Set_InformationList_DM_Rsp (pctxt, &pvalue->rL_Set_InformationList_DM_Rsp);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementObjectType_DM_Rsp                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementObjectType_DM_Rsp (ASN1CTXT* pctxt, DedicatedMeasurementObjectType_DM_Rsp* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementObjectType_DM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* rL */
         case 0:
            PU_PUSHNAME (pctxt, "u.rL");

            pvalue->u.rL = rtMemAllocTypeZ (pctxt, RL_DM_Rsp);
            if (pvalue->u.rL == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_DM_Rsp (pctxt, pvalue->u.rL);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rLS */
         case 1:
            PU_PUSHNAME (pctxt, "u.rLS");

            pvalue->u.rLS = rtMemAllocTypeZ (pctxt, RL_Set_DM_Rsp);
            if (pvalue->u.rLS == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_Set_DM_Rsp (pctxt, pvalue->u.rLS);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* all_RL */
         case 2:
            PU_PUSHNAME (pctxt, "u.all_RL");

            pvalue->u.all_RL = rtMemAllocTypeZ (pctxt, RL_DM_Rsp);
            if (pvalue->u.all_RL == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_DM_Rsp (pctxt, pvalue->u.all_RL);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* all_RLS */
         case 3:
            PU_PUSHNAME (pctxt, "u.all_RLS");

            pvalue->u.all_RLS = rtMemAllocTypeZ (pctxt, RL_Set_DM_Rsp);
            if (pvalue->u.all_RLS == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_Set_DM_Rsp (pctxt, pvalue->u.all_RLS);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementObjectType_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_DM_Rsp                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_DM_Rsp (ASN1CTXT* pctxt, RL_InformationItem_DM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_DM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dPCH_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dPCH_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cFNPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cFNPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dPCH_ID */

   if (pvalue->m.dPCH_IDPresent) {
      PU_PUSHNAME (pctxt, "dPCH_ID");

      stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dedicatedMeasurementValue */

   PU_PUSHNAME (pctxt, "dedicatedMeasurementValue");

   stat = asn1PD_DedicatedMeasurementValue (pctxt, &pvalue->dedicatedMeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cFN */

   if (pvalue->m.cFNPresent) {
      PU_PUSHNAME (pctxt, "cFN");

      stat = asn1PD_CFN (pctxt, &pvalue->cFN);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_Info_DM_Rsp                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_Info_DM_Rsp (ASN1CTXT* pctxt, PUSCH_Info_DM_Rsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Info_DM_Rsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (256 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_PUSCH_ID (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Info_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationItem_DM_Rsp                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationItem_DM_Rsp (ASN1CTXT* pctxt, RL_Set_InformationItem_DM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_DM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "cFNPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cFNPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dedicatedMeasurementValue */

   PU_PUSHNAME (pctxt, "dedicatedMeasurementValue");

   stat = asn1PD_DedicatedMeasurementValue (pctxt, &pvalue->dedicatedMeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cFN */

   if (pvalue->m.cFNPresent) {
      PU_PUSHNAME (pctxt, "cFN");

      stat = asn1PD_CFN (pctxt, &pvalue->cFN);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Multiple_DedicatedMeasurementValueItem_TDD_DM_Rsp         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Multiple_DedicatedMeasurementValueItem_TDD_DM_Rsp (ASN1CTXT* pctxt, Multiple_DedicatedMeasurementValueItem_TDD_DM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_DedicatedMeasurementValueItem_TDD_DM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dedicatedMeasurementValue */

   PU_PUSHNAME (pctxt, "dedicatedMeasurementValue");

   stat = asn1PD_DedicatedMeasurementValue (pctxt, &pvalue->dedicatedMeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_DedicatedMeasurementValueItem_TDD_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Multiple_DedicatedMeasurementValueList_TDD_DM_Rsp         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Multiple_DedicatedMeasurementValueList_TDD_DM_Rsp (ASN1CTXT* pctxt, Multiple_DedicatedMeasurementValueList_TDD_DM_Rsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(239), 0 };
   int stat = 0;
   Multiple_DedicatedMeasurementValueItem_TDD_DM_Rsp* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_DedicatedMeasurementValueList_TDD_DM_Rsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Multiple_DedicatedMeasurementValueItem_TDD_DM_Rsp);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Multiple_DedicatedMeasurementValueItem_TDD_DM_Rsp (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_DedicatedMeasurementValueList_TDD_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Multiple_DedicatedMeasurementValueItem_LCR_TDD_DM_Rsp     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Multiple_DedicatedMeasurementValueItem_LCR_TDD_DM_Rsp (ASN1CTXT* pctxt, Multiple_DedicatedMeasurementValueItem_LCR_TDD_DM_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_DedicatedMeasurementValueItem_LCR_TDD_DM_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dedicatedMeasurementValue */

   PU_PUSHNAME (pctxt, "dedicatedMeasurementValue");

   stat = asn1PD_DedicatedMeasurementValue (pctxt, &pvalue->dedicatedMeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_DedicatedMeasurementValueItem_LCR_TDD_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Multiple_DedicatedMeasurementValueList_LCR_TDD_DM_Rsp     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Multiple_DedicatedMeasurementValueList_LCR_TDD_DM_Rsp (ASN1CTXT* pctxt, Multiple_DedicatedMeasurementValueList_LCR_TDD_DM_Rsp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(95), 0 };
   int stat = 0;
   Multiple_DedicatedMeasurementValueItem_LCR_TDD_DM_Rsp* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_DedicatedMeasurementValueList_LCR_TDD_DM_Rsp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Multiple_DedicatedMeasurementValueItem_LCR_TDD_DM_Rsp);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Multiple_DedicatedMeasurementValueItem_LCR_TDD_DM_Rsp (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Multiple_DedicatedMeasurementValueList_LCR_TDD_DM_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementInitiationFailure                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementInitiationFailure (ASN1CTXT* pctxt, DedicatedMeasurementInitiationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementInitiationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementInitiationFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementReport                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementReport (ASN1CTXT* pctxt, DedicatedMeasurementReport* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementReport: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_DM_Rprt                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_DM_Rprt (ASN1CTXT* pctxt, RL_InformationList_DM_Rprt* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_DM_Rprt: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_DM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_DM_Rprt                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_DM_Rprt (ASN1CTXT* pctxt, RL_DM_Rprt* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_DM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_InformationList_DM_Rprt */

   PU_PUSHNAME (pctxt, "rL_InformationList_DM_Rprt");

   stat = asn1PD_RL_InformationList_DM_Rprt (pctxt, &pvalue->rL_InformationList_DM_Rprt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_DM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationList_DM_Rprt                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationList_DM_Rprt (ASN1CTXT* pctxt, RL_Set_InformationList_DM_Rprt* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_DM_Rprt: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_DM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_DM_Rprt                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_DM_Rprt (ASN1CTXT* pctxt, RL_Set_DM_Rprt* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_DM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_InformationList_DM_Rprt */

   PU_PUSHNAME (pctxt, "rL_Set_InformationList_DM_Rprt");

   stat = asn1PD_RL_Set_InformationList_DM_Rprt (pctxt, &pvalue->rL_Set_InformationList_DM_Rprt);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_DM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementObjectType_DM_Rprt                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementObjectType_DM_Rprt (ASN1CTXT* pctxt, DedicatedMeasurementObjectType_DM_Rprt* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementObjectType_DM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* rL */
         case 0:
            PU_PUSHNAME (pctxt, "u.rL");

            pvalue->u.rL = rtMemAllocTypeZ (pctxt, RL_DM_Rprt);
            if (pvalue->u.rL == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_DM_Rprt (pctxt, pvalue->u.rL);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rLS */
         case 1:
            PU_PUSHNAME (pctxt, "u.rLS");

            pvalue->u.rLS = rtMemAllocTypeZ (pctxt, RL_Set_DM_Rprt);
            if (pvalue->u.rLS == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_Set_DM_Rprt (pctxt, pvalue->u.rLS);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* all_RL */
         case 2:
            PU_PUSHNAME (pctxt, "u.all_RL");

            pvalue->u.all_RL = rtMemAllocTypeZ (pctxt, RL_DM_Rprt);
            if (pvalue->u.all_RL == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_DM_Rprt (pctxt, pvalue->u.all_RL);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* all_RLS */
         case 3:
            PU_PUSHNAME (pctxt, "u.all_RLS");

            pvalue->u.all_RLS = rtMemAllocTypeZ (pctxt, RL_Set_DM_Rprt);
            if (pvalue->u.all_RLS == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_Set_DM_Rprt (pctxt, pvalue->u.all_RLS);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementObjectType_DM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_DM_Rprt                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_DM_Rprt (ASN1CTXT* pctxt, RL_InformationItem_DM_Rprt* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_DM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dPCH_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dPCH_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dPCH_ID */

   if (pvalue->m.dPCH_IDPresent) {
      PU_PUSHNAME (pctxt, "dPCH_ID");

      stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dedicatedMeasurementValueInformation */

   PU_PUSHNAME (pctxt, "dedicatedMeasurementValueInformation");

   stat = asn1PD_DedicatedMeasurementValueInformation (pctxt, &pvalue->dedicatedMeasurementValueInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_DM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_Info_DM_Rprt                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_Info_DM_Rprt (ASN1CTXT* pctxt, PUSCH_Info_DM_Rprt* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(256), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Info_DM_Rprt: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (256 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_PUSCH_ID (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Info_DM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationItem_DM_Rprt                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationItem_DM_Rprt (ASN1CTXT* pctxt, RL_Set_InformationItem_DM_Rprt* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_DM_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dedicatedMeasurementValueInformation */

   PU_PUSHNAME (pctxt, "dedicatedMeasurementValueInformation");

   stat = asn1PD_DedicatedMeasurementValueInformation (pctxt, &pvalue->dedicatedMeasurementValueInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_DM_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementTerminationRequest                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementTerminationRequest (ASN1CTXT* pctxt, DedicatedMeasurementTerminationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementTerminationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementTerminationRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementFailureIndication                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementFailureIndication (ASN1CTXT* pctxt, DedicatedMeasurementFailureIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementFailureIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkFailureIndication                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkFailureIndication (ASN1CTXT* pctxt, RadioLinkFailureIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkFailureIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_RL_FailureInd                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_RL_FailureInd (ASN1CTXT* pctxt, RL_InformationList_RL_FailureInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_FailureInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_RL_FailureInd                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_RL_FailureInd (ASN1CTXT* pctxt, RL_RL_FailureInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_RL_FailureInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_InformationList_RL_FailureInd */

   PU_PUSHNAME (pctxt, "rL_InformationList_RL_FailureInd");

   stat = asn1PD_RL_InformationList_RL_FailureInd (pctxt, &pvalue->rL_InformationList_RL_FailureInd);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationList_RL_FailureInd                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationList_RL_FailureInd (ASN1CTXT* pctxt, RL_Set_InformationList_RL_FailureInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_RL_FailureInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_RL_FailureInd                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_RL_FailureInd (ASN1CTXT* pctxt, RL_Set_RL_FailureInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_RL_FailureInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_InformationList_RL_FailureInd */

   PU_PUSHNAME (pctxt, "rL_Set_InformationList_RL_FailureInd");

   stat = asn1PD_RL_Set_InformationList_RL_FailureInd (pctxt, &pvalue->rL_Set_InformationList_RL_FailureInd);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_InformationList_RL_FailureInd                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_InformationList_RL_FailureInd (ASN1CTXT* pctxt, CCTrCH_InformationList_RL_FailureInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_InformationList_RL_FailureInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_InformationList_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_RL_FailureInd                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_RL_FailureInd (ASN1CTXT* pctxt, CCTrCH_RL_FailureInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_RL_FailureInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cCTrCH_InformationList_RL_FailureInd */

   PU_PUSHNAME (pctxt, "cCTrCH_InformationList_RL_FailureInd");

   stat = asn1PD_CCTrCH_InformationList_RL_FailureInd (pctxt, &pvalue->cCTrCH_InformationList_RL_FailureInd);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reporting_Object_RL_FailureInd                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reporting_Object_RL_FailureInd (ASN1CTXT* pctxt, Reporting_Object_RL_FailureInd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_Reporting_Object_RL_FailureInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* rL */
         case 0:
            PU_PUSHNAME (pctxt, "u.rL");

            pvalue->u.rL = rtMemAllocTypeZ (pctxt, RL_RL_FailureInd);
            if (pvalue->u.rL == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_RL_FailureInd (pctxt, pvalue->u.rL);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rL_Set */
         case 1:
            PU_PUSHNAME (pctxt, "u.rL_Set");

            pvalue->u.rL_Set = rtMemAllocTypeZ (pctxt, RL_Set_RL_FailureInd);
            if (pvalue->u.rL_Set == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_Set_RL_FailureInd (pctxt, pvalue->u.rL_Set);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* cCTrCH */
         case 3:
            PU_PUSHNAME (pctxt, "u.cCTrCH");

            pvalue->u.cCTrCH = rtMemAllocTypeZ (pctxt, CCTrCH_RL_FailureInd);
            if (pvalue->u.cCTrCH == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CCTrCH_RL_FailureInd (pctxt, pvalue->u.cCTrCH);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Reporting_Object_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_RL_FailureInd                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_RL_FailureInd (ASN1CTXT* pctxt, RL_InformationItem_RL_FailureInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_FailureInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationItem_RL_FailureInd                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationItem_RL_FailureInd (ASN1CTXT* pctxt, RL_Set_InformationItem_RL_FailureInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_RL_FailureInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_InformationItem_RL_FailureInd                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_InformationItem_RL_FailureInd (ASN1CTXT* pctxt, CCTrCH_InformationItem_RL_FailureInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_InformationItem_RL_FailureInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_InformationItem_RL_FailureInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkPreemptionRequiredIndication                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkPreemptionRequiredIndication (ASN1CTXT* pctxt, RadioLinkPreemptionRequiredIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkPreemptionRequiredIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkPreemptionRequiredIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_RL_PreemptRequiredInd                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_RL_PreemptRequiredInd (ASN1CTXT* pctxt, RL_InformationList_RL_PreemptRequiredInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_PreemptRequiredInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_PreemptRequiredInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_RL_PreemptRequiredInd                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_RL_PreemptRequiredInd (ASN1CTXT* pctxt, RL_InformationItem_RL_PreemptRequiredInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_PreemptRequiredInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_PreemptRequiredInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkRestoreIndication                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkRestoreIndication (ASN1CTXT* pctxt, RadioLinkRestoreIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkRestoreIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkRestoreIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationList_RL_RestoreInd                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationList_RL_RestoreInd (ASN1CTXT* pctxt, RL_InformationList_RL_RestoreInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_RestoreInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationList_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_RL_RestoreInd                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_RL_RestoreInd (ASN1CTXT* pctxt, RL_RL_RestoreInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_RL_RestoreInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_InformationList_RL_RestoreInd */

   PU_PUSHNAME (pctxt, "rL_InformationList_RL_RestoreInd");

   stat = asn1PD_RL_InformationList_RL_RestoreInd (pctxt, &pvalue->rL_InformationList_RL_RestoreInd);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationList_RL_RestoreInd                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationList_RL_RestoreInd (ASN1CTXT* pctxt, RL_Set_InformationList_RL_RestoreInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_RL_RestoreInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationList_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_RL_RestoreInd                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_RL_RestoreInd (ASN1CTXT* pctxt, RL_Set_RL_RestoreInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_RL_RestoreInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_InformationList_RL_RestoreInd */

   PU_PUSHNAME (pctxt, "rL_Set_InformationList_RL_RestoreInd");

   stat = asn1PD_RL_Set_InformationList_RL_RestoreInd (pctxt, &pvalue->rL_Set_InformationList_RL_RestoreInd);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_InformationList_RL_RestoreInd                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_InformationList_RL_RestoreInd (ASN1CTXT* pctxt, CCTrCH_InformationList_RL_RestoreInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_InformationList_RL_RestoreInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_InformationList_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_RL_RestoreInd                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_RL_RestoreInd (ASN1CTXT* pctxt, CCTrCH_RL_RestoreInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_RL_RestoreInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cCTrCH_InformationList_RL_RestoreInd */

   PU_PUSHNAME (pctxt, "cCTrCH_InformationList_RL_RestoreInd");

   stat = asn1PD_CCTrCH_InformationList_RL_RestoreInd (pctxt, &pvalue->cCTrCH_InformationList_RL_RestoreInd);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reporting_Object_RL_RestoreInd                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reporting_Object_RL_RestoreInd (ASN1CTXT* pctxt, Reporting_Object_RL_RestoreInd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_Reporting_Object_RL_RestoreInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* rL */
         case 0:
            PU_PUSHNAME (pctxt, "u.rL");

            pvalue->u.rL = rtMemAllocTypeZ (pctxt, RL_RL_RestoreInd);
            if (pvalue->u.rL == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_RL_RestoreInd (pctxt, pvalue->u.rL);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rL_Set */
         case 1:
            PU_PUSHNAME (pctxt, "u.rL_Set");

            pvalue->u.rL_Set = rtMemAllocTypeZ (pctxt, RL_Set_RL_RestoreInd);
            if (pvalue->u.rL_Set == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_RL_Set_RL_RestoreInd (pctxt, pvalue->u.rL_Set);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* cCTrCH */
         case 3:
            PU_PUSHNAME (pctxt, "u.cCTrCH");

            pvalue->u.cCTrCH = rtMemAllocTypeZ (pctxt, CCTrCH_RL_RestoreInd);
            if (pvalue->u.cCTrCH == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CCTrCH_RL_RestoreInd (pctxt, pvalue->u.cCTrCH);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Reporting_Object_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_InformationItem_RL_RestoreInd                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_InformationItem_RL_RestoreInd (ASN1CTXT* pctxt, RL_InformationItem_RL_RestoreInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_RestoreInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_InformationItem_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_InformationItem_RL_RestoreInd                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_InformationItem_RL_RestoreInd (ASN1CTXT* pctxt, RL_Set_InformationItem_RL_RestoreInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_RL_RestoreInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_Set_ID */

   PU_PUSHNAME (pctxt, "rL_Set_ID");

   stat = asn1PD_RL_Set_ID (pctxt, &pvalue->rL_Set_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_InformationItem_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_InformationItem_RL_RestoreInd                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_InformationItem_RL_RestoreInd (ASN1CTXT* pctxt, CCTrCH_InformationItem_RL_RestoreInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_InformationItem_RL_RestoreInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_InformationItem_RL_RestoreInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompressedModeCommand                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CompressedModeCommand (ASN1CTXT* pctxt, CompressedModeCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompressedModeCommand: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompressedModeCommand: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ErrorIndication (ASN1CTXT* pctxt, ErrorIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrivateMessage (ASN1CTXT* pctxt, PrivateMessage* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtDListInit (&pvalue->extElem1);

   /* decode privateIEs */

   PU_PUSHNAME (pctxt, "privateIEs");

   stat = asn1PD_PrivateIE_Container (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalSharedChannelReconfigurationRequestFDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PhysicalSharedChannelReconfigurationRequestFDD (ASN1CTXT* pctxt, PhysicalSharedChannelReconfigurationRequestFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PhysicalSharedChannelReconfigurationRequestFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PhysicalSharedChannelReconfigurationRequestFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDPA_CellPortion_InformationList_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDPA_CellPortion_InformationList_PSCH_ReconfRqst (ASN1CTXT* pctxt, HSDPA_CellPortion_InformationList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDPA_CellPortion_InformationList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDPA_CellPortion_InformationList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDPA_CellPortion_InformationItem_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDPA_CellPortion_InformationItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, HSDPA_CellPortion_InformationItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDPA_CellPortion_InformationItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hS_PDSCH_HS_SCCH_ScramblingCode_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_PDSCH_HS_SCCH_ScramblingCode_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_PDSCH_FDD_Code_Information_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_PDSCH_FDD_Code_Information_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_SCCH_FDD_Code_Information_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SCCH_FDD_Code_Information_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PD_CellPortionID (pctxt, &pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_PDSCH_HS_SCCH_ScramblingCode_PSCH_ReconfRqst */

   if (pvalue->m.hS_PDSCH_HS_SCCH_ScramblingCode_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "hS_PDSCH_HS_SCCH_ScramblingCode_PSCH_ReconfRqst");

      stat = asn1PD_DL_ScramblingCode (pctxt, &pvalue->hS_PDSCH_HS_SCCH_ScramblingCode_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hS_PDSCH_FDD_Code_Information_PSCH_ReconfRqst */

   if (pvalue->m.hS_PDSCH_FDD_Code_Information_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "hS_PDSCH_FDD_Code_Information_PSCH_ReconfRqst");

      stat = asn1PD_HS_PDSCH_FDD_Code_Information (pctxt, &pvalue->hS_PDSCH_FDD_Code_Information_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hS_SCCH_FDD_Code_Information_PSCH_ReconfRqst */

   if (pvalue->m.hS_SCCH_FDD_Code_Information_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "hS_SCCH_FDD_Code_Information_PSCH_ReconfRqst");

      stat = asn1PD_HS_SCCH_FDD_Code_Information (pctxt, &pvalue->hS_SCCH_FDD_Code_Information_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDPA_CellPortion_InformationItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalSharedChannelReconfigurationRequestTDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PhysicalSharedChannelReconfigurationRequestTDD (ASN1CTXT* pctxt, PhysicalSharedChannelReconfigurationRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PhysicalSharedChannelReconfigurationRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PhysicalSharedChannelReconfigurationRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCHSets_AddItem_PSCH_ReconfRqst                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCHSets_AddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCHSets_AddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_AddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "pDSCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pDSCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pDSCHSet_ID */

   PU_PUSHNAME (pctxt, "pDSCHSet_ID");

   stat = asn1PD_PDSCHSet_ID (pctxt, &pvalue->pDSCHSet_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pDSCH_InformationList */

   if (pvalue->m.pDSCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "pDSCH_InformationList");

      stat = asn1PD_PDSCH_Information_AddList_PSCH_ReconfRqst (pctxt, &pvalue->pDSCH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_AddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCHSets_AddList_PSCH_ReconfRqst                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCHSets_AddList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCHSets_AddList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   PDSCHSets_AddItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_AddList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PDSCHSets_AddItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PDSCHSets_AddItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_AddList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_InformationAddItem_PSCH_ReconfRqst                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_InformationAddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Code_InformationAddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationAddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pDSCH_ID */

   PU_PUSHNAME (pctxt, "pDSCH_ID");

   stat = asn1PD_PDSCH_ID (pctxt, &pvalue->pDSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationAddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_InformationAddList_PSCH_ReconfRqst                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_InformationAddList_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Code_InformationAddList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   DL_Code_InformationAddItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationAddList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Code_InformationAddItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Code_InformationAddItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationAddList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationAddItem_PSCH_ReconfRqst            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationAddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Timeslot_InformationAddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationAddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Code_InformationAddList_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "dL_Code_InformationAddList_PSCH_ReconfRqst");

   stat = asn1PD_DL_Code_InformationAddList_PSCH_ReconfRqst (pctxt, &pvalue->dL_Code_InformationAddList_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationAddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationAddList_PSCH_ReconfRqst            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationAddList_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Timeslot_InformationAddList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   DL_Timeslot_InformationAddItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationAddList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Timeslot_InformationAddItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Timeslot_InformationAddItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationAddList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCH_Information_AddItem_PSCH_ReconfRqst                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCH_Information_AddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCH_Information_AddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_Information_AddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Timeslot_InformationAddList_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "dL_Timeslot_InformationAddList_PSCH_ReconfRqst");

   stat = asn1PD_DL_Timeslot_InformationAddList_PSCH_ReconfRqst (pctxt, &pvalue->dL_Timeslot_InformationAddList_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_Information_AddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_InformationAddItem_LCR_PSCH_ReconfRqst            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_InformationAddItem_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Code_InformationAddItem_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationAddItem_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pDSCH_ID */

   PU_PUSHNAME (pctxt, "pDSCH_ID");

   stat = asn1PD_PDSCH_ID (pctxt, &pvalue->pDSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationAddItem_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_InformationAddList_LCR_PSCH_ReconfRqst            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_InformationAddList_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Code_InformationAddList_LCR_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   DL_Code_InformationAddItem_LCR_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationAddList_LCR_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Code_InformationAddItem_LCR_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Code_InformationAddItem_LCR_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationAddList_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Code_InformationAddList_LCR_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "dL_Code_InformationAddList_LCR_PSCH_ReconfRqst");

   stat = asn1PD_DL_Code_InformationAddList_LCR_PSCH_ReconfRqst (pctxt, &pvalue->dL_Code_InformationAddList_LCR_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   DL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "dL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst");

   stat = asn1PD_DL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst (pctxt, &pvalue->dL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCHSets_ModifyItem_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCHSets_ModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCHSets_ModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_ModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pDSCHSet_ID */

   PU_PUSHNAME (pctxt, "pDSCHSet_ID");

   stat = asn1PD_PDSCHSet_ID (pctxt, &pvalue->pDSCHSet_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pDSCH_InformationList */

   PU_PUSHNAME (pctxt, "pDSCH_InformationList");

   stat = asn1PD_PDSCH_Information_ModifyList_PSCH_ReconfRqst (pctxt, &pvalue->pDSCH_InformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_ModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCHSets_ModifyList_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCHSets_ModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCHSets_ModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   PDSCHSets_ModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_ModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PDSCHSets_ModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PDSCHSets_ModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_ModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_InformationModifyItem_PSCH_ReconfRqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Code_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pDSCH_ID */

   PU_PUSHNAME (pctxt, "pDSCH_ID");

   stat = asn1PD_PDSCH_ID (pctxt, &pvalue->pDSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_InformationModifyList_PSCH_ReconfRqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_InformationModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Code_InformationModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   DL_Code_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Code_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Code_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_InformationModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationModifyItem_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Timeslot_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftAndBurstTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftAndBurstTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_Code_InformationModifyList_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_Code_InformationModifyList_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   if (pvalue->m.midambleShiftAndBurstTypePresent) {
      PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

      stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_Code_InformationModifyList_PSCH_ReconfRqst */

   if (pvalue->m.dL_Code_InformationModifyList_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "dL_Code_InformationModifyList_PSCH_ReconfRqst");

      stat = asn1PD_DL_Code_InformationModifyList_PSCH_ReconfRqst (pctxt, &pvalue->dL_Code_InformationModifyList_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationModifyList_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Timeslot_InformationModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   DL_Timeslot_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Timeslot_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Timeslot_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCH_Information_ModifyItem_PSCH_ReconfRqst              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCH_Information_ModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCH_Information_ModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_Information_ModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "repetitionPeriodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionPeriodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "repetitionLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_PhysicalChannelOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_PhysicalChannelOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_Timeslot_InformationModifyList_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_Timeslot_InformationModifyList_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   if (pvalue->m.repetitionPeriodPresent) {
      PU_PUSHNAME (pctxt, "repetitionPeriod");

      stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode repetitionLength */

   if (pvalue->m.repetitionLengthPresent) {
      PU_PUSHNAME (pctxt, "repetitionLength");

      stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_PhysicalChannelOffset */

   if (pvalue->m.tdd_PhysicalChannelOffsetPresent) {
      PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

      stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_Timeslot_InformationModifyList_PSCH_ReconfRqst */

   if (pvalue->m.dL_Timeslot_InformationModifyList_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "dL_Timeslot_InformationModifyList_PSCH_ReconfRqst");

      stat = asn1PD_DL_Timeslot_InformationModifyList_PSCH_ReconfRqst (pctxt, &pvalue->dL_Timeslot_InformationModifyList_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_Information_ModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pDSCH_ID */

   PU_PUSHNAME (pctxt, "pDSCH_ID");

   stat = asn1PD_PDSCH_ID (pctxt, &pvalue->pDSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Code_LCR_InformationModifyList_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Code_LCR_InformationModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Code_LCR_InformationModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   DL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_LCR_InformationModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Code_LCR_InformationModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_Code_LCR_InformationModifyList_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_Code_LCR_InformationModifyList_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   if (pvalue->m.midambleShiftLCRPresent) {
      PU_PUSHNAME (pctxt, "midambleShiftLCR");

      stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_Code_LCR_InformationModifyList_PSCH_ReconfRqst */

   if (pvalue->m.dL_Code_LCR_InformationModifyList_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "dL_Code_LCR_InformationModifyList_PSCH_ReconfRqst");

      stat = asn1PD_DL_Code_LCR_InformationModifyList_PSCH_ReconfRqst (pctxt, &pvalue->dL_Code_LCR_InformationModifyList_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   DL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "repetitionPeriodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionPeriodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "repetitionLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_PhysicalChannelOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_PhysicalChannelOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   if (pvalue->m.repetitionPeriodPresent) {
      PU_PUSHNAME (pctxt, "repetitionPeriod");

      stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode repetitionLength */

   if (pvalue->m.repetitionLengthPresent) {
      PU_PUSHNAME (pctxt, "repetitionLength");

      stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_PhysicalChannelOffset */

   if (pvalue->m.tdd_PhysicalChannelOffsetPresent) {
      PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

      stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst */

   if (pvalue->m.dL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "dL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst");

      stat = asn1PD_DL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst (pctxt, &pvalue->dL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCHSets_DeleteItem_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCHSets_DeleteItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCHSets_DeleteItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_DeleteItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pDSCHSet_ID */

   PU_PUSHNAME (pctxt, "pDSCHSet_ID");

   stat = asn1PD_PDSCHSet_ID (pctxt, &pvalue->pDSCHSet_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_DeleteItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCHSets_DeleteList_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCHSets_DeleteList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PDSCHSets_DeleteList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   PDSCHSets_DeleteItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_DeleteList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PDSCHSets_DeleteItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PDSCHSets_DeleteItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSets_DeleteList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCHSets_AddItem_PSCH_ReconfRqst                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCHSets_AddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCHSets_AddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_AddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "pUSCH_InformationListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pUSCH_InformationListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pUSCHSet_ID */

   PU_PUSHNAME (pctxt, "pUSCHSet_ID");

   stat = asn1PD_PUSCHSet_ID (pctxt, &pvalue->pUSCHSet_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pUSCH_InformationList */

   if (pvalue->m.pUSCH_InformationListPresent) {
      PU_PUSHNAME (pctxt, "pUSCH_InformationList");

      stat = asn1PD_PUSCH_Information_AddList_PSCH_ReconfRqst (pctxt, &pvalue->pUSCH_InformationList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_AddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCHSets_AddList_PSCH_ReconfRqst                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCHSets_AddList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCHSets_AddList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   PUSCHSets_AddItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_AddList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PUSCHSets_AddItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PUSCHSets_AddItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_AddList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationAddItem_PSCH_ReconfRqst                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationAddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Code_InformationAddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationAddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pUSCH_ID */

   PU_PUSHNAME (pctxt, "pUSCH_ID");

   stat = asn1PD_PUSCH_ID (pctxt, &pvalue->pUSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationAddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationAddList_PSCH_ReconfRqst                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationAddList_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Code_InformationAddList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   UL_Code_InformationAddItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationAddList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Code_InformationAddItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Code_InformationAddItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationAddList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationAddItem_PSCH_ReconfRqst            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationAddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Timeslot_InformationAddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationAddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Code_InformationAddList_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "uL_Code_InformationAddList_PSCH_ReconfRqst");

   stat = asn1PD_UL_Code_InformationAddList_PSCH_ReconfRqst (pctxt, &pvalue->uL_Code_InformationAddList_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationAddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationAddList_PSCH_ReconfRqst            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationAddList_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Timeslot_InformationAddList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   UL_Timeslot_InformationAddItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationAddList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Timeslot_InformationAddItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Timeslot_InformationAddItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationAddList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_Information_AddItem_PSCH_ReconfRqst                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_Information_AddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCH_Information_AddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Information_AddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Timeslot_InformationAddList_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "uL_Timeslot_InformationAddList_PSCH_ReconfRqst");

   stat = asn1PD_UL_Timeslot_InformationAddList_PSCH_ReconfRqst (pctxt, &pvalue->uL_Timeslot_InformationAddList_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Information_AddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationAddItem_LCR_PSCH_ReconfRqst            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationAddItem_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Code_InformationAddItem_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationAddItem_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pUSCH_ID */

   PU_PUSHNAME (pctxt, "pUSCH_ID");

   stat = asn1PD_PUSCH_ID (pctxt, &pvalue->pUSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationAddItem_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationAddList_LCR_PSCH_ReconfRqst            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationAddList_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Code_InformationAddList_LCR_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   UL_Code_InformationAddItem_LCR_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationAddList_LCR_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Code_InformationAddItem_LCR_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Code_InformationAddItem_LCR_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationAddList_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Code_InformationAddList_LCR_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "uL_Code_InformationAddList_LCR_PSCH_ReconfRqst");

   stat = asn1PD_UL_Code_InformationAddList_LCR_PSCH_ReconfRqst (pctxt, &pvalue->uL_Code_InformationAddList_LCR_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   UL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Timeslot_InformationAddItem_LCR_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   PU_PUSHNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionLength */

   PU_PUSHNAME (pctxt, "repetitionLength");

   stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_PhysicalChannelOffset */

   PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

   stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "uL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst");

   stat = asn1PD_UL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst (pctxt, &pvalue->uL_Timeslot_InformationAddList_LCR_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_AddInformation_LCR_AddItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCHSets_ModifyItem_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCHSets_ModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCHSets_ModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_ModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pUSCHSet_ID */

   PU_PUSHNAME (pctxt, "pUSCHSet_ID");

   stat = asn1PD_PUSCHSet_ID (pctxt, &pvalue->pUSCHSet_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pUSCH_InformationList */

   PU_PUSHNAME (pctxt, "pUSCH_InformationList");

   stat = asn1PD_PUSCH_Information_ModifyList_PSCH_ReconfRqst (pctxt, &pvalue->pUSCH_InformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_ModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCHSets_ModifyList_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCHSets_ModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCHSets_ModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   PUSCHSets_ModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_ModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PUSCHSets_ModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PUSCHSets_ModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_ModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationModifyItem_PSCH_ReconfRqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Code_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pUSCH_ID */

   PU_PUSHNAME (pctxt, "pUSCH_ID");

   stat = asn1PD_PUSCH_ID (pctxt, &pvalue->pUSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_InformationModifyList_PSCH_ReconfRqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_InformationModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Code_InformationModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   UL_Code_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Code_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Code_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_InformationModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationModifyItem_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Timeslot_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftAndBurstTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftAndBurstTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uL_Code_InformationModifyList_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_Code_InformationModifyList_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   if (pvalue->m.midambleShiftAndBurstTypePresent) {
      PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

      stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uL_Code_InformationModifyList_PSCH_ReconfRqst */

   if (pvalue->m.uL_Code_InformationModifyList_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "uL_Code_InformationModifyList_PSCH_ReconfRqst");

      stat = asn1PD_UL_Code_InformationModifyList_PSCH_ReconfRqst (pctxt, &pvalue->uL_Code_InformationModifyList_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationModifyList_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Timeslot_InformationModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   UL_Timeslot_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Timeslot_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Timeslot_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_Information_ModifyItem_PSCH_ReconfRqst              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_Information_ModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCH_Information_ModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Information_ModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "repetitionPeriodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionPeriodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "repetitionLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_PhysicalChannelOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_PhysicalChannelOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uL_Timeslot_InformationModifyList_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_Timeslot_InformationModifyList_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   if (pvalue->m.repetitionPeriodPresent) {
      PU_PUSHNAME (pctxt, "repetitionPeriod");

      stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode repetitionLength */

   if (pvalue->m.repetitionLengthPresent) {
      PU_PUSHNAME (pctxt, "repetitionLength");

      stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_PhysicalChannelOffset */

   if (pvalue->m.tdd_PhysicalChannelOffsetPresent) {
      PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

      stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uL_Timeslot_InformationModifyList_PSCH_ReconfRqst */

   if (pvalue->m.uL_Timeslot_InformationModifyList_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "uL_Timeslot_InformationModifyList_PSCH_ReconfRqst");

      stat = asn1PD_UL_Timeslot_InformationModifyList_PSCH_ReconfRqst (pctxt, &pvalue->uL_Timeslot_InformationModifyList_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_Information_ModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pUSCH_ID */

   PU_PUSHNAME (pctxt, "pUSCH_ID");

   stat = asn1PD_PUSCH_ID (pctxt, &pvalue->pUSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Code_LCR_InformationModifyList_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Code_LCR_InformationModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Code_LCR_InformationModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   UL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_LCR_InformationModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Code_LCR_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Code_LCR_InformationModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tFCI_PresencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFCI_PresencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uL_Code_LCR_InformationModifyList_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_Code_LCR_InformationModifyList_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   if (pvalue->m.midambleShiftLCRPresent) {
      PU_PUSHNAME (pctxt, "midambleShiftLCR");

      stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tFCI_Presence */

   if (pvalue->m.tFCI_PresencePresent) {
      PU_PUSHNAME (pctxt, "tFCI_Presence");

      stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uL_Code_LCR_InformationModifyList_PSCH_ReconfRqst */

   if (pvalue->m.uL_Code_LCR_InformationModifyList_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "uL_Code_LCR_InformationModifyList_PSCH_ReconfRqst");

      stat = asn1PD_UL_Code_LCR_InformationModifyList_PSCH_ReconfRqst (pctxt, &pvalue->uL_Code_LCR_InformationModifyList_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst (ASN1CTXT* pctxt, UL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   UL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Timeslot_LCR_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "repetitionPeriodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionPeriodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "repetitionLengthPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionLengthPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_PhysicalChannelOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_PhysicalChannelOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uL_Timeslot_InformationModifyList_LCR_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uL_Timeslot_InformationModifyList_LCR_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode repetitionPeriod */

   if (pvalue->m.repetitionPeriodPresent) {
      PU_PUSHNAME (pctxt, "repetitionPeriod");

      stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->repetitionPeriod);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode repetitionLength */

   if (pvalue->m.repetitionLengthPresent) {
      PU_PUSHNAME (pctxt, "repetitionLength");

      stat = asn1PD_RepetitionLength (pctxt, &pvalue->repetitionLength);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_PhysicalChannelOffset */

   if (pvalue->m.tdd_PhysicalChannelOffsetPresent) {
      PU_PUSHNAME (pctxt, "tdd_PhysicalChannelOffset");

      stat = asn1PD_TDD_PhysicalChannelOffset (pctxt, &pvalue->tdd_PhysicalChannelOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uL_Timeslot_InformationModifyList_LCR_PSCH_ReconfRqst */

   if (pvalue->m.uL_Timeslot_InformationModifyList_LCR_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "uL_Timeslot_InformationModifyList_LCR_PSCH_ReconfRqst");

      stat = asn1PD_UL_Timeslot_LCR_InformationModifyList_PSCH_ReconfRqst (pctxt, &pvalue->uL_Timeslot_InformationModifyList_LCR_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_ModifyInformation_LCR_ModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCHSets_DeleteItem_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCHSets_DeleteItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCHSets_DeleteItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_DeleteItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pUSCHSet_ID */

   PU_PUSHNAME (pctxt, "pUSCHSet_ID");

   stat = asn1PD_PUSCHSet_ID (pctxt, &pvalue->pUSCHSet_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_DeleteItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCHSets_DeleteList_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCHSets_DeleteList_PSCH_ReconfRqst (ASN1CTXT* pctxt, PUSCHSets_DeleteList_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   PUSCHSets_DeleteItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_DeleteList_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PUSCHSets_DeleteItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PUSCHSets_DeleteItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSets_DeleteList_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_HS_PDSCH_Codelist_PSCH_ReconfRqst                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_HS_PDSCH_Codelist_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_HS_PDSCH_Codelist_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Codelist_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (16 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Codelist_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_HS_PDSCH_Timeslot_InformationItem_PSCH_ReconfRqst      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_HS_PDSCH_Timeslot_InformationItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_HS_PDSCH_Timeslot_InformationItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Timeslot_InformationItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxHSDSCH_HSSCCH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxHSDSCH_HSSCCH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_HS_PDSCH_Codelist_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "dl_HS_PDSCH_Codelist_PSCH_ReconfRqst");

   stat = asn1PD_DL_HS_PDSCH_Codelist_PSCH_ReconfRqst (pctxt, &pvalue->dl_HS_PDSCH_Codelist_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxHSDSCH_HSSCCH_Power */

   if (pvalue->m.maxHSDSCH_HSSCCH_PowerPresent) {
      PU_PUSHNAME (pctxt, "maxHSDSCH_HSSCCH_Power");

      stat = asn1PD_MaximumTransmissionPower (pctxt, &pvalue->maxHSDSCH_HSSCCH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Timeslot_InformationItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   DL_HS_PDSCH_Timeslot_InformationItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_HS_PDSCH_Timeslot_InformationItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_HS_PDSCH_Timeslot_InformationItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (16 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_HS_PDSCH_Timeslot_InformationItem_LCR_PSCH_ReconfRqst  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_HS_PDSCH_Timeslot_InformationItem_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_HS_PDSCH_Timeslot_InformationItem_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Timeslot_InformationItem_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "maxHSDSCH_HSSCCH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxHSDSCH_HSSCCH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst */

   PU_PUSHNAME (pctxt, "dl_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst");

   stat = asn1PD_DL_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst (pctxt, &pvalue->dl_HS_PDSCH_Codelist_LCR_PSCH_ReconfRqst);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maxHSDSCH_HSSCCH_Power */

   if (pvalue->m.maxHSDSCH_HSSCCH_PowerPresent) {
      PU_PUSHNAME (pctxt, "maxHSDSCH_HSSCCH_Power");

      stat = asn1PD_MaximumTransmissionPower (pctxt, &pvalue->maxHSDSCH_HSSCCH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Timeslot_InformationItem_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, DL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   DL_HS_PDSCH_Timeslot_InformationItem_LCR_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_HS_PDSCH_Timeslot_InformationItem_LCR_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_HS_PDSCH_Timeslot_InformationItem_LCR_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_PDSCH_TDD_Information_PSCH_ReconfRqst                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_PDSCH_TDD_Information_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_PDSCH_TDD_Information_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_PDSCH_TDD_Information_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst */

   if (pvalue->m.dL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "dL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst");

      stat = asn1PD_DL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst (pctxt, &pvalue->dL_HS_PDSCH_Timeslot_Information_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst */

   if (pvalue->m.dL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "dL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst");

      stat = asn1PD_DL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst (pctxt, &pvalue->dL_HS_PDSCH_Timeslot_Information_LCR_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_PDSCH_TDD_Information_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_Information_PSCH_ReconfRqst                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_Information_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SICH_Information_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_Information_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsSICH_ID */

   PU_PUSHNAME (pctxt, "hsSICH_ID");

   stat = asn1PD_HS_SICH_ID (pctxt, &pvalue->hsSICH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_Information_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_InformationItem_PSCH_ReconfRqst                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_InformationItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SCCH_InformationItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hS_SCCH_ID */

   PU_PUSHNAME (pctxt, "hS_SCCH_ID");

   stat = asn1PD_HS_SCCH_ID (pctxt, &pvalue->hS_SCCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_SCCH_MaxPower */

   PU_PUSHNAME (pctxt, "hS_SCCH_MaxPower");

   stat = asn1PD_DL_Power (pctxt, &pvalue->hS_SCCH_MaxPower);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_SICH_Information */

   PU_PUSHNAME (pctxt, "hS_SICH_Information");

   stat = asn1PD_HS_SICH_Information_PSCH_ReconfRqst (pctxt, &pvalue->hS_SICH_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_Information_PSCH_ReconfRqst                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_Information_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SCCH_Information_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   HS_SCCH_InformationItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_Information_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_SCCH_InformationItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_SCCH_InformationItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_Information_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_Information_LCR_PSCH_ReconfRqst                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_Information_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SICH_Information_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_Information_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsSICH_ID */

   PU_PUSHNAME (pctxt, "hsSICH_ID");

   stat = asn1PD_HS_SICH_ID (pctxt, &pvalue->hsSICH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_Information_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_InformationItem_LCR_PSCH_ReconfRqst               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_InformationItem_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SCCH_InformationItem_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationItem_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hS_SCCH_ID */

   PU_PUSHNAME (pctxt, "hS_SCCH_ID");

   stat = asn1PD_HS_SCCH_ID (pctxt, &pvalue->hS_SCCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode first_TDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "first_TDD_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->first_TDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode second_TDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "second_TDD_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->second_TDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_SCCH_MaxPower */

   PU_PUSHNAME (pctxt, "hS_SCCH_MaxPower");

   stat = asn1PD_DL_Power (pctxt, &pvalue->hS_SCCH_MaxPower);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_SICH_Information_LCR */

   PU_PUSHNAME (pctxt, "hS_SICH_Information_LCR");

   stat = asn1PD_HS_SICH_Information_LCR_PSCH_ReconfRqst (pctxt, &pvalue->hS_SICH_Information_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationItem_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_Information_LCR_PSCH_ReconfRqst                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_Information_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SCCH_Information_LCR_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   HS_SCCH_InformationItem_LCR_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_Information_LCR_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_SCCH_InformationItem_LCR_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_SCCH_InformationItem_LCR_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_Information_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Add_To_HS_SCCH_Resource_Pool_PSCH_ReconfRqst              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Add_To_HS_SCCH_Resource_Pool_PSCH_ReconfRqst (ASN1CTXT* pctxt, Add_To_HS_SCCH_Resource_Pool_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Add_To_HS_SCCH_Resource_Pool_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hS_SCCH_Information_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SCCH_Information_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_SCCH_Information_LCR_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SCCH_Information_LCR_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hS_SCCH_Information_PSCH_ReconfRqst */

   if (pvalue->m.hS_SCCH_Information_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "hS_SCCH_Information_PSCH_ReconfRqst");

      stat = asn1PD_HS_SCCH_Information_PSCH_ReconfRqst (pctxt, &pvalue->hS_SCCH_Information_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hS_SCCH_Information_LCR_PSCH_ReconfRqst */

   if (pvalue->m.hS_SCCH_Information_LCR_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "hS_SCCH_Information_LCR_PSCH_ReconfRqst");

      stat = asn1PD_HS_SCCH_Information_LCR_PSCH_ReconfRqst (pctxt, &pvalue->hS_SCCH_Information_LCR_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Add_To_HS_SCCH_Resource_Pool_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_InformationModify_PSCH_ReconfRqst                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_InformationModify_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SICH_InformationModify_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_InformationModify_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "timeSlotPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timeSlotPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftAndBurstTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftAndBurstTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_ChannelisationCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_ChannelisationCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsSICH_ID */

   PU_PUSHNAME (pctxt, "hsSICH_ID");

   stat = asn1PD_HS_SICH_ID (pctxt, &pvalue->hsSICH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   if (pvalue->m.timeSlotPresent) {
      PU_PUSHNAME (pctxt, "timeSlot");

      stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode midambleShiftAndBurstType */

   if (pvalue->m.midambleShiftAndBurstTypePresent) {
      PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

      stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_ChannelisationCode */

   if (pvalue->m.tdd_ChannelisationCodePresent) {
      PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_InformationModify_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_InformationModifyItem_PSCH_ReconfRqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_InformationModifyItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SCCH_InformationModifyItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationModifyItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "timeSlotPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timeSlotPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftAndBurstTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftAndBurstTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_ChannelisationCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_ChannelisationCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_SCCH_MaxPowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SCCH_MaxPowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_SICH_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SICH_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hS_SCCH_ID */

   PU_PUSHNAME (pctxt, "hS_SCCH_ID");

   stat = asn1PD_HS_SCCH_ID (pctxt, &pvalue->hS_SCCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   if (pvalue->m.timeSlotPresent) {
      PU_PUSHNAME (pctxt, "timeSlot");

      stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode midambleShiftAndBurstType */

   if (pvalue->m.midambleShiftAndBurstTypePresent) {
      PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

      stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_ChannelisationCode */

   if (pvalue->m.tdd_ChannelisationCodePresent) {
      PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hS_SCCH_MaxPower */

   if (pvalue->m.hS_SCCH_MaxPowerPresent) {
      PU_PUSHNAME (pctxt, "hS_SCCH_MaxPower");

      stat = asn1PD_DL_Power (pctxt, &pvalue->hS_SCCH_MaxPower);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hS_SICH_Information */

   if (pvalue->m.hS_SICH_InformationPresent) {
      PU_PUSHNAME (pctxt, "hS_SICH_Information");

      stat = asn1PD_HS_SICH_InformationModify_PSCH_ReconfRqst (pctxt, &pvalue->hS_SICH_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationModifyItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_InformationModify_PSCH_ReconfRqst                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_InformationModify_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SCCH_InformationModify_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   HS_SCCH_InformationModifyItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationModify_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_SCCH_InformationModifyItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_SCCH_InformationModifyItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationModify_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_InformationModify_LCR_PSCH_ReconfRqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_InformationModify_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SICH_InformationModify_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_InformationModify_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "timeSlotLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timeSlotLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tdd_ChannelisationCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tdd_ChannelisationCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsSICH_ID */

   PU_PUSHNAME (pctxt, "hsSICH_ID");

   stat = asn1PD_HS_SICH_ID (pctxt, &pvalue->hsSICH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotLCR */

   if (pvalue->m.timeSlotLCRPresent) {
      PU_PUSHNAME (pctxt, "timeSlotLCR");

      stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode midambleShiftLCR */

   if (pvalue->m.midambleShiftLCRPresent) {
      PU_PUSHNAME (pctxt, "midambleShiftLCR");

      stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tdd_ChannelisationCode */

   if (pvalue->m.tdd_ChannelisationCodePresent) {
      PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_InformationModify_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_InformationModifyItem_LCR_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_InformationModifyItem_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SCCH_InformationModifyItem_LCR_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationModifyItem_LCR_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "timeSlotLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timeSlotLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "first_TDD_ChannelisationCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.first_TDD_ChannelisationCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "second_TDD_ChannelisationCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.second_TDD_ChannelisationCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_SCCH_MaxPowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SCCH_MaxPowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_SICH_Information_LCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SICH_Information_LCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hS_SCCH_ID */

   PU_PUSHNAME (pctxt, "hS_SCCH_ID");

   stat = asn1PD_HS_SCCH_ID (pctxt, &pvalue->hS_SCCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotLCR */

   if (pvalue->m.timeSlotLCRPresent) {
      PU_PUSHNAME (pctxt, "timeSlotLCR");

      stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode midambleShiftLCR */

   if (pvalue->m.midambleShiftLCRPresent) {
      PU_PUSHNAME (pctxt, "midambleShiftLCR");

      stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode first_TDD_ChannelisationCode */

   if (pvalue->m.first_TDD_ChannelisationCodePresent) {
      PU_PUSHNAME (pctxt, "first_TDD_ChannelisationCode");

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->first_TDD_ChannelisationCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode second_TDD_ChannelisationCode */

   if (pvalue->m.second_TDD_ChannelisationCodePresent) {
      PU_PUSHNAME (pctxt, "second_TDD_ChannelisationCode");

      stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->second_TDD_ChannelisationCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hS_SCCH_MaxPower */

   if (pvalue->m.hS_SCCH_MaxPowerPresent) {
      PU_PUSHNAME (pctxt, "hS_SCCH_MaxPower");

      stat = asn1PD_DL_Power (pctxt, &pvalue->hS_SCCH_MaxPower);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hS_SICH_Information_LCR */

   if (pvalue->m.hS_SICH_Information_LCRPresent) {
      PU_PUSHNAME (pctxt, "hS_SICH_Information_LCR");

      stat = asn1PD_HS_SICH_InformationModify_LCR_PSCH_ReconfRqst (pctxt, &pvalue->hS_SICH_Information_LCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationModifyItem_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_InformationModify_LCR_PSCH_ReconfRqst             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_InformationModify_LCR_PSCH_ReconfRqst (ASN1CTXT* pctxt, HS_SCCH_InformationModify_LCR_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   HS_SCCH_InformationModifyItem_LCR_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationModify_LCR_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_SCCH_InformationModifyItem_LCR_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_SCCH_InformationModifyItem_LCR_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_InformationModify_LCR_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modify_HS_SCCH_Resource_Pool_PSCH_ReconfRqst              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Modify_HS_SCCH_Resource_Pool_PSCH_ReconfRqst (ASN1CTXT* pctxt, Modify_HS_SCCH_Resource_Pool_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Modify_HS_SCCH_Resource_Pool_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hS_SCCH_InformationModify_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SCCH_InformationModify_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hS_SCCH_InformationModify_LCR_PSCH_ReconfRqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_SCCH_InformationModify_LCR_PSCH_ReconfRqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hS_SCCH_InformationModify_PSCH_ReconfRqst */

   if (pvalue->m.hS_SCCH_InformationModify_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "hS_SCCH_InformationModify_PSCH_ReconfRqst");

      stat = asn1PD_HS_SCCH_InformationModify_PSCH_ReconfRqst (pctxt, &pvalue->hS_SCCH_InformationModify_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hS_SCCH_InformationModify_LCR_PSCH_ReconfRqst */

   if (pvalue->m.hS_SCCH_InformationModify_LCR_PSCH_ReconfRqstPresent) {
      PU_PUSHNAME (pctxt, "hS_SCCH_InformationModify_LCR_PSCH_ReconfRqst");

      stat = asn1PD_HS_SCCH_InformationModify_LCR_PSCH_ReconfRqst (pctxt, &pvalue->hS_SCCH_InformationModify_LCR_PSCH_ReconfRqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Modify_HS_SCCH_Resource_Pool_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Delete_From_HS_SCCH_Resource_PoolItem_PSCH_ReconfRqst     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Delete_From_HS_SCCH_Resource_PoolItem_PSCH_ReconfRqst (ASN1CTXT* pctxt, Delete_From_HS_SCCH_Resource_PoolItem_PSCH_ReconfRqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Delete_From_HS_SCCH_Resource_PoolItem_PSCH_ReconfRqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hS_SCCH_ID */

   PU_PUSHNAME (pctxt, "hS_SCCH_ID");

   stat = asn1PD_HS_SCCH_ID (pctxt, &pvalue->hS_SCCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Delete_From_HS_SCCH_Resource_PoolItem_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Delete_From_HS_SCCH_Resource_Pool_PSCH_ReconfRqst         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Delete_From_HS_SCCH_Resource_Pool_PSCH_ReconfRqst (ASN1CTXT* pctxt, Delete_From_HS_SCCH_Resource_Pool_PSCH_ReconfRqst* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Delete_From_HS_SCCH_Resource_PoolItem_PSCH_ReconfRqst* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Delete_From_HS_SCCH_Resource_Pool_PSCH_ReconfRqst: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Delete_From_HS_SCCH_Resource_PoolItem_PSCH_ReconfRqst);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Delete_From_HS_SCCH_Resource_PoolItem_PSCH_ReconfRqst (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Delete_From_HS_SCCH_Resource_Pool_PSCH_ReconfRqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalSharedChannelReconfigurationResponse              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PhysicalSharedChannelReconfigurationResponse (ASN1CTXT* pctxt, PhysicalSharedChannelReconfigurationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PhysicalSharedChannelReconfigurationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PhysicalSharedChannelReconfigurationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalSharedChannelReconfigurationFailure               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PhysicalSharedChannelReconfigurationFailure (ASN1CTXT* pctxt, PhysicalSharedChannelReconfigurationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PhysicalSharedChannelReconfigurationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PhysicalSharedChannelReconfigurationFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeneralCauseList_PSCH_ReconfFailure                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeneralCauseList_PSCH_ReconfFailure (ASN1CTXT* pctxt, GeneralCauseList_PSCH_ReconfFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_PSCH_ReconfFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_PSCH_ReconfFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD (ASN1CTXT* pctxt, Unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD (ASN1CTXT* pctxt, Unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetSpecificCauseList_PSCH_ReconfFailureTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SetSpecificCauseList_PSCH_ReconfFailureTDD (ASN1CTXT* pctxt, SetSpecificCauseList_PSCH_ReconfFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SetSpecificCauseList_PSCH_ReconfFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD */

   if (pvalue->m.unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDDPresent) {
      PU_PUSHNAME (pctxt, "unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD");

      stat = asn1PD_Unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD (pctxt, &pvalue->unsuccessful_PDSCHSetList_PSCH_ReconfFailureTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD */

   if (pvalue->m.unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDDPresent) {
      PU_PUSHNAME (pctxt, "unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD");

      stat = asn1PD_Unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD (pctxt, &pvalue->unsuccessful_PUSCHSetList_PSCH_ReconfFailureTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SetSpecificCauseList_PSCH_ReconfFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseLevel_PSCH_ReconfFailure                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseLevel_PSCH_ReconfFailure (ASN1CTXT* pctxt, CauseLevel_PSCH_ReconfFailure* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_PSCH_ReconfFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* generalCause */
         case 0:
            PU_PUSHNAME (pctxt, "u.generalCause");

            pvalue->u.generalCause = rtMemAllocTypeZ (pctxt, GeneralCauseList_PSCH_ReconfFailure);
            if (pvalue->u.generalCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeneralCauseList_PSCH_ReconfFailure (pctxt, pvalue->u.generalCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* setSpecificCause */
         case 1:
            PU_PUSHNAME (pctxt, "u.setSpecificCause");

            pvalue->u.setSpecificCause = rtMemAllocTypeZ (pctxt, SetSpecificCauseList_PSCH_ReconfFailureTDD);
            if (pvalue->u.setSpecificCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SetSpecificCauseList_PSCH_ReconfFailureTDD (pctxt, pvalue->u.setSpecificCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_PSCH_ReconfFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_PDSCHSetItem_PSCH_ReconfFailureTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_PDSCHSetItem_PSCH_ReconfFailureTDD (ASN1CTXT* pctxt, Unsuccessful_PDSCHSetItem_PSCH_ReconfFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_PDSCHSetItem_PSCH_ReconfFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pDSCHSet_ID */

   PU_PUSHNAME (pctxt, "pDSCHSet_ID");

   stat = asn1PD_PDSCHSet_ID (pctxt, &pvalue->pDSCHSet_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_PDSCHSetItem_PSCH_ReconfFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_PUSCHSetItem_PSCH_ReconfFailureTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_PUSCHSetItem_PSCH_ReconfFailureTDD (ASN1CTXT* pctxt, Unsuccessful_PUSCHSetItem_PSCH_ReconfFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_PUSCHSetItem_PSCH_ReconfFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode pUSCHSet_ID */

   PU_PUSHNAME (pctxt, "pUSCHSet_ID");

   stat = asn1PD_PUSCHSet_ID (pctxt, &pvalue->pUSCHSet_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_PUSCHSetItem_PSCH_ReconfFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetRequest                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetRequest (ASN1CTXT* pctxt, ResetRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationContextInfoList_Reset                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommunicationContextInfoList_Reset (ASN1CTXT* pctxt, CommunicationContextInfoList_Reset* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1048575), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;
   int lstat;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationContextInfoList_Reset: start\n");

   rtDListInit (pvalue);

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   for (;;) {
      /* decode length determinant */

      PU_PUSHNAME (pctxt, "count");

      lstat = pd_Length (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      PU_POPNAME (pctxt);

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         PU_PUSHELEMNAME (pctxt, xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);
         rtDListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == 0) break;
   }
   stat = pu_checkSizeConstraint (pctxt, pvalue->count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationContextInfoList_Reset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationContextList_Reset                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommunicationContextList_Reset (ASN1CTXT* pctxt, CommunicationContextList_Reset* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationContextList_Reset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode communicationContextInfoList_Reset */

   PU_PUSHNAME (pctxt, "communicationContextInfoList_Reset");

   stat = asn1PD_CommunicationContextInfoList_Reset (pctxt, &pvalue->communicationContextInfoList_Reset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationContextList_Reset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationControlPortInfoList_Reset                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommunicationControlPortInfoList_Reset (ASN1CTXT* pctxt, CommunicationControlPortInfoList_Reset* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationControlPortInfoList_Reset: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationControlPortInfoList_Reset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationControlPortList_Reset                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommunicationControlPortList_Reset (ASN1CTXT* pctxt, CommunicationControlPortList_Reset* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationControlPortList_Reset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode communicationControlPortInfoList_Reset */

   PU_PUSHNAME (pctxt, "communicationControlPortInfoList_Reset");

   stat = asn1PD_CommunicationControlPortInfoList_Reset (pctxt, &pvalue->communicationControlPortInfoList_Reset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationControlPortList_Reset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetIndicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetIndicator (ASN1CTXT* pctxt, ResetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetIndicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* communicationContext */
         case 0:
            PU_PUSHNAME (pctxt, "u.communicationContext");

            pvalue->u.communicationContext = rtMemAllocTypeZ (pctxt, CommunicationContextList_Reset);
            if (pvalue->u.communicationContext == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CommunicationContextList_Reset (pctxt, pvalue->u.communicationContext);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* communicationControlPort */
         case 1:
            PU_PUSHNAME (pctxt, "u.communicationControlPort");

            pvalue->u.communicationControlPort = rtMemAllocTypeZ (pctxt, CommunicationControlPortList_Reset);
            if (pvalue->u.communicationControlPort == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CommunicationControlPortList_Reset (pctxt, pvalue->u.communicationControlPort);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* nodeB */
         case 2:
            PU_PUSHNAME (pctxt, "u.nodeB");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationContextType_Reset                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommunicationContextType_Reset (ASN1CTXT* pctxt, CommunicationContextType_Reset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationContextType_Reset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* cRNC_CommunicationContextID */
         case 0:
            PU_PUSHNAME (pctxt, "u.cRNC_CommunicationContextID");

            stat = asn1PD_CRNC_CommunicationContextID (pctxt, &pvalue->u.cRNC_CommunicationContextID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* nodeB_CommunicationContextID */
         case 1:
            PU_PUSHNAME (pctxt, "u.nodeB_CommunicationContextID");

            stat = asn1PD_NodeB_CommunicationContextID (pctxt, &pvalue->u.nodeB_CommunicationContextID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationContextType_Reset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationContextInfoItem_Reset                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommunicationContextInfoItem_Reset (ASN1CTXT* pctxt, CommunicationContextInfoItem_Reset* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationContextInfoItem_Reset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode communicationContextType_Reset */

   PU_PUSHNAME (pctxt, "communicationContextType_Reset");

   stat = asn1PD_CommunicationContextType_Reset (pctxt, &pvalue->communicationContextType_Reset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationContextInfoItem_Reset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationControlPortInfoItem_Reset                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommunicationControlPortInfoItem_Reset (ASN1CTXT* pctxt, CommunicationControlPortInfoItem_Reset* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationControlPortInfoItem_Reset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode communicationControlPortID */

   PU_PUSHNAME (pctxt, "communicationControlPortID");

   stat = asn1PD_CommunicationControlPortID (pctxt, &pvalue->communicationControlPortID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationControlPortInfoItem_Reset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResponse                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResetResponse (ASN1CTXT* pctxt, ResetResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeInitiationRequest                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeInitiationRequest (ASN1CTXT* pctxt, InformationExchangeInitiationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeInitiationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeInitiationRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_InfEx_Rqst                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_InfEx_Rqst (ASN1CTXT* pctxt, Cell_InfEx_Rqst* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InfEx_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InfEx_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeObjectType_InfEx_Rqst                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeObjectType_InfEx_Rqst (ASN1CTXT* pctxt, InformationExchangeObjectType_InfEx_Rqst* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeObjectType_InfEx_Rqst: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* cell */
         case 0:
            PU_PUSHNAME (pctxt, "u.cell");

            pvalue->u.cell = rtMemAllocTypeZ (pctxt, Cell_InfEx_Rqst);
            if (pvalue->u.cell == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Cell_InfEx_Rqst (pctxt, pvalue->u.cell);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeObjectType_InfEx_Rqst: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeInitiationResponse                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeInitiationResponse (ASN1CTXT* pctxt, InformationExchangeInitiationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeInitiationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeInitiationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_InfEx_Rsp                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_InfEx_Rsp (ASN1CTXT* pctxt, Cell_InfEx_Rsp* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InfEx_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode requestedDataValue */

   PU_PUSHNAME (pctxt, "requestedDataValue");

   stat = asn1PD_RequestedDataValue (pctxt, &pvalue->requestedDataValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_InfEx_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeObjectType_InfEx_Rsp                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeObjectType_InfEx_Rsp (ASN1CTXT* pctxt, InformationExchangeObjectType_InfEx_Rsp* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeObjectType_InfEx_Rsp: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* cell */
         case 0:
            PU_PUSHNAME (pctxt, "u.cell");

            pvalue->u.cell = rtMemAllocTypeZ (pctxt, Cell_InfEx_Rsp);
            if (pvalue->u.cell == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Cell_InfEx_Rsp (pctxt, pvalue->u.cell);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeObjectType_InfEx_Rsp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeInitiationFailure                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeInitiationFailure (ASN1CTXT* pctxt, InformationExchangeInitiationFailure* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeInitiationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeInitiationFailure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationReport                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationReport (ASN1CTXT* pctxt, InformationReport* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationReport: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_Inf_Rprt                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cell_Inf_Rprt (ASN1CTXT* pctxt, Cell_Inf_Rprt* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_Inf_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode requestedDataValueInformation */

   PU_PUSHNAME (pctxt, "requestedDataValueInformation");

   stat = asn1PD_RequestedDataValueInformation (pctxt, &pvalue->requestedDataValueInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cell_Inf_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeObjectType_InfEx_Rprt                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeObjectType_InfEx_Rprt (ASN1CTXT* pctxt, InformationExchangeObjectType_InfEx_Rprt* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeObjectType_InfEx_Rprt: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* cell */
         case 0:
            PU_PUSHNAME (pctxt, "u.cell");

            pvalue->u.cell = rtMemAllocTypeZ (pctxt, Cell_Inf_Rprt);
            if (pvalue->u.cell == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Cell_Inf_Rprt (pctxt, pvalue->u.cell);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeObjectType_InfEx_Rprt: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeTerminationRequest                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeTerminationRequest (ASN1CTXT* pctxt, InformationExchangeTerminationRequest* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeTerminationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeTerminationRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeFailureIndication                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeFailureIndication (ASN1CTXT* pctxt, InformationExchangeFailureIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeFailureIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationInitiationRequestTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationInitiationRequestTDD (ASN1CTXT* pctxt, CellSynchronisationInitiationRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationInitiationRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationInitiationRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTransInit_CellSyncInitiationRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstTransInit_CellSyncInitiationRqstTDD (ASN1CTXT* pctxt, CellSyncBurstTransInit_CellSyncInitiationRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTransInit_CellSyncInitiationRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cSBTransmissionID */

   PU_PUSHNAME (pctxt, "cSBTransmissionID");

   stat = asn1PD_CSBTransmissionID (pctxt, &pvalue->cSBTransmissionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sfn */

   PU_PUSHNAME (pctxt, "sfn");

   stat = asn1PD_SFN (pctxt, &pvalue->sfn);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstCode */

   PU_PUSHNAME (pctxt, "cellSyncBurstCode");

   stat = asn1PD_CellSyncBurstCode (pctxt, &pvalue->cellSyncBurstCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstCodeShift */

   PU_PUSHNAME (pctxt, "cellSyncBurstCodeShift");

   stat = asn1PD_CellSyncBurstCodeShift (pctxt, &pvalue->cellSyncBurstCodeShift);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode initialDLTransPower */

   PU_PUSHNAME (pctxt, "initialDLTransPower");

   stat = asn1PD_DL_Power (pctxt, &pvalue->initialDLTransPower);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTransInit_CellSyncInitiationRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeslotInfo_CellSyncInitiationRqstTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeslotInfo_CellSyncInitiationRqstTDD (ASN1CTXT* pctxt, TimeslotInfo_CellSyncInitiationRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeslotInfo_CellSyncInitiationRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (15 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_TimeSlot (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeslotInfo_CellSyncInitiationRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstMeasureInit_CellSyncInitiationRqstTDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstMeasureInit_CellSyncInitiationRqstTDD (ASN1CTXT* pctxt, CellSyncBurstMeasureInit_CellSyncInitiationRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasureInit_CellSyncInitiationRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "sfnPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sfnPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cSBMeasurementID */

   PU_PUSHNAME (pctxt, "cSBMeasurementID");

   stat = asn1PD_CSBMeasurementID (pctxt, &pvalue->cSBMeasurementID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstCode */

   PU_PUSHNAME (pctxt, "cellSyncBurstCode");

   stat = asn1PD_CellSyncBurstCode (pctxt, &pvalue->cellSyncBurstCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstCodeShift */

   PU_PUSHNAME (pctxt, "cellSyncBurstCodeShift");

   stat = asn1PD_CellSyncBurstCodeShift (pctxt, &pvalue->cellSyncBurstCodeShift);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode synchronisationReportType */

   PU_PUSHNAME (pctxt, "synchronisationReportType");

   stat = asn1PD_SynchronisationReportType (pctxt, &pvalue->synchronisationReportType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sfn */

   if (pvalue->m.sfnPresent) {
      PU_PUSHNAME (pctxt, "sfn");

      stat = asn1PD_SFN (pctxt, &pvalue->sfn);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode synchronisationReportCharacteristics */

   PU_PUSHNAME (pctxt, "synchronisationReportCharacteristics");

   stat = asn1PD_SynchronisationReportCharacteristics (pctxt, &pvalue->synchronisationReportCharacteristics);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasureInit_CellSyncInitiationRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeId_TransInitLCR_CellSyncInitiationRqstTDD       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeId_TransInitLCR_CellSyncInitiationRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeId_TransInitLCR_CellSyncInitiationRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeId_TransInitLCR_CellSyncInitiationRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cSBTransmissionID */

   PU_PUSHNAME (pctxt, "cSBTransmissionID");

   stat = asn1PD_CSBTransmissionID (pctxt, &pvalue->cSBTransmissionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sfn */

   PU_PUSHNAME (pctxt, "sfn");

   stat = asn1PD_SFN (pctxt, &pvalue->sfn);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PD_UARFCN (pctxt, &pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sYNCDlCodeId */

   PU_PUSHNAME (pctxt, "sYNCDlCodeId");

   stat = asn1PD_SYNCDlCodeId (pctxt, &pvalue->sYNCDlCodeId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dwPCH_Power */

   PU_PUSHNAME (pctxt, "dwPCH_Power");

   stat = asn1PD_DwPCH_Power (pctxt, &pvalue->dwPCH_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeId_TransInitLCR_CellSyncInitiationRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeId_MeasureInitLCR_CellSyncInitiationRqstTDD     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeId_MeasureInitLCR_CellSyncInitiationRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeId_MeasureInitLCR_CellSyncInitiationRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeId_MeasureInitLCR_CellSyncInitiationRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "sfnPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sfnPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cSBMeasurementID */

   PU_PUSHNAME (pctxt, "cSBMeasurementID");

   stat = asn1PD_CSBMeasurementID (pctxt, &pvalue->cSBMeasurementID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sfn */

   if (pvalue->m.sfnPresent) {
      PU_PUSHNAME (pctxt, "sfn");

      stat = asn1PD_SFN (pctxt, &pvalue->sfn);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PD_UARFCN (pctxt, &pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sYNCDlCodeId */

   PU_PUSHNAME (pctxt, "sYNCDlCodeId");

   stat = asn1PD_SYNCDlCodeId (pctxt, &pvalue->sYNCDlCodeId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode synchronisationReportType */

   PU_PUSHNAME (pctxt, "synchronisationReportType");

   stat = asn1PD_SynchronisationReportType (pctxt, &pvalue->synchronisationReportType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode synchronisationReportCharacteristics */

   PU_PUSHNAME (pctxt, "synchronisationReportCharacteristics");

   stat = asn1PD_SynchronisationReportCharacteristics (pctxt, &pvalue->synchronisationReportCharacteristics);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeId_MeasureInitLCR_CellSyncInitiationRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationInitiationResponseTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationInitiationResponseTDD (ASN1CTXT* pctxt, CellSynchronisationInitiationResponseTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationInitiationResponseTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationInitiationResponseTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationInitiationFailureTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationInitiationFailureTDD (ASN1CTXT* pctxt, CellSynchronisationInitiationFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationInitiationFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationInitiationFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationReconfigurationRequestTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationReconfigurationRequestTDD (ASN1CTXT* pctxt, CellSynchronisationReconfigurationRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationReconfigurationRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationReconfigurationRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTransInfoItem_CellSyncReconfRqstTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstTransInfoItem_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, CellSyncBurstTransInfoItem_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTransInfoItem_CellSyncReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "cellSyncBurstCodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cellSyncBurstCodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cellSyncBurstCodeShiftPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cellSyncBurstCodeShiftPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dlTransPowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dlTransPowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cSBTransmissionID */

   PU_PUSHNAME (pctxt, "cSBTransmissionID");

   stat = asn1PD_CSBTransmissionID (pctxt, &pvalue->cSBTransmissionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncFrameNumberToTransmit */

   PU_PUSHNAME (pctxt, "syncFrameNumberToTransmit");

   stat = asn1PD_SyncFrameNumber (pctxt, &pvalue->syncFrameNumberToTransmit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstCode */

   if (pvalue->m.cellSyncBurstCodePresent) {
      PU_PUSHNAME (pctxt, "cellSyncBurstCode");

      stat = asn1PD_CellSyncBurstCode (pctxt, &pvalue->cellSyncBurstCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cellSyncBurstCodeShift */

   if (pvalue->m.cellSyncBurstCodeShiftPresent) {
      PU_PUSHNAME (pctxt, "cellSyncBurstCodeShift");

      stat = asn1PD_CellSyncBurstCodeShift (pctxt, &pvalue->cellSyncBurstCodeShift);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dlTransPower */

   if (pvalue->m.dlTransPowerPresent) {
      PU_PUSHNAME (pctxt, "dlTransPower");

      stat = asn1PD_DL_Power (pctxt, &pvalue->dlTransPower);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTransInfoItem_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTransReconfInfo_CellSyncReconfRqstTDD        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstTransReconfInfo_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, CellSyncBurstTransReconfInfo_CellSyncReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(10), 0 };
   int stat = 0;
   CellSyncBurstTransInfoItem_CellSyncReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTransReconfInfo_CellSyncReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellSyncBurstTransInfoItem_CellSyncReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellSyncBurstTransInfoItem_CellSyncReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTransReconfInfo_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstMeasInfo_CellSyncReconfRqstTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstMeasInfo_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, CellSyncBurstMeasInfo_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfo_CellSyncReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "synchronisationReportTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.synchronisationReportTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "synchronisationReportCharacteristicsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.synchronisationReportCharacteristicsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellSyncBurstMeasInfoList_CellSyncReconfRqstTDD */

   PU_PUSHNAME (pctxt, "cellSyncBurstMeasInfoList_CellSyncReconfRqstTDD");

   stat = asn1PD_CellSyncBurstMeasInfoList_CellSyncReconfRqstTDD (pctxt, &pvalue->cellSyncBurstMeasInfoList_CellSyncReconfRqstTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode synchronisationReportType */

   if (pvalue->m.synchronisationReportTypePresent) {
      PU_PUSHNAME (pctxt, "synchronisationReportType");

      stat = asn1PD_SynchronisationReportTypeIE (pctxt, &pvalue->synchronisationReportType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode synchronisationReportCharacteristics */

   if (pvalue->m.synchronisationReportCharacteristicsPresent) {
      PU_PUSHNAME (pctxt, "synchronisationReportCharacteristics");

      stat = asn1PD_SynchronisationReportCharacteristicsIE (pctxt, &pvalue->synchronisationReportCharacteristics);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfo_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstInfoItem_CellSyncReconfRqstTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstInfoItem_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, CellSyncBurstInfoItem_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstInfoItem_CellSyncReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cSBMeasurementID */

   PU_PUSHNAME (pctxt, "cSBMeasurementID");

   stat = asn1PD_CSBMeasurementID (pctxt, &pvalue->cSBMeasurementID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstCode */

   PU_PUSHNAME (pctxt, "cellSyncBurstCode");

   stat = asn1PD_CellSyncBurstCode (pctxt, &pvalue->cellSyncBurstCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstCodeShift */

   PU_PUSHNAME (pctxt, "cellSyncBurstCodeShift");

   stat = asn1PD_CellSyncBurstCodeShift (pctxt, &pvalue->cellSyncBurstCodeShift);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstInfoItem_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstInfoList_CellSyncReconfRqstTDD               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstInfoList_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, CellSyncBurstInfoList_CellSyncReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   CellSyncBurstInfoItem_CellSyncReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstInfoList_CellSyncReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellSyncBurstInfoItem_CellSyncReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellSyncBurstInfoItem_CellSyncReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstInfoList_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstMeasInfoItem_CellSyncReconfRqstTDD           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstMeasInfoItem_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, CellSyncBurstMeasInfoItem_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoItem_CellSyncReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode syncFrameNrToReceive */

   PU_PUSHNAME (pctxt, "syncFrameNrToReceive");

   stat = asn1PD_SyncFrameNumber (pctxt, &pvalue->syncFrameNrToReceive);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncBurstInfo */

   PU_PUSHNAME (pctxt, "syncBurstInfo");

   stat = asn1PD_CellSyncBurstInfoList_CellSyncReconfRqstTDD (pctxt, &pvalue->syncBurstInfo);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoItem_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstMeasInfoListIE_CellSyncReconfRqstTDD         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstMeasInfoListIE_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, CellSyncBurstMeasInfoListIE_CellSyncReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(10), 0 };
   int stat = 0;
   CellSyncBurstMeasInfoItem_CellSyncReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoListIE_CellSyncReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellSyncBurstMeasInfoItem_CellSyncReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellSyncBurstMeasInfoItem_CellSyncReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoListIE_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeIdTransReconfItemLCR_CellSyncReconfRqstTDD      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeIdTransReconfItemLCR_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeIdTransReconfItemLCR_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdTransReconfItemLCR_CellSyncReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "sYNCDlCodeIdPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sYNCDlCodeIdPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dwPCH_PowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dwPCH_PowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cSBTransmissionID */

   PU_PUSHNAME (pctxt, "cSBTransmissionID");

   stat = asn1PD_CSBTransmissionID (pctxt, &pvalue->cSBTransmissionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncFrameNumberforTransmit */

   PU_PUSHNAME (pctxt, "syncFrameNumberforTransmit");

   stat = asn1PD_SyncFrameNumber (pctxt, &pvalue->syncFrameNumberforTransmit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PD_UARFCN (pctxt, &pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sYNCDlCodeId */

   if (pvalue->m.sYNCDlCodeIdPresent) {
      PU_PUSHNAME (pctxt, "sYNCDlCodeId");

      stat = asn1PD_SYNCDlCodeId (pctxt, &pvalue->sYNCDlCodeId);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dwPCH_Power */

   if (pvalue->m.dwPCH_PowerPresent) {
      PU_PUSHNAME (pctxt, "dwPCH_Power");

      stat = asn1PD_DwPCH_Power (pctxt, &pvalue->dwPCH_Power);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdTransReconfItemLCR_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeIdTransReconfInfoLCR_CellSyncReconfRqstTDD      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeIdTransReconfInfoLCR_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeIdTransReconfInfoLCR_CellSyncReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(512), 0 };
   int stat = 0;
   SYNCDlCodeIdTransReconfItemLCR_CellSyncReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdTransReconfInfoLCR_CellSyncReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SYNCDlCodeIdTransReconfItemLCR_CellSyncReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SYNCDlCodeIdTransReconfItemLCR_CellSyncReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdTransReconfInfoLCR_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeIdInfoItemLCR_CellSyncReconfRqstTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeIdInfoItemLCR_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeIdInfoItemLCR_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdInfoItemLCR_CellSyncReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "propagationDelayCompensationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.propagationDelayCompensationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cSBMeasurementID */

   PU_PUSHNAME (pctxt, "cSBMeasurementID");

   stat = asn1PD_CSBMeasurementID (pctxt, &pvalue->cSBMeasurementID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sYNCDlCodeId */

   PU_PUSHNAME (pctxt, "sYNCDlCodeId");

   stat = asn1PD_SYNCDlCodeId (pctxt, &pvalue->sYNCDlCodeId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PD_UARFCN (pctxt, &pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode propagationDelayCompensation */

   if (pvalue->m.propagationDelayCompensationPresent) {
      PU_PUSHNAME (pctxt, "propagationDelayCompensation");

      stat = asn1PD_TimingAdjustmentValueLCR (pctxt, &pvalue->propagationDelayCompensation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdInfoItemLCR_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeIdInfoListLCR_CellSyncReconfRqstTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeIdInfoListLCR_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeIdInfoListLCR_CellSyncReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   SYNCDlCodeIdInfoItemLCR_CellSyncReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdInfoListLCR_CellSyncReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SYNCDlCodeIdInfoItemLCR_CellSyncReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SYNCDlCodeIdInfoItemLCR_CellSyncReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdInfoListLCR_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeIdMeasInfoItem_CellSyncReconfRqstTDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeIdMeasInfoItem_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeIdMeasInfoItem_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdMeasInfoItem_CellSyncReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode syncFrameNrToReceive */

   PU_PUSHNAME (pctxt, "syncFrameNrToReceive");

   stat = asn1PD_SyncFrameNumber (pctxt, &pvalue->syncFrameNrToReceive);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sYNCDlCodeIdInfoLCR */

   PU_PUSHNAME (pctxt, "sYNCDlCodeIdInfoLCR");

   stat = asn1PD_SYNCDlCodeIdInfoListLCR_CellSyncReconfRqstTDD (pctxt, &pvalue->sYNCDlCodeIdInfoLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdMeasInfoItem_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeIdMeasInfoList_CellSyncReconfRqstTDD            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeIdMeasInfoList_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeIdMeasInfoList_CellSyncReconfRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   SYNCDlCodeIdMeasInfoItem_CellSyncReconfRqstTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdMeasInfoList_CellSyncReconfRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SYNCDlCodeIdMeasInfoItem_CellSyncReconfRqstTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SYNCDlCodeIdMeasInfoItem_CellSyncReconfRqstTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdMeasInfoList_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeIdMeasInfoLCR_CellSyncReconfRqstTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeIdMeasInfoLCR_CellSyncReconfRqstTDD (ASN1CTXT* pctxt, SYNCDlCodeIdMeasInfoLCR_CellSyncReconfRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdMeasInfoLCR_CellSyncReconfRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "synchronisationReportTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.synchronisationReportTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "synchronisationReportCharacteristicsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.synchronisationReportCharacteristicsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sYNCDlCodeIdMeasInfoList */

   PU_PUSHNAME (pctxt, "sYNCDlCodeIdMeasInfoList");

   stat = asn1PD_SYNCDlCodeIdMeasInfoList_CellSyncReconfRqstTDD (pctxt, &pvalue->sYNCDlCodeIdMeasInfoList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode synchronisationReportType */

   if (pvalue->m.synchronisationReportTypePresent) {
      PU_PUSHNAME (pctxt, "synchronisationReportType");

      stat = asn1PD_SynchronisationReportType (pctxt, &pvalue->synchronisationReportType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode synchronisationReportCharacteristics */

   if (pvalue->m.synchronisationReportCharacteristicsPresent) {
      PU_PUSHNAME (pctxt, "synchronisationReportCharacteristics");

      stat = asn1PD_SynchronisationReportCharacteristics (pctxt, &pvalue->synchronisationReportCharacteristics);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeIdMeasInfoLCR_CellSyncReconfRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationReconfigurationResponseTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationReconfigurationResponseTDD (ASN1CTXT* pctxt, CellSynchronisationReconfigurationResponseTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationReconfigurationResponseTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationReconfigurationResponseTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationReconfigurationFailureTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationReconfigurationFailureTDD (ASN1CTXT* pctxt, CellSynchronisationReconfigurationFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationReconfigurationFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationReconfigurationFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationAdjustmentRequestTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationAdjustmentRequestTDD (ASN1CTXT* pctxt, CellSynchronisationAdjustmentRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationAdjustmentRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationAdjustmentRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellAdjustmentInfo_SyncAdjustmentRqstTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellAdjustmentInfo_SyncAdjustmentRqstTDD (ASN1CTXT* pctxt, CellAdjustmentInfo_SyncAdjustmentRqstTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellAdjustmentInfo_SyncAdjustmentRqstTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellAdjustmentInfo_SyncAdjustmentRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellAdjustmentInfoItem_SyncAdjustmentRqstTDD              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellAdjustmentInfoItem_SyncAdjustmentRqstTDD (ASN1CTXT* pctxt, CellAdjustmentInfoItem_SyncAdjustmentRqstTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellAdjustmentInfoItem_SyncAdjustmentRqstTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "frameAdjustmentValuePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.frameAdjustmentValuePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timingAdjustmentValuePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timingAdjustmentValuePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dLTransPowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dLTransPowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sfnPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sfnPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode frameAdjustmentValue */

   if (pvalue->m.frameAdjustmentValuePresent) {
      PU_PUSHNAME (pctxt, "frameAdjustmentValue");

      stat = asn1PD_FrameAdjustmentValue (pctxt, &pvalue->frameAdjustmentValue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode timingAdjustmentValue */

   if (pvalue->m.timingAdjustmentValuePresent) {
      PU_PUSHNAME (pctxt, "timingAdjustmentValue");

      stat = asn1PD_TimingAdjustmentValue (pctxt, &pvalue->timingAdjustmentValue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dLTransPower */

   if (pvalue->m.dLTransPowerPresent) {
      PU_PUSHNAME (pctxt, "dLTransPower");

      stat = asn1PD_DL_Power (pctxt, &pvalue->dLTransPower);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode sfn */

   if (pvalue->m.sfnPresent) {
      PU_PUSHNAME (pctxt, "sfn");

      stat = asn1PD_SFN (pctxt, &pvalue->sfn);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellAdjustmentInfoItem_SyncAdjustmentRqstTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationAdjustmentResponseTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationAdjustmentResponseTDD (ASN1CTXT* pctxt, CellSynchronisationAdjustmentResponseTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationAdjustmentResponseTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationAdjustmentResponseTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationAdjustmentFailureTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationAdjustmentFailureTDD (ASN1CTXT* pctxt, CellSynchronisationAdjustmentFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationAdjustmentFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationAdjustmentFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeneralCauseList_SyncAdjustmntFailureTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GeneralCauseList_SyncAdjustmntFailureTDD (ASN1CTXT* pctxt, GeneralCauseList_SyncAdjustmntFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_SyncAdjustmntFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeneralCauseList_SyncAdjustmntFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_cell_InformationRespList_SyncAdjustmntFailu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_cell_InformationRespList_SyncAdjustmntFailureTDD (ASN1CTXT* pctxt, Unsuccessful_cell_InformationRespList_SyncAdjustmntFailureTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_cell_InformationRespList_SyncAdjustmntFailureTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_cell_InformationRespList_SyncAdjustmntFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSpecificCauseList_SyncAdjustmntFailureTDD             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSpecificCauseList_SyncAdjustmntFailureTDD (ASN1CTXT* pctxt, CellSpecificCauseList_SyncAdjustmntFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSpecificCauseList_SyncAdjustmntFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode unsuccessful_cell_InformationRespList_SyncAdjustmntFailureTDD */

   PU_PUSHNAME (pctxt, "unsuccessful_cell_InformationRespList_SyncAdjustmntFailureTDD");

   stat = asn1PD_Unsuccessful_cell_InformationRespList_SyncAdjustmntFailureTDD (pctxt, &pvalue->unsuccessful_cell_InformationRespList_SyncAdjustmntFailureTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSpecificCauseList_SyncAdjustmntFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseLevel_SyncAdjustmntFailureTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseLevel_SyncAdjustmntFailureTDD (ASN1CTXT* pctxt, CauseLevel_SyncAdjustmntFailureTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_SyncAdjustmntFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* generalCause */
         case 0:
            PU_PUSHNAME (pctxt, "u.generalCause");

            pvalue->u.generalCause = rtMemAllocTypeZ (pctxt, GeneralCauseList_SyncAdjustmntFailureTDD);
            if (pvalue->u.generalCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GeneralCauseList_SyncAdjustmntFailureTDD (pctxt, pvalue->u.generalCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* cellSpecificCause */
         case 1:
            PU_PUSHNAME (pctxt, "u.cellSpecificCause");

            pvalue->u.cellSpecificCause = rtMemAllocTypeZ (pctxt, CellSpecificCauseList_SyncAdjustmntFailureTDD);
            if (pvalue->u.cellSpecificCause == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CellSpecificCauseList_SyncAdjustmntFailureTDD (pctxt, pvalue->u.cellSpecificCause);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseLevel_SyncAdjustmntFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unsuccessful_cell_InformationRespItem_SyncAdjustmntFailu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unsuccessful_cell_InformationRespItem_SyncAdjustmntFailureTDD (ASN1CTXT* pctxt, Unsuccessful_cell_InformationRespItem_SyncAdjustmntFailureTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_cell_InformationRespItem_SyncAdjustmntFailureTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cause */

   PU_PUSHNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unsuccessful_cell_InformationRespItem_SyncAdjustmntFailureTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationTerminationRequestTDD                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationTerminationRequestTDD (ASN1CTXT* pctxt, CellSynchronisationTerminationRequestTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationTerminationRequestTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationTerminationRequestTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationFailureIndicationTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationFailureIndicationTDD (ASN1CTXT* pctxt, CellSynchronisationFailureIndicationTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationFailureIndicationTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationFailureIndicationTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSynchronisationReportTDD                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSynchronisationReportTDD (ASN1CTXT* pctxt, CellSynchronisationReportTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationReportTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSynchronisationReportTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncInfoItemIE_CellSyncReprtTDD                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncInfoItemIE_CellSyncReprtTDD (ASN1CTXT* pctxt, CellSyncInfoItemIE_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncInfoItemIE_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "syncReportType_CellSyncReprtTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.syncReportType_CellSyncReprtTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode c_ID_CellSyncReprtTDD */

   PU_PUSHNAME (pctxt, "c_ID_CellSyncReprtTDD");

   stat = asn1PD_C_ID_IE_CellSyncReprtTDD (pctxt, &pvalue->c_ID_CellSyncReprtTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncReportType_CellSyncReprtTDD */

   if (pvalue->m.syncReportType_CellSyncReprtTDDPresent) {
      PU_PUSHNAME (pctxt, "syncReportType_CellSyncReprtTDD");

      stat = asn1PD_SyncReportTypeIE_CellSyncReprtTDD (pctxt, &pvalue->syncReportType_CellSyncReprtTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncInfoItemIE_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncInfo_CellSyncReprtTDD                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncInfo_CellSyncReprtTDD (ASN1CTXT* pctxt, CellSyncInfo_CellSyncReprtTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   CellSyncInfoItemIE_CellSyncReprtTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncInfo_CellSyncReprtTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellSyncInfoItemIE_CellSyncReprtTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellSyncInfoItemIE_CellSyncReprtTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncInfo_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstAvailable_CellSyncReprtTDD                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstAvailable_CellSyncReprtTDD (ASN1CTXT* pctxt, CellSyncBurstAvailable_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstAvailable_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellSyncBurstTiming */

   PU_PUSHNAME (pctxt, "cellSyncBurstTiming");

   stat = asn1PD_CellSyncBurstTiming (pctxt, &pvalue->cellSyncBurstTiming);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstSIR */

   PU_PUSHNAME (pctxt, "cellSyncBurstSIR");

   stat = asn1PD_CellSyncBurstSIR (pctxt, &pvalue->cellSyncBurstSIR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstAvailable_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstInfo_CellSyncReprtTDD                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstInfo_CellSyncReprtTDD (ASN1CTXT* pctxt, CellSyncBurstInfo_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstInfo_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* cellSyncBurstAvailable */
         case 0:
            PU_PUSHNAME (pctxt, "u.cellSyncBurstAvailable");

            pvalue->u.cellSyncBurstAvailable = rtMemAllocTypeZ (pctxt, CellSyncBurstAvailable_CellSyncReprtTDD);
            if (pvalue->u.cellSyncBurstAvailable == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_CellSyncBurstAvailable_CellSyncReprtTDD (pctxt, pvalue->u.cellSyncBurstAvailable);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* cellSyncBurstNotAvailable */
         case 1:
            PU_PUSHNAME (pctxt, "u.cellSyncBurstNotAvailable");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstInfo_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstMeasInfoItem_CellSyncReprtTDD_cellSyncBurst  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstMeasInfoItem_CellSyncReprtTDD_cellSyncBurstInfo_CellSyncReprtTDD (ASN1CTXT* pctxt, CellSyncBurstMeasInfoItem_CellSyncReprtTDD_cellSyncBurstInfo_CellSyncReprtTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   CellSyncBurstInfo_CellSyncReprtTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoItem_CellSyncReprtTDD_cellSyncBurstInfo_CellSyncReprtTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellSyncBurstInfo_CellSyncReprtTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellSyncBurstInfo_CellSyncReprtTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoItem_CellSyncReprtTDD_cellSyncBurstInfo_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstMeasInfoItem_CellSyncReprtTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstMeasInfoItem_CellSyncReprtTDD (ASN1CTXT* pctxt, CellSyncBurstMeasInfoItem_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoItem_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sFN */

   PU_PUSHNAME (pctxt, "sFN");

   stat = asn1PD_SFN (pctxt, &pvalue->sFN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstInfo_CellSyncReprtTDD */

   PU_PUSHNAME (pctxt, "cellSyncBurstInfo_CellSyncReprtTDD");

   stat = asn1PD_CellSyncBurstMeasInfoItem_CellSyncReprtTDD_cellSyncBurstInfo_CellSyncReprtTDD (pctxt, &pvalue->cellSyncBurstInfo_CellSyncReprtTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoItem_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstMeasInfoList_CellSyncReprtTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstMeasInfoList_CellSyncReprtTDD (ASN1CTXT* pctxt, CellSyncBurstMeasInfoList_CellSyncReprtTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(10), 0 };
   int stat = 0;
   CellSyncBurstMeasInfoItem_CellSyncReprtTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoList_CellSyncReprtTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CellSyncBurstMeasInfoItem_CellSyncReprtTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CellSyncBurstMeasInfoItem_CellSyncReprtTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstMeasInfoList_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntStdPhCellSyncInfo_CellSyncReprtTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IntStdPhCellSyncInfo_CellSyncReprtTDD (ASN1CTXT* pctxt, IntStdPhCellSyncInfo_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntStdPhCellSyncInfo_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellSyncBurstMeasuredInfo */

   PU_PUSHNAME (pctxt, "cellSyncBurstMeasuredInfo");

   stat = asn1PD_CellSyncBurstMeasInfoList_CellSyncReprtTDD (pctxt, &pvalue->cellSyncBurstMeasuredInfo);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntStdPhCellSyncInfo_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncReportType_CellSyncReprtTDD                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncReportType_CellSyncReprtTDD (ASN1CTXT* pctxt, SyncReportType_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncReportType_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* intStdPhSyncInfo_CellSyncReprtTDD */
         case 0:
            PU_PUSHNAME (pctxt, "u.intStdPhSyncInfo_CellSyncReprtTDD");

            pvalue->u.intStdPhSyncInfo_CellSyncReprtTDD = rtMemAllocTypeZ (pctxt, IntStdPhCellSyncInfo_CellSyncReprtTDD);
            if (pvalue->u.intStdPhSyncInfo_CellSyncReprtTDD == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_IntStdPhCellSyncInfo_CellSyncReprtTDD (pctxt, pvalue->u.intStdPhSyncInfo_CellSyncReprtTDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* lateEntrantCell */
         case 1:
            PU_PUSHNAME (pctxt, "u.lateEntrantCell");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* frequencyAcquisition */
         case 2:
            PU_PUSHNAME (pctxt, "u.frequencyAcquisition");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncReportType_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdAvailable_CellSyncReprtTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeIdAvailable_CellSyncReprtTDD (ASN1CTXT* pctxt, SyncDLCodeIdAvailable_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdAvailable_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode syncDLCodeIdTiming */

   PU_PUSHNAME (pctxt, "syncDLCodeIdTiming");

   stat = asn1PD_CellSyncBurstTimingLCR (pctxt, &pvalue->syncDLCodeIdTiming);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncDLCodeIdSIR */

   PU_PUSHNAME (pctxt, "syncDLCodeIdSIR");

   stat = asn1PD_CellSyncBurstSIR (pctxt, &pvalue->syncDLCodeIdSIR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdAvailable_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdItem_CellSyncReprtTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeIdItem_CellSyncReprtTDD (ASN1CTXT* pctxt, SyncDLCodeIdItem_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdItem_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* syncDLCodeIdAvailable */
         case 0:
            PU_PUSHNAME (pctxt, "u.syncDLCodeIdAvailable");

            pvalue->u.syncDLCodeIdAvailable = rtMemAllocTypeZ (pctxt, SyncDLCodeIdAvailable_CellSyncReprtTDD);
            if (pvalue->u.syncDLCodeIdAvailable == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SyncDLCodeIdAvailable_CellSyncReprtTDD (pctxt, pvalue->u.syncDLCodeIdAvailable);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* syncDLCodeIDNotAvailable */
         case 1:
            PU_PUSHNAME (pctxt, "u.syncDLCodeIDNotAvailable");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdItem_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdInfo_CellSyncReprtTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeIdInfo_CellSyncReprtTDD (ASN1CTXT* pctxt, SyncDLCodeIdInfo_CellSyncReprtTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   SyncDLCodeIdItem_CellSyncReprtTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdInfo_CellSyncReprtTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SyncDLCodeIdItem_CellSyncReprtTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SyncDLCodeIdItem_CellSyncReprtTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdInfo_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdsMeasInfoItem_CellSyncReprtTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeIdsMeasInfoItem_CellSyncReprtTDD (ASN1CTXT* pctxt, SyncDLCodeIdsMeasInfoItem_CellSyncReprtTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdsMeasInfoItem_CellSyncReprtTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sFN */

   PU_PUSHNAME (pctxt, "sFN");

   stat = asn1PD_SFN (pctxt, &pvalue->sFN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncDLCodeIdInfo_CellSyncReprtTDD */

   PU_PUSHNAME (pctxt, "syncDLCodeIdInfo_CellSyncReprtTDD");

   stat = asn1PD_SyncDLCodeIdInfo_CellSyncReprtTDD (pctxt, &pvalue->syncDLCodeIdInfo_CellSyncReprtTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdsMeasInfoItem_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdsMeasInfoList_CellSyncReprtTDD                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeIdsMeasInfoList_CellSyncReprtTDD (ASN1CTXT* pctxt, SyncDLCodeIdsMeasInfoList_CellSyncReprtTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(512), 0 };
   int stat = 0;
   SyncDLCodeIdsMeasInfoItem_CellSyncReprtTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdsMeasInfoList_CellSyncReprtTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SyncDLCodeIdsMeasInfoItem_CellSyncReprtTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SyncDLCodeIdsMeasInfoItem_CellSyncReprtTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdsMeasInfoList_CellSyncReprtTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BearerRearrangementIndication                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BearerRearrangementIndication (ASN1CTXT* pctxt, BearerRearrangementIndication* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_BearerRearrangementIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BearerRearrangementIndication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_RearrangeItem_Bearer_RearrangeInd                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_RearrangeItem_Bearer_RearrangeInd (ASN1CTXT* pctxt, DCH_RearrangeItem_Bearer_RearrangeInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_RearrangeItem_Bearer_RearrangeInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_RearrangeItem_Bearer_RearrangeInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_RearrangeList_Bearer_RearrangeInd                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_RearrangeList_Bearer_RearrangeInd (ASN1CTXT* pctxt, DCH_RearrangeList_Bearer_RearrangeInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_RearrangeItem_Bearer_RearrangeInd* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_RearrangeList_Bearer_RearrangeInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_RearrangeItem_Bearer_RearrangeInd);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_RearrangeItem_Bearer_RearrangeInd (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_RearrangeList_Bearer_RearrangeInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_RearrangeItem_Bearer_RearrangeInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_RearrangeItem_Bearer_RearrangeInd (ASN1CTXT* pctxt, DSCH_RearrangeItem_Bearer_RearrangeInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_RearrangeItem_Bearer_RearrangeInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dSCH_ID */

   PU_PUSHNAME (pctxt, "dSCH_ID");

   stat = asn1PD_DSCH_ID (pctxt, &pvalue->dSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_RearrangeItem_Bearer_RearrangeInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_RearrangeList_Bearer_RearrangeInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_RearrangeList_Bearer_RearrangeInd (ASN1CTXT* pctxt, DSCH_RearrangeList_Bearer_RearrangeInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   DSCH_RearrangeItem_Bearer_RearrangeInd* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_RearrangeList_Bearer_RearrangeInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DSCH_RearrangeItem_Bearer_RearrangeInd);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DSCH_RearrangeItem_Bearer_RearrangeInd (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_RearrangeList_Bearer_RearrangeInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_RearrangeItem_Bearer_RearrangeInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_RearrangeItem_Bearer_RearrangeInd (ASN1CTXT* pctxt, USCH_RearrangeItem_Bearer_RearrangeInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_RearrangeItem_Bearer_RearrangeInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uSCH_ID */

   PU_PUSHNAME (pctxt, "uSCH_ID");

   stat = asn1PD_USCH_ID (pctxt, &pvalue->uSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_RearrangeItem_Bearer_RearrangeInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_RearrangeList_Bearer_RearrangeInd                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_RearrangeList_Bearer_RearrangeInd (ASN1CTXT* pctxt, USCH_RearrangeList_Bearer_RearrangeInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   USCH_RearrangeItem_Bearer_RearrangeInd* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_RearrangeList_Bearer_RearrangeInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, USCH_RearrangeItem_Bearer_RearrangeInd);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_USCH_RearrangeItem_Bearer_RearrangeInd (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_RearrangeList_Bearer_RearrangeInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_RearrangeItem_Bearer_RearrangeInd                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_RearrangeItem_Bearer_RearrangeInd (ASN1CTXT* pctxt, HSDSCH_RearrangeItem_Bearer_RearrangeInd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_RearrangeItem_Bearer_RearrangeInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_ID");

   stat = asn1PD_HSDSCH_MACdFlow_ID (pctxt, &pvalue->hsDSCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_RearrangeItem_Bearer_RearrangeInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_RearrangeList_Bearer_RearrangeInd                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_RearrangeList_Bearer_RearrangeInd (ASN1CTXT* pctxt, HSDSCH_RearrangeList_Bearer_RearrangeInd* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   HSDSCH_RearrangeItem_Bearer_RearrangeInd* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_RearrangeList_Bearer_RearrangeInd: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSDSCH_RearrangeItem_Bearer_RearrangeInd);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSDSCH_RearrangeItem_Bearer_RearrangeInd (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_RearrangeList_Bearer_RearrangeInd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkActivationCommandFDD                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkActivationCommandFDD (ASN1CTXT* pctxt, RadioLinkActivationCommandFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkActivationCommandFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkActivationCommandFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DelayedActivationInformationList_RL_ActivationCmdFDD      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DelayedActivationInformationList_RL_ActivationCmdFDD (ASN1CTXT* pctxt, DelayedActivationInformationList_RL_ActivationCmdFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationInformationList_RL_ActivationCmdFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationInformationList_RL_ActivationCmdFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DelayedActivationInformation_RL_ActivationCmdFDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DelayedActivationInformation_RL_ActivationCmdFDD (ASN1CTXT* pctxt, DelayedActivationInformation_RL_ActivationCmdFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationInformation_RL_ActivationCmdFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode delayed_activation_update */

   PU_PUSHNAME (pctxt, "delayed_activation_update");

   stat = asn1PD_DelayedActivationUpdate (pctxt, &pvalue->delayed_activation_update);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationInformation_RL_ActivationCmdFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkActivationCommandTDD                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkActivationCommandTDD (ASN1CTXT* pctxt, RadioLinkActivationCommandTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkActivationCommandTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkActivationCommandTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DelayedActivationInformationList_RL_ActivationCmdTDD      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DelayedActivationInformationList_RL_ActivationCmdTDD (ASN1CTXT* pctxt, DelayedActivationInformationList_RL_ActivationCmdTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   ProtocolIE_Single_Container* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationInformationList_RL_ActivationCmdTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ProtocolIE_Single_Container);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ProtocolIE_Single_Container (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationInformationList_RL_ActivationCmdTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DelayedActivationInformation_RL_ActivationCmdTDD          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DelayedActivationInformation_RL_ActivationCmdTDD (ASN1CTXT* pctxt, DelayedActivationInformation_RL_ActivationCmdTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationInformation_RL_ActivationCmdTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode delayed_activation_update */

   PU_PUSHNAME (pctxt, "delayed_activation_update");

   stat = asn1PD_DelayedActivationUpdate (pctxt, &pvalue->delayed_activation_update);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationInformation_RL_ActivationCmdTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkParameterUpdateIndicationFDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkParameterUpdateIndicationFDD (ASN1CTXT* pctxt, RadioLinkParameterUpdateIndicationFDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkParameterUpdateIndicationFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkParameterUpdateIndicationFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RadioLinkParameterUpdateIndicationTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RadioLinkParameterUpdateIndicationTDD (ASN1CTXT* pctxt, RadioLinkParameterUpdateIndicationTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkParameterUpdateIndicationTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RadioLinkParameterUpdateIndicationTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSNotificationUpdateCommand                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MBMSNotificationUpdateCommand (ASN1CTXT* pctxt, MBMSNotificationUpdateCommand* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MBMSNotificationUpdateCommand: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "protocolExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode protocolIEs */

   PU_PUSHNAME (pctxt, "protocolIEs");

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      PU_PUSHNAME (pctxt, "protocolExtensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MBMSNotificationUpdateCommand: end\n");

   return (stat);
}

